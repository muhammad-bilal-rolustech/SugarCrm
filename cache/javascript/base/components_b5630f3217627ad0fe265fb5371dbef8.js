(function(app) {
 SUGAR.jssource = {"fields": {
"base": {
"link-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link existing record" action used in Subpanels.
 *
 * It needs to be sticky so that we keep things lined up nicely.
 *
 * @class View.Fields.Base.LinkActionField
 * @alias SUGAR.App.view.fields.BaseLinkActionField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Link-action Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Click handler for the select action.
     *
     * Opens a drawer for selecting records to link to the current record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        app.drawer.open(
            this.getDrawerOptions(),
            _.bind(this.selectDrawerCallback, this)
        );
    },

    /**
     * Format drawer options used by {@link #openSelectDrawer}.
     *
     * By default it uses {@link View.Layouts.Base.SelectionListLayout} layout.
     * You can extend this method if you need to pass more or different options.
     *
     * @return {Object}
     * @return {string} return.module The module to select records from.
     * @return {Object} return.parent The parent context of the selection list
     *                                context to pass to the drawer.
     * @return {Data.Bean} return.recParentModel The current record to link to.
     * @return {string} return.recLink The relationship link.
     * @return {View.View} return.recView The view for the selection list.
     * @return {Backbone.Model} return.filterOptions The filter options object.
     * */
    getDrawerOptions: function() {
        var parentModel = this.context.get('parentModel');
        var linkModule = this.context.get('module');
        var link = this.context.get('link');

        var filterOptions = new app.utils.FilterOptions().config(this.def);
        filterOptions.setInitialFilter(this.def.initial_filter || '$relate');
        filterOptions.populateRelate(parentModel);

        return {
            layout: 'multi-selection-list-link',
            context: {
                module: linkModule,
                recParentModel: parentModel,
                recLink: link,
                recContext: this.context,
                recView: this.view,
                independentMassCollection: true,
                filterOptions: filterOptions.format()
            }
        };
    },

    /**
     * Callback method used when the drawer is closed.
     *
     * If a record has been selected, it makes a request to the server to link
     * it to the parent record.
     * On success, it refreshes the subpanel collection so the new record
     * appears in the subpanel.
     *
     * Finally, it expands the subpanel context by setting the `collapsed`
     * property to `false`.
     *
     * @param {Data.Bean} model The selected record to link to parent record.
     */
    selectDrawerCallback: function(model) {
        if (!model) {
            return;
        }

        var parentModel = this.context.get('parentModel');
        var link = this.context.get('link');

        var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
            options = {
                //Show alerts for this request
                showAlerts: true,
                relate: true,
                success: _.bind(function(model) {
                    //We've just linked a related, however, the list of records from
                    //loadData will come back in DESC (reverse chronological order
                    //with our newly linked on top). Hence, we reset pagination here.
                    this.context.get('collection').resetPagination();
                    this.context.set('collapsed', false);
                }, this),
                error: function(error) {
                    app.alert.show('server-error', {
                        level: 'error',
                        messages: 'ERR_GENERIC_SERVER_ERROR'
                    });
                }
            };
        relatedModel.save(null, options);
    },

    /**
     * Check if link action should be disabled or not.
     *
     * The side effect of linking another record on a required relationship is
     * that the record could be already linked to a record and in that case we
     * would delete this existing link.
     *
     * @return {boolean} `true` if it should be disabled, `false` otherwise.
     * @override
     */
    isDisabled: function() {
        if (this._super('isDisabled')) {
            return true;
        }
        var link = this.context.get('link'),
            parentModule = this.context.get('parentModule'),
            required = app.utils.isRequiredLink(parentModule, link);
        return required;
    }
}) },
"sticky-rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sticky Rowaction does not disappear when user does not have access.
 *
 * It becomes disabled instead. This allows us to keep things lined up nicely
 * in Subpanel.
 *
 * @class View.Fields.Base.StickyRowactionField
 * @alias SUGAR.App.view.fields.BaseStickyRowactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Sticky-rowaction Field (base) 

    extendsFrom: 'RowactionField',
    /**
     * @param options
     * @override
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';  //TODO Hack that loads rowaction templates.  I hope to remove this when SP-966 is fixed.
    },
    /**
     * We always render StickyRowactions and instead set disable class when the user has no access
     * @private
     */
    _render: function() {
        if(this.isDisabled()){
            if(_.isUndefined(this.def.css_class) || this.def.css_class.indexOf('disabled') === -1){
                this.def.css_class = (this.def.css_class) ? this.def.css_class + " disabled" : "disabled";
            }
            //Remove event listeners on this action since it is disabled
            this.undelegateEvents();
        }
        this._super("_render");
    },
    /**
     * Essentially the replacement of 'hasAccess' method for implementors of StickyRowactionField.
     * Used to determine if this rowaction should be rendered in a disabled state because the user lacks permission, etc.
     *
     * This is a default implementation disables when the user lacks access.
     * @return {boolean}
     */
    isDisabled: function(){
        return !this._super("hasAccess");
    },
    /**
     * Forces StickyRowaction to be rendered and visible in Actiondropdowns.
     * @return {boolean} `true` always
     */
    hasAccess: function(){
        return true;
    }

}) },
"button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ButtonField
 * @alias SUGAR.App.view.fields.BaseButtonField
 * @extends View.Fields.Base.BaseField
 */
({
	// Button Field (base) 

    tagName: "span",
    fieldTag: "a",

    plugins: ['Tooltip', 'MetadataEventDriven'],

    initialize: function(options) {
        var self = this;

        this.events = _.extend({}, {
            'click *' : 'preventClick'
        }, this.events, options.def.events);

        this._super('initialize', [options]);

        // take advantage of this hook to do the acl check
        // we use this wrapper because our spec
        // requires us to set the button.isHidden = true
        // if we don't render it.
        this.before("render", function() {
            if (self.hasAccess()) {
                this._show();
                return true;
            }
            else {
                this.hide();
                return false;
            }
        });
    },
    _render:function(){
        this.fullRoute = _.isString(this.def.route) ? this.def.route : null;

        app.view.Field.prototype._render.call(this);
    },
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this.def.css_class = this.def.css_class || '';
        var css_class = this.def.css_class.split(' ');
        if (disable) {
            css_class.push('disabled');
        } else {
            css_class = _.without(css_class, 'disabled');
        }
        this.def.css_class = _.unique(_.compact(css_class)).join(' ');
        app.view.Field.prototype.setDisabled.call(this, disable);
    },

    /**
     * Prevents the `click` event from propagating further if the button is
     * in a disabled state.
     *
     * @param {Event} evt The `click` event.
     * @return {boolean} Returns `false` if the button is disabled.
     */
    preventClick: function(evt) {
        // FIXME: isDisabled should not check against `this.action`, and should
        // should eliminate the need here to check for the `disabled` class.
        // Should be fixed with SC-3418.
        if (this.isDisabled() || this.$(this.fieldTag).hasClass('disabled')) {
            evt.preventDefault();
            evt.stopImmediatePropagation();
            return false;
        }
    },

    /**
     * Handles the jquery showing and event throwing
     * of the button. does no access checks.
     * @protected
     */
    _show: function() {
        if (this.isHidden !== false) {
            if (!this.triggerBefore("show")) {
                return false;
            }

            this.getFieldElement().removeClass("hide").show();
            this.isHidden = false;
            this.trigger('show');
        }
    },
    show: function() {
        if(this.hasAccess()) {
            this._show();
        } else {
            this.isHidden = true;
        }
    },
    hide: function() {
        if (this.isHidden !== true) {
            if (!this.triggerBefore("hide")) {
                return false;
            }

            this.getFieldElement().addClass("hide").hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    },
    /**
     * Track using the flag that is set on the hide and show from above.
     *
     * It should check the visivility by isHidden instead of DOM visibility testing
     * since actiondropdown renders its dropdown lazy
     *
     * @return {boolean}
     */
    isVisible: function() {
        return !this.isHidden;
    },
    /**
     * @inheritdoc
     *
     * No data changes to bind.
     */
    bindDomChange: function () {
    },
    /**
     * @inheritdoc
     *
     * No need to bind DOM changes to a model.
     */
    bindDataChange: function () {
    },
    /**
     * Determine if ACLs or other properties (for example, "allow_bwc") allow for the button to show
     * @return {Boolean} true if allow access, false otherwise
     */
    hasAccess: function() {
        // buttons use the acl_action and acl_module properties in metadata to denote their action for acls
        var acl_module = this.def.acl_module,
            acl_action = this.def.acl_action;
        //Need to test BWC status
        if(_.isBoolean(this.def.allow_bwc) && !this.def.allow_bwc){
            var isBwc = app.metadata.getModule(acl_module || this.module).isBwcEnabled;
            if(isBwc){
                return false; //Action not allowed for BWC module
            }
        }
        // Finally check ACLs
        if (!acl_module) {
            return app.acl.hasAccessToModel(acl_action, this.model, this);
        } else {
            return app.acl.hasAccess(acl_action, acl_module);
        }
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuickcreateField
 * @alias SUGAR.App.view.fields.BaseQuickcreateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Quickcreate Field (base) 

    events: {
        'click .actionLink[data-event="true"]' : '_handleActionLink'
    },

    plugins: ['LinkedModel'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        //Listen to create view model changes to keep track of unsaved changes
        app.events.on('create:model:changed', this.createModelChanged, this);
        this.on('linked-model:create', this._prepareCtxForReload, this);
    },

    /**
     * Changes properties on the context so that its collection can be
     * re-fetched.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _prepareCtxForReload: function() {
        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
    },

    /**
     * Keeps track of if the create view's model has changed.
     * @param hasChanged
     */
    createHasChanges: false,
    createModelChanged: function(hasChanged) {
        this.createHasChanges = hasChanged;
    },
    /**
     * When menu item is clicked, warn if open drawers, reset drawers and open create
     * @param evt
     * @private
     */
    _handleActionLink: function(evt) {
        var $actionLink = $(evt.currentTarget),
            module = $actionLink.data('module'),
            moduleMeta = app.metadata.getModule(this.context.get('module'));
        this.actionLayout = $actionLink.data('layout');
        if (this.createHasChanges) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: 'LBL_WARN_UNSAVED_CHANGES',
                onConfirm: _.bind(function() {
                    app.drawer.reset(false);
                    this.createRelatedRecord(module);
                }, this)
            });
        } else {
            // TODO: SP-1568 - We don't yet deal with bwc model changed attributes so
            // this will navigate to new create page WITHOUT alert for unsaved changes
            this.createRelatedRecord(module);
        }
    },
    /**
     * Route to Create Related record UI for a BWC module.
     *
     * @param {String} module Module name.
     */
    routeToBwcCreate: function(module) {
        var context = this.getRelatedContext(module);
        if (context) {
            app.bwc.createRelatedRecord(module, this.context.get('model'), context.link);
        } else {
            var route = app.bwc.buildRoute(module, null, 'EditView');
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Returns context link and module name
     * if possible to create a record with context.
     *
     * @param {String} module Module name.
     * @return {Array|undefined}
     */
    getRelatedContext: function(module) {
        var meta = app.metadata.getModule(module),
            context;

        if (meta && meta.menu.quickcreate.meta.related) {
            var parentModel = this.context.get('model');

            if (parentModel.isNew()) {
                return;
            }

            context = _.find(
                meta.menu.quickcreate.meta.related,
                function(metadata) {
                    return metadata.module === parentModel.module;
                }
            );
        }

        return context;
    },

    /**
     * Open the appropriate quick create layout in a drawer
     *
     * @param {String} module Module name.
     */
    openCreateDrawer: function(module) {
        var relatedContext = this.getRelatedContext(module),
            model = null;

        if (relatedContext) {
            model = this.createLinkModel(this.context.get('model'), relatedContext.link);
        }
        app.drawer.open({
            layout: this.actionLayout || 'create',
            context: {
                create: true,
                module: module,
                model: model
            }
        }, _.bind(function (refresh, model) {
            if (refresh) {
                // When user quick creates a model he has no access, it loads the 404 page so we need to redirect him to
                // his previous page manually
                if (model && !model.id) {
                    app.router.refresh();
                    return;
                }
                if (model && relatedContext) {
                    // Refresh the subpanel.
                    this.context.trigger('panel-top:refresh', relatedContext.link);
                    return;
                }
                //Check main context to see if it needs to be updated
                this._loadContext(app.controller.context, module);
                //Also check child contexts for updates
                if (app.controller.context.children) {
                    _.each(app.controller.context.children, function(context){
                        this._loadContext(context, module);
                    }, this);
                }
            }
        }, this));
    },
    /**
     * Conditionally load context if it is for given module
     * @param context Context to load
     * @param module Module name to check
     * @private
     */
    _loadContext: function(context, module){
        var collection = context.get('collection');
        if (collection && collection.module === module) {
            var options = {
                //Don't show alerts for this request, background update
                showAlerts: false
            };
            context.resetLoadFlag(false);
            context.set('skipFetch', false);
            context.loadData(options);
        }
    }
}) },
"emailaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Emailaction is a button that when selected will launch the appropriate email
 * client. Email options for prepopulating fields on email compose or mailto
 * link are set based on field def settings.
 *
 * @class View.Fields.Base.EmailactionField
 * @alias SUGAR.App.view.fields.BaseEmailactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Emailaction Field (base) 

    extendsFrom: 'ButtonField',
    plugins: ['EmailClientLaunch'],

    /**
     * @inheritdoc
     *
     * Set up email options to prepopulate fields on email compose (or set up
     * mailto link if not using Sugar Email Client)
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initEmailOptions();
    },

    /**
     * Set up email options, listening for parent model changes to update the
     * email options on change.
     *
     * @private
     */
    _initEmailOptions: function() {
        var context = this.context.parent || this.context,
            parentModel = context.get('model');

        if (parentModel instanceof Backbone.Model) {
            this._updateEmailOptions(parentModel);
            parentModel.on('change', function(model) {
                this._updateEmailOptions(model);
                this.render();
            }, this);
        }
    },

    /**
     * Update email options based on field def settings
     *
     * @param {Object} parentModel
     * @private
     */
    _updateEmailOptions: function(parentModel) {
        if (this.def.set_recipient_to_parent) {
            this.addEmailOptions({to_addresses: [{bean: parentModel}]});
        }

        if (this.def.set_related_to_parent) {
            this.addEmailOptions({related: parentModel});
        }
    }
}) },
"save-and-send-invites-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * SaveAndSendInvitesButtonField field is a field for Meetings/Calls that handles setting the flag for sending emails to guests
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.SaveAndSendInvitesButtonField
 * @alias SUGAR.App.view.fields.BaseSaveAndSendInvitesButtonField
 * @extends View.Fields.Base.RowactionField
 *
 */
({
	// Save-and-send-invites-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * Sets the type to "rowaction" so that the templates are loaded from
     * super.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Setting model event to allow unsetting of send_invites after validation error or data sync completed.
     * @inheritdoc
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('error:validation data:sync:complete', function() {
            this.model.unset('send_invites');
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Silently sets `send_invites` to true on the model before saving.
     */
    rowActionSelect: function(event) {
        this.model.set('send_invites', true, {silent: true});
        this._super('rowActionSelect', [event]);
    }
}) },
"manage-subscription": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ManageSubscriptionField
 * @alias SUGAR.App.view.fields.BaseManageSubscriptionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Manage-subscription Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Event to navigate to the BWC Manage Subscriptions
     */
    rowActionSelect: function() {

        var route = app.bwc.buildRoute('Campaigns', this.model.id, 'Subscriptions', {
            return_module: this.module,
            return_id: this.model.id
        });
        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * Check access for Campaigns Module.
     */
    hasAccess: function() {
        var access = app.acl.hasAccess('view', 'Campaigns');
        return access && this._super('hasAccess');
    }
}) },
"repeat-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RepeatCount field is a special int field for Meetings/Calls that adds
 * max validation (which can't be done via metadata due to config value)
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatCountField
 * @alias SUGAR.App.view.fields.BaseRepeatCountField
 * @extends View.Fields.Base.IntField
 */
({
	// Repeat-count Field (base) 

    extendsFrom: 'IntField',

    /**
     * @property {int} defaultCount
     *
     * The number of occurrences to use as a default in the UI when creating a
     * new record.
     */
    defaultCount: 10,

    /**
     * @inheritdoc
     *
     * Add custom max value validation. The value of the field is defaulted in
     * the UI when creating a new record.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // setting type & def.type so number validator will run
        this.type = this.def.type = 'int';

        this.def['default'] = this.def['default'] || this.defaultCount;
        if (this.model.isNew() && !this.model.isCopy()) {
            this.model.setDefault(this.name, this.def['default']);
        }

        this.model.addValidationTask(
            'repeat_count_max_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountMax, this)
        );
    },

    /**
     * @inheritdoc
     *
     * Always returns an empty string if the value is 0, '0', null, or
     * undefined.
     */
    format: function(value) {
        value = this._super('format', [value]);

        return (value === '0' || value == null) ? '' : value;
    },

    /**
     * @inheritdoc
     *
     * Converts the value to an integer so that the integer representation is
     * always used in the model. If the value cannot be expressed as an number,
     * then it is left untouched. If the value is an empty string, then it is
     * converted to 0.
     */
    unformat: function(value) {
        if (!_.isString(value)) {
            // can't unformat it, so let the validator do the work
            return value;
        }

        // get the unformatted number
        value = this._super('unformat', [value]);

        if (_.isString(value)) {
            // it couldn't be unformatted
            if (value.trim() === '') {
                // it's the equivalent of 0
                value = 0;
            }
        } else {
            // it's a number, so make it an integer
            value = Math.round(value);
        }

        return value;
    },

    /**
     * Custom required validator for the `repeat_count` field.
     *
     * This validates `repeat_count` is not above the max allowed value
     * Since max value is in a config, cannot use sidecar maxValue validator.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountMax: function(fields, errors, callback) {
        var repeatCount = parseInt(this.model.get(this.name), 10),
            maxRepeatCount = app.config.calendar.maxRepeatCount;

        if (repeatCount > maxRepeatCount) {
            errors[this.name] = {'maxValue': maxRepeatCount};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_max_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"unlink-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.UnlinkActionField
 * @alias SUGAR.App.view.fields.BaseUnlinkActionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Unlink-action Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * By default `list:unlinkrow:fire` event is triggered if none supplied
     * through metadata.
     */
    initialize: function(options) {
        options.def.event = options.def.event || 'list:unlinkrow:fire';
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * If parent module matches `Homepage` then `false` is returned.
     *
     * Plus, we cannot unlink one-to-many relationships when the relationship
     * is a required field - if that's the case `false` is returned as well.
     *
     * @return {Boolean} `true` if access is allowed, `false` otherwise.
     */
    hasAccess: function() {
        var parentModule = this.context.get('parentModule');
        if (parentModule === 'Home') {
            return false;
        }

        var link = this.context.get('link');
        if (link && app.utils.isRequiredLink(parentModule, link)) {
            return false;
        }

        return this._super('hasAccess');
    }
}) },
"rowactions-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsCreateField
 * @alias SUGAR.App.view.fields.BaseRowactionsCreateField
 * @extends View.Fields.Base.RowactionsField
 */
({
	// Rowactions-create Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * @inheritdoc
     *
     * Overriding FieldsetField's method to use def.buttons not def.fields
     *
     * @override
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    }
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextareaField
 * @alias SUGAR.App.view.fields.BaseTextareaField
 * @extends View.Fields.Base.BaseField
 */
({
	// Textarea Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag : 'textarea',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} max_display_chars The maximum number of characters to be
     *   displayed before truncating the field.
     * - {Boolean} collapsed Defines whether or not the textarea detail view
     *   should be collapsed on initial render.
     *
     *     // ...
     *     'settings' => array(
     *         'max_display_chars' => 50,
     *         'collapsed' => false
     *         //...
     *     ),
     *     //...
     *
     * @protected
     * @type {Object}
     */
    _defaultSettings: {
        max_display_chars: 450,
        collapsed: true
    },

    /**
     * State variable that keeps track of whether or not the textarea field
     * is collapsed in detail view.
     *
     * @type {Boolean}
     */
    collapsed: undefined,

    /**
     * Settings after applying metadata settings on top of
     * {@link View.Fields.BaseTextareaField#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    plugins: ['EllipsisInline'],

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=toggle]': 'toggleCollapsed'
    },

    /**
     * @inheritdoc
     *
     * Initializes settings on the field by calling
     * {@link View.Fields.BaseTextareaField#_initSettings _initSettings}.
     * Also sets {@link View.Fields.BaseTextareaField#collapsed collapsed}
     * to the value in `this._settings.collapsed` (either default or metadata).
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSettings();
        this.collapsed = this._settings.collapsed;
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Fields.BaseTextareaField} Instance of this field.
     * @protected
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.def && this.def.settings || {}
        );
        return this;
    },

    /**
     * @inheritdoc
     *
     * Prevents editing the textarea field in a list view.
     *
     * @param {String} name The mode to set the field to.
     */
    setMode: function(name) {
        // FIXME: This will be updated pending changes to fields in sidecar,
        // see SC-2608, SC-2776.
        // FIXME: Check on 'merge-duplicates' to identify editable fields
        // see SC-3325
        var isList = (this.tplName === 'list') && _.contains(['edit', 'disabled'], name),
            mode = isList && this.view.name !== 'merge-duplicates' ? this.tplName : name;
        this._super('setMode', [mode]);
    },

    /**
     * @inheritdoc
     *
     * Formatter that always returns the value set on the textarea field. Sets
     * a `short` value for a truncated representation, if the lenght of the
     * value on the field exceeds that of `max_display_chars`. The return value
     * can either be a string, or an object such as {long: 'abc'} or
     * {long: 'abc', short: 'ab'}, for example.
     *
     * @param {String} value The value set on the textarea field.
     * @return {String|Object} The value set on the textarea field.
     */
    format: function(value) {
        // If the tplName is 'edit' then value needs to be a string. Otherwise 
        // send back the object containing `value.long` and, if necessary,
        // `value.short`.
        if (this.tplName !== 'edit') {
            var max = this._settings.max_display_chars;
            value = {long: value};

            if (value.long && value.long.length > max) {
                value.short = value.long.substr(0, max).trim();
            }
        }

        return value;
    },

    /**
     * Toggles the field between displaying the truncated `short` or `long`
     * value for the field, and toggles the label for the 'more/less' link.
     */
    toggleCollapsed: function() {
        this.collapsed = !this.collapsed;
        this.render();
    },

    /**
     * Overrides default implementation so that whitespaces won't be stripped.
     */
    unformat: function(value) {
        return value;
    }
}) },
"iframe": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IframeField
 * @alias SUGAR.App.view.fields.BaseIframeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Iframe Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        if (this.tplName === 'disabled') {
            this.$(this.fieldTag).attr('disabled', 'disabled');
        }
    },

    /**
     * @inheritdoc
     */
    unformat: function(value) {
        value = (value !== '' && value != 'http://') ? value.trim() : '';
        return value;
    },

    /**
     * @inheritdoc
     *
     * Formatter for the iframe field. If the iframe field definition is
     * configured with a generated url (`this.def.gen`) by another field, those
     * field values (defined in curly braces) are parsed from the model and set
     * on the value to be returned. Finally, if the value doesn't contain
     * 'http://' or 'https://', it is prepended on the value before being
     * returned.
     *
     * @param {String} value The value set on the iframe field.
     * @return {String} The formatted iframe value.
     */
    format: function(value) {
        if (_.isEmpty(value)) {
            // Name conflict with iframe's default value def and the list view's
            // default column flag
            value = _.isString(this.def['default']) ? this.def['default'] : undefined;
        }

        if (this.def.gen == '1') {
            var regex = /{(.+?)}/,
                result = null;
            do {
                result = regex.exec(value);
                if (result) {
                    value = value.replace(result[0], this.model.get(result[1]));
                }
            } while (result);
        }

        if (_.isString(value) && !value.match(/^(http|https):\/\//)) {
            value = 'http://' + value.trim();
        }
        return value;
    }
}) },
"recurrence": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Recurrence is a field for Meetings/Calls module used to set attributes
 * about a recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RecurrenceField
 * @alias SUGAR.App.view.fields.BaseRecurrenceField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Recurrence Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @property {int} repeatCountMin
     *
     * The minimum number of occurrences that is allowed when the repeat_count
     * field is used.
     */
    repeatCountMin: 1,

    /**
     * @inheritdoc
     *
     * Add validator to ensure that either `repeat_count` or `repeat_until`
     * has a value set
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.addValidationTask(
            'repeat_count_or_until_required_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountOrUntilRequired, this)
        );
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:repeat_type', this.repeatTypeChanged, this);
        this.model.on('change:repeat_count', this.repeatCountChanged, this);
        this.model.on('change:repeat_until', this.repeatUntilChanged, this);
    },

    /**
     * Inherit fieldset templates
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        var originalType = this.type;
        this.type = 'fieldset';
        this._super('_loadTemplate');
        this.type = originalType;
    },

    /**
     * @inheritdoc
     *
     * Prepare the recurrence fields based on the value of `repeat_type`
     */
    _render: function() {
        var repeatType = this.model.get('repeat_type');

        this._super('_render');

        switch (repeatType) {
            case 'Daily':
            case 'Weekly':
            case 'Monthly':
            case 'Yearly':
                this.show();
                break;
            default:
                this.hide();
                break;
        }

        this.prepareView();
    },

    /**
     * Set up the recurrence fields based on `repeat_type` and the action
     *
     * * `repeat_dow` - show when repeat_type is weekly, hide otherwise
     * * `repeat_count` & `repeat_until` - always show both fields on edit view
     * and only show the field which as a value on detail view
     */
    prepareView: function() {
        var repeatType = this.model.get('repeat_type'),
            repeatUntil = this.model.get('repeat_until');

        if (repeatType === 'Weekly') {
            this._showField('repeat_dow');
        } else {
            this._hideField('repeat_dow');
        }

        if (this.action === 'edit') {
            this._showField('repeat_count');
            this._showField('repeat_until');
            this._getFieldRecordCellByType('label').show();
        } else {
            if (repeatUntil && (repeatUntil.length > 0)) {
                this._hideField('repeat_count');
                this._showField('repeat_until');
            } else {
                this._showField('repeat_count');
                this._hideField('repeat_until');
            }
            this._getFieldRecordCellByType('label').hide();
        }
    },

    /**
     * Set field defaults when `repeat_type` changes & then re-render so the
     * hide/show logic is applied.
     *
     * When `repeat_type` is cleared (set to None), force all fields to their
     * default values
     */
    repeatTypeChanged: function() {
        var force = !this._isPopulated(this.model.get('repeat_type'));
        _.each(this.fields, function(field) {
            if (force || !this._isPopulated(this.model.get(field.name))) {
                this.model.set(field.name, field.def['default']);
            }
        }, this);

        this.render();
    },

    /**
     * Clear out `repeat_until` field when `repeat_count` is set
     */
    repeatCountChanged: function() {
        if (this._isPopulated(this.model.get('repeat_count'))) {
            this.model.set('repeat_until', '');
        }
    },

    /**
     * Clear out `repeat_count` field when `repeat_until` is set
     */
    repeatUntilChanged: function() {
        if (this._isPopulated(this.model.get('repeat_until'))) {
            this.model.set('repeat_count', '');
        }
    },

    /**
     * Show the given field
     *
     * @param {string} fieldName Name of the field to show
     * @private
     */
    _showField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).show();
    },

    /**
     * Hide the given field
     *
     * @param {string} fieldName Name of the field to hide
     * @private
     */
    _hideField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).hide();
    },

    /**
     * Returns the field cell for a given field name
     *
     * @param {string} fieldName Name of the field to select
     * @return {jQuery} jQuery selected record cell
     * @private
     */
    _getFieldRecordCellByName: function(fieldName) {
        var selector = '.fieldset-field[data-name="' + fieldName + '"]';
        return this.$(selector);
    },

    /**
     * Returns the field cell for a given field type
     *
     * @param {string} fieldType Type of the field to select
     * @return {jQuery} jQuery selected record cell
     * @private
     */
    _getFieldRecordCellByType: function(fieldType) {
        var selector = '.fieldset-field[data-type="' + fieldType + '"]';
        return this.$(selector);
    },

    /**
     * Check if a particular field is populated
     *
     * @param {string|number} value The value to check if it is populated
     * @return {boolean} Returns true if the field is populated
     * @private
     */
    _isPopulated: function(value) {
        return !_.isUndefined(value) && !_.isNull(value) && value !== '';
    },

    /**
     * Custom validator for the `repeat_count`/`repeat_until` field.
     *
     * This validates `repeat_count` is required and meets the minimum value
     * requirement if `repeat_until` is not specified.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountOrUntilRequired: function(fields, errors, callback) {
        var repeatCount, repeatCountIsPopulated, repeatUntilIsPopulated;

        repeatCount = this.model.get('repeat_count');
        repeatCountIsPopulated = this._isPopulated(repeatCount);
        repeatUntilIsPopulated = this._isPopulated(this.model.get('repeat_until'));

        if (this._isPopulated(this.model.get('repeat_type'))) {
            if (!repeatUntilIsPopulated && !repeatCountIsPopulated) {
                errors.repeat_count = {required: true};
            } else if (!repeatUntilIsPopulated && repeatCountIsPopulated && repeatCount < this.repeatCountMin) {
                errors.repeat_count = {minValue: this.repeatCountMin};
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_or_until_required_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Relate field provides a link to a module that is set in the definition of
 * this field metadata.
 *
 * This field requires at least the follow definitions to be exist in the
 * field:
 *
 * ```
 * array(
 *     'name' => 'account_name',
 *     'rname' => 'name',
 *     'id_name' => 'account_id',
 *     'module' => 'Accounts',
 *     'link' => true,
 *     //...
 * ),
 * ```
 *
 * The field also support a `populate_list` to update other fields in the
 * current model from other fields of the selected model.
 *
 * ```
 * array(
 *     //...
 *     'populate_list' => array(
 *         'populate_list' => array(
 *         'billing_address_street' => 'primary_address_street',
 *         'billing_address_city' => 'primary_address_city',
 *         'billing_address_state' => 'primary_address_state',
 *         'billing_address_postalcode' => 'primary_address_postalcode',
 *         'billing_address_country' => 'primary_address_country',
 *         'phone_office' => 'phone_work',
 *         //...
 *
 *     ),
 * )
 * ```
 *
 * This field allows you to configure the minimum chars that trigger a search
 * when using the typeahead feature.
 *
 * ```
 * array(
 *     //...
 *     'minChars' => 3,
 * )
 * ```
 *
 * TODO: there is a conflict in the link property of `this.def.link` that
 * should be populated from the view/field metadata with the `vardefs` one
 * which needs to be addressed.
 *
 * TODO: we have a mix of properties here with camelCase and underscore.
 * Needs to be addressed.
 *
 * @class View.Fields.Base.RelateField
 * @alias SUGAR.App.view.fields.BaseRelateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Relate Field (base) 

    fieldTag: 'input.select2',
    plugins: ['QuickSearchFilter', 'EllipsisInline'],

    /**
     * Initializes field and binds all function calls to this
     * @param {Object} options
     */
    initialize: function(options) {
        /**
         * Boolean used for the 'allowClear' select2 option.
         *
         * @property {boolean}
         * @protected
         */
        this._allow_single_deselect = true;
        /**
         * Minimum input characters to trigger the search. Used for
         * `minimumInputLength` select2 option.
         *
         * @property {number}
         * @protected
         */
        this._minChars = options.def.minChars || 1;
        /**
         * Separator used by select2 to separate values. Used for `separator`
         * select2 option.
         *
         * @property {string}
         * @protected
         */
        this._separator = '|';
        /**
         * Maximum number of records the user can select.
         *
         * @property {number}
         * @protected
         */
        this._maxSelectedRecords = 20;

        this._super('initialize', [options]);
        /**
         * The template used for a pill in case of multiselect field.
         *
         * @property {Function}
         * @private
         */
        this._select2formatSelectionTemplate = app.template.getField('relate', 'pill', this.module);

        var populateMetadata = app.metadata.getModule(this.getSearchModule());

        if (_.isEmpty(populateMetadata)) {
            return;
        }
        _.each(this.def.populate_list, function(target, source) {
            if (_.isUndefined(populateMetadata.fields[source])) {
                app.logger.error('Fail to populate the related attributes: attempt to access undefined key - ' +
                this.getSearchModule() + '::' + source);
            }
        }, this);

        this._createSearchCollection();
    },

    /**
     * Creates a Filters BeanCollection to easily apply filters.
     * The user must have `list` access to the search module to create a
     * {@link Data.Base.FiltersBeanCollection}.
     *
     * @protected
     */
    _createFiltersCollection: function(options) {
        var searchModule = this.getSearchModule();

        if (!app.acl.hasAccess('list', searchModule)) {
            app.logger.debug('No "list" access to ' + searchModule + ' so skipping the creation of filter.');
            return;
        }

        if (app.metadata.getModule('Filters') && searchModule) {
            this.filters = app.data.createBeanCollection('Filters');
            this.filters.setModuleName(searchModule);
            this.filters.setFilterOptions(this.getFilterOptions());
            this.filters.load(options);
        }
    },
    /**
     * Creates a {@link Data.BeanCollection} for the search results pertaining
     * to the search module.
     *
     * @protected
     */
    _createSearchCollection: function() {
        var searchModule = this.getSearchModule();
        if (searchModule && app.metadata.getModule(searchModule)) {
            this.searchCollection = app.data.createBeanCollection(searchModule);
        } else {
            this.searchCollection = null;
        }
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.on('keydown.record', {field: this}, callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.focusser.on('keydown.record', {field: this}, callback);
            plugin.search.on('keydown.record', {field: this}, callback);
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.off('keydown.record', callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.search.off('keydown.record', callback);
        }
    },

    focus: function() {
        if (this.action !== 'disabled') {
            //Need to defer to ensure that all the related elements have finished
            //rendering before attempting to open the dropdown.
            _.defer(_.bind(function() {
                this.$(this.fieldTag).first().select2('open');
            }, this));
        }
    },

    /**
     * //FIXME: We shouldn't have this method. SC-4121 will address this.
     * Creates the css classes to set to the select2 plugin.
     *
     * @return {string}
     * @private
     */
    _buildCssClasses: function() {
        var cssClasses = [];
        if (this.view.name === 'recordlist') {
            cssClasses.push('select2-narrow');
        }
        if (this.type === 'parent') {
            cssClasses.push('select2-parent');
        }
        if (this.def.isMultiSelect) {
            cssClasses.push('select2-choices-pills-close same-size-pills');
        }
        return cssClasses.join(' ');
    },

    /**
     * Renders relate field
     */
    _render: function() {
        var searchModule = this.getSearchModule();

        this._super('_render');

        //FIXME remove check for tplName SC-2608
        switch(this.tplName) {
            case 'edit':
            case 'massupdate':
                // `searchModule` can be undefined for a parent field when there
                // is no value set (ie in create mode). In that case, we don't
                // want to render the dropdown disabled.
                if (!_.isUndefined(searchModule)) {
                    if (!app.acl.hasAccess('list', searchModule) ||
                        !_.contains(app.metadata.getModuleNames(), searchModule)) {
                        this._renderDisabledDropdown();
                        break;
                    }
                }
                if (_.isUndefined(this.filters)) {
                    this._createFiltersCollection({
                        success: _.bind(function() {
                            if (!this.disposed) {
                                this._renderEditableDropdown();
                            }
                        }, this)
                    });
                } else {
                    this._renderEditableDropdown();
                }
                break;
            case 'disabled':
                this._renderDisabledDropdown();
                break;
        }
        return this;
    },

    /**
     * Renders the editable dropdown using the `select2` plugin.
     *
     * Since a filter may have to be applied on the field, we need to fetch
     * the list of filters for the current module before rendering the dropdown
     * (and enabling the searchahead feature that requires the filter
     * definition).
     *
     * @private
     */
    _renderEditableDropdown: function() {
        var self = this;
        var $dropdown = this.$(this.fieldTag);

        var loadingLabel = app.lang.get('LBL_LOADING', this.module);

        var inList = this.view.name === 'recordlist';
        $dropdown.select2({
            width: inList ? 'off' : '100%',
            dropdownCssClass: _.bind(this._buildCssClasses, this),
            multiple: !!this.def.isMultiSelect,
            containerCssClass: _.bind(this._buildCssClasses, this),
            separator: this._separator,
            initSelection: _.bind(this._onInitSelect, this),
            formatInputTooShort: function() {
                return '';
            },
            formatSelection: _.bind(this._onFormatSelection, this),
            formatSearching: loadingLabel,
            placeholder: this.getPlaceHolder(),
            allowClear: self._allow_single_deselect,
            minimumInputLength: self._minChars,
            maximumSelectionSize: 20,
            query: _.bind(this.search, this)
        }).on('select2-open', _.bind(this._onSelect2Open, this))
            .on('searchmore', function() {
                $(this).select2('close');
                self.openSelectDrawer();
            }).on('change', function(e) {
                var plugin = $(this).data('select2'),
                    id = e.val;

                if (_.isUndefined(id)) {
                    return;
                }

                // For multiselect fields, we update the data-rname attributes
                // so it stays in sync with the id list, and allows us to use
                // 'setValue' method. The use of 'setValue' method is required
                // to re-render the field.
                if (self.def.isMultiSelect) {
                    var dataRname = plugin.opts.element.data('rname');
                    dataRname = dataRname ? dataRname.split(self._separator) : [];
                    var ids = $(this).select2('val');

                    if (e.added) {
                        dataRname.push(e.added.text);
                    } else if (e.removed) {
                        dataRname = _.without(dataRname, e.removed.text);
                    } else {
                        return;
                    }
                    var models = _.map(ids, function(id, index) {
                        return {id: id, value: dataRname[index]};
                    });

                    self.setValue(models);
                    return;
                }

                var value = (id) ? plugin.selection.find('span').text() : $(this).data('rname'),
                    collection = plugin.context,
                    attributes = {};
                if (collection && !_.isEmpty(id)) {
                    // if we have search results use that to set new values
                    var model = collection.get(id);
                    attributes.id = model.id;
                    attributes.value = model.get('name');
                    _.each(model.attributes, function(value, field) {
                        if (app.acl.hasAccessToModel('view', model, field)) {
                            attributes[field] = attributes[field] || model.get(field);
                        }
                    });
                } else if (e.currentTarget.value && value) {
                    // if we have previous values keep them
                    attributes.id = value;
                    attributes.value = e.currentTarget.value;
                } else {
                    // default to empty
                    attributes.id = '';
                    attributes.value = '';
                }

                self.setValue(attributes);
            });
        var plugin = $dropdown.data('select2');
        if (plugin && plugin.focusser) {
            plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
        }
    },

    /**
     * Renders the dropdown in disabled mode.
     *
     * @private
     */
    _renderDisabledDropdown: function() {
        var loadingLabel = app.lang.get('LBL_LOADING', this.module);
        var $dropdown = this.$(this.fieldTag);

        $dropdown.select2({
            width: '100%',
            initSelection: function(el, callback) {
                var $el = $(el),
                    id = $el.val(),
                    text = $el.data('rname');
                callback({id: id, text: text});
            },
            formatInputTooShort: function() {
                return '';
            },
            formatSearching: function() {
                return loadingLabel;
            },
            placeholder: this.getPlaceHolder(),
            allowClear: self._allow_single_deselect,
            minimumInputLength: self._minChars,
            query: _.bind(this.search, this)
        });
        $dropdown.select2('disable');
    },

    /**
     * Callback for select2 `initSelection` property.
     *
     * @param {HTMLElement} el The select2 element that stores values.
     * @param {Function} callback select2 callback to initialize the plugin.
     * @private
     */
    _onInitSelect: function(el, callback) {
        var $el = $(el),
            id = $el.val(),
            text = $el.data('rname');

        if (!this.def.isMultiSelect) {
            return callback({id: id, text: text});
        }
        var ids = id.split(this._separator);
        text = text.split(this._separator);
        callback(_.map(ids, function(value, index) {
            return {id: value, text: text[index]};
        }));
    },

    /**
     * Callback for select2 `formatSelection` property.
     *
     * @param {Object} obj object containing the item name.
     * @return {string} A string containing template for a pill.
     *
     * @private
    */
    _onFormatSelection: function(obj) {
        var ctx = {};
        //TODO We should investigate why it's sometimes `text` and
        //sometimes `id` and make it always same if possible.
        ctx.text = obj.text || obj.id;
        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Callback when select2 plugin opens.
     * @private
     * @param {Event} e The `click` event.
     */
    _onSelect2Open: function(e) {
        var plugin = this.$(e.currentTarget).data('select2');
        if (plugin.searchmore) {
            return;
        }
        var label = app.lang.get('LBL_SEARCH_AND_SELECT_ELLIPSIS', this.module);
        var $tpl = $('<div/>').addClass('select2-result-label').html(label);
        var onMouseDown = function() {
            plugin.opts.element.trigger($.Event('searchmore'));
            plugin.close();
        };
        var $content = $('<li class="select2-result">').append($tpl).mousedown(onMouseDown);
        plugin.searchmore = $('<ul class="select2-results">').append($content);
        plugin.dropdown.append(plugin.searchmore);
    },

    /**
     * Builds the route for the relate module's record.
     * @param {String} module The related module.
     * @param {String} id The record id to link to.
     *
     * TODO since base.js has a build href, we should try to reuse code or
     * extend this one from other "link" field
     */
    buildRoute: function(module, id) {
        var oldModule = module;
        // This is a workaround until bug 61478 is resolved to keep parity with 6.7
        if (module === 'Users' && this.context.get('module') !== 'Users') {
            module = 'Employees';
        }

        if (_.isEmpty(module) || (!_.isUndefined(this.def.link) && !this.def.link)) {
            return;
        }
        var action = (this.def.link && this.def.route)? this.def.route.action :"view";
        if (!_.isEmpty(id) && app.acl.hasAccess(action, oldModule)) {
            this.href = '#' + app.router.buildRoute(module, id);
        } else {
            // if no access to module, remove the href
            this.href = undefined;
        }
    },

    // Derived controllers can override these if related module and id in another
    // place.
    _buildRoute: function () {
        this.buildRoute(this.getSearchModule(), this._getRelateId());
    },
    _getRelateId: function () {
        return this.model.get(this.def.id_name);
    },

    /**
     * @inheritdoc
     *
     * When there is no value set and we are in a create view, we try to check
     * if the parent context module matches this relate field. If it matches,
     * we pre-populate with that data.
     *
     * FIXME: the relate field should use this method to pre-populate the
     * values without touching the model or else we need to use silent to
     * prevent the warning of unsaved changes, consequently we can't bind
     * events like `change` to it.
     *
     * TODO: the model might not have the field that we are relating to. On
     * those corner cases, we need to fetch from the server that information.
     *
     * @return {String} This field's value. Need to change to object with all
     *   data that we need to render the field.
     */
    format: function(value) {

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            /**
             * Flag to indicate that the value has been set from the context
             * once, so if later the value is unset, we don't set it again on
             * {@link #format}.
             *
             * @type {boolean}
             * @protected
             */
            this._valueSetOnce = true;
        }
        setFromCtx = value === null && !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            parentCtx.get('module') === this.def.module &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            this.def.auto_populate = true;
            // FIXME the setValue receives a model but not a backbone model...
            this.setValue(model.toJSON());
            // FIXME we need to iterate over the populated_ that is causing
            // unsaved warnings when doing the auto populate.
        }
        if (!this.def.isMultiSelect) {
            this._buildRoute();
        }

        var idList = this.model.get(this.def.id_name);
        if (_.isArray(value)) {
            this.formattedRname = value.join(this._separator);
            this.formattedIds = idList.join(this._separator);
        } else {
            this.formattedRname = value;
            this.formattedIds = idList;
        }
        return value;
    },

    /**
     * Sets the value in the field.
     *
     * @param {Object|Array} models The source models attributes.
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        var updateRelatedFields = true,
            values = {};
        if (_.isArray(models)) {
            // Does not make sense to update related fields if we selected
            // multiple models
            updateRelatedFields = false;
        } else {
            models = [models];
        }

        values[this.def.id_name] = [];
        values[this.def.name] = [];

        _.each(models, _.bind(function(model) {
            values[this.def.id_name].push(model.id);
            values[this.def.name].push(model[this.getRelatedModuleField()] || model.value);
        }, this));

        // If it's not a multiselect relate, we get rid of the array.
        if (!this.def.isMultiSelect) {
            values[this.def.id_name] = values[this.def.id_name][0];
            values[this.def.name] = values[this.def.name][0];
        }
        this.model.set(values);

        if (updateRelatedFields) {
            // TODO: move this to SidecarExpressionContext
            // check if link field is currently populated
            if (this.model.get(this.def.link)) {
                // unset values of related bean fields in order to make the model load
                // the values corresponding to the currently selected bean
                this.model.unset(this.def.link);
            } else {
                // unsetting what is not set won't trigger "change" event,
                // we need to trigger it manually in order to notify subscribers
                // that another related bean has been chosen.
                // the actual data will then come asynchronously
                this.model.trigger('change:' + this.def.link);
            }
            this.updateRelatedFields(models[0]);
        }
    },

    /**
     * Handles update of related fields.
     *
     * @param {Object} model The source model attributes.
     */
    updateRelatedFields: function(model) {
        var newData = {},
            self = this;
        _.each(this.def.populate_list, function(target, source) {
            source = _.isNumber(source) ? target : source;
            if (!_.isUndefined(model[source]) && app.acl.hasAccessToModel('edit', this.model, target)) {
                var before = this.model.get(target),
                    after = model[source];

                if (before !== after) {
                    newData[target] = model[source];
                }
            }
        }, this);

        if (_.isEmpty(newData)) {
            return;
        }

        // if this.def.auto_populate is true set new data and doesn't show alert message
        if (!_.isUndefined(this.def.auto_populate) && this.def.auto_populate == true) {
            // if we have a currency_id, set it first to trigger the currency conversion before setting
            // the values to the model, this prevents double conversion from happening
            if (!_.isUndefined(newData.currency_id)) {
                this.model.set({currency_id: newData.currency_id});
                delete newData.currency_id;
            }
            this.model.set(newData);
            return;
        }

        // load template key for confirmation message from defs or use default
        var messageTplKey = this.def.populate_confirm_label || 'TPL_OVERWRITE_POPULATED_DATA_CONFIRM',
            messageTpl = Handlebars.compile(app.lang.get(messageTplKey, this.getSearchModule())),
            fieldMessageTpl = app.template.getField(
                this.type,
                'overwrite-confirmation',
                this.model.module),
            messages = [],
            relatedModuleSingular = app.lang.getModuleName(this.def.module);

        _.each(newData, function(value, field) {
            var before = this.model.get(field),
                after = value;

            if (before !== after) {
                var def = this.model.fields[field];
                messages.push(fieldMessageTpl({
                    before: before,
                    after: after,
                    field_label: app.lang.get(def.label || def.vname || field, this.module)
                }));
            }
        }, this);

        app.alert.show('overwrite_confirmation', {
            level: 'confirmation',
            messages: messageTpl({
                values: new Handlebars.SafeString(messages.join(', ')),
                moduleSingularLower: relatedModuleSingular.toLowerCase()
            }),
            onConfirm: function() {
                // if we have a currency_id, set it first to trigger the currency conversion before setting
                // the values to the model, this prevents double conversion from happening
                if (!_.isUndefined(newData.currency_id)) {
                    self.model.set({currency_id: newData.currency_id});
                    delete newData.currency_id;
                }
                self.model.set(newData);
            }
        });
    },

    /**
     * Opens the selection drawer.
     *
     * Note that if the field definitions have a `filter_relate` property, it
     * will open the drawer and filter by this relate field.
     *
     *     @example a Revenue Line Item is associated to an account and to an
     *      opportunity. If I want to open a drawer to select an opportunity
     *      with an initial filter that filters opportunities by the account
     *      associated to the revenue line item, in the field definitions I can
     *      specify:
     *      ```
     *      'filter_relate' => array(
     *          'account_id' => 'account_id',
     *      ),
     *      ```
     *      The key is the field name in the Revenue Line Items record,
     *      the value is the field name in the Opportunities record.
     */
    openSelectDrawer: function() {
        var layout = 'selection-list';
        var context = {
            module: this.getSearchModule(),
            fields: this.getSearchFields(),
            filterOptions: this.getFilterOptions()
        };

        if (!!this.def.isMultiSelect) {
            layout = 'multi-selection-list';
            _.extend(context, {
                preselectedModelIds: _.clone(this.model.get(this.def.id_name)),
                maxSelectedRecords: this._maxSelectedRecords,
                isMultiSelect: true
            });
        }

        app.drawer.open({
            layout: layout,
            context: context
        }, _.bind(this.setValue, this));
    },

    /**
     * Gets the list of fields to search by in the related module.
     *
     * @return {Array} The list of fields.
     */
    getSearchFields: function() {
        return _.union(['id', this.getRelatedModuleField()], _.keys(this.def.populate_list || {}));
    },

    /**
     * Gets the related field name in the related module record.
     *
     * Falls back to `name` if not defined.
     *
     * @return {String} The field name.
     */
    getRelatedModuleField: function() {
        return this.def.rname || 'name';
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect refresh the select2 plugin
     */
    bindDomChange: function () {
    },

    /**
     * Gets the correct module to search based on field/link defs.
     *
     * If both `this.def.module` and `link.module` are empty, fall back onto the
     * metadata manager to get the proper module as a last resort.
     *
     * @return {String} The module to search on.
     */
    getSearchModule: function () {
        // If we have a module property on this field, use it
        if (this.def.module) {
            return this.def.module;
        }

        // No module in the field def, so check if there is a module in the def
        // for the link field
        var link = this.def.link && this.model.fields && this.model.fields[this.def.link] || {};
        if (link.module) {
            return link.module;
        }

        // At this point neither the def nor link field def have a module... let
        // metadata manager try find it
        return app.data.getRelatedModule(this.model.module, this.def.link);
    },
    getPlaceHolder: function () {
        var searchModule = this.getSearchModule(),
            searchModuleLower = searchModule.toLocaleLowerCase(),
            module = app.lang.getModuleName(searchModule, {defaultValue: searchModuleLower});

        return app.lang.get('LBL_SEARCH_SELECT_MODULE', this.module, {
            module: new Handlebars.SafeString(module)
        });
    },

    /**
     * Formats the filter options.
     *
     * @param {Boolean} force `true` to force retrieving the filter options
     *   whether or not it is available in memory.
     * @return {Object} The filter options.
     */
    getFilterOptions: function(force) {
        if (this._filterOptions && !force) {
            return this._filterOptions;
        }
        this._filterOptions = new app.utils.FilterOptions()
            .config(this.def)
            .setInitialFilter(this.def.initial_filter || '$relate')
            .populateRelate(this.model)
            .format();
        return this._filterOptions;
    },

    /**
     * Builds the filter definition to pass to the request when doing a quick
     * search.
     *
     * It will combine the filter definition for the search term with the
     * initial filter definition. Both are optional, so this method may return
     * an empty filter definition (empty `array`).
     *
     * @param {String} searchTerm The term typed in the quick search field.
     * @return {Array} The filter definition.
     */
    buildFilterDefinition: function(searchTerm) {
        if (!app.metadata.getModule('Filters') || !this.filters) {
            return [];
        }
        var filterBeanClass = app.data.getBeanClass('Filters').prototype,
            filterOptions = this.getFilterOptions() || {},
            filter = this.filters.collection.get(filterOptions.initial_filter),
            filterDef,
            populate,
            searchTermFilter,
            searchModule;

        if (filter) {
            populate = filter.get('is_template') && filterOptions.filter_populate;
            filterDef = filterBeanClass.populateFilterDefinition(filter.get('filter_definition') || {}, populate);
            searchModule = filter.moduleName;
        }

        searchTermFilter = filterBeanClass.buildSearchTermFilter(searchModule || this.getSearchModule(), searchTerm);

        return filterBeanClass.combineFilterDefinitions(filterDef, searchTermFilter);
    },

    /**
     * Searches for related field.
     * @param event
     */
    search: _.debounce(function(query) {
        var term = query.term || '',
            self = this,
            searchModule = this.getSearchModule(),
            params = {},
            limit = self.def.limit || 5,
            relatedModuleField = this.getRelatedModuleField();

        if (query.context) {
            params.offset = this.searchCollection.next_offset;
        }
        params.filter = this.buildFilterDefinition(term);

        this.searchCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            update: true,
            remove: _.isUndefined(params.offset),
            fields: this.getSearchFields(),
            context: self,
            params: params,
            limit: limit,
            success: function(data) {
                var fetch = {results: [], more: data.next_offset > 0, context: data};
                if (fetch.more) {
                    var fieldEl = self.$(self.fieldTag),
                    //For teamset widget, we should specify which index element to be filled in
                        plugin = (fieldEl.length > 1) ? $(fieldEl.get(self.currentIndex)).data("select2") : fieldEl.data("select2"),
                        height = plugin.searchmore.children("li:first").children(":first").outerHeight(),
                    //0.2 makes scroll not to touch the bottom line which avoid fetching next record set
                        maxHeight = height * (limit - .2);
                    plugin.results.css("max-height", maxHeight);
                }
                _.each(data.models, function (model, index) {
                    if (params.offset && index < params.offset) {
                        return;
                    }
                    fetch.results.push({
                        id: model.id,
                        text: model.get(relatedModuleField) + ''
                    });
                });
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback(fetch);
                }
            },
            error: function() {
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback({results: []});
                }
                app.logger.error("Unable to fetch the bean collection.");
            }
        });
    }, app.config.requiredElapsed || 500),

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', function() {
                this.getFilterOptions(true);
            }, this);

            this.model.on('change:' + this.name, function() {
                if (this.disposed) {
                    return;
                }
                var $dropdown = this.$(this.fieldTag);
                if (!_.isEmpty($dropdown.data('select2'))) {
                    var value = this.model.get(this.def.name);
                    value = _.isArray(value) ? value.join(this._separator) : value;
                    value = value ? value.trim() : value;

                    $dropdown.data('rname', value);

                    // `id` can be an array of ids if the field is a multiselect.
                    var id = this.model.get(this.def.id_name);
                    if (_.isEqual($dropdown.select2('val'), id)) {
                        return;
                    }

                    $dropdown.select2('val', id);
                } else {
                    this.render();
                }
            }, this);
        }
    },

    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        app.view.Field.prototype.unbindDom.call(this);
    }

}) },
"change-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangePasswordField
 * @alias SUGAR.App.view.fields.BaseChangePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Change-password Field (base) 

    fieldTag: 'input:not(:disabled)',

    events: {
        'click .togglePasswordFields': 'togglePasswordFields'
    },

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['confirm_password'] = 'ERR_REENTER_PASSWORDS';
        this._extendModel();
    },

    /**
     * Extends the model
     * - adds a validation task _doValidatePasswordConfirmation : handle the password confirmation validation
     * - revertAttributes : to unset temporary attributes _new_password and _confirm_password
     */
    _extendModel: function() {
        // _hasChangePasswordModifs is a flag to make sure model methods are overriden only once
        if (this.model && !this.model._hasChangePasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do extend model only once
            this.model._hasChangePasswordModifs = true;

            /**
             * Validates new password and confirmation match
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             */
            this.model._doValidatePasswordConfirmation = function(fields, errors, callback) {
                // Find any change password field
                var changePasswordFields = _.filter(fields, function(field) {
                    return field.type === 'change-password' || field.type === 'change-my-password';
                });
                _.each(changePasswordFields, function(field) {
                    // Get the new password and the confirmation
                    var password = this.get(field.name + '_new_password'),
                        confirmation = this.get(field.name + '_confirm_password');

                    /**
                     * Passwords don't match
                     */
                    if (password !== confirmation) {
                        // Adds the validation error
                        // confirm_password is added to errorName2Keys on initialize
                        errors[field.name] = errors[field.name] || {};
                        errors[field.name]['confirm_password'] = true;
                    } else if (!errors[field.name]) {
                        /**
                         * Passwords match
                         */
                        this.unset(field.name + '_current_password'); //Needs to be cleared for change-my-password
                        if (password !== '') {
                            this.unset(field.name + '_new_password');
                            this.unset(field.name + '_confirm_password');
                            this.set(field.name, password);
                        }
                    }
                }, this);

                callback(null, fields, errors);
            };

            /**
             * Adds the validation task to the model
             * @override
             * @param options
             */
            this.model.addValidationTask('password_confirmation_' + this.cid, _.bind(this.model._doValidatePasswordConfirmation, this.model));

            /**
             * Unsets new password and confirmation values on revertAttributes
             * @override
             * @param options
             */
            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_new_password') || attr.match('_confirm_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (this.model) {
            this.newPassword = this.model.get(this.name + '_new_password');
            this.confirmPassword = this.model.get(this.name + '_confirm_password');
            // Decides to display inputs or the link
            this.showPasswordFields = this.showPasswordFields ||
                //Show password fields if the formatted value is empty
                !this.format(this.value) ||
                //Show password fields if they aren't empty
                !!(this.newPassword || this.confirmPassword);
        }
        app.view.Field.prototype._render.call(this);
        this.showPasswordFields = false;
        this.$inputs = this.$(this.fieldTag);
        this.focusIndex = 0;
        return this;
    },

    /**
     * Sets an arbitrary value just to display stars on detail view
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (value === true) return 'value_setvalue_set';
        return value;
    },

    /**
     * Reset the arbitrary value
     * @override
     * @param {String} value
     * @return {Mixed} value boolean is the value is not set
     */
    unformat: function(value) {
        if (value === 'value_setvalue_set') return true;
        return value;
    },

    /**
     * Sets a password attribute on the model of this field.
     *
     * @private
     * @param {Event} evt The event object.
     */
    _setPasswordAttribute: function(evt) {
        var $el = this.$(evt.currentTarget);
        var attr = $el.attr('name');
        var val = $el.val();

        this.model.set(this.name + '_' + attr, this.unformat(val));
    },

    /**
     * @override
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) return;

        this.$('input[name=new_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));

        var self = this;
        this.$('input[name=confirm_password]').on('change.' + this.cid, function() {
            var val = self.unformat($(this).val());
            self.model.set(self.name + '_confirm_password', val);
            self.model.set(self.name, val);
        });

        this.$('input[name=new_password], input[name=confirm_password]').on('focus.' + this.cid, _.bind(this.handleFocus, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=new_password], input[name=confirm_password]')
            .off('change.' + this.cid)
            .off('focus.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * @return {Boolean} `true` if there is another input to focus, `false` if
     *   it is the last input already.
     */
    focus: function() {
        if (!this.$inputs.length) {
            this.togglePasswordFields();
        }
        // this should be zero but lets make sure
        if (this.focusIndex < 0) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.$inputs.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // focus the next item in our list of inputs
            this.$inputs[this.focusIndex].focus();
            this.focusIndex++;
            return true;
        }
    },

    /**
     * Displays inputs for the new password and the confirmation
     * @param event
     */
    togglePasswordFields: function(event) {
        this.showPasswordFields = true;
        this.render();
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('password_confirmation_' + this.cid);
        this._super('_dispose');
    }
}) },
"username": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UsernameField
 * @alias SUGAR.App.view.fields.BaseUsernameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Username Field (base) 

    //FIXME: SC-3447 this field should have bidirectional input
    direction: 'ltr'
}) },
"forecast-pareto-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastParetoChartField
 * @alias SUGAR.App.view.fields.BaseForecastParetoChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Forecast-pareto-chart Field (base) 

    /**
     * The data from the server
     */
    _serverData: undefined,

    /**
     * The open state of the sidepanel
     */
    state: "open",

    /**
     * Visible state of the preview window
     */
    preview_open: false,

    /**
     * Is the dashlet collapsed or not
     * @param boolean
     */
    collapsed: false,

    /**
     * Throttled Set Server Data call to prevent it from firing multiple times right in a row.
     */
    throttledSetServerData: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.once('render', function() {
            this.renderChart();
        }, this);

        this._super('initialize', [options]);

        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            // we need to listen to the context on the layout for this view for when it collapses
            this.view.layout.on('dashlet:collapse', this.handleDashletCollapse, this);
            this.view.layout.context.on('dashboard:collapse:fire', this.handleDashletCollapse, this);
            // We listen to this event to call the chart resize method
            // because the size of the dashlet can change in the dashboard.
            this.view.layout.context.on('dashlet:draggable:stop', this.handleDashletCollapse, this);
        }

        this.throttledSetServerData = _.throttle(this._setServerData, 1000);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        app.events.on('preview:open', function() {
            this.preview_open = true;
        }, this);
        app.events.on('preview:close', function() {
            this.preview_open = false;
            this.renderDashletContents();
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.state = state;
                this.renderDashletContents();
            });
        }

        this.model.on('change', function(model) {
            var changed = _.keys(model.changed);
            if (!_.isEmpty(_.intersection(['user_id', 'display_manager', 'timeperiod_id'], changed))) {
                this.renderChart();
            }
        }, this);

        this.model.on('change:group_by change:dataset change:ranges', this.renderDashletContents, this);
    },

    /**
     * Utility method to check is the dashlet is visible
     *
     * @return {boolean}
     */
    isDashletVisible: function() {
        return (!this.disposed && this.state === 'open' &&
                !this.preview_open && !this.collapsed && !_.isUndefined(this._serverData));
    },

    /**
     * Utility method to resize dashlet with check for visibility
     *
     * @return {boolean}
     */
    resize: function() {
        if (this.isDashletVisible() && this.paretoChart && _.isFunction(this.paretoChart.update)) {
            this.paretoChart.update();
        }
    },

    /**
     * Utility method to render the chart if the dashlet is visible
     *
     * @return {boolean}
     */
    renderDashletContents: function() {
        if (this.isDashletVisible()) {
            this.convertDataToChartData();
            this.generateD3Chart();

            return true;
        }

        return false;
    },

    /**
     * Utility method since there are two event listeners
     *
     * @param {Boolean} collapsed       Is this dashlet collapsed or not
     */
    handleDashletCollapse: function(collapsed) {
        this.collapsed = collapsed;

        this.renderDashletContents();
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    self.paretoChart.width(640).height(320).update();
                    // Pause for a second to let chart finish rendering
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                self.paretoChart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            this.view.layout.off('dashlet:collapse', null, this);
            this.view.layout.context.off('dashboard:collapse:fire', null, this);
            this.view.layout.context.off('dashlet:draggable:stop', null, this);
        }
        app.events.off(null, null, this);
        this._super('unbindData');
    },

    /**
     * Render the chart for the first time
     *
     * @param {Object} [options]        Options from the dashlet loaddata call
     */
    renderChart: function(options) {
        if (this.disposed || !this.triggerBefore('chart:pareto:render') ||
            _.isUndefined(this.model.get('timeperiod_id')) ||
            _.isUndefined(this.model.get('user_id'))
        ) {
            return;
        }

        this._serverData = undefined;

        this.chartId = this.cid + '_chart';
        this.paretoChart = nv.models.paretoChart()
            .margin({top: 0, right: 10, bottom: 0, left: 10})
            .showTitle(false)
            .tooltips(true)
            .direction(app.lang.direction)
            .tooltipQuota(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var val = app.currency.formatAmountLocale(e.val, app.currency.getBaseCurrencyId());
                return '<p><b>' + e.key + ': <b>' + val + '</b></p>';
            })
            .tooltipLine(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var val = app.currency.formatAmountLocale(e.point.y, app.currency.getBaseCurrencyId());
                return '<p><b>' + app.lang.get('LBL_CUMULATIVE_TOTAL', 'Forecasts') + '</b></p><p>' + key + ': <b>' + val + '</b></p>';
            })
            .tooltipBar(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var val = app.currency.formatAmountLocale(e.value),
                    lbl = app.lang.get('LBL_SALES_STAGE', 'Forecasts');
                if (this.model.get('group_by') == 'probability') {
                    lbl = app.lang.get('LBL_OW_PROBABILITY', 'Forecasts') + ' (%)';
                }

                return '<p>' + lbl + ': <b>' + key + '</b></p>' +
                    '<p>' + app.lang.get('LBL_AMOUNT', 'Forecasts') + ': <b>' + val + '</b></p>' +
                    '<p>' + app.lang.get('LBL_PERCENT', 'Forecasts') + ': <b>' + x + '%</b></p>';
            }, this))
            .colorData('default')
            .colorFill('default')
            .yAxisTickFormat(function(d) {
                var si = d3.formatPrefix(d, 2);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + d3.round(si.scale(d), 2) + si.symbol;
            })
            .quotaTickFormat(function(d) {
                var si = d3.formatPrefix(d, 2);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + d3.round(si.scale(d), 2) + si.symbol;
            })
            //TODO: only do barClick if dashlet in Forecasts intelligence pane
            .barClick(function(data, eo, chart, container) {
                var d = eo.series,
                    selectedSeries = eo.seriesIndex;

                d.disabled = !d.disabled;

                chart.dispatch.tooltipHide();

                if (!chart.stacked()) {
                    data.filter(function(d) {
                        return d.series === selectedSeries && d.type === 'line';
                    }).map(function(d) {
                        d.disabled = !d.disabled;
                        return d;
                    });
                }

                // if there are no enabled data series, enable them all
                if (!data.filter(function(d) {
                    return !d.disabled && d.type === 'bar';
                }).length) {
                    data.map(function(d) {
                        d.disabled = false;
                        container.selectAll('.nv-series').classed('disabled', false);
                        return d;
                    });
                }

                container.call(chart);
            })
            .id(this.chartId)
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA')
            });

        // just on the off chance that no options param is passed in
        options = options || {};
        options.success = _.bind(function(data) {
            if(this.model) {
                this.model.set({
                    title: data.title
                });
                this._serverData = data;
                this.convertDataToChartData();
                this.generateD3Chart();
            }
        }, this);

        var read_options = {};
        if (this.model.has('no_data') && this.model.get('no_data') === true) {
            read_options['no_data'] = 1;
        }

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.model.get('display_manager')) {
            read_options['target_quota'] = (this.model.get('show_target_quota')) ? 1 : 0;
        }

        var url = app.api.buildURL(this.buildChartUrl(), null, null, read_options);

        app.api.call('read', url, {}, options);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var params = this.model.toJSON();

        // clear out the current chart before a re-render
        if (!_.isEmpty(this.paretoChart)) {
            $(window).off('resize.' + this.sfId);
            d3.select('#' + this.chartId + ' svg').remove();
        }

        this.paretoChart.stacked(!params.display_manager);

        if (this.d3Data.data.length > 0) {
            // if the chart element is hidden by a previous render, but has data now, show it
            this.$('.nv-chart').toggleClass('hide', false);
            this.$('.block-footer').toggleClass('hide', true);

            // After the .call(paretoChart) line, we are selecting the text elements for the Y-Axis
            // only so we can custom format the Y-Axis values
            d3.select('#' + this.chartId)
                .append('svg')
                .datum(this.d3Data)
                .call(this.paretoChart);

            $(window).on('resize.' + this.sfId, _.debounce(_.bind(this.resize, this), 100));
            this.handlePrinting('on');

            this.$('.nv-chart').on('click', _.bind(function(e){
              this.paretoChart.dispatch.chartClick();
            }, this));
        } else {
            this.$('.nv-chart').toggleClass('hide', true);
            this.$('.block-footer').toggleClass('hide', false);
        }

        this.trigger('chart:pareto:rendered');
    },

    /**
     * Utility method to determine which data we need to parse,
     */
    convertDataToChartData: function() {
        if(this.state == 'closed' || this.preview_open || this.collapsed || _.isUndefined(this._serverData)) {
            return -1;
        }

        if (this.model.get('display_manager')) {
            this.convertManagerDataToChartData();
        } else {
            this.convertRepDataToChartData(this.model.get('group_by'));
        }
    },

    /**
     * Parse the Manager Data and set the d3Data object
     */
    convertManagerDataToChartData: function() {
        var dataset = this.model.get('dataset'),
            records = this._serverData.data,
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'quotaLabel': app.lang.get((this.model.get('show_target_quota')) ? 'LBL_QUOTA_ADJUSTED' : 'LBL_QUOTA', 'Forecasts'),
                    'groupData': records.map(function(record, i) {
                        return {
                            group: i,
                            l: record.name,
                            t: parseFloat(record[dataset]) + parseFloat(record[dataset + '_adjusted'])
                        };
                    })
                },
                'data': []
            },
            disabledKeys = this.getDisabledChartKeys(),
            barData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds]),
                            y0: 0
                        };
                    }),
                    label = this._serverData.labels['dataset'][ds];

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: vals,
                    valuesOrig: vals
                };
            }, this),
            lineData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds])
                        };
                    }),
                    addToLine = 0,
                    label = this._serverData.labels['dataset'][ds];

                _.each(vals, function(val, i, list) {
                    list[i].y += addToLine;
                    addToLine = list[i].y;
                });

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'line',
                    values: vals,
                    valuesOrig: vals
                };
            }, this);

        if(this.model.get('show_target_quota')) {
            // add target quota to chart data
            chartData.properties.targetQuota = +this._serverData.target_quota;
            chartData.properties.targetQuotaLabel = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        chartData.data = barData.concat(lineData);
        this.d3Data = chartData;
    },

    /**
     * Convert the Rep Data and set the d3Data Object
     *
     * @param {string} type     What we are dispaying
     */
    convertRepDataToChartData: function(type) {
        // clear any NaNs
        _.each(this._serverData.data, function(point) {
            if (_.has(point, 'likely') && isNaN(point.likely)) {
                point.likely = 0;
            }
            if (_.has(point, 'best') && isNaN(point.best)) {
                point.best = 0;
            }
            if (_.has(point, 'worst') && isNaN(point.worst)) {
                point.worst = 0;
            }
        });

        var dataset = this.model.get('dataset'),
            ranges = this.model.get('ranges'),
            seriesIdx = 0,
            barData = [],
            lineVals = this._serverData['x-axis'].map(function(axis, i) {
                return { series: seriesIdx, x: i + 1, y: 0 };
            }),
            line = {
                'key': this._serverData.labels.dataset[dataset],
                'type': 'line',
                'series': seriesIdx,
                'values': [],
                'valuesOrig': []
            },
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'quotaLabel': app.lang.get('LBL_QUOTA', 'Forecasts'),
                    'groupData': this._serverData['x-axis'].map(function(item, i) {
                        return {
                            'group': i,
                            'l': item.label,
                            't': 0
                        };
                    })
                },
                'data': []
            },
            records = this._serverData.data,
            data = (!_.isEmpty(ranges)) ? records.filter(function(rec) {
                return _.contains(ranges, rec.forecast);
            }) : records,
            disabledKeys = this.getDisabledChartKeys();

        _.each(this._serverData.labels[type], function(label, value) {
            var td = data.filter(function(d) {
                return (d[type] == value);
            });

            if (!_.isEmpty(td)) {
                var barVal = this._serverData['x-axis'].map(function(axis, i) {
                        return { series: seriesIdx, x: i + 1, y: 0, y0: 0 };
                    }),
                    axis = this._serverData['x-axis'];

                // loop though all the data and map it to the correct x series
                _.each(td, function(record) {
                    for (var y = 0; y < axis.length; y++) {
                        if (record.date_closed_timestamp >= axis[y].start_timestamp &&
                            record.date_closed_timestamp <= axis[y].end_timestamp) {
                            // add the value
                            var val = parseFloat(record[dataset]);
                            barVal[y].y += val;
                            chartData.properties.groupData[y].t += val;
                            lineVals[y].y += val;
                            break;
                        }
                    }
                }, this);

                barData.push({
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: barVal,
                    valuesOrig: app.utils.deepCopy(barVal)
                });

                // increase the series
                seriesIdx++;
            }
        }, this);

        if (!_.isEmpty(barData)) {
            // fix the line
            var addToLine = 0;
            _.each(lineVals, function(val, i, list) {
                list[i].y += addToLine;
                addToLine = list[i].y;
            });

            line.values = lineVals;
            line.valuesOrig = app.utils.deepCopy(lineVals);

            barData.push(line);
            chartData.data = barData;
        }

        this.d3Data = chartData;
    },

    /**
     * Look at the current chart if it exists and return the keys that are currently
     * disabled they can still be disabled when the chart is re-rendered
     *
     * @return {Array}
     */
    getDisabledChartKeys: function() {
        var currentChartData = d3.select('#' + this.chartId + ' svg').data(),
            disabledBars = (!_.isUndefined(currentChartData[0])) ?
                _.filter(currentChartData[0].data, function(d) {
                    return (!_.isUndefined(d.disabled) && d.disabled === true);
                }) : [];

        return (!_.isEmpty(disabledBars)) ? _.map(disabledBars, function(d) {
            return d.key;
        }) : [];
    },

    /**
     * Accepts params object and builds the proper endpoint url for charts
     *
     * @return {String} has the proper structure for the chart url.
     */
    buildChartUrl: function() {
        var baseUrl = this.model.get('display_manager') ? 'ForecastManagerWorksheets' : 'ForecastWorksheets';
        return baseUrl + '/chart/' + this.model.get('timeperiod_id') + '/' + this.model.get('user_id');
    },

    /**
     * Do we have serverData yet?
     * @return {boolean}
     */
    hasServerData: function() {
        return !_.isUndefined(this._serverData);
    },

    /**
     * Return the data that was passed back from the server
     * @return {Object}
     */
    getServerData: function() {
        return this._serverData;
    },

    /**
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     */
    setServerData: function(data, adjustLabels) {
        this.throttledSetServerData(data, adjustLabels);
    },

    /**
     * This method is called by the _.throttle call in initialize
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     * @private
     */
    _setServerData: function(data, adjustLabels) {
        this._serverData = data;

        if (adjustLabels === true) {
            this.adjustProbabilityLabels();
        }
        this.renderDashletContents();
    },

    /**
     * When the Probability Changes on the Rep Worksheet, The labels in the chart data need to be updated
     * to Account for the potentially new label.
     */
    adjustProbabilityLabels: function() {
        var probabilities = _.unique(_.map(this._serverData.data, function(item) {
            return item.probability;
        })).sort();

        this._serverData.labels.probability = _.object(probabilities, probabilities);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.handlePrinting('off');
        $(window).off('resize.' + this.sfId);
        this.$('.nv-chart').off('click');
        this._super('_dispose');
    }

}) },
"teamset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TeamsetField
 * @alias SUGAR.App.view.fields.BaseTeamsetField
 * @extends View.Fields.Base.RelateField
 */
({
	// Teamset Field (base) 

    extendsFrom: 'RelateField',

    events: {
        'click .btn[name=add]': 'addItem',
        'click .btn[name=remove]': 'removeItem',
        'click .btn[name=primary]': 'setPrimaryItem',
        'change input.select2': 'inputChanged'
    },
    plugins: ['QuickSearchFilter', 'EllipsisInline', 'Tooltip', 'FieldDuplicate'],

    /**
     * HTML tag of the append team checkbox.
     *
     * @property {String}
     */
    appendTeamTag: 'input[name=append_team]',

    initialize: function (options) {
        this._super('initialize', [options]);
        /**
         * @inheritdoc
         */
        this._allow_single_deselect = false;

        /**
         * @inheritdoc
         */
        this._minChars = 1;

        this._currentIndex = 0;
        this.model.on("change:team_name_type", this.appendTeam, this);
    },

    /**
     * @inheritdoc
     *
     * Binds append team checkbox change for massupdate.
     */
    bindDomChange: function() {
        var $el = this.$(this.appendTeamTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTeamValue = $el.prop('checked');
                this.model.set('team_name_type', this.appendTeamValue ? '1' : '0');
            }, this));
        }
        this._super('bindDomChange');
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.appendTeamTag).off();
        this._super('unbindDom');
    },

    /**
     * Handler on copy teamset values from one model to another.
     *
     * Prevent unchecking last team in team set in order to force the existence
     * of at least one checked team. If primary team is unchecked the next
     * checked team is defined as primary. Set up `checked` property for
     * current team and render field. Returns `false` to prevent processing
     * of teamset field copy cause all logic is implemented in this method.
     *
     * Called from {@link app.plugins._beforeFieldDuplicate}.
     */
    beforeFieldDuplicate: function(params) {

        if (!params.model || !params.data) {
            return false;
        }

        if (this.name !== params.data.fieldName ||
            params.model.get('id') !== this.model.get('id')
        ) {
            return true;
        }

        var checked = params.data.checked || false,
            teamId = params.data.recordItemId || null,
            teams = this.model.get(this.name),
            team = _.findWhere(teams, {'id': teamId}),
            primaryTeam = _.findWhere(teams, {'primary': true}),
            checkedTeams = _.where(teams, {'checked': true}),
            newPrimaryTeam = null;

        if (checked === false && checkedTeams.length === 1) {
            if (!this.disposed) {
                this.render();
            }
            return false;
        }

        if (checked === false && primaryTeam === team) {
            newPrimaryTeam = _.find(checkedTeams, function(item) {
                return item.id !== team.id;
            });
            if (newPrimaryTeam) {
                team.primary = false;
                newPrimaryTeam.primary = true;
            }
        }

        if (team) {
            team.checked = checked;
        }

        if (!this.disposed) {
            this.render();
        }
        return false;
    },

    /**
     * Handler to format field for `merge-duplicate` view.
     *
     * For teamset field we override value to have set of teams from all models
     * for primary record in merge-duplicate view.
     *
     * Called from {@link app.plugins._formatFieldForDuplicate}.
     */
    formatFieldForDuplicate: function() {
        if (_.isUndefined(this.view.generatedValues) ||
            _.isUndefined(this.view.generatedValues.teamsets)
        ) {
            return;
        }

        var allTeams = this.view.generatedValues.teamsets[this.name];

        if (!(this.view.collection instanceof Backbone.Collection)) {
            return;
        }

        _.each(this.view.collection.models, function(model) {
            var teamIds = _.compact(_.pluck(model.get(this.name), 'id')),
                primaryTeam = _.findWhere(model.get(this.name), {primary: true}),
                teams = [];

            _.each(allTeams, function(team) {
                if (model === this.view.primaryRecord || _.contains(teamIds, team.id)) {
                    teams.push(_.extend(app.utils.deepCopy(team), {
                        checked: (model === this.view.primaryRecord && _.contains(teamIds, team.id) === true),
                        primary: (primaryTeam && primaryTeam.id === team.id)
                    }));
                } else {
                    teams.push({
                        checked: false,
                        primary: false
                    });
                }
            }, this);
            model.set(this.name, teams, {silent: true});
        }, this);
    },

    /**
     * Handler to unformat field for `merge-duplicate` view.
     *
     * For teamset field we should exclude teams that are not selected before
     * save primary record.
     *
     * Called from {@link app.plugins._unformatFieldForDuplicate}.
     */
    unformatFieldForDuplicate: function() {
        if (!this.view.primaryRecord) {
            return;
        }

        this.view.primaryRecord.set(
            this.name,
            _.where(this.view.primaryRecord.get(this.name), {'checked': true}),
            {silent: true}
        );
    },

    /**
     * Changes default behavior when doing inline editing on a List view.  We want to
     * load 'list' template instead of 'edit' template because this keeps the teamset widget
     * read-only during inline editing. See SP-1197.
     * Overrides templates for `merge-duplicate` view.
     * @override
     * @private
     */
    _loadTemplate: function() {
        this._super("_loadTemplate");

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);

        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }

        // If we're loading edit template on List view switch to detail template instead
        if (!template && this.view.action === 'list' && _.contains(['edit','detail'], this.tplName)) {
            this.template = app.template.getField(
                this.type,
                'list',
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }

        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Add ability to edit and save an invalid team set.
     */
    _render: function () {
        var self = this;

        if (_.isEmpty(this.value) && this.action == 'edit') {
            // Leave an empty team set on list view in case of cancel.
            this.value = app.utils.deepCopy(app.user.getPreference('default_teams'));
            this._updateAndTriggerChange(this.value);
        }
        this._super('_render');

        if (this.tplName === 'edit') {
            this.$(this.fieldTag).each(function (index, el) {
                var plugin = $(el).data("select2");
                // If there is a plugin but no team index, set it
                if (!_.isUndefined(plugin) && _.isUndefined(plugin.setTeamIndex)) {
                    plugin.setTeamIndex = function () {
                        self._currentIndex = $(this).data("index");
                    };
                    plugin.opts.element.on("select2-open", plugin.setTeamIndex);
                }
            });
        }
    },

    /**
     * Called to update value when a selection is made from options view dialog
     * @param model New value for teamset
     */
    setValue: function (model) {
        if (!model) {
            return;
        }
        var index = this._currentIndex,
            team = this.value;
        team[index || 0].id = model.id;
        team[index || 0].name = model.value;
        this._updateAndTriggerChange(team);
    },
    format: function (value) {
        if (this.model.isNew() && (_.isEmpty(value) || this.model.get(this.name) != value)) {
            //load the default team setting that is specified in the user profile settings
            if (_.isEmpty(value)) {
                value = app.utils.deepCopy(app.user.getPreference("default_teams"));
                this.model.setDefault(this.name, value);
            }
        }
        value = app.utils.deepCopy(value);
        if (!_.isArray(value)) {
            value = [
                {
                    name: value
                }
            ];
        }
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        if (this.view.action === 'list' && this.view.name !== 'merge-duplicates' && this.view.name !== 'audit') {
            //Display primary team in list view
            var primaryTeam = _.find(value, function (team) {
                return team.primary;
            });
            // If there is no primary team discovered return an empty string
            return !_.isUndefined(primaryTeam) && !_.isUndefined(primaryTeam.name) ? primaryTeam.name : "";
        }
        // Place the add button as needed
        if (_.isArray(value) && value.length > 0) {
            _.each(value, function (team) {
                delete team.remove_button;
                delete team.add_button;
            });
            if (!value[this._currentIndex]) {
                value[this._currentIndex] = {};
            }
            value[value.length - 1].add_button = true;
            // number of valid teams
            var numTeams = _.filter(value, function (team) {
                return !_.isUndefined(team.id);
            }).length;
            // Show remove button for all unset combos and only set combos if there are more than one
            _.each(value, function (team) {
                if (_.isUndefined(team.id) || numTeams > 1) {
                    team.remove_button = true;
                }
            });
        }
        return value;
    },

    /**
     * Validates for equality on id and primary properties
     * since other attributes are used for rendering.
     *
     * @override
     */
    equals: function(other) {
        var validateMap = function(item) {
            return {
                id: item.id,
                primary: item.primary
            };
        };
        return _.isEqual(
            _.map(this.getFormattedValue(), validateMap),
            _.map(other.getFormattedValue(), validateMap)
        );
    },

    addTeam: function () {
        this.value.push({});
        this._currentIndex++;
        this._updateAndTriggerChange(this.value);
    },
    removeTeam: function (index) {
        // Do not remove last team.
        if (index === 0 && this.value.length === 1) {
            return;
        }
        if (this._currentIndex === this.value.length - 1) {
            this._currentIndex--;
        }
        //Pick first team to be Primary if we're removing Primary team
        var removed = this.value.splice(index, 1);
        if (removed && removed.length > 0 && removed[0].primary) {
            this.setPrimary(0);
        }
        this._updateAndTriggerChange(this.value);
    },
    appendTeam: function () {
        var appendTeam = this.model.get("team_name_type");
        if (appendTeam !== "1") {
            var primaryTeam = _.find(this.value, function (team) {
                return team.primary;
            }, this);
            if (_.isEmpty(primaryTeam)) {
                this.setPrimary(0);
            }
        }
    },
    setPrimary: function (index) {
        var previousPrimary = null,
            appendTeam = this.model.get("team_name_type");
        _.each(this.value, function (team, i) {
            if (team.primary && appendTeam === "1") {
                previousPrimary = i;
            }
            team.primary = false;
        });
        //If this team is set, then allow it to turn primary
        if (previousPrimary !== index && this.value[index].name) {
            this.value[index].primary = true;
        }
        this._updateAndTriggerChange(this.value);
        return (this.value[index]) ? this.value[index].primary : false;
    },
    //Forcing change event since backbone isn't picking up on changes within an object within the array.
    inputChanged: function (evt) {
        this._updateAndTriggerChange(this.value);
    },
    /**
     * @inheritdoc
     * Restore the select2 focus location after refresh the dom.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                this.render();
                if (!_.isEmpty(this.$(this.fieldTag).data('select2'))) {
                    this.$(this.$(this.fieldTag).get(this._currentIndex)).focus();
                }
            }, this);
        }
    },
    /**
     * Forcing change event on value update since backbone isn't picking up on changes within an object within the array.
     * @param value New value for teamset field
     * @private
     */
    _updateAndTriggerChange: function (value) {
        // SP-1437: No Warning message when update with Team field only

        // The following is provided for your convenience should you wish to learn more about
        // Backbone Model .changedAttributes() not showing all changes.
        // For a list of the actual third party software used in this Sugar product,
        // please visit http://support.sugarcrm.com/06_Customer_Center/11_Third_Party_Software/.
        //
        // http://stackoverflow.com/questions/17221680/backbone-model-changedattributes-not-showing-all-changes
        _.each(value, function(team) {
            // "add_button" and "remove_button" are JS elements, don't track them.
            delete team.add_button;
            delete team.remove_button;
        });
        this.model.unset(this.name, {silent: true}).set(this.name, value);//force changedAttributes
        this.model.trigger("change");
    },
    addItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        //Only allow adding a Team when ones been selected (SP-534)
        if (!index || this.value[index].id) {
            this.addTeam();
        }
    }, 0),
    removeItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        if (_.isNumber(index)) {
            this.removeTeam(index);
        }
    }, 0),
    setPrimaryItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');

        //Don't allow setting to primary until user's selected an actual team (SP-530)
        if (!this.value[index] || !this.value[index].id) {
            return;
        }
        this.$(".btn[name=primary]").removeClass("active");
        if (this.setPrimary(index)) {
            this.$(".btn[name=primary][data-index=" + index + "]").addClass("active");
        }
    }, 0)
}) },
"selection": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseSelectionField
 * @extends View.Fields.Base.BaseField
 */
({
	// Selection Field (base) 

    events: {
        'click input.selection': 'toggleSelect'
    },
    toggleSelect: function(evt) {
        var $el = $(evt.currentTarget).is(":checked");
        if($el) {
            this.check();
        } else {
            this.uncheck();
        }
    },
    check: function() {
        if(this.model) {
            this.context.set('selection_model', this.model);
        }
    },
    uncheck: function() {
        if(this.model) {
            this.context.unset('selection_model');
        }
    },
    bindDomChange: function() {
        //don't update the row's model & re-render, this is just a mechanism for selecting a row
    }
}) },
"copy": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CopyField
 * @alias SUGAR.App.view.fields.BaseCopyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Copy Field (base) 

    'events': {
        'click button': 'copyOnce'
    },

    _initialValues: null,
    _fields: null,
    _inSync: false,

    /**
     * Initializes the copy field component.
     *
     * Initializes the initialValues and fields properties.
     * Enables sync by default.
     *
     * @inheritdoc
     */
    initialize: function(options) {

        this._super('initialize', [options]);
        this._initialValues = {};
        this._fields = {};

        if (_.isUndefined(this.def.sync)) {
            this.def.sync = true;
        }

        this.before('render', function() {
            this.setDisabled(!this.hasAccess());
            return true;
        }, this);
    },

    /**
     * Function called for each click on checkbox (normally acts as toggle
     * function).
     *
     * If the checkbox is checked, copy all the source fields to target ones
     * based on the mapping definition of this field and disable target fields.
     * Otherwise, restore all the values of the modified fields by this copy
     * widget and enable target fields.
     *
     */
    toggle: function() {
        this.sync(this.$fieldTag.is(':checked'));
    },

    sync: function(enable) {

        enable = this.hasAccess() && (_.isUndefined(enable) || enable);

        if (this._inSync === enable) {
            return;
        }
        this._inSync = enable;

        if (!enable) {
            this.syncCopy(false);
            this.restore();
            return;
        }

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(true);
            }
        }, this);

        this.syncCopy(true);
    },

    /**
     * Function called for each click on button (normally acts as copy once).
     *
     * If the button is pressed, copy all the source fields to target ones
     * based on the mapping definition of this field.
     *
     * @param {Event} evt
     *   The event (expecting a click event) that triggers the copy once.
     */
    copyOnce: function(evt) {

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
        }, this);
    },

    /**
     * Copies the source field value to the target field.
     *
     * Store the initial value of the target field to be able to restore it
     * after. Copy the source field value to the target field.
     *
     * @param {View.Field} from
     *   The source field to get the value from.
     * @param {View.Field} to
     *   The target field to set the value to.
     */
    copy: function(from, to) {

        if (!this.model.has(from)) {
            return;
        }

        if (_.isUndefined(this._initialValues[to])) {
            this._initialValues[to] = this.model.get(to);
        }

        if (app.acl.hasAccessToModel('edit', this.model, to)) {
            this.model.set(to, this.model.get(from));
        }
    },

    /**
     * Restores all the initial value of the fields that were modified by this
     * copy command.
     */
    restore: function() {

        _.each(this._initialValues, function(value, field) {
            this.model.set(field, value);
        }, this);

        _.each(this.def.mapping, function(target, source) {
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(false);
            }
        }, this);

        this._initialValues = {};
    },

    /**
     * Enables or disables the sync copy only if the field has the `sync`
     * definition to set to TRUE.
     *
     * @param {Boolean} enable
     *   TRUE to keep the mapping fields in sync, FALSE otherwise.
     */
    syncCopy: function(enable) {

        if (!this.def.sync) {
            return;
        }

        if (!enable) {
            this.model.off(null, this.copyChanged, this);
            return;
        }

        var events = _.map(_.keys(this.def.mapping), function(field) {
            return 'change:' + field;
        });
        this.model.on(events.join(' '), this.copyChanged, this);
    },

    /**
     * Callback for the syncCopy binding.
     *
     * @param {Backbone.Model} model
     *   The model that was changed.
     * @param {*} value
     *   The value of the field that was changed.
     */
    copyChanged: function(model, value) {
        _.each(model.changedAttributes(), function(newValue, field) {
            model.set(this.def.mapping[field], model.get(field));
        }, this);
    },

    /**
     * Get the field with the supplied name.
     *
     * Cache the fields locally to be faster on next request of the same field.
     *
     * @param {String} name
     *   The name of the field to search for.
     *
     * @return {View.Field}
     *   The field with the name given.
     */
    getField: function(name) {

        if (_.isUndefined(this._fields[name])) {
            this._fields[name] = _.find(this.view.fields, function(field) {
                return field.name == name;
            });
        }

        return this._fields[name];
    },

    unformat: function(value) {
        // TODO this should change once we save this in the db
        return null;
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function(value) {
        if (_.isNull(value)) {
            // TODO this should change to the value once we get it from the model
            return this._inSync;
        }
        return value;
    },
    /**
     * Binds DOM changes to a model.
     */
    bindDomChange: function() {

        if (!(this.model instanceof Backbone.Model)) return;

        var self = this;
        var el = this.$fieldTag = this.$el.find(this.fieldTag);
        el.on("change", function() {
          self.toggle();
        });
    },
    /**
     * @inheritdoc
     *
     * This will make the fields in sync if it is on by default.
     */
    bindDataChange: function() {

        // TODO this field should be saved on the DB so we don't have this hack
        if (this.model && this.def.sync) {

            var active = !_.isUndefined(this.def['default']) ? this.def['default'] : true;
            if (!active && this.model.isNew()) {
                return;
            }

            var inSync = this.model.isNew() || _.all(this.def.mapping, function(target, source) {
                return this.model.has(source) && this.model.get(source) === this.model.get(target);
            }, this);
            this.sync(inSync);
        }
    },

    /**
     * Determine if ACLs allow for the copy to show
     * ACL check should return true if there is access to read target and edit
     * source for at least to one mapped field
     * @return {Boolean}
     */
    hasAccess: function() {
        return _.some(this.def.mapping || [], function(toField, fromField) {
            return app.acl.hasAccessToModel('read', this.model, fromField) &&
                app.acl.hasAccessToModel('edit', this.model, toField);
        }, this);
    }
}) },
"linkfromreportbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * LinkFromReportButton allows user to select a report and relate records to
 * primary record.
 *
 * @class View.Fields.Base.LinkfromreportbuttonField
 * @alias SUGAR.App.view.fields.BaseLinkfromreportbuttonField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Linkfromreportbutton Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Event handler for the select button that opens a
     * {@link View.Layouts.Base.SelectionListLinkLayout} in  a drawer for linking
     * an existing record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        var filteredModule = 'Reports',
            filterOptions = new app.utils.FilterOptions().config(this.def);

        var thisContextModule = this.context.get('module');
        if (thisContextModule !== filteredModule) {
            filterOptions.setLangModules([thisContextModule, filteredModule, 'Filters']);
        }

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: 'Reports',
                filterOptions: filterOptions.format()
            }
        }, _.bind(this.selectDrawerCallback, this));
    },

    /**
     * Process the report that was selected by the user.
     * @param {Object} model
     */
    selectDrawerCallback: function(model) {
        if (!model || _.isEmpty(model.id)) {
            return;
        }

        if (model.module != this.context.get('module')) {
            app.alert.show('listfromreport-warning', {
                level: 'warning',
                messages: app.lang.get('LBL_LINK_FROM_REPORT_WRONG_MODULE'),
                autoClose: true
            });
            return;
        }

        var recordListUrl = app.api.buildURL('Reports', 'record_list', {id: model.id}),
            self = this;

        app.alert.show('listfromreport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

        app.api.call(
            'create',
            recordListUrl,
            null,
            {
                success: _.bind(self.linkRecordList, self),
                error: function(error) {
                    app.alert.dismiss('listfromreport_loading');
                    app.alert.show('server-error', {
                        level: 'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                }
            }
        );
    },

    /**
     * Links records from a report to the parent record
     * @param {Object} response
     */
    linkRecordList: function(response) {
        var parentModel = this.context.get('parentModel'),
            parentModule = parentModel.get('module') || parentModel.get('_module'),
            link = this.context.get('link'), action = 'link/' + link + '/add_record_list',
            url = app.api.buildURL(
                parentModule,
                action,
                {
                    id: parentModel.get('id'),
                    relatedId: response.id
                }
            );

        app.api.call('create', url, null, {
            success: _.bind(this.linkSuccessCallback, this),
            error: _.bind(this.linkErrorCallback, this),
            complete: function(data) {
                app.alert.dismiss('listfromreport_loading');
            }
        });
    },

    /**
     * Success callback function for api call
     * @param {Object} results
     */
    linkSuccessCallback: function(results) {
        var message, messageLevel;
        if (results.related_records.success.length > 0) {
            messageLevel = 'success';
            message = app.lang.get('LBL_LINK_FROM_REPORT_SUCCESS', null, {
                reportCount: results.related_records.success.length
            });
        } else {
            messageLevel = 'warning';
            message = app.lang.get('LBL_LINK_FROM_REPORT_NO_DATA');
        }

        app.alert.show('server-success', {
            level: messageLevel,
            messages: message,
            autoClose: true
        });

        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
        this.context.loadData();
    },

    /**
     * Error callback function for api call
     * @param {Object} error
     */
    linkErrorCallback: function(error) {
        app.alert.show('server-error', {
            level: 'error',
            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
        });
    },

    /**
     * Returns false if current user does not have access to Reports module - ACL checks
     * @return {Boolean} true if allow access, false otherwise
     * @override
     */
    isDisabled: function() {
        return !app.acl.hasAccess('view', 'Reports');
    }
}) },
"preview-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Preview-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * True if the preview button is for a BWC module, false if not
     * @property {boolean}
     */
    isBwcEnabled: undefined,

    /**
     * Holds the proper tooltip label key
     */
    tooltip: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var fieldModule = options.model.get('_module');
        this.isBwcEnabled = app.metadata.getModule(fieldModule).isBwcEnabled;

        this._super('initialize', [options]);

        if(this.isBwcEnabled) {
            this.tooltip = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else {
            this.tooltip = this.def.tooltip;
        }
    }
}) },
"fieldset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * A fieldset is a field that contains one or more child fields.
 * The hbs template sets the placeholders of child fields but the creation of
 * child fields reside in the controller.
 *
 * Accessibility is checked against each child field as well as the fieldset.
 * We do not hide the fieldset in the event that the fieldset is accessible and
 * all child fields are not.
 *
 * Supported properties:
 *
 * - {Array} fields List of fields that are part of the fieldset.
 * - {boolean} show_child_labels Set to `true` to show labels on child fields in
 * the record view.
 * - {boolean} inline Set to `true` to render the fieldset inline.
 * - {boolean} equal_spacing When in inline mode, setting `true` will make the
 * fields inside fieldsets to have equal spacing, rather than being left aligned.
 *
 * Example usage:
 *
 *      array(
 *          'name' => 'date_entered_by',
 *          'type' => 'fieldset',
 *          'label' => 'LBL_DATE_ENTERED',
 *          'fields' => array(
 *              array(
 *                  'name' => 'date_entered',
 *              ),
 *              array(
 *                  'type' => 'label',
 *                  'default_value' => 'LBL_BY',
 *              ),
 *              array(
 *                  'name' => 'created_by_name',
 *              ),
 *          )
 *      )
 *
 * @class View.Fields.Base.FieldsetField
 * @alias SUGAR.App.view.fields.BaseFieldsetField
 * @extends View.Fields.Base.BaseField
 */
({
	// Fieldset Field (base) 

    /**
     * Initializes the fieldset field component.
     *
     * Initializes the fields property.
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * Children fields that are created as part of this field.
         *
         * @property {Array}
         */
        this.fields = [];

        var inlineTag = this.def.inline ? '-inline' : '';
        this.def.css_class = (this.def.css_class ? this.def.css_class + ' fieldset' :
            'fieldset') + inlineTag;

        if (this.def.equal_spacing && this.def.inline) {
            this.def.css_class += ' fieldset-equal';
        }
    },

    /**
     * @inheritdoc
     *
     * Looks for the fallback template as specified by the view. Returns the
     * `detail` template if it's not found.
     * FIXME: SC-3363 This should be the default behavior in `field.js`.
     */
    _getFallbackTemplate: function(viewName) {
        if (_.contains(this.fallbackActions, viewName)) {
            return viewName;
        }
        if (app.template.get('f.' + this.type + '.' + this.view.fallbackFieldTemplate)) {
            return this.view.fallbackFieldTemplate;
        }
        return 'detail';
    },

    /**
     * @inheritdoc
     *
     * Loads the `record-detail` template if the view is `record`.
     * FIXME: This is a quick hack and will be fixed by SC-3364.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if ((this.view.name === 'record' || this.view.name === 'create'
            || this.view.name === 'create-nodupecheck' || this.view.name === 'pmse-case')
            && this.type === 'fieldset' && !_.contains(this.fallbackActions, this.action)) {

            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * @inheritdoc
     *
     * If current fieldset is not readonly, it always falls back to false
     * (nodata unsupportable).
     * If current fieldset is readonly and all dependant fields contains empty
     * data set, then it falls back to true.
     *
     * @return {Boolean} true if this fieldset is readonly and all the data
     * fields are empty.
     */
    showNoData: function() {

        if (!this.def.readonly) {
            return false;
        }

        return !_.some(this.fields, function(field) {
            return field.name && field.model.has(field.name);
        });
    },

    /**
     * @inheritdoc
     *
     * We set the result from `field.getPlaceholder()` into a property named
     * `placeholder` for each of the child fields. These placeholders help us
     * render the child fields when placed in the hbs file.
     */
    _render: function() {
        var fields = this._getChildFields();
        _.each(fields, function(field) {
            field.placeholder = field.getPlaceholder();
        }, this);

        this.focusIndex = 0;

        this._super('_render');

        this._renderFields(fields);

        return this;
    },

    /**
     * Renders the children fields in their respective placeholders.
     *
     * @param {Array} fields The children fields.
     * @protected
     */
    _renderFields: function(fields) {
        // In terms of performance it is better to search the DOM once for
        // all the fieldset fields, than to search the DOM for each field.
        // That's why we cache the DOM elements in the `fieldElems` hash and pass
        // them to {@link Backbone.View#setElement}.
        var fieldElems = {};

        this.$('span[sfuuid]').each(function() {
            var $this = $(this);
            var sfId = $this.attr('sfuuid');
            fieldElems[sfId] = $this;
        });

        _.each(fields, function(field) {
            field.setElement(fieldElems[field.sfId]);
            field.render();
        }, this);
    },

    /**
     * Gets the child field definitions that are defined in the metadata.
     *
     * @return {Object} Metadata of the child fields.
     * @protected
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.fields);
    },

    /**
     * Creates the children fields that are specified in the definitions.
     *
     * @return {Array} Children fields that are created.
     * @protected
     */
    _getChildFields: function() {
        var metaFields = this._getChildFieldsMeta();
        if (_.isEmpty(this.fields) && metaFields) {
            _.each(metaFields, function(fieldDef) {
                var field = app.view.createField({
                    def: fieldDef,
                    view: this.view,
                    viewName: this.options.viewName,
                    model: this.model
                });
                this.fields.push(field);
                field.parent = this;
            }, this);
        }
        return this.fields;
    },

    /**
     * @inheritdoc
     */
    clearErrorDecoration: function() {
        _.each(this.fields, function(field) {
            field.clearErrorDecoration();
        });

        this._super('clearErrorDecoration');
    },

    /**
     * The tab handler.
     *
     * Focus on the next child field. Skips disabled fields.
     *
     * @return {boolean} `true` if this method should be called upon the next tab.
     */
    focus: function() {
        // this should be zero but lets make sure
        if (this.focusIndex < 0 || !this.focusIndex) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.fields.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // this field is disabled skip ahead
            if (this.fields[this.focusIndex] && this.fields[this.focusIndex].isDisabled()) {
                this.focusIndex++;
                return this.focus();
            }
            // if the next field returns true its not done focusing so don't
            // increment to the next field
            if (_.isFunction(this.fields[this.focusIndex].focus) && this.fields[this.focusIndex].focus()) {
            } else {
                var field = this.fields[this.focusIndex];
                var $el = field.$(field.fieldTag + ':first');
                $el.focus().val($el.val());
                this.focusIndex++;
            }
            return true;
        }
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this._super('setDisabled', [disable]);
        _.each(this.fields, function(field) {
            field.setDisabled(disable);
        }, this);
    },

    /**
     * @inheritdoc
     */
    setViewName: function(view) {
        this._super('setViewName', [view]);
        _.each(this.fields, function(field) {
            field.setViewName(view);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Set action name of child fields of this field set.
     * Reset current focus index to the first item when it switches to different mode.
     */
    setMode: function(name) {
        this.focusIndex = 0;

        //Set the mode on child fields without rendering
        _.each(this.fields, function(field) {
            var oldAction = field._previousAction || field.action;
            field._removeViewClass(oldAction);
            if (field.isDisabled()) {
                field._previousAction = name;
            } else {
                field.action = name;
            }
            field.setViewName(name);
        });

        //The _super 'setMode' would render all child fields.
        this._super('setMode', [name]);
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    bindDomChange: function() {
    },

    /**
     * @inheritdoc
     *
     * Keep empty because you cannot set a value of a type `fieldset`.
     */
    bindDataChange: function() {
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    unbindDom: function() {
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        //fields inside fieldset need to be disposed before the fielset itself is disposed.
        _.each(this.fields, function(field) {
            field.parent = null;
            field.dispose();
        });
        this.fields = null;
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"dashletaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DashletactionField
 * @alias SUGAR.App.view.fields.BaseDashletactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Dashletaction Field (base) 

    events: {
        'click [data-dashletaction]': 'actionClicked'
    },
    extendsFrom: 'ButtonField',
    /**
     * Trigger the function which is in the dashlet view.
     *
     * @param {Event} evt Mouse event.
     */
    actionClicked: function(evt) {
        if (this.preventClick(evt) === false) {
            return;
        }
        var action = $(evt.currentTarget).data('dashletaction');
        this._runAction(evt, action);
    },

    /**
     * Handles rowaction's event trigger and propagate the event to the main dashlet.
     *
     * @param {Event} evt Mouse event.
     * @param {String} action Name of executing parent action.
     * @protected
     */
    _runAction: function(evt, action) {
        if (!action) {
            return;
        }
        var dashlet = this.view.layout ? _.first(this.view.layout._components) : null;
        if (dashlet && _.isFunction(dashlet[action])) {
            dashlet[action](evt, this.def.params);
        } else if (_.isFunction(this.view[action])) {
            this.view[action](evt, this.def.params);
        }
    }
}) },
"bool": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BoolField
 * @alias SUGAR.App.view.fields.BaseBoolField
 * @extends View.Fields.Base.BaseField
 */
({
	// Bool Field (base) 

    /**
     * HTML tag of the select2 field.
     *
     * @property {String}
     */
    select2fieldTag: 'select',

    /**
     * @inheritdoc
     *
     * Renders both checkbox and dropdown
     */
    _render: function() {
        this._super('_render');
        this.$(this.select2fieldTag).select2({'minimumResultsForSearch': -1});
    },

    /**
     * @inheritdoc
     */
    _getFallbackTemplate: function(viewName) {
        if (viewName === 'massupdate') {
            return 'dropdown';
        }
        return this._super('_getFallbackTemplate', [viewName]);
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var $el = this.$(this.select2fieldTag);
        if (!$el.length) {
            $el = this.$(this.fieldTag);
        }
        $el.on('change', _.bind(function() {
            var value = $el.is(this.select2fieldTag) ? $el.val() : $el.prop('checked');
            this.model.set(this.name, this.unformat(value));
        }, this));
    },

    /**
     * @inheritdoc
     *
     * Bypass `render` when action is `massupdate` or `edit`.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.action === 'massupdate') {
                this.$(this.select2fieldTag).val(this.format(value) ? '1' : '0');
            } else if (this.action === 'edit') {
                this.$(this.fieldTag).prop('checked', this.format(value));
            } else {
                this.render();
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.select2fieldTag).off();
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to unformat.
     * @return {Boolean} Unformatted value.
     */
    unformat: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to format.
     * @return {Boolean} formatted value.
     */
    format: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    }
}) },
"favorite": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FavoriteField
 * @alias SUGAR.App.view.fields.BaseFavoriteField
 * @extends View.Fields.Base.BaseField
 */
({
	// Favorite Field (base) 


    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    'events': {
        'click .fa-favorite': 'toggle'
    },
    plugins: ['Tooltip'],
    /**
     * @inheritdoc
     *
     * The favorite is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        app.view.Field.prototype.initialize.call(this, options);
    },

    /**
     * Check first if the module has favoritesEnabled before rendering it.
     *
     * @private
     */
    _render: function() {
        // can't favorite something without an id
        if (!this.model.get('id')) {
            return null;
        }
        if (!app.metadata.getModule(this.model.module).favoritesEnabled) {
            app.logger.error("Trying to use favorite field on a module that doesn't support it: '" + this.model.module + "'.");
            return null;
        }
        return app.view.Field.prototype._render.call(this);
    },

    /**
     * Function called for each click on the star icon (normally acts as toggle
     * function).
     *
     * If the star is checked, copy all the source fields to target ones
     * based on the mapping definition of this field. Otherwise, restore all the
     * values of the modified fields by this copy widget.
     *
     * @param {Event} evt
     *   The event (expecting click event) that triggered the checkbox status
     *   change.
     */
    toggle: function(evt) {
        var self = this,
            star = $(evt.currentTarget);

        var options = {
            silent: true,
            alerts: false
        };
        //when we toggle favorite icon on list view we need to update the view to actually see the changes
        if (self.view && self.view.action === 'list') {
            options.success = function() {
                self._refreshListView();
            };
        }

        if (this.model.favorite(!this.model.isFavorite(), options) === false) {
            app.logger.error("Unable to set '" + this.model.module + "' record '" + this.model.id + "' as favorite");
            return;
        }
        if (this.model.isFavorite()) {
            star.addClass('active');
            this.model.trigger("favorite:active");
        }
        else {
            star.removeClass('active');
        }
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function() {
        return this.model.isFavorite();
    },

    /**
     * On model save success, this function gets called to refresh the list
     * view.
     *
     * {@link View.Fields.Base.FavoriteField} is using about the same method.
     *
     * @private
     */
    _refreshListView: function() {
        var filterPanelLayout = this.view;
        //Try to find the filterpanel layout
        while (filterPanelLayout && filterPanelLayout.name !== 'filterpanel') {
            filterPanelLayout = filterPanelLayout.layout;
        }
        //If filterpanel layout found and not disposed, then pick the value from the quicksearch input and
        //trigger the filtering
        if (filterPanelLayout && !filterPanelLayout.disposed && this.collection) {
            filterPanelLayout.applyLastFilter(this.collection, 'favorite');
        }
    }
}) },
"chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ChartField
 * @alias SUGAR.App.view.fields.BaseChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Chart Field (base) 

    /**
     * Contains the actual chart being displayed
     */
    chart_loaded: false,
    chart: null,
    chartType: '',

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:rawChartData', function(model, newChartData) {
            // make sure this.model.get('rawChartData') is not null by checking that
            // the newChartData (data set for the model's rawChartData) is not null
            if (newChartData && this.model.get('rawChartData').values.length > 0) {
                this.displayNoData(false);
                this.$('.nv-chart').attr('class', 'nv-chart nv-' + this.chartType);
                // if the chart already exists, remove it before we generate the new one
                if (this.chart_loaded) {
                    this.$('#d3_' + this.cid + ' svg').remove();
                }
                this.generateD3Chart();
            } else {
                this.displayNoData(true);
            }
        }, this);
    },

    overflowHandler: function(distance) {
        var b = this.view.$el.parents().filter(function() {
            return $(this).css('overflow-y') === 'auto' || $(this).css('overflow-y') === 'scroll';
        }).first();

        b.scrollTop(b.scrollTop() + distance);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var self = this,
            chart,
            chartId = this.cid,
            chartData = this.model.get('rawChartData'),
            chartParams = this.model.get('rawChartParams') || {},
            chartConfig = this.getChartConfig(chartData),
            reportData = this.model.get('rawReportData'),
            params = {
                contentEl: chartId,
                minColumnWidth: 120,
                margin: {top: 0, right: 10, bottom: 10, left: 10},
                allowScroll: true,
                overflowHandler: _.bind(this.overflowHandler, this)
            };

        if (!_.isEmpty(chartParams)) {
            params = _.extend(params, chartParams);
            chartData.properties[0].type = chartParams.chart_type;
            // allow override of chart type
            chartConfig = this.getChartConfig(chartData);
        }

        chartConfig['direction'] = app.lang.direction;

        chart = new loadSugarChart(chartId, chartData, [], chartConfig, params, _.bind(function(chart) {
            self.chart = chart;
            self.chart_loaded = _.isFunction(this.chart.update);
        }, this));

        // This event fires when a preview is closed.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the preview was open.
        app.events.on('preview:close', function() {
            if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
                this.resize();
            }
        }, this);
        // This event fires when the dashlet is collapsed or opened.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the dashlet was closed.
        this.view.layout.on('dashlet:collapse', function(collapse) {
            if (!collapse) {
                this.resize();
            }
        }, this);
        // This event fires when the dashlet is dragged and dropped.
        // We listen to this event to call the chart resize method
        // because the size of the dashlet can change in the dashboard.
        this.view.layout.context.on('dashlet:draggable:stop', function() {
            this.resize();
        }, this);
        // Resize chart on window resize.
        // This event also fires when the sidebar is collapsed or opened.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the sidebar was closed.
        $(window).on('resize.' + this.sfId, _.debounce(_.bind(this.resize, this), 100));
        // Resize chart on print.
        this.handlePrinting('on');
        // This on click event is required to dismiss the dropdown legend
        this.$('.nv-chart').on('click', _.bind(function(e){
          this.chart.dispatch.chartClick();
        }, this));
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartData) {
        var chartConfig,
            chartData = chartData || this.model.get('rawChartData');

        switch (chartData.properties[0].type) {
            case 'pie chart':
                chartConfig = {
                    pieType: 'basic',
                    chartType: 'pieChart'
                };
                break;

            case 'line chart':
                chartConfig = {
                    lineType: 'basic',
                    chartType: 'lineChart'
                };
                break;

            case 'funnel chart':
            case 'funnel chart 3D':
                chartConfig = {
                    funnelType: 'basic',
                    chartType: 'funnelChart'
                };
                break;

            case 'gauge chart':
                chartConfig = {
                    gaugeType: 'basic',
                    chartType: 'gaugeChart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;
        }

        this.chartType = chartConfig.chartType;

        return chartConfig;
    },

    /**
     * Checks to see if the chart is available and is displayed before resizing
     */
    resize: function() {
        // If (this.chart_loaded && !this.sidebar_closed && !this.preview_open && !this.dashlet_collapsed) {
        if (!this.chart_loaded) {
            return;
        }
        // This handles the case of preview open and dashlet collapsed.
        // We don't need to handle the case of collapsed sidepane
        // because charts can resize when inside an invisible container.
        // It is being inside a display:none container that causes problems.
        if (!this.view.$el || !this.view.$el.is(':visible')) {
            return;
        }
        this.chart.update();
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                        self.chart.legend.showAll(true);
                    }
                    self.chart.width(640).height(320).update();
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                    self.chart.legend.showAll(false);
                }
                self.chart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * Toggle display of dashlet content and NoData message
     * @param {boolean} state The visibility state of the dashlet content.
     */
    displayNoData: function(state) {
        this.$('[data-content="chart"]').toggleClass('hide', state);
        this.$('[data-content="nodata"]').toggleClass('hide', !state);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.view && this.view.layout) {
            this.view.layout.off(null, null, this);
        }
        if (this.view && this.view.layout) {
            this.view.layout.context.off(null, null, this);
        }
        this.$('.nv-chart').off('click');
        $(window).off('resize.' + this.sfId);
        this.handlePrinting('off');

        app.view.Field.prototype._dispose.call(this);
    }
}) },
"datetimecombo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DatetimecomboField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboField
 * @extends View.Fields.Base.DateField
 */
({
	// Datetimecombo Field (base) 

    extendsFrom: 'DateField',

    /**
     * HTML tag of the secondary field.
     *
     * @property {String}
     */
    secondaryFieldTag: 'input[data-type=time]',

    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * If a time picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasTimePicker = false;
    },

    /**
     * @inheritdoc
     *
     * Add `show-timepicker` on click listener.
     */
    _initEvents: function() {
        this._super('_initEvents');

        _.extend(this.events, {
            'click [data-action="show-timepicker"]': 'showTimePicker'
        });

        return this;
    },

    /**
     * @override
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateTimeFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * @inheritdoc
     */
    _initPlaceholderAttribute: function() {
        this._super('_initPlaceholderAttribute');

        var placeholder = this.getTimePlaceHolder(this.getUserTimeFormat());

        this.secondaryFieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * Handler to show time picker on icon click.
     *
     * We trigger the focus on element instead of the jqueryfied element, to
     * trigger the focus on the input and avoid the `preventDefault()` imposed
     * in the library.
     */
    showTimePicker: function() {
        this.$(this.secondaryFieldTag)[0].focus();
    },

    /**
     * Return user time format.
     *
     * @return {String} User time format.
     */
    getUserTimeFormat: function() {
        return app.user.getPreference('timepref');
    },

    /**
     * Return user time format.
     *
     * @return {String} User time format.
     */
    getUserDateTimeFormat: function() {
        return this.getUserDateFormat() + ' ' + this.getUserTimeFormat();
    },

    /**
     * Return time place holder based on supplied format.
     *
     * @param {String} format Format.
     * @return {String} Time place holder.
     */
    getTimePlaceHolder: function(format) {
        var map = {
            'H': 'hh',
            'h': 'hh',
            'i': 'mm',
            'a': '',
            'A': ''
        };

        return format.replace(/[HhiaA]/g, function(s) {
            return map[s];
        });
    },

    /**
     * Set up the time picker.
     *
     * @protected
     */
    _setupTimePicker: function() {
        var options;

        this.def.time || (this.def.time = {});

        options = {
            timeFormat: this.getUserTimeFormat(),
            scrollDefaultNow: _.isUndefined(this.def.time.scroll_default_now) ?
                true :
                !!this.def.time.scroll_default_now,
            step: this.def.time.step || 15,
            disableTextInput: _.isUndefined(this.def.time.disable_text_input) ?
                false :
                !!this.def.time.disable_text_input,
            className: this.def.time.css_class || 'prevent-mousedown',
            appendTo: this.$el
        };

        this._enableDuration(options);

        this.$(this.secondaryFieldTag).timepicker(options);
        this._hasTimePicker = true;
    },

    /**
     * Show duration on the timepicker dropdown if enabled in view definition.
     * @param {Object} options - timepicker options
     * @private
     */
    _enableDuration: function(options) {
        var self = this;

        if (this.def.time.duration) {
            options.maxTime = 85500; //23.75 hours, which is 11:45pm

            options.durationTime = function() {
                var dateStartString = self.model.get(self.def.time.duration.relative_to),
                    dateEndString = self.model.get(self.name),
                    startDate,
                    endDate;

                this.minTime = null;
                this.showDuration = false;

                if (!dateStartString || !dateEndString) {
                    return;
                }

                startDate = app.date(dateStartString);
                endDate = app.date(dateEndString);

                if ((startDate.years() === endDate.years()) && (startDate.months() === endDate.months()) && (startDate.days() === endDate.days())) {
                    this.minTime = app.date.duration({
                        hours: startDate.hours(),
                        minutes: startDate.minutes()
                    }).asSeconds();
                    this.showDuration = true;
                }

                return this.minTime;
            };
        }
    },

    /**
     * Handle date and time picker changes.
     *
     * If model value is defined and supplied date or time is empty, an empty
     * string is returned, otherwise, empty values will fallback to current
     * date/time.
     *
     * All parameters and returned value are formatted according to user
     * preferences.
     *
     * @param {String} d Date value.
     * @param {String} t Time value.
     * @return {String} Datetime value.
     */
    handleDateTimeChanges: function(d, t) {
        if (this.model.get(this.name) && (!d || !t)) {
            return '';
        }

        var now = app.date();

        d = d || (t && now.format(app.date.convertFormat(this.getUserDateFormat())));
        t = t || (d && now.format(app.date.convertFormat(this.getUserTimeFormat())));

        return (d + ' ' + t).trim();
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Handles `hide` date picker event expecting to set the default time if
     * not filled yet, see {@link #handleDateTimeChanges}.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     *
     * @override
     */
    handleHideDatePicker: function() {
        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            d = $dateField.val(),
            t = $timeField.val(),
            datetime = this.unformat(this.handleDateTimeChanges(d, t));

        if (!datetime) {
            $dateField.val('');
            $timeField.val('');
        }
        this.model.set(this.name, datetime);
    },

    /**
     * @inheritdoc
     *
     * Bind time picker `changeTime` event expecting to set the default date if
     * not filled yet, see {@link #handleDateTimeChanges}.
     */
    bindDomChange: function() {
        this._super('bindDomChange');

        if (this._inDetailMode()) {
            return;
        }

        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            selfView = this.view;

        $timeField.timepicker().on({
            showTimepicker: function() {
                // Remove 24:00 from the list since it does not make sense when used in conjunction with a date.
                // Timepicker plugin specifically added 24:00 since it can be used by itself without a date and
                // that is what the standard calls for. (https://github.com/jonthornton/jquery-timepicker/issues/149)
                $(this).data('timepickerList').find('li:contains("24:00"), li:contains("24.00")').remove();
                selfView.trigger('list:scrollLock', true);
            },
            hideTimepicker: function() {
                selfView.trigger('list:scrollLock', false);
            },
            change: _.bind(function() {
                var t = $timeField.val().trim(),
                    datetime = '';

                if (t) {
                    var d = $dateField.val();
                    datetime = this.unformat(this.handleDateTimeChanges(d, t));
                    if (!datetime) {
                        $dateField.val('');
                        $timeField.val('');
                    }
                }
                this.model.set(this.name, datetime);
            }, this),
            focus: _.bind(function() {
                this.handleFocus();
            }, this)
        });
    },

    /**
     * @inheritdoc
     *
     * Add extra logic to unbind secondary field tag.
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        this.$(this.secondaryFieldTag).off();
    },

    /**
     * Binds model changes on this field, taking into account both field tags.
     *
     * @override
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.disposed) {
                return;
            }
            
            if (this._inDetailMode()) {
                this.render();
                return;
            }

            value = this.format(value) || {'date': '', 'time': ''};

            this.$(this.fieldTag).val(value['date']);
            this.$(this.secondaryFieldTag).val(value['time']);
        }, this);
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Datetime value to format.
     * @return {Object/String/undefined} On edit mode the returned value is an
     *   object with two keys, `date` and `time`. On detail mode the returned
     *   value is a date, formatted according to user preferences if supplied
     *   value is a valid date, otherwise returned value is `undefined`.
     *
     * @override
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        if (this.action === 'edit' || this.action === 'massupdate') {
            value = {
                'date': value.format(app.date.convertFormat(this.getUserDateFormat())),
                'time': value.format(app.date.convertFormat(this.getUserTimeFormat()))
            };

        } else {
            value = value.formatUser(false);
        }

        return value;
    },

    /**
     * Unformats datetime value for storing in model.
     *
     * @return {String} Unformatted value or `undefined` if value is
     *   an invalid date.
     *
     * @override
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateTimeFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.format();
    },

    /**
     * Override decorateError to take into account the two fields.
     *
     * @override
     */
    decorateError: function (errors) {
        var ftag = this.fieldTag || '',
            $ftag = this.$(ftag),
            errorMessages = [],
            $tooltip;

        // Add error styling
        this.$el.closest('.record-cell').addClass('error');
        this.$el.addClass('error');

        if (_.isString(errors)) {
            // A custom validation error was triggered for this field
            errorMessages.push(errors);
        } else {
            // For each error add to error help block
            _.each(errors, function (errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
        }

        $ftag.parent().addClass('error');

        $tooltip = [$(this.exclamationMarkTemplate(errorMessages)), $(this.exclamationMarkTemplate(errorMessages))];

        var self = this;

        $ftag.parent().children('input').each(function(index) {
            $(this).after($tooltip[index]);
            self.createErrorTooltips($tooltip[index]);
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this._inDetailMode()) {
            return;
        }

        this._setupTimePicker();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('remove');
        }

        this._super('_dispose');
    }
}) },
"dnb-bal-import-menu-label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DnbBalImportMenuLabelField
 * @alias SUGAR.App.view.fields.BaseDnbBalImportMenuLabelField
 * @extends View.Field.LabelField
 */
({
	// Dnb-bal-import-menu-label Field (base) 

    extendsFrom: 'LabelField',

    /**
     * @inheritdoc
     */
    format: function(value) {
        // Establish our current connector name, in this case, dnb
        var connector = 'dnb';

        // And get the connectors config data if it exists
        var connectors = app.config.connectors || {};

        // If the connector is configured, set the label from the default value
        if (connectors[connector] && connectors[connector].configured) {
            value = app.lang.get(this.def.default_value, this.module);
        } else {
            // Otherwise, make it empty so the template loads nothing
            value = '';
        }

        return value;
    }
}) },
"link-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link" button used in selection list for linking existing records.
 *
 * @class View.Fields.Base.LinkButtonField
 * @alias SUGAR.App.view.fields.BaseLinkButtonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Link-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        this.listenTo(this.massCollection, 'add remove', function() {
            this.setDisabled(this.massCollection.length === 0);
        });

        if (this.massCollection.length === 0) {
            this.setDisabled(true);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'rowaction';
        this._super('_loadTemplate');
        this.type = 'link-button';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"int": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IntField
 * @alias SUGAR.App.view.fields.BaseIntField
 * @extends View.Fields.Base.BaseField
 */
({
	// Int Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * Unformats the integer based on userPreferences (grouping separator).
     * If we weren't able to parse the value, `undefined` is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|undefined} the unformatted value.
     */
    unformat: function(value) {
        return app.utils.unformatNumberStringLocale(value, true);
    },

    /**
     * @inheritdoc
     *
     * Formats the integer based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite integer it will
     * return `undefined`.
     *
     * @param {Number} value the integer value to format as per user
     *   preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        var numberGroupSeparator = '', decimalSeparator = '';

        if (!this.def.disable_num_format) {
            numberGroupSeparator = app.user.getPreference('number_grouping_separator') || ',';
            decimalSeparator = app.user.getPreference('decimal_separator') || '.';
        }

        return app.utils.formatNumber(
            value, 0, 0,
            numberGroupSeparator,
            decimalSeparator
        );
    }
}) },
"avatar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AvatarField
 * @alias SUGAR.App.view.fields.BaseAvatarField
 * @extends View.Fields.Base.ImageField
 */
({
	// Avatar Field (base) 

    extendsFrom: 'ImageField',

    plugins: ['File', 'FieldDuplicate', 'Tooltip'],

    MAPSIZECLASS: {
        'large': 'label-module-lg',
        'medium': 'label-module-md',
        'button': 'label-module-btn',
        'default': '',  //This field does not fallback to this size
        'small': 'label-module-sm',
        'mini': 'label-module-mini'
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        var template,
            className;
        this._super("_render");
        if (this.action !== 'edit' || this.view.name === 'merge-duplicates') {
            if (_.isEmpty(this.value)) {
                className = _.isUndefined(this.MAPSIZECLASS[this.def.size]) ? this.MAPSIZECLASS['large'] : this.MAPSIZECLASS[this.def.size];
                // replace the image field with the module icon when there is no avatar to display
                // load the module icon template
                template = app.template.getField(this.type, 'module-icon', this._getModuleName());
                if (template) {
                    this.$('.image_field').replaceWith(template({
                        module: this._getModuleName(),
                        labelSizeClass: className,
                        tooltipPlacement: app.lang.direction === 'ltr' ? 'right' : 'left'
                    }));
                }
            } else {
                // add the image_rounded class to the image_field div when there is an avatar to display
                this.$('.image_field').addClass('image_rounded');
            }
        }
        return this;
    },

    /**
     * Gets the record's module name.
     *
     * FIXME: This isn't the right way to do it. The
     * {@link View.Views.Base.HistorySummaryView} view should use a true
     * {@link Data.MixedBeanCollection} so we don't have to do this.
     *
     * @return {string} The module name.
     * @protected
     */
    _getModuleName: function() {
        if (this.view.name === 'history-summary') {
            return this.model.get('_module');
        }
        return this.module;
    },

    /**
     * To inherit templates from the image field, we want to tell sidecar to load the templates from the image field's
     * directory. To do this, we must change this.type to "image" temporarily. We want to restore this.type before
     * exiting, however, so that we don't really change the field's attributes.
     *
     * Beware that this causes sidecar to never automatically load any templates found in the avatar field's directory.
     * Sidecar will always look for templates in the image field's directory, by default.
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'image';
        this._super("_loadTemplate");
        this.type = this.def.type;
    }
}) },
"range": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RangeField
 * @alias SUGAR.App.view.fields.BaseRangeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Range Field (base) 

    /**
     * holder for the field tag, so we can get at it easily
     */
    fieldTag: '.rangeSlider',

    /**
     * Object that maps the sliderType from metadata, to the appropriate noUiSlider settings.
     * The number of handles this slider has can be set in metadata by specifying sliderType to be as follows:
     * - 'single' - a single slider, the value of the field will just be the integer value of the slide
     * - 'upper' - a single slider, visually connected to the upper range, the value of the field will be {min: <value of slide>, max: this.rangeMax}
     * - 'lower' - a single slider, visually connected to the lower range, the value of the field will be {min: this.rangeMin, max: <value of slide>}
     * - 'double' - a double slider, the value of the field will be [<value of lower slide>, <value of upper slide>]
     * - 'connected' - a double slider, visually connected together, the value of the field will be {min: <value of lower slide>, max: <value of upper slide>}
     */
    _sliderTypeSettings: {
        single: {handles: 1, connect: false},
        upper: {handles: 1, connect: 'upper'},
        lower: {handles: 1, connect: 'lower'},
        'double': {handles: 2, connect: false},
        connected: {handles: 2, connect: true}
    },

    /**
     * Renders this field.  This is where the noUiSlider gets added.
     * @param value
     * @private
     */
    _render: function(value) {
        app.view.Field.prototype._render.call(this);

        this._setupSlider(this.$el.find(this.fieldTag));
    },

    /**
     * Unformats a value for storing in a model.
     *
     * Cleans up the value to store it in a model based on the sliderType
     * @param {Mixed} value The value to unformat.
     * @return {Mixed} Unformatted value based on sliderType:
     * - single - integer value
     * - double - array of two integer values
     * - upper, lower, connected - a range as {min, max}.
     */
    unformat: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return _.first(value);
            case 'upper':
                return {
                    min: _.first(value),
                    max: this.def.maxRange || 100
                };
            case 'lower':
                return {
                    min: this.def.minRange || 0,
                    max: _.last(value)
                };
            case 'double':
                return [
                    _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                ];
            case 'connected':
            default:
                return {
                    min: _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    max: _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                };
        }
    },

    /**
     * Formats a value for display.
     *
     * Converts the field stored in the model for a slider type, into a value usable by noUiSlider widget
     * @param {Mixed} value The value to format.
     * @return {Mixed} Formatted value.
     */
    format: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return [ value || this.def.rangeMin || 0 ];
            case 'upper':
                return [ value.min || this.def.rangeMin || 0 ];
            case 'lower':
                return [ value.max || this.def.rangeMax || 100 ];
            case 'double':
                return value;
            case 'connected':
            default:
                if(value) {
                    return [ value.min || this.def.rangeMin || 0, value.max || this.def.rangeMax || 100];
                }
        }
        return [this.def.rangeMin || 0, this.def.rangeMax || 100];
    },

    /**
     * Sets up the noUiSlider jquery widget on the given jQuery element.
     * @param jqel a jquery element, i. e. $.find(this.fieldTag)
     * @private
     */
    _setupSlider: function(jqel) {

        jqel.noUiSlider('init', {
            knobs: this._calculateHandles(),
            connect: this._setupHandleConnections(this.def.sliderType || 'single'),
            scale: this._setupSliderEndpoints(),
            start: this._setupSliderStartPositions(),
            change: this._sliderChange,
            end: this._sliderChangeComplete,
            field: this
        });

        if(!this.def.hideStyle){
            this._addStyle(jqel);
        }


        if(this.def.enabled == false || this.def.view != 'edit') {
            jqel.noUiSlider('disable');
        }
    },

    /**
     * Adds the style elements to the slider fields
     * @param jqel the jQuery wrapped element that has a noUiSlider attached to it.
     */
    _addStyle: function(jqel) {
        var start = this._setupSliderStartPositions(),
            endpoints = this._setupSliderEndpoints();
        jqel.append(function(){
            var html = "",
                segments = 11,
                w = $(this).width(),
                segmentWidth = w/(segments-1),
                acum = 0;

            for(i=0;i<segments;i++) {
                acum = (segmentWidth * i)-2;
                html += "<div class='ticks' style='left:"+acum+"px'></div>";
            }
            return html;

        })
        .find('.noUi-handle div').each(function(index){
            if(i>1) {i=0;}
            $(this).append('<div class="tooltip fade top in infoBox"><div class="tooltip-arrow"></div><div class="tooltip-inner">' + start[i] + '%'+'</div></div>');
            i++;
        });

        this.$('.noUiSliderEnds').attr('data-content-before', _.first(endpoints) + '%').attr('data-content-after', _.last(endpoints) + '%')
    },

    /**
     * Used to calculate the number of sliders for this field by the sliderType set in metadata.
     * @return {integer} The number of handles for the slider
     * @private
     */
    _calculateHandles: function() {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].handles;
    },

    /**
     * Used to set up the graphical connections for the handles based on the slider type
     * @param sliderType the value from metadata.  Valid options are 'single', 'upper', 'lower', 'double', 'connected'
     * @return {string || bool} The value to pass as the 'connect' setting for the noUiSlider jquery widget
     * @private
     */
    _setupHandleConnections: function(sliderType) {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].connect;
    },

    /**
     * Calculates the min and max range for the sliders.
     * @return {array} the min and max setting for the range field that will be pass as the noUiSlider scale
     * @private
     */
    _setupSliderEndpoints: function() {
        var minRange = this.def.minRange || 0,
            maxRange = this.def.maxRange || 100;

        return [minRange, maxRange];
    },

    /**
     * Used to get the starting positions for the sliders to pass to the noUiSlider widget.
     * @return {integer || array} the start values contained in the model for the field.  Falls back on minRange from
     * metadata if the model is empty/undefined, or 0 if no model value and minRange is undefined in metadata.
     * @private
     */
    _setupSliderStartPositions: function() {
        var value;

        if (this.model) {
            value = this.model.get(this.name);
        }

        if (_.isUndefined(value) || (_.isArray(value) && _.isEmpty(value))) {
            return [ this.def.minRange || 0, this.def.maxRange || 100 ];
        }

        return this.format(value);
    },

    /**
     * Gets the value for the jquery slider widget and cleans it up to be used by the view
     * @param jqel the jquery element that has the noUiSlider attached to it.
     * @return {array} for sliderType set to 'single', an array with a single value, for all others, an array of two values.
     */
    getSliderValues: function(jqel) {
        var value = jqel.noUiSlider('value');

        return this.unformat(value);
    },

    /**
     * The function that gets called whenever the sliders are in the process of getting moved/changed.
     *
     * The context of `this` is the noUiSlider from which the function was activated. The field is passed through the
     * settings and can be accessed using `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'change' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChange: function(type) {
        var field = this.data('api').options.field,
            values;

        if(field.def.updateOn && (field.def.updateOn == 'change' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        if(!field.def.hideStyle) {
            values = this.noUiSlider( 'value' );
            this.find('.noUi-lowerHandle .infoBox .tooltip-inner').text(values[0]+"%");
            this.find('.noUi-upperHandle .infoBox .tooltip-inner').text(values[1]+"%");
        }

        // disables the hook if moved by another slider, to prevent circular references
        if(type != 'move' && _.isFunction(field.sliderChangeDelegate)) {
            field.sliderChangeDelegate(field.getSliderValues(this));
        }
    },

    /**
     * The function that gets called whenever the slider change is complete.
     *
     * The context of `this` is the noUiSlider from
     * which the function was activated. The field is passed through the settings and can be accessed using
     * `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'done' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChangeComplete: function(type) {
        var field = this.data('api').options.field;

        if(field.def.updateOn && (field.def.updateOn == 'done' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        // if this is set, this hook will be called when slider is done moving.
        if(_.isFunction(field.sliderDoneDelegate)) {
            field.sliderDoneDelegate(field.getSliderValues(this));
        }
    }

}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DateField
 * @alias SUGAR.App.view.fields.BaseDateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Date Field (base) 

    /**
     * @inheritdoc
     */
    plugins: [
        'EllipsisInline',
        'Tooltip'
    ],

    /**
     * @inheritdoc
     */
    fieldTag: 'input[data-type=date]',

    /**
     * @inheritdoc
     */
    events: {
        'hide': 'handleHideDatePicker'
    },

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: Remove this when SIDECAR-517 gets in
        this._initPlugins();
        this._super('initialize', [options]);
        this._initEvents();
        this._initDefaultValue();
        this._initPlaceholderAttribute();
        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;

        /**
         * If a date picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasDatePicker = false;
    },

    /**
     * Initialize plugins.
     *
     * @chainable
     * @protected
     * @template
     *
     * FIXME: Remove this when SIDECAR-517 gets in
     */
    _initPlugins: function() {
        return this;
    },

    /**
     * Initialize events.
     *
     * @chainable
     * @protected
     * @template
     */
    _initEvents: function() {
        return this;
    },

    /**
     * If we're creating a new model and a valid `display_default` property was
     * supplied (e.g.: `next friday`) we'll use it as a date instead.
     *
     * @chainable
     * @protected
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * Initializes the field's placeholder attribute.
     *
     * Placeholder attribute can be used in different ways. Based on metadata
     * settings one can do:
     *
     *     // ...
     *     array(
     *         'name' => 'my_date_field',
     *         'type' => 'date',
     *         'placeholder' => 'TPL_MY_PLACEHOLDER',
     *         // ...
     *     )
     *     // ...
     *
     * Where `TPL_MY_PLACEHOLDER` is able to receive the `format` flag such as:
     *
     *     'TPL_MY_PLACEHOLDER' => 'Accepts the {{format}} format'
     *
     * If none supplied, user date format is used instead
     * {@link #getUserDateformat}.
     *
     * @chainable
     * @protected
     */
    _initPlaceholderAttribute: function() {
        var placeholder = app.date.toDatepickerFormat(this.getUserDateFormat());

        this.fieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * Return user date format.
     *
     * @return {String} User date format.
     */
    getUserDateFormat: function() {
        return app.user.getPreference('datepref');
    },

    /**
     * Set up date picker.
     *
     * We rely on the library to confirm that the date picker is only created
     * once.
     *
     * @protected
     */
    _setupDatePicker: function() {
        var $field = this.$(this.fieldTag),
            userDateFormat = this.getUserDateFormat(),
            options = {
                format: app.date.toDatepickerFormat(userDateFormat),
                languageDictionary: this._patchPickerMeta(),
                weekStart: parseInt(app.user.getPreference('first_day_of_week'), 10)
            };

        var appendToTarget = this._getAppendToTarget();
        if (appendToTarget) {
            options['appendTo'] = appendToTarget;
        }

        $field.datepicker(options);
        this._hasDatePicker = true;
    },

    /**
     * Retrieve an element against which the date picker should be appended to.
     *
     * FIXME: find a proper way to do this and avoid scrolling issues SC-2739
     *
     * @return {jQuery/undefined} Element against which the date picker should
     *   be appended to, `undefined` if none.
     * @private
     */
    _getAppendToTarget: function() {
        var component = this.closestComponent('main-pane') ||
            this.closestComponent('drawer') ||
            this.closestComponent('preview-pane');

        if (component) {
            return component.$el;
        }

        return;
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Plus, we're using the `hide` event instead of the `changeDate` event
     * because the latter doesn't track copy/paste of dates whether from
     * keyboard or mouse and it also doesn't track field clearance through
     * keyboard, e.g.: selecting date text and press cmd+x.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     */
    handleHideDatePicker: function() {
        var $field = this.$(this.fieldTag),
            value = this.unformat($field.val());

        if (!value) {
            $field.val(value);
        }

        this.model.set(this.name, value);
    },

    /**
     * {@override}
     *
     * Parent method isn't called 'cause `handleHideDatePicker()` already takes
     * care of unformatting the value.
     */
    bindDomChange: function() {
        if (this._inDetailMode()) {
            return;
        }

        var $field = this.$(this.fieldTag);

        $field.on('focus', _.bind(this.handleFocus, this));

        $('.main-pane, .flex-list-view-content').on('scroll.' + this.cid, _.bind(function() {
            // make sure the dom element exists before trying to place the datepicker
            if (this._getAppendToTarget()) {
                $field.datepicker('place');
            }
        }, this));
    },

    /**
     * Determine if the field is currently in a read-only (detail) mode.
     *
     * @return {boolean}
     * @protected
     */
    _inDetailMode: function() {
        return this.action !== 'edit' && this.action !== 'massupdate';
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        $('.main-pane, .flex-list-view-content').off('scroll.' + this.cid);

        var $field = this.$(this.fieldTag),
            datePicker = $field.data('datepicker');
        if (datePicker && !datePicker.hidden) {
            // todo: when SC-2395 gets implemented change this to 'remove' not 'hide'
            $field.datepicker('hide');
        }
    },

    /**
     * Patches our `dom_cal_*` metadata for use with date picker plugin since
     * they're very similar.
     *
     * @private
     */
    _patchPickerMeta: function() {
        var pickerMap = [], pickerMapKey, calMapIndex, mapLen, domCalKey,
            calProp, appListStrings, calendarPropsMap, i, filterIterator;

        appListStrings = app.metadata.getStrings('app_list_strings');

        filterIterator = function(v, k, l) {
            return v[1] !== "";
        };

        // Note that ordering here is used in following for loop
        calendarPropsMap = ['dom_cal_day_long', 'dom_cal_day_short', 'dom_cal_month_long', 'dom_cal_month_short'];

        for (calMapIndex = 0, mapLen = calendarPropsMap.length; calMapIndex < mapLen; calMapIndex++) {

            domCalKey = calendarPropsMap[calMapIndex];
            calProp  = appListStrings[domCalKey];

            // Patches the metadata to work w/datepicker; initially, "calProp" will look like:
            // {0: "", 1: "Sunday", 2: "Monday", 3: "Tuesday", 4: "Wednesday", 5: "Thursday", 6: "Friday", 7: "Saturday"}
            // But we need:
            // ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            if (!_.isUndefined(calProp) && !_.isNull(calProp)) {
                // Reject the first 0: "" element and then map out the new language tuple
                // so it's back to an array of strings
                calProp = _.filter(calProp, filterIterator).map(function(prop) {
                    return prop[1];
                });
                //e.g. pushed the Sun in front to end (as required by datepicker)
                calProp.push(calProp);
            }
            switch (calMapIndex) {
                case 0:
                    pickerMapKey = 'day';
                    break;
                case 1:
                    pickerMapKey = 'daysShort';
                    break;
                case 2:
                    pickerMapKey = 'months';
                    break;
                case 3:
                    pickerMapKey = 'monthsShort';
                    break;
            }
            pickerMap[pickerMapKey] = calProp;
        }
        return pickerMap;
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Date value to format.
     * @return {String/undefined} Formatted value or `undefined` if value is an
     *   invalid date.
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        return value.formatUser(true);
    },

    /**
     * Unformats date value for storing in model.
     *
     * @return {String/undefined} Unformatted value or `undefined` if value is
     *   an invalid date.
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.formatServer(true);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this.tplName !== 'edit' && this.tplName !== 'massupdate') {
            this._hasDatePicker = false;
            return;
        }

        this._setupDatePicker();
    },

    /**
     * Focus on the date field.
     */
    focus: function() {
        this.$(this.fieldTag).datepicker('focusShow');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: new date picker versions have support for plugin removal/destroy
        // we should do the upgrade in order to prevent memory leaks

        if (this._hasDatePicker) {
            $(window).off('resize', this.$(this.fieldTag).data('datepicker').place);
        }

        this._super('_dispose');
    }
}) },
"closebutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ClosebuttonField is a field for Meetings/Calls/Tasks that handles setting a value on a field in the model based on meta data with
 * an option to create a new record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ClosebuttonField
 * @alias SUGAR.App.view.fields.BaseClosebuttonField
 * @extends View.Fields.Base.RowactionField
 */


({
	// Closebutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * Setup click event handlers.
     * @inheritdoc
     *
     * @param {Object} options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, options.def.events, {
            'click [name="record-close"]': 'closeClicked',
            'click [name="record-close-new"]': 'closeNewClicked'
        });

        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Handle record close event.
     *
     * @param {Event} event The click event for the close button
     */
    closeClicked: function(event) {
        this._close(false);
    },

    /**
     * Handle record close and create new event.
     *
     * @param {Event} event The click event for the close and create new button
     */
    closeNewClicked: function(event) {
        this._close(true);
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if record displayed is already closed
     */
    _render: function() {
        if (this.model.get(this.getStatusFieldName()) === this.getClosedStatus()) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Retrieve the closed status value from the fields meta definition
     *
     * @return {string}
     */
    getClosedStatus: function() {
        return ((this.def && this.def.closed_status) ?
            this.def.closed_status :
            'Completed');
    },

    /**
     * Retrieve the status field name from the field meta definition.
     * Defaults to 'status'
     *
     * @return {string}
     */
    getStatusFieldName: function() {
        return ((this.def && this.def.status_field_name) ?
            this.def.status_field_name :
            'status');
    },

    /**
     * Close the record by setting the appropriate status on the record.
     *
     * @param {boolean} createNew Flag for whether to open a new drawer to create a
     *   record after close.
     * @private
     */
    _close: function(createNew) {
        var self = this;

        this.model.set(this.getStatusFieldName(), this.getClosedStatus());
        this.model.save({}, {
            success: function() {
                self.showSuccessMessage();
                if (createNew) {
                    self.openDrawerToCreateNewRecord();
                }
            },
            error: function(error) {
                self.showErrorMessage();
                app.logger.error('Record failed to close. ' + error);

                // we didn't save, revert!
                self.model.revertAttributes();
            }
        });
    },

    /**
     * Open a drawer to create a new record.
     */
    openDrawerToCreateNewRecord: function() {
        var self = this,
            statusField = this.getStatusFieldName(),
            module = app.metadata.getModule(this.model.module),
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);

        if (module.fields[statusField] && module.fields[statusField]['default']) {
            prefill.set(statusField, module.fields[statusField]['default']);
        } else {
            prefill.unset(statusField);
        }

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill
            }
        }, function() {
            if (self.parent) {
                self.parent.render();
            } else {
                self.render();
            }
        });
    },

    /**
     * Display a success message.
     *
     * This message includes the value the status field was set to - so we need
     * to retrieve the translated string (if there is one).
     */
    showSuccessMessage: function() {
        var statusField = this.getStatusFieldName(),
            statusFieldMetadata = app.metadata.getModule(this.module).fields[statusField],
            optionStrings,
            statusValue;

        // if this is an enum field, retrieve translated value
        if (statusFieldMetadata && statusFieldMetadata.options) {
            optionStrings = app.lang.getAppListStrings(statusFieldMetadata.options);
            statusValue = optionStrings[this.getClosedStatus()].toLocaleLowerCase();
        } else {
            // not an enum field - just display lowercase version of the value
            statusValue = this.getClosedStatus().toLocaleLowerCase();
        }

        app.alert.show('status_change_success', {
            level: 'success',
            autoClose: true,
            messages: app.lang.get('TPL_STATUS_CHANGE_SUCCESS',
                this.module,
                {
                    moduleSingular: app.lang.getModuleName(this.module),
                    status: statusValue
                }
            )
        });
    },

    /**
     * Display an error message.
     */
    showErrorMessage: function() {
        app.alert.show('close_record_error', {
            level: 'error',
            title: app.lang.get('ERR_AJAX_LOAD')
        });
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:status', this.render, this);
        }
    }
}) },
"image": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ImageField
 * @alias SUGAR.App.view.fields.BaseImageField
 * @extends View.Fields.Base.BaseField
 */
({
	// Image Field (base) 

    fieldTag: 'input[type=file]',

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        "click .delete": "delete",
        "change input[type=file]": "selectImage"
    },

    plugins: ['File', 'FieldDuplicate'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @override
     *
     * FIXME: The {@link #model} used by this view should be a {@link Data.Bean}
     * and not a simple {@link Backbone.Model}. This should be removed when
     * {@link View.Views.Base.HistorySummaryView} view is refactored to use a
     * true {@link Data.MixedBeanCollection}.
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        // FIXME: This needs an API instead. SC-3369 should address this.
        // Also, this field should extend the file field to inherit these
        // error properties.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        // FIXME: we should have a {@link Da
        if (_.isFunction(this.model.addValidationTask)) {
            this.model.hasImageRequiredValidator = true;
            this.model.addValidationTask('image_required_' + this.cid, _.bind(this._doValidateImageField, this));
        }
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        //Remove specific validation task from the model
        this.model.hasImageRequiredValidator = false;
        if (this.model.removeValidationTask) {
            this.model.removeValidationTask('image_required_' + this.cid);
        }
        app.view.Field.prototype._dispose.call(this);
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (this.disposed || this.view.name !== 'merge-duplicates') {
            return;
        }
        this.render();
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.model.fileField = this.name;
        app.view.Field.prototype._render.call(this);

        //Define default sizes
        if (this.view && this.view.meta && this.view.meta.type === 'list') {
            this.width = this.height = this.$el.parent().height() || 42;
            this.def.width = this.def.height = undefined;
        } else {
            this.width = parseInt(this.def.width || this.def.height, 10) || 42;
            this.height = parseInt(this.def.height, 10) || this.width;
        }

        //Resize widget before the image is loaded
        this.resizeWidth(this.width);
        this.resizeHeight(this.height);
        this.$('.image_field').removeClass('hide');
        //Resize widget once the image is loaded
        this.$('img').addClass('hide').on('load', $.proxy(this.resizeWidget, this));
        return this;
    },

    /**
     * @override
     * @param value
     * @return value
     */
    format: function(value) {
        if (value) {
            value = this.buildUrl() + "&_hash=" + value;
        }
        return value;
    },

    /**
     * @override
     */
    bindDataChange: function() {
        //Keep empty for edit because you cannot set a value of an input type `file`
        var viewType = this.view.name || this.options.viewName;
        var ignoreViewType = ["edit", "create"];
        if ((_.indexOf(ignoreViewType, viewType) < 0)
            && (this.view.action !== "edit")
            && (this.view.name !== 'merge-duplicates')) {
            app.view.Field.prototype.bindDataChange.call(this);
        }
    },

    /**
     * @override
     */
    bindDomChange: function() {
        //Override default behavior
        this.$(this.fieldTag).on('focus', _.bind(this.handleFocus, this));
    },

    /**
     * This is the custom implementation of bindDomChange. Here we upload the image to give a preview to the user.
     * @param e
     */
    selectImage: function(e) {
        var self = this,
            $input = self.$('input[type=file]');

        //Set flag to indicate we are previewing an image
        self.preview = true;

        //Remove error message
        self.clearErrorDecoration();

        // Upload a temporary file for preview
        self.model.uploadFile(
            self.name,
            $input,
            {
                field: self.name,
                //Callbacks
                success: function(rsp) {
                    //read the guid
                    var fileId = (rsp[self.name]) ? rsp[self.name]['guid'] : null;
                    var url = app.api.buildFileURL({
                        module: self.module,
                        id: 'temp',
                        field: self.name,
                        fileId: fileId
                    }, {keep: true});
                    // show image
                    var image = $('<img>').addClass('hide').attr('src', url).on('load', $.proxy(self.resizeWidget, self));
                    self.$('.image_preview').html(image);

                    // Add the guid to the list of fields to set on the model.
                    if (fileId) {
                        if (!self.model.fields[self.name + '_guid']) {
                            self.model.fields[self.name + '_guid'] = {
                                type: 'file_temp',
                                group: self.name
                            };
                        }
                        self.model.unset(self.name);
                        self.model.set(self.name + '_guid', fileId);
                    }

                    //Trigger a change event with param "image" so the view can detect that the dom changed.
                    self.model.trigger("change", "image");
                },
                error: function(resp) {
                    var errors = errors || {},
                        fieldName = self.name;
                    errors[fieldName] = {};

                    switch (resp.error) {
                        case 'request_too_large':
                           errors[fieldName].tooBig = true;
                           break;
                        default:
                            errors[fieldName].uploadFailed = true;
                    }
                    self.model.unset(fieldName + '_guid');
                    self.model.trigger('error:validation:' + this.field, errors[fieldName]);
                    self.model.trigger('error:validation', errors);
                }
            },
            { temp: true }); //for File API to understand we upload a temporary file
    },

    /**
     * Calls when deleting the image or canceling the preview
     * @param e
     */
    'delete': function(e) {
        var self = this;
        //If we are previewing a file and want to cancel
        if (this.preview === true) {
            self.preview = false;
            self.clearErrorDecoration();
            self.render();
            return;
        }

        // If it's a duplicate, don't delete the file
        if (this._duplicateBeanId) {
            self.model.unset(self.name);
            self.model.set(self.name, null);
            self.render();
            return;
        }

        var confirmMessage = app.lang.get('LBL_IMAGE_DELETE_CONFIRM', self.module);
        if (confirm(confirmMessage)) {
            //Otherwise delete the image
            app.api.call('delete', self.buildUrl({htmlJsonFormat: false}), {}, {
                    success: function(response) {
                        //Need to fire the change event twice so model.previous(self.name) is also changed.
                        self.model.unset(self.name);
                        self.model.set(self.name, null);
                        if (response.record && response.record.date_modified) {
                            self.model.set('date_modified', response.record.date_modified);
                        }
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(data) {
                        // refresh token if it has expired
                        app.error.handleHttpError(data, {});
                    }}
            );
        }
    },

    /**
     * Build URI for File API
     * @param options
     */
    buildUrl: function(options) {
        return app.api.buildFileURL({
            module: this._duplicateBeanModule ? this._duplicateBeanModule : this.module,
            id: this._duplicateBeanId ? this._duplicateBeanId : this.model.id,
            field: this.name
        }, options);
    },

    /**
     * Resize widget based on field defs and image size
     */
    resizeWidget: function() {
        var image = this.$('.image_preview img, .image_detail img');

        if (!image[0]) return;

        var isDefHeight = !_.isUndefined(this.def.height) && this.def.height > 0,
            isDefWidth = !_.isUndefined(this.def.width) && this.def.width > 0;

        //set width/height defined in field defs
        if (isDefWidth) {
            image.css('width', this.width);
        }
        if (isDefHeight) {
            image.css('height', this.height);
        }

        if (!isDefHeight && !isDefWidth)
            image.css({
                'height': this.height,
                'width': this.width
            });

        //now resize widget
        //we resize the widget based on current image height
        this.resizeHeight(image.height());
        //if height was defined but not width, we want to resize image width to keep
        //proportionality: this.height/naturalHeight = newWidth/naturalWidth
        if (isDefHeight && !isDefWidth) {
            var newWidth = Math.floor((this.height / image[0].naturalHeight) * image[0].naturalWidth);
            image.css('width', newWidth);
            this.resizeWidth(newWidth);
        }

        image.removeClass('hide');
        this.$('.delete').remove();
        var icon = this.preview === true ? 'times' : 'trash-o';
        image.closest('label, a').after('<span class="image_btn delete fa fa-' + icon + ' " />');
    },

    /**
     * Utility function to append px to an integer
     *
     * @param size
     * @return {string}
     */
    formatPX: function(size) {
        size = parseInt(size, 10);
        return size + 'px';
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param height (in pixels)
     */
    resizeHeight: function(height) {
        var $image_field = this.$('.image_field'),
            isEditAndIcon = this.$('.fa-plus').length > 0;

        if (isEditAndIcon) {
            var $image_btn = $image_field.find('.image_btn');
            var edit_btn_height = parseInt($image_btn.css('height'), 10);

            var previewHeight = parseInt(height, 10);
            //Remove the edit button height in edit view so that the icon is centered.
            previewHeight -= edit_btn_height ? edit_btn_height : 0;
            previewHeight = this.formatPX(previewHeight);

            $image_field.find('.fa-plus').css({lineHeight: previewHeight});
        }


        var totalHeight = this.formatPX(height);
        $image_field.css({'height': totalHeight, minHeight: totalHeight, lineHeight: totalHeight});
        $image_field.find('label').css({lineHeight: totalHeight});
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param width (in pixels)
     */
    resizeWidth: function(width) {
        var $image_field = this.$('.image_field'),
            width = this.formatPX(width),
            isInHeaderpane = $(this.el).closest('.headerpane').length > 0,
            isInRowFluid = $(this.el).closest('.row-fluid').closest('.record').length > 0;

        if (isInHeaderpane || !isInRowFluid) {
            //Need to fix width
            $image_field.css({'width': width});
        } else {
            //Width will be the biggest possible
            $image_field.css({'maxWidth': width});
        }
    },

    /**
     * Custom requiredValidator for image field because we need to check if the
     * input inside the view is empty or not.
     *
     * @param {Object} fields Hash of field definitions to validate.
     * @param {Object} errors Error validation errors.
     * @param {Function} callback Async.js waterfall callback.
     */
    _doValidateImageField: function(fields, errors, callback) {
        if (this.def.required && !this.model.get(this.name + '_guid') && !this.model.get(this.name)) {
            errors[this.name] = errors[this.name] || {};
            errors[this.name].required = true;
        }

        callback(null, fields, errors);
    },

    /**
     * Handles errors message
     *
     * @override
     * @param errors
     */
    handleValidationError: function(errors) {
        var errorMessages = [];

        if (this.action === 'detail') {
            this.setMode('edit');
        }

        //Change the preview of the image widget
        this.$('.image_preview').html('<i class="fa fa-times"></i>');
        //Put the cancel icon
        this.$('label').after('<span class="image_btn delete fa fa-times" />');

        this.$el.closest('.record-cell').addClass("error");
        this.$el.addClass('input-append error');

        _.each(errors, function(errorContext, errorName) {
            errorMessages.push(app.error.getErrorString(errorName, errorContext));
        });
        this.$('.image_field').append(this.exclamationMarkTemplate(errorMessages));
        this.createErrorTooltips(this.$('.error-tooltip'));
    },

    /**
     * @override
     */
    clearErrorDecoration: function() {
        //Remove the current icon
        this.$('.delete').remove();
        //Remove error message
        this.$('.error-tooltip').remove();
        this.$el.closest('.record-cell').removeClass('error');
        this.$el.removeClass('input-append error');
    }
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the base field and all of other fields extend from it.
 *
 * @class View.Fields.Base.BaseField
 * @alias SUGAR.App.view.fields.BaseBaseField
 * @extends View.Field
 */
({
	// Base Field (base) 

    plugins: ['EllipsisInline', 'Tooltip', 'MetadataEventDriven'],

    /**
     * @inheritdoc
     *
     * Some plugins use events which prevents {@link View.Field#delegateEvents}
     * to fallback to metadata defined events.
     * This will make sure we merge metadata events with the ones provided by
     * the plugins.
     */
    initialize: function(options) {

        this.events = _.extend({}, this.events, options.def.events);

        this._super('initialize', arguments);

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var action = 'view';
        if (this.def.link && this.def.route) {
            action = this.def.route.action;
        }
        if (this.def.link && app.acl.hasAccessToModel(action, this.model)) {
            this.href = this.buildHref();
        }
        app.view.Field.prototype._render.call(this);
    },

    /**
     * Takes care of building href for when there's a def.link and also if is
     * bwc enabled.
     *
     * Deprecated functionality:
     * If `this.def.bwcLink` is set to `true` on metadata, we force the href
     * to be in BWC.
     *
     * TODO remove this from the base field
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module');
        // FIXME remove this.def.bwcLink functionality (not yet removed due to Portal need for Documents)
        return '#' + app.router.buildRoute(module, this.model.get('id'), defRoute.action, this.def.bwcLink);
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value if it is a String.
     */
    unformat: function(value) {
        return _.isString(value) ? value.trim() : value;
    }
}) },
"repeat-until": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Until is a custom field for Meetings/Calls modules used to add
 * validation that ensures the date is after the end date, but only if this
 * field is editable.
 *
 * FIXME: This component will be moved out of clients/base folder as part of
 * MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatUntilField
 * @alias SUGAR.App.view.fields.BaseRepeatUntilField
 * @extends View.Fields.Base.DateField
 */
({
	// Repeat-until Field (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     *
     * Add validation that ensures the date is after the end date, but only if
     * this field is editable.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'date';

        this.model.addValidationTask(
            'repeat_until_validator_' + this.cid,
            _.bind(this._doValidateRepeatUntil, this)
        );
    },

    /**
     * Custom validator for the `repeat_until` field.
     *
     * This validates `repeat_until` to ensure the date is on or after the start date,
     * but only if this field is editable.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatUntil: function(fields, errors, callback) {
        var isOnOrAfterStartDate,
            startDate = this.model.get('date_start'),
            repeatUntil = this.model.get(this.name),
            startDateField = this.view.getField('date_start');

        if (!_.isEmpty(repeatUntil) && (this.action === 'edit') && startDateField) {
            startDate = app.date(startDate).minutes(0).hours(0);
            isOnOrAfterStartDate = !app.date(repeatUntil).isBefore(startDate);
            if (!isOnOrAfterStartDate || !startDate.isValid()) {
                errors[this.name] = {'isAfter': startDateField.label};
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_until_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AttachmentsField
 * @alias SUGAR.App.view.fields.BaseAttachmentsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Attachments Field (base) 

    fieldSelector: '.attachments',
    fileInputSelector: '.fileinput',
    $node: null,
    fileCounter: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, options.def.events, {
            'change .fileinput': 'uploadFile'
        });
        app.view.Field.prototype.initialize.call(this, options);

        this.context.on('attachment:add', this.addAttachment, this);
        this.context.on('attachment:upload:remove', this.removeUploadedAttachment, this);
        this.context.on('attachments:remove-by-tag', this.removeAttachmentsByTag, this);
        this.context.on('attachments:remove-by-id', this.removeAttachmentsById, this);

        // Put id on the context so <label>s can be created elsewhere to trigger this file input
        // This is required to work around an IE issue (only files picked directly or
        // from click on label can be uploaded - not programatically)
        this.fileInputName = 'email_attachment';
        this.context.set('attachment_field_' + this.fileInputName, this.cid);

        this.clearUserAttachmentCache();

        // keep track of active file upload requests so that they can be
        // aborted when the user cancels an in-progress upload
        this.requests = {};
    },

    /**
     * Allow Backspace and Delete Keys for attachments (Select2) and disable all other keys
     * @param e
     * @return {Boolean}
     * @private
     */
    _keyHandler: function(e) {
        // if key is backspace or delete ...
        if ((event.keyCode == 8 || event.keyCode == 46)) {
            return true; // Allow
        }
        return false; // Ignore Any other Keyboard Input
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var result = app.view.Field.prototype._render.call(this);

        this.$node = this.$(this.fieldSelector);

        this.$node.select2({
            allowClear:          true,
            multiple:            true,
            containerCssClass:   'select2-choices-pills-close',
            containerCss:        {'width':'100%'},
            tags: [],
            formatSelection: this.formatSelection,
            width: 'off',
            escapeMarkup: function(m) { return m; }
        });

        var inp = this.$el.find('.attachments.select2-container .select2-choices .select2-search-field .select2-input');
        if (inp && inp[0]) {
            $(inp[0]).keypress(this._keyHandler);
            $(inp[0]).keyup(this._keyHandler);
            $(inp[0]).keydown(this._keyHandler);
        }

        //handle case where attachments are pre-populated on the model
        this.refreshFromModel();

        return result;
    },

    /**
     * Add attachment to the select2 field and update the model explicitly (because select2 does not fire change on add)
     *
     * @param attachment object containing at least guid and nameForDisplay attributes
     */
    addAttachment: function(attachment) {
        this.addAttachmentToContainer(attachment);
        this.updateModel();
    },

    /**
     * Just add the attachment to the container - useful for upload progress items
     * @param attachment
     */
    addAttachmentToContainer: function(attachment) {
        var attachments = this.getDisplayedAttachments();

        if (attachment.replaceId) {
            attachments = _.map(attachments, function(existing) {
                return (existing.id == attachment.replaceId) ? attachment : existing;
            });
            delete attachment.replaceId;
        } else {
            attachments.push(attachment);
        }

        this.setDisplayedAttachments(attachments);
    },

    /**
     * @inheritdoc
     * Update model if attachments are removed (select2-removing event fires when attachment removed)
     * Prevent dropdown from opening on this field (its a container only)
     */
    bindDomChange: function() {
        this.$node = this.$(this.fieldSelector);
        this.$node.on("select2-removing", _.bind(this.handleChange, this));
        this.$node.on("select2-opening", function(event) {
            event.preventDefault();
        });
    },

    /**
     * Before handling any attachment uploads, need to clear the user's attachment cache.
     */
    clearUserAttachmentCache: function() {
        var clearCacheUrl = app.api.buildURL('Mail/attachment', "cache");
        app.api.call('delete', clearCacheUrl);
    },

    /**
     * Format how the attachment should be displayed in the pill
     *
     * @param attachment
     * @return {String}
     */
    formatSelection: function(attachment) {
        var item = '<span data-id="'+attachment.id+'">'+attachment.nameForDisplay+'</span>';
        if (attachment.showProgress) {
            item += ' <i class="fa fa-refresh fa-spin"></i>';
        }
        return item;
    },

    /**
     * Get the attachments displayed in select2
     *
     * @return {array} of attachments
     */
    getDisplayedAttachments: function() {
        return this.$node.select2('data');
    },

    /**
     * Handle change event fired by select2 - this is really just remove attachment events
     * @param event
     */
    handleChange: function(event) {
        if (event && event.choice && event.choice.id) {
            this.removeAttachmentsById(event.choice.id);
        }

        this.updateModel();
        this.notifyAttachmentsChanged();
    },

    /**
     * Fire event when attachment is removed
     * (useful for attachment types that require cleanup)
     *
     * Aborts the associated request if it is still active.
     *
     * @param attachment
     */
    notifyAttachmentRemoved: function(attachment) {
        if (this.requests[attachment.id]) {
            app.api.abortRequest(this.requests[attachment.id]);
        }

        this.context.trigger('attachment:' + attachment.type + ':remove', attachment);
    },

    /**
     * Fire event when attachments displayed has changed
     *
     * @param attachments
     */
    notifyAttachmentsChanged: function(attachments) {
        attachments = attachments || this.getDisplayedAttachments();
        this.context.trigger('attachments:updated', attachments);
    },

    /**
     * Refresh select2 from model
     */
    refreshFromModel: function() {
        var attachments = [];
        if (this.model.has(this.name)) {
            attachments = this.model.get(this.name);
        }
        this.setDisplayedAttachments(attachments);
    },

    /**
     * Remove attachments in list based on a given truth test iterator
     * Removes from select2 and then updates the model
     *
     * @param iterator
     */
    removeAttachmentsByIterator: function(iterator) {
        var attachments = this.getDisplayedAttachments();
        attachments = _.reject(attachments, iterator);
        this.setDisplayedAttachments(attachments);
        this.updateModel();
    },

    /**
     * Remove attachments in list based on a given guid
     *
     * @param id
     */
    removeAttachmentsById: function(id) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.id && attachment.id === id) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove attachments in list based on a given tag
     *
     * @param tag
     */
    removeAttachmentsByTag: function(tag) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.tag && attachment.tag === tag) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove the given attachment from the server, if there is a problem doing this, no big deal (hence no error alert)
     * @param attachment
     */
    removeUploadedAttachment: function(attachment) {
        var deleteUrl = app.api.buildURL('Mail/attachment', "delete", {id:attachment.id});
        app.api.call('delete', deleteUrl);
    },

    /**
     * Sets the attachments on select2
     */
    setDisplayedAttachments: function(attachments) {
        this.$node.select2('data', attachments);
        this.notifyAttachmentsChanged(attachments);
    },

    /**
     * Update the model from the data stored in select2
     */
    updateModel: function() {
        this.model.set(this.name, this.getDisplayedAttachments());
    },

    /**
     * Upload the file and define callbacks for success & failure
     */
    uploadFile: function() {
        var $fileInput = this.$(this.fileInputSelector),
            ajaxParams = {
                files: $fileInput,
                iframe: true
            },
            fileId,
            myURL,
            options;

        //don't do anything if user cancels out of picking a file
        if (_.isEmpty(this.getFileInputVal())) {
            return;
        }

        //Notify user of progress uploading by adding a placeholder pill
        this.fileCounter++;
        fileId = 'upload'+this.fileCounter;
        this.addAttachmentToContainer({
            id: fileId,
            nameForDisplay: this.getFileInputVal().split('\\').pop(),
            showProgress: true
        });

        // pass OAuth token as GET-parameter during file upload.
        // otherwise, in case if file is too large, the whole request body may
        // be ignored by interpreter together with the token
        options = {
            format: 'sugar-html-json',
            oauth_token: app.api.getOAuthToken()
        };
        myURL = app.api.buildURL('Mail/attachment', null, null, options);
        var request = app.api.call('create', myURL, null, {
                success: _.bind(function (result) {
                    if (this.disposed === true) return; //if field is already disposed, bail out
                    if (!result.guid) {
                        this.handleUploadError(fileId, result);
                        app.logger.error('Attachment Upload Failed - no guid returned from API');
                        return;
                    }

                    //add attachment to container, replacing placeholder pill from above
                    result.id = result.guid;
                    delete result.guid;
                    result.type = 'upload';
                    result.replaceId = fileId;
                    this.context.trigger('attachment:add', result);
                }, this),

                error: _.bind(function(e) {
                    //if field is already disposed, bail out
                    if (this.disposed === true) {
                        return;
                    }

                    // When a user cancels a file upload, the associated request
                    // is aborted. The error handler is called when a request is
                    // aborted. No error message needs to be shown in this case.
                    if (e && e.errorThrown === 'abort') {
                        return;
                    }

                    this.handleUploadError(fileId, e);
                    app.logger.error('Attachment Upload Failed: ' + e);
                }, this),

                complete: _.bind(function() {
                    // the request is done so there is nothing to cancel
                    // no need to keep track of finished requests
                    delete this.requests[fileId];

                    //clear out the file input so we can detect the next change, even if it is the same file
                    this.clearFileInputVal($fileInput);
                }, this)
            },
            ajaxParams
        );

        // keep track of the request so that it can be aborted when the user cancels the file upload
        if (request) {
            this.requests[fileId] = request.uid;
        }
    },

    /**
     * Retrieve the val from the file input element (return null if not there)
     */
    getFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (_.isUndefined($fileInput)) {
            return null;
        }
        return $fileInput.val();
    },

    /**
     * Clear the value of the file input element
     * This is a bit of a hack, but is required for cross-browser (read IE isn't playing nice)
     * FIXME: When we drop IE10 support, change to: $fileInput.val(null);
     *
     * @param $fileInput
     */
    clearFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (!_.isUndefined($fileInput)) {
            $fileInput.wrap('<form>').closest('form').get(0).reset();
            $fileInput.unwrap();
        }
    },

    /**
     * When upload fails, display an error alert and remove the placeholder pill
     * @param fileId
     * @param {Object} [error] The error object containing the message to display.
     * @param {string} [error.error_message] The error message to display.
     */
    handleUploadError: function(fileId, error) {
        var message = (error && error.error_message) ? error.error_message : 'LBL_EMAIL_ATTACHMENT_UPLOAD_FAILED';

        this.context.trigger('attachments:remove-by-id', fileId);
        app.alert.show('upload_error', {
            level: 'error',
            messages: message
        });
    },

    /**
     * Turn off re-rendering of field when model changes - let select2 handle how the field looks
     */
    bindDataChange:$.noop,

    _dispose: function() {
        this.$node.select2('destroy');
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EnumField
 * @alias SUGAR.App.view.fields.BaseEnumField
 * @extends View.Fields.Base.BaseField
 */
({
	// Enum Field (base) 

    fieldTag: 'input.select2',

    plugins: ['EllipsisInline'],

    /**
     * HTML tag of the append value checkbox.
     *
     * @property {String}
     */
    appendValueTag: 'input[name=append_value]',

    /**
     * Whether this field is in the midst of fetching options for its dropdown.
     *
     * @type {Boolean}
     */
    isFetchingOptions: false,

    /**
     * The dropdown elements.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": "value1",
     *         "key2": "value2",
     *         "key3": "value3"
     *     }
     *     ```
     *
     * @type {Object}
     */
    items: null,

    /**
     * The keys of dropdown elements and their index in the related
     * `app_list_keys` array.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": 1,
     *         "key2": 0,
     *         "key3": 2
     *     }
     *     ```
     *
     * If no `app_list_keys` entry, or if elements in the expected order, the
     * object will be empty.
     *
     * @type {Object}
     */
    _keysOrder: null,

    initialize: function(){
        this._super("initialize", arguments);

        //Reset the availible options based on the user's access and the model's values
        if (_.isString(this.def.options)) {
            var self = this;

            this.listenTo(this.model, "sync", function(model){
                var options = app.lang.getAppListStrings(self.def.options);
                if (options) {
                    self.items = self._filterOptions(options);
                }
            });
        }

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;
    },

    /**
     * @inheritdoc
     *
     * Returns the direction of the field depending on the nature of the first
     * option when the language direction is `rtl`.
     */
    direction: function() {
        if (_.isEmpty(this.items) || app.lang.direction !== 'rtl') {
            return;
        }

        var firstOption = _.values(this.items)[0];
        return app.utils.isDirectionRTL(firstOption) ? 'rtl' : 'ltr';
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $el = this.$(this.fieldTag);
        if ($el) {
            $el.on('keydown.record', {field: this}, callback);
            var plugin = $el.data('select2');
            if (plugin) {
                if (plugin.focusser) {
                    plugin.focusser.on('keydown.record', {field: this}, callback);
                }
                plugin.search.on('keydown.record', {field: this}, callback);
            }
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        if (this.$el) {
            var $el = this.$(this.fieldTag);
            if ($el) {
                $el.off('keydown.record', callback);
                var plugin = $el.data('select2');
                if (plugin) {
                    plugin.search.off('keydown.record', callback);
                }
            }
        }
    },

    /**
     * @override
     * @protected
     * @chainable
     */
    _render: function() {
        var self = this;
        if (!this.items || _.isEmpty(this.items)) {
            this.loadEnumOptions(false, function() {
                self.isFetchingOptions = false;
                //Re-render widget since we have fresh options list
                if(!this.disposed){
                    this.render();
                }
            });
            if (this.isFetchingOptions){
                // Set loading message in place of empty DIV while options are loaded via API
                this.$el.html(app.lang.get('LBL_LOADING'));
                return this;
            }
        }
        //Use blank value label for blank values on multiselects
        if (this.def.isMultiSelect && !_.isUndefined(this.items['']) && this.items[''] === '') {
            var obj = {};
            _.each(this.items, function(value, key) {
               // Only work on key => value pairs that are not both blank
               if (key !== '' && value !== '') {
                   obj[key] = value;
               }
            }, this);
            this.items = obj;
        }
        this.items = this._filterOptions(this.items);
        var optionsKeys = _.isObject(this.items) ? _.keys(this.items) : [],
            defaultValue = this._checkForDefaultValue(this.model.get(this.name), optionsKeys);

        app.view.Field.prototype._render.call(this);
        // if displaying the noaccess template, just exit the method
        if (this.tplName == 'noaccess') {
            return this;
        }
        var select2Options = this.getSelect2Options(optionsKeys);
        var $el = this.$(this.fieldTag);
        //FIXME remove check for tplName SC-2608
        if (this.tplName === 'edit' || this.tplName === 'list-edit' || this.tplName === 'massupdate') {
            $el.select2(select2Options);
            var plugin = $el.data('select2');

            if (plugin && this.dir) {
                plugin.container.attr('dir', this.dir);
                plugin.results.attr('dir', this.dir);
            }

            if (plugin && plugin.focusser) {
                plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
            }
            $el.on('change', function(ev) {
                var value = ev.val;
                if (_.isUndefined(value)) {
                    return;
                }
                if (self.model) {
                    self.model.set(self.name, self.unformat(value));
                }
            });
            if (this.def.ordered) {
                $el.select2('container').find('ul.select2-choices').sortable({
                    containment: 'parent',
                    start: function() {
                        $el.select2('onSortStart');
                    },
                    update: function() {
                        $el.select2('onSortEnd');
                    }
                });
            }
        } else if (this.tplName === 'disabled') {
            $el.select2(select2Options);
            $el.select2('disable');
        }
        //Setup selected value in Select2 widget
        if (!_.isUndefined(this.value)) {
            // To make pills load properly when autoselecting a string val
            // from a list val needs to be an array
            if (!_.isArray(this.value)) {
                this.value = [this.value];
            }
            // Trigger the `change` event only if we automatically set the
            // default value.
            $el.select2('val', this.value, !!defaultValue);
        }
        return this;
    },

    /**
     * Sets the model value to the default value if required
     * @private
     */
    _checkForDefaultValue: function(currentValue, optionsKeys){

        // Javascript keys function returns strings even if keys are numbers.  The parameter optionsKeys
        // is obtained by _.keys() operation on an object. Even if the object keys were numeric originally,
        // optionsKeys will be an array of strings. Hence we need to cast currentValue to a string
        // for comparison sake.
        if ((typeof currentValue !== 'undefined') && (currentValue !== null)) {
            currentValue = currentValue.toString();
        }

        var action = this.action || this.view.action;
        //After rendering the dropdown, the selected value should be the value set in the model,
        //or the default value. The default value fallbacks to the first option if no other is selected
        //or the selected value is not available in the list of items,
        //if the user has write access to the model for the field we are currently on.
        //This should be done only if available options are loaded, otherwise the value in model will be reset to
        //default even if it's in available options but they are not loaded yet
        if (!this.def.isMultiSelect
            && !_.isEmpty(this.items)
            && !(this.model.has(this.name) && optionsKeys.indexOf(currentValue) > -1)
            && app.acl.hasAccessToModel('write', this.model, this.name)
            && (action == 'edit' || action == 'create')
        ) {
            var defaultValue = this._getDefaultOption(optionsKeys);
            //Forecasting uses backbone model (not bean) for custom enums so we have to check here
            if (_.isFunction(this.model.setDefault)) {
                this.model.setDefault(this.name, defaultValue);
            }
        }
    },

    /**
     * Called when focus on inline editing
     */
    focus: function () {
        //We must prevent focus for multi select otherwise when inline editing the dropdown is opened and it is
        //impossible to click on a pill `x` icon in order to remove an item
        if(this.action !== 'disabled' && !this.def.isMultiSelect) {
            this.$(this.fieldTag).select2('open');
        }
    },

    /**
     * Load the options for this field and pass them to callback function.  May be asynchronous.
     * @param {Boolean} fetch (optional) Force use of Enum API to load options.
     * @param {Function} callback (optional) Called when enum options are available.
     */
    loadEnumOptions: function(fetch, callback) {
        var self = this;
        var _itemsKey = 'cache:' + this.module + ':' + this.name + ':items';

        this.items = this.def.options || this.context.get(_itemsKey);

        fetch = fetch || false;

        if (fetch || !this.items) {
            this.isFetchingOptions = true;
            var _key = 'request:' + this.module + ':' + this.name;
            //if previous request is existed, ignore the duplicate request
            if (this.context.get(_key)) {
                var request = this.context.get(_key);
                request.xhr.done(_.bind(function(o) {
                    if (this.items !== o) {
                        this.items = o;
                        callback.call(this);
                    }
                }, this));
            } else {
                var request = app.api.enumOptions(self.module, self.name, {
                    success: function(o) {
                        if(self.disposed) { return; }
                        if (self.items !== o) {
                            self.items = o;
                            self.context.set(_itemsKey, self.items);
                            self.context.unset(_key);
                            callback.call(self);
                        }
                    }
                    // Use Sugar7's default error handler
                });
                this.context.set(_key, request);
            }
        } else if (_.isString(this.items)) {
            this.items = app.lang.getAppListStrings(this.items);
        }
    },

    /**
     * Helper function for generating Select2 options for this enum
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {Object} Select2 options, refer to Select2 documentation for what each option means
     */
    getSelect2Options: function(optionsKeys){
        var select2Options = {};
        select2Options.allowClear = _.indexOf(optionsKeys, "") >= 0;
        select2Options.transformVal = _.identity;

        /* From http://ivaynberg.github.com/select2/#documentation:
         * Initial value that is selected if no other selection is made
         */
        if(!this.def.isMultiSelect) {
            select2Options.placeholder = app.lang.get("LBL_SEARCH_SELECT");
        }

        /* From http://ivaynberg.github.com/select2/#documentation:
         * "Calculate the width of the container div to the source element"
         */
        select2Options.width = this.def.enum_width ? this.def.enum_width : '100%';

        /* Because the select2 dropdown is appended to <body>, we need to be able
         * to pass a classname to the constructor to allow for custom styling
         */
        select2Options.dropdownCssClass = this.def.dropdown_class ? this.def.dropdown_class : '';

        /* To get the Select2 multi-select pills to have our styling, we need to be able
         * to either pass a classname to the constructor to allow for custom styling
         * or set the 'select2-choices-pills-close' if the isMultiSelect option is set in def
         */
        select2Options.containerCssClass = this.def.container_class ? this.def.container_class : (this.def.isMultiSelect ? 'select2-choices-pills-close' : '');

        /* Because the select2 dropdown is calculated at render to be as wide as container
         * to make it differ the dropdownCss.width must be set (i.e.,100%,auto)
         */
        if (this.def.dropdown_width) {
            select2Options.dropdownCss = { width: this.def.dropdown_width };
        }

        /* All select2 dropdowns should only show the search bar for fields with 7 or more values,
         * this adds the ability to specify that threshold in metadata.
         */
        select2Options.minimumResultsForSearch = this.def.searchBarThreshold ? this.def.searchBarThreshold : 7;

        /* If is multi-select, set multiple option on Select2 widget.
         */
        if (this.def.isMultiSelect) {
            select2Options.multiple = true;
        }

        /* If we need to define a custom value separator
         */
        select2Options.separator = this.def.separator || ',';
        if (this.def.separator) {
            select2Options.tokenSeparators = [this.def.separator];
        }

        select2Options.initSelection = _.bind(this._initSelection, this);
        select2Options.query = _.bind(this._query, this);
        select2Options.sortResults = _.bind(this._sortResults, this);

        return select2Options;
    },

    /**
     * Set the option selection during select2 initialization.
     * Also used during drag/drop in multiselects.
     * @param {Selector} $ele Select2 element selector
     * @param {Function} callback Select2 data callback
     * @private
     */
    _initSelection: function($ele, callback){
        var data = [];
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        options = this.items = this._filterOptions(options);
        var values = $ele.val();
        if (this.def.isMultiSelect) {
            values = values.split(this.def.separator || ',');
        }
        _.each(_.pick(options, values), function(value, key){
            data.push({id: key, text: value});
        }, this);
        if(data.length === 1){
            callback(data[0]);
        } else {
            callback(data);
        }
    },

    /**
     * Returns dropdown list options which can be used for editing 
     *
     * @param {Object} Dropdown list options
     * @return {Object}
     * @private
     */
    _filterOptions: function (options) {
        var currentValue,
            syncedVal,
            newOptions = {},
            filter = app.metadata.getEditableDropdownFilter(this.def.options);

        /**
         * Flag to indicate that the options have already been filtered and do
         * not need to be sorted.
         *
         * @type {boolean}
         */
        this.isFiltered = !_.isEmpty(filter);

        if (!this.isFiltered) {
            return options;
        }

        if (!_.contains(this.view.plugins, "Editable")) {
            return options;
        }
        //Force the current value(s) into the availible options
        syncedVal = this.model.getSynced();
        currentValue = _.isUndefined(syncedVal[this.name]) ? this.model.get(this.name) : syncedVal[this.name];
        if (_.isString(currentValue)) {
            currentValue = [currentValue];
        }

        var currentIndex = {};

        // add current values to the index in case if current model is saved to the server in order to prevent data loss
        if (!this.model.isNew()) {
            _.each(currentValue, function(value) {
                currentIndex[value] = true;
            });
        }

        //Now remove the disabled options
        if (!this._keysOrder) {
            this._keysOrder = {};
        }
        _.each(filter, function(val, index) {
            var key = val[0],
                visible = val[1];
            if ((visible || key in currentIndex) && !_.isUndefined(options[key]) && options[key] !== false) {
                this._keysOrder[key] = index;
                newOptions[key] = options[key];
            }
        }, this);

        return newOptions;
    },

    /**
     * Adapted from eachOptions helper in hbt-helpers.js
     * Select2 callback used for loading the Select2 widget option list
     * @param {Object} query Select2 query object
     * @private
     */
    _query: function(query){
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        var data = {
            results: [],
            // only show one "page" of results
            more: false
        };
        if (_.isObject(options)) {
            _.each(options, function(element, index) {
                var text = "" + element;
                //additionally filter results based on query term
                if(query.matcher(query.term, text)){
                    data.results.push({id: index, text: text});
                }
            });
        } else {
            options = null;
        }
        query.callback(data);
    },

    /**
     * Sort the dropdown items.
     *
     * - If `def.sort_alpha` is `true`, return the dropdown items sorted
     * alphabetically.
     * - If {@link Core.Language#getAppListKeys} is defined for
     * `this.def.options`, return the items in this order.
     * - Otherwise, fall back to the default behavior and just return the
     * `results`.
     *
     * This method is the implementation of the select2 `sortResults` option.
     * See {@link http://ivaynberg.github.io/select2/ official documentation}.
     *
     * @param {Array} results The list of results `{id: *, text: *}.`
     * @param {jQuery} container jQuery wrapper of the node that should contain
     *  the representation of the result.
     * @param {Object} query The query object used to request this set of
     *  results.
     * @return {Array} The list of results {id: *, text: *} sorted.
     * @private
     */
    _sortResults: function(results, container, query) {
        var sortedResults;

        if (this.def.sort_alpha) {
            sortedResults = _.sortBy(results, function(item) {
                return item.text;
            });
            return sortedResults;
        }

        // Do not sort if options have already been filtered; or if the key ordering is empty,
        // we should not change the order as the options were generated by a function.
        if (this.isFiltered && _.isEmpty(this._keysOrder)) {
            return results;
        }

        this._setupKeysOrder();
        // If the key ordering is empty, we should not change the order as the options were generated by a function.
        if (_.isEmpty(this._keysOrder)) {
            return results;
        }

        // if it is not a dependency field (visibility_grid is not defined), we show the order from drop down list.
        if (!this.def.visibility_grid) {
            sortedResults = _.sortBy(results, function(item) {
                return this._keysOrder[item.id];
            }, this);
            return sortedResults;
        }

        return results;
    },

    _setupKeysOrder: function() {
        var keys, orderedKeys, filteredOrderedKeys;
        if (!this._keysOrder) {
            keys = _.keys(this.items);
            this._keysOrder = {};
            orderedKeys = _.map(app.lang.getAppListKeys(this.def.options), function(appListKey) {
                return appListKey.toString();
            });
            filteredOrderedKeys = _.intersection(orderedKeys, keys);
            if (!_.isEqual(filteredOrderedKeys, keys)) {
                _.each(filteredOrderedKeys, function(key, index) {
                    return this._keysOrder[key] = index;
                }, this);
            }
        }
    },

    /**
     * Helper function for retrieving the default value for the selection
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {string} The default value
     */
    _getDefaultOption: function (optionsKeys) {
        //  Return the default if it's available in the definition.
        if (this.def && (!_.isEmptyValue(this.def.default)) ) {
            return this.def.default;
        } else {
            this._setupKeysOrder();
            var invertedKeysOrder = _.invert(this._keysOrder);
            //Check if we have a keys order, and that the sets of keys match
            if (!_.isEmpty(invertedKeysOrder) && _.isEmpty(_.difference(_.keys(this._keysOrder), optionsKeys))) {
                return _.first(invertedKeysOrder);
            }
            return _.first(optionsKeys);
        }
    },

    /**
     *  Convert select2 value into model appropriate value for sync
     *
     * @param value Value from select2 widget
     * @return {String|Array} Unformatted value as String or String Array
     */
    unformat: function(value) {
        if (this.def.isMultiSelect && _.isArray(value)) {
            var possibleKeys = _.keys(this.items);
            if (!this.def.ordered) {
                // if it's not ordered, i.e. sortable, force order
                value = _.intersection(possibleKeys, value);
            } else {
                // no need to force order, just keep valid keys
                value = _.intersection(value, possibleKeys);
            }
            return value;
        }

        if (this.def.isMultiSelect && _.isNull(value)) {
            return [];  // Returning value that is null equivalent to server.  Backbone.js won't sync attributes with null values.
        } else {
            return value;
        }
    },

    /**
     * Convert server value into one appropriate for display in widget
     *
     * @param value
     * @return {Array} Value for select2 widget as String Array
     */
    format: function(value){
        if (this.def.isMultiSelect && _.isArray(value) && _.indexOf(value, '') > -1) {
            value = _.clone(value);

            // Delete empty values from the select list
            delete value[''];
        }
        if(this.def.isMultiSelect && _.isString(value)){
            return this.convertMultiSelectDefaultString(value);
        } else {
            return value;
        }
    },

    /**
     * Converts multiselect default strings into array of option keys for template
     * @param {String} defaultString string of the format "^option1^,^option2^,^option3^"
     * @return {Array} of the format ["option1","option2","option3"]
     */
    convertMultiSelectDefaultString: function(defaultString) {
        var result = defaultString.split(",");
        _.each(result, function(value, key) {
            // Remove empty values in the selection
            if (value !== '^^') {
                result[key] = value.replace(/\^/g,"");
            }
        });
        return result;
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (_.isEmpty(this.$(this.fieldTag).data('select2'))) {
                    this.render();
                } else {
                    this.$(this.fieldTag).select2('val', this.format(this.model.get(this.name)));
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * Binds append value checkbox change for massupdate.
     *
     * @override
     */
    bindDomChange: function() {
        var $el = this.$(this.appendValueTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendValue = $el.prop('checked');
                //FIXME: Should use true booleans (SC-2828)
                this.model.set(this.name + '_replace', this.appendValue ? '1' : '0');
            }, this));
        }

    },

    /**
     * @override
     */
    unbindDom: function() {
        this.$(this.appendValueTag).off();
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @override
     */
    unbindData: function() {
        var _key = 'request:' + this.module + ':' + this.name;
        this.context.unset(_key);
        app.view.Field.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.unbindKeyDown();
        this._super('_dispose');
    }
}) },
"label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LabelField
 * @alias SUGAR.App.view.fields.BaseLabelField
 * @extends View.Fields.Base.BaseField
 */
({
	// Label Field (base) 

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDataChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDomChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    unbindDom: $.noop,

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (this.def.formatted_value) {
            value = this.def.formatted_value;
        } else {
            value = app.lang.get(this.def.default_value, this.module);
        }
        return value;
    }
}) },
"vcard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.VcardField
 * @alias SUGAR.App.view.fields.BaseVcardField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Vcard Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Downloads the vCard from the Rest API.
     *
     * First we do an ajax call to the `ping` API. This will check if the token
     * hasn't expired before we append it to the URL of the VCardDownload.
     *
     */
    rowActionSelect: function() {
        var url = app.api.buildURL(this.model.module, 'vcard', {id: this.model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the vCard download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', this.render, this);
        }
    }
}) },
"change-my-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangeMyPasswordField
 * @alias SUGAR.App.view.fields.BaseChangeMyPasswordField
 * @extends View.Fields.Base.ChangePasswordField
 */
({
	// Change-my-password Field (base) 

    extendsFrom: 'ChangePasswordField',

    /**
     * @inheritdoc
     */
    fieldTag: 'input',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['current_password'] = 'ERR_PASSWORD_MISMATCH';
        app.error.errorName2Keys['new_password'] = 'ERR_ENTER_NEW_PASSWORD';

        this.__extendModel();
    },


    /**
     * Extends the model (note that the model is already extended by ChangePasswordField)
     * - adds a validation task _doValidateCurrentPassword : handle the current password validation
     * - revertAttributes : to unset temporary attributes _current_password
     */
    __extendModel: function() {

        // _hasChangePasswordModifs is a flag to make sure model methods are overriden only once
        if (this.model && !this.model._hasChangeMyPasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do override methods only once
            this.model._hasChangeMyPasswordModifs = true;

            /**
             * Validates current password against server
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             * @private
             */
            this.model._doValidateCurrentPassword = function(fields, errors, callback) {
                // Find the change my password field
                var field = _.find(fields, function(field) {
                    return field.type === 'change-my-password';
                });

                // change-my-password field was not changed, so
                // don't attempt to validate password
                if (!field) {
                    callback(null, fields, errors);
                    return;
                }

                //Get the current password
                var current = this.get(field.name + '_current_password');
                var password = this.get(field.name + '_new_password'),
                    confirmation = this.get(field.name + '_confirm_password');

                if (_.isEmpty(current) && _.isEmpty(password) && _.isEmpty(confirmation)) {
                    callback(null, fields, errors);
                    return;
                }
                //current is non-empty but we haven't put new/confirm passwords
                if (!_.isEmpty(current) && _.isEmpty(password) && _.isEmpty(confirmation)) {
                    errors[field.name] = errors[field.name] || {};
                    errors[field.name]['new_password'] = true;
                    callback(null, fields, errors);
                    return;
                }
                //Validate current password
                var alertOptions = {
                    title: app.lang.get("LBL_VALIDATING"),
                    level: "process"
                };
                app.alert.show('validation', alertOptions);

                app.api.verifyPassword(current, {
                    success: function(data) {
                        if(!data || !data.valid) {
                            errors[field.name] = errors[field.name] || {};
                            errors[field.name]['current_password'] = true;
                        }
                    },
                    error: function(error) {
                        errors[field.name] = errors[field.name] || {};
                        errors[field.name]['current_password'] = true;
                    },
                    /**
                     * After check is done, close alert and trigger the completion of the validation to the editor
                     */
                    complete: function() {
                        app.alert.dismiss('validation');
                        callback(null, fields, errors);
                    }
                });
            };
            this.model.addValidationTask('current_password_' + this.cid, _.bind(this.model._doValidateCurrentPassword, this.model));

            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_current_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (this.action === 'edit') {
            this.currentPassword = this.model.get(this.name + '_current_password');
            value = '';
        } else if (value === true) {
            value = 'value_setvalue_set';
        }
        return value;
    },

    /**
     * @override
     */
    decorateError: function (errors) {
        var ftag = this.fieldTag;
        if (errors['current_password']) {
            this.fieldTag = 'input[name=current_password]';
            app.view.Field.prototype.decorateError.call(this, {current_password: true});
        }
        errors = _.omit(errors, 'current_password');
        if (!_.isEmpty(errors)) {
            this.fieldTag = 'input[name!=current_password]';
            app.view.Field.prototype.decorateError.call(this, errors);
        }
        this.fieldTag = ftag;
    },

    /**
     * @override
     */
    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     */
    bindDomChange: function() {
        this.$('input[name=current_password], input[name=new_password], input[name=confirm_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=current_password]').off('change.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('current_password_' + this.cid);
        this._super('_dispose');
    }

}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseEditablelistbuttonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Editablelistbutton Field (base) 

    events: {
        'click [name=inline-save]' : 'saveClicked',
        'click [name=inline-cancel]' : 'cancelClicked'
    },
    extendsFrom: 'ButtonField',
    initialize: function(options) {
        this._super("initialize", [options]);
        if(this.name === 'inline-save') {
            this.model.off("change", null, this);
            this.model.on("change", function() {
                this.changed = true;
            }, this);
        }
    },
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);
        if(this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) >= 0 ) {
            this.template = app.template.getField('button', 'edit', this.module, 'edit');
        } else {
            this.template = app.template.empty;
        }
    },
    /**
     * Called whenever validation completes on the model being edited
     * @param {boolean} isValid TRUE if model is valid
     * @private
     */
    _validationComplete : function(isValid){
        if (!isValid) {
            this.setDisabled(false);
            return;
        }
        if (!this.changed) {
            this.cancelEdit();
            return;
        }

        this._save();
    },

    _save: function() {
        var self = this,
            successCallback = function(model) {
                self.changed = false;
                self.view.toggleRow(model.id, false);
            },
            options = {
                success: successCallback,
                error: function(error) {
                    if (error.status === 409) {
                        app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                            if (model) {
                                if (isDatabaseData) {
                                    successCallback(model);
                                } else {
                                    self._save();
                                }
                            }
                        });
                    }
                },
                complete: function() {
                    // remove this model from the list if it has been unlinked
                    if (self.model.get('_unlinked')) {
                        self.collection.remove(self.model, { silent: true });
                        self.collection.trigger('reset');
                        self.view.render();
                    } else {
                        self.setDisabled(false);
                    }
                },
                lastModified: self.model.get('date_modified'),
                //Show alerts for this request
                showAlerts: {
                    'process': true,
                    'success': {
                        messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                    }
                },
                relate: this.model.link ? true : false
            };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    saveModel: function() {
        this.setDisabled(true);
        var fieldsToValidate = this.view.getFields(this.module, this.model);
        this.model.doValidate(fieldsToValidate, _.bind(this._validationComplete, this));
    },
    cancelEdit: function() {
        if (this.isDisabled()) {
            this.setDisabled(false);
        }
        this.changed = false;
        this.model.revertAttributes();
        this.view.clearValidationErrors();
        this.view.toggleRow(this.model.id, false);

        // trigger a cancel event across the parent context so listening components
        // know the changes made in this row are being reverted
        if(this.context.parent) {
            this.context.parent.trigger('editablelist:cancel', this.model);
        }
    },
    saveClicked: function(evt) {
        if (!$(evt.currentTarget).hasClass('disabled')) {
            this.saveModel();
        }
    },
    cancelClicked: function(evt) {
        this.cancelEdit();
    }
}) },
"tag": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TagField
 * @alias SUGAR.App.view.fields.BaseTagField
 * @extends View.Fields.Base.BaseField
 */
({
	// Tag Field (base) 

    plugins: ['EllipsisInline'],

    /**
     * HTML tag of the append tag checkbox.
     *
     * @property {String}
     */
    appendTagInput: 'input[name=append_tag]',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // init bean collection used for type aheads
        this.filterResults = app.data.createBeanCollection('Tags');

        // initialize value to empty array
        if (!this.model.has(this.name)) {
            this.model.setDefault(this.name, []);
        }

        // Set append as default when mass updating tags
        this.appendTagValue = true;
        this.model.setDefault('tag_type', this.appendTagValue ? '1' : '0');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.setTagList();

        this._super('_render');

        this.initializeSelect2();
        this.$select2.on('change', _.bind(this.storeValues, this));
        this.$select2.on('select2-selecting', this.handleNewSelection);
    },

    /**
     * Set up tagList variable for use in the list view
     */
    setTagList: function() {
        var self = this;
        this.value = this.getFormattedValue();
        this.tagList = [];
        if (this.value) {
            _.each(this.value, function(tag){
                if (_.isString(tag)) {
                    self.tagList.push(tag);
                } else {
                    self.tagList.push(tag.name);
                }
            })
            this.tagList = this.tagList.join(', ');
        }
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        return _.map(value, function(tag){
            return _.extend(tag, {encodedValue: encodeURIComponent(tag.name)});
        });
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     *
     * @param term
     * @param results
     * @return {Mixed}
     * @private
     */
    _createSearchChoice: function(term, results) {
        // If tag is for filter, don't allow new choices to be selected
        if (this.view.action === 'filter-rows') {
            return false;
        }

        // Trim up the term for sanity sake
        term = $.trim(term);

        // Check previously found results to see tag exists with different casing
        if (results && results.length) {
            if (_.find(results, function(tag) {
                return tag.text.toLowerCase() === term.toLowerCase();
            })) {
                return false;
            }
        }
        
        // Check if input is empty after trim
        if (term === '') {
            return false;
        }

        // Check for existence amongst tags that exist but haven't been saved yet
        if (this.checkExistingTags(term)) {
            return false;
        }

        return {
            id: term,
            text: term + ' ' + app.lang.get('LBL_TAG_NEW_TAG'),
            locked: false,
            newTag: true
        };
    },

    /**
     * Check tag select2's currently selected tags for term to see if it already exists (case insensitive)
     * @param term term to be checked
     * @return {boolean} `true` if tag exists already, `false` otherwise
     */
    checkExistingTags: function(term) {
        if (this.$select2 && _.isFunction(this.$select2.val)) {
            var currentSelections = this.$select2.val().split(',');
        }
        if (currentSelections && currentSelections.length) {
            if (_.find(currentSelections, function(tag) {
                return tag.toLowerCase() === term.toLowerCase();
            })) {
                return true;
            }
        }

        return false;
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     * @param query
     * @private
     */
    _query: function(query) {
        var self = this,
            shortlist = {results: []};

        // Trim the query term right up front since it needs to be clean
        query.term = $.trim(query.term);

        this.filterResults.filterDef = {
            'filter': [{
                'name_lower': { '$starts': query.term.toLowerCase() }
            }]
        };

        // Tags should always be available because it's public
        this.filterResults.module = 'Tags';
        this.filterResults.fetch({
            success: function(data) {
                shortlist.results = self.parseRecords(data.models);

                //Format results so that already existing records don't show up
                shortlist.results = _.reject(shortlist.results, function(result) {
                    return self.checkExistingTags(result.text)
                });

                query.callback(shortlist);
            },
            error: function() {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Upon selection of a tag, if it's a new tag, get rid of the text indicating new tag
     * @param {event} e
     */
    handleNewSelection: function(e) {
        // For new tags, look for New Tag indicator and remove it if it's there
        if (e.object.newTag) {
            var newTagIdx = e.object.text.lastIndexOf(' ' + app.lang.get('LBL_TAG_NEW_TAG'));
            e.object.text = e.object.text.substr(0, newTagIdx);
        }
    },

    /**
     * Initialize select2 jquery widget
     */
    initializeSelect2: function() {
        var self = this,
            escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';

        this.$select2 = this.$('.select2field').select2({
            placeholder: '',
            minimumResultsForSearch: 5,
            minimumInputLength: 1,
            tags: true,
            multiple: true,
            closeOnSelect: true,
            width: '100%',
            containerCssClass: 'select2-choices-pills-close',
            tokenSeparators: [','],

            initSelection: function(element, callback) {
                var data = self.parseRecords(self.value);
                callback(data);
            },

            createSearchChoice: _.bind(this._createSearchChoice, this),
            query: _.debounce(_.bind(this._query, this), 300),

            sortResults: function(results, container, query) {
                results = _.sortBy(results, 'text');
                return results;
            }
        });

        this.setSelect2Records();

        // Workaround to make select2 treat enter the same as it would a comma (INT-668)
        this.$('.select2-search-field > input.select2-input').on('keyup', function(e) {
            if (e.keyCode === 13) {
                var val = self.$('input.select2-input').val();

                // Trim the tag
                val = $.trim(val);

                // Prevent blank tags
                if (val === '') {
                    return;
                }

                // Sanitize input
                if (escapeChars.indexOf(val.charAt(0)) >= 0) {
                    val = '\\\\' + val;
                }

                var tags = self.$select2.select2('data');

                // If the current input already exists as a tag (case insensitive), just exit
                var exists = _.find(tags, function(tag) {
                    return tag.id.toLowerCase() === val.toLowerCase();
                });
                if (exists) {
                    // Close the search box and return
                    self.$select2.select2('close');
                    // Re-opens the search box with the default message
                    // (this is to maintain consistency with select2's OOB tokenizer)
                    self.$select2.select2('open');
                    return;
                }

                // Otherwise, create a tag out of current input
                tags.push({id: val, text: val, locked: false});
                self.$select2.select2('data', tags, true);
                e.preventDefault();

                // Close the search box
                self.$select2.select2('close');
            }
        });
    },

    /**
     * Format related records in select2 format
     * @param {array} list of objects/beans
     */
    parseRecords: function(list) {
        var results = [];

        _.each(list, function(item) {
            var record = item;

            // we may have a bean from a collection
            if (_.isFunction(record.toJSON)) {
                record = record.toJSON();
            }
            if (_.isString(record)) {
                results.push({id: record, text: record});
            } else {
                results.push({id: record.name, text: record.name});
            }
        });

        return results;
    },

    /**
     * Store selected/removed values on our field which is put to the server
     * @param {event} e - event data
     */
    storeValues: function(e) {
        this.value = app.utils.deepCopy(this.value) || [];
        if (e.added) {
            app.analytics.trackEvent('click', 'tag_pill_added');
            // Check if added is an array or a single object
            if (_.isArray(e.added)) {
                // Even if it is an array, only one object gets added at a time,
                // so we just need it to be the first element
                e.added = e.added[0];
            }

            // Check to see if the tag we're adding has already been added.
            var valFound = _.find(this.value, function(vals) {
                return vals.name === e.added.text;
            });

            if (!valFound) {
                this.value.push(e.added.text);
            }
        } else if (e.removed) {
            app.analytics.trackEvent('click', 'tag_pill_removed');
            // Remove the tag
            this.value = _.reject(this.value, function(record) {
                if (_.isString(record)) {
                    return record === e.removed.text;
                } else {
                    return record.name === e.removed.text;
                }
            });
        }
        this.model.set('tag', this.value);
    },

    /**
     * Sanitize the tags and set the select2
     */
    setSelect2Records: function() {
        var escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';
        var records = _.map(this.value, function(record) {
            if (_.isString(record)) {
                // If a special character is the first character of a tag, it breaks select2 and jquery and everything
                // So escape that character if it's the first char
                if (escapeChars.indexOf(record.charAt(0)) >= 0) {
                    return '\\\\' + record;
                }
                return record;
            }
            if (escapeChars.indexOf(record.name.charAt(0)) >= 0) {
                return '\\\\' + record.name;
            }
            return record.name;
        });

        this.$select2.select2('val', records);

    },

    /**
     * Avoid rendering process on Select2 change in order to keep focus
     * @override
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (!_.isEmpty(this.$select2.data('select2'))) {
                    this.setTagList();
                    this.setSelect2Records();
                } else {
                    this.render();
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * @override
     */
    bindDomChange: function() {
        // Borrowed from team set
        var $el = this.$(this.appendTagInput);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTagValue = $el.prop('checked');
                this.model.set('tag_type', this.appendTagValue ? '1' : '0');
            }, this));
        }
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        // This line is likewise borrowed from team set
        this.$(this.appendTagInput).off();
        this.$('.select2field').select2('destroy');
        this._super('unbindDom');
    }

}) },
"file": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FileField
 * @alias SUGAR.App.view.fields.BaseFileField
 * @extends View.Fields.Base.BaseField
 */
({
	// File Field (base) 

    fieldTag: 'input[type=file]',
    supportedImageExtensions: {
        'image/jpeg': 'jpg',
        'image/png': 'png',
        'image/gif': 'gif'
    },
    events: {
        'click [data-action=download]': 'startDownload',
        'click [data-action=delete]': 'deleteFile'
    },
    fileUrl: '',
    plugins: ['File', 'FieldDuplicate', 'EllipsisInline'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME: This needs an API instead. SC-3369 should address this.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        if (this.model) {
            this.model.addValidationTask('file_upload_' + this.cid, _.bind(this._doValidateFile, this));
        }
    },

    /**
     * Validator for the file field. If the field is required and has no value,
     * it will fail validation prior to performing a file upload. If there is a
     * value, it will perform a file upload to the temporary folder (required in
     * order to test uploads for files that are potentially larger than
     * `upload_max_filesize` in php.ini).
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     */
    _doValidateFile: function(fields, errors, callback) {
        var fieldName = this.name,
            $field = this.$(this.fieldTag);

        if ($field.length === 0) {
            callback(null, fields, errors);
            return;
        }

        var val = $field.val();
        if (_.isEmpty(val)) {
            if (this.def.required) {
                errors[fieldName] = errors[fieldName] || {};
                errors[fieldName].required = true;
            }
            callback(null, fields, errors);
            return;
        }

        var ajaxParams = {
            temp: true,
            iframe: true,
            deleteIfFails: false,
            htmlJsonFormat: true
        };

        app.alert.show('upload', {
            level: 'process',
            title: app.lang.get('LBL_UPLOADING'),
            autoclose: false
        });

        this.model.uploadFile(fieldName, $field, {
            success:_.bind(this._doValidateFileSuccess, this, fields, errors, callback),
            error:_.bind(this._doValidateFileError, this, fields, errors, callback)
        }, ajaxParams);
    },

    /**
     * Success callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(fields, errors, callback, data) {
        app.alert.dismiss('upload');

        var guid = data.record && data.record.id;
        if (!guid) {
            app.logger.error('Temporary file uploaded has no GUID.');
            this._doValidateFileError(fields, errors, callback, data);
            return;
        }

        var fieldName = this.name;
        // Add the guid to the list of fields to set on the model.
        if (!this.model.fields[fieldName + '_guid']) {
            this.model.fields[fieldName + '_guid'] = {
                type: 'file_temp',
                group: fieldName
            };
        }
        this.model.set(fieldName + '_guid', guid);

        // Update filename of the model with the value from response,
        // since it may have been modified on the server side
        this.model.set(fieldName, data.record[fieldName]);

        callback(null, fields, errors);
    },

    /**
     * Error callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} resp Error object returned from the API.
     */
    _doValidateFileError: function(fields, errors, callback, resp) {
        app.alert.dismiss('upload');

        var errors = errors || {},
            fieldName = this.name;
        errors[fieldName] = {};

        switch (resp.error) {
            case 'request_too_large':
                errors[fieldName].tooBig = true;
                break;
            default:
                errors[fieldName].uploadFailed = true;
        }
        this.model.unset(fieldName + '_guid');
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // Remove specific validation task from the model.
        this.model.removeValidationTask('file_upload_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Handler for delete file control
     *
     * Calls api to remove attached file from the model and
     * clear value and shows input[type=file] to upload new file
     * @param {Event} e
     */
    deleteFile: function(e) {
        var self = this;

        if (this.model.isNew()) {
            this.model.unset(this.name);
            if (this.disposed) {
                return;
            }
            this.render();
            return;
        }

        app.alert.show('delete_file_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_FILE_DELETE_CONFIRM', self.module),
            onConfirm: function() {
                var data = {
                        module: self.module,
                        id: self.model.id,
                        field: self.name
                    },
                    callbacks = {
                        success: function() {
                            self.model.set(self.name, '');
                            self.model.save({}, {
                                //Show alerts for this request
                                showAlerts: {
                                    'process': true,
                                    'success': {
                                        messages: app.lang.get('LBL_FILE_DELETED', self.module)
                                    }
                                },
                                fields: [self.name]
                            });
                            if (self.disposed) {
                                return;
                            }
                            // Because delete button is enabled in edit mode only and
                            // bindDataChange is overrided to prevent rendering field
                            // in edit mode call render method manually
                            self.render();
                        },
                        error: function(data) {
                            // refresh token if it has expired
                            app.error.handleHttpError(data, {});
                        }
                    };
                app.api.file('delete', data, null, callbacks, {htmlJsonFormat: false});
            }
        });
    },

    /**
     * @inheritdoc
     */
    setMode: function(name) {
        if (!_.isEmpty(this._errors)) {
            if (this.action === 'edit') {
                this.clearErrorDecoration();
                this.decorateError(this._errors);
                return;
            }
        }

        this._super('setMode', [name]);
    },

    /**
     * @inheritdoc
     *
     * Override field templates for merge-duplicate view.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.name === 'merge-duplicates') {
            this.template = app.template.getField(this.type,
                'merge-duplicates-' + this.tplName,
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}.
     */
    onFieldDuplicate: function() {
        if (this.disposed ||
            this.view.name !== 'merge-duplicates' ||
            this.options.viewName !== 'edit'
        ) {
            return;
        }
        this.render();
    },

    _render: function() {
        // This array will contain objects accessible in the view
        this.model = this.model || this.view.model;
        app.view.Field.prototype._render.call(this);
        return this;
    },
    format: function(value) {
        var attachments = [];
        // Not the same behavior either the value is a string or an array of files
        if (_.isArray(value)) {
            // If it's an array, we get the uri for each files in the response
            _.each(value, function(file) {
                var fileObj = {
                    name: file.name,
                    url: this.formatUri(file.uri)
                };
                attachments.push(fileObj);
            }, this);
        } else if (value) {
            // If it's a string, build the uri with the api library
            var urlOpts = {
                    module: this.module,
                    id: this.model.id,
                    field: this.name
                },
                fileObj = this._createFileObj(value, urlOpts);
            attachments.push(fileObj);
        }
        // Cannot be a hard check against "list" since subpanel-list needs this too
        return attachments;
    },

    /**
     * Creates a file object
     * @param {string} value The file name
     * @param {Object} urlOpts URL options
     * @return {Object} The created file object
     * @return {string} return.name The file name
     * @return {string} return.docType The document type
     * @return {string} return.mimeType The file's MIME type
     * @return {string} return.url The file resource url
     * @private
     */
    _createFileObj: function (value, urlOpts) {
        var isImage = this._isImage(this.model.get('file_mime_type')),
            forceDownload = !isImage,
            mimeType = isImage ? 'image' : '',
            docType = this.model.get('doc_type');
        return {
            name: value,
            mimeType: mimeType,
            docType: docType,
            url: app.api.buildFileURL(urlOpts,
                {
                    htmlJsonFormat: false,
                    passOAuthToken: false,
                    cleanCache: true,
                    forceDownload: forceDownload
                })
        };
    },

    /**
     * This is overridden by portal in order to prepend site url
     * @param {String} uri
     * @return {string} formatted uri
     */
    formatUri: function(uri) {
        return uri;
    },

    startDownload: function(e) {
        var uri = this.$(e.currentTarget).data('url');

        app.api.fileDownload(uri, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     *
     * Overrides `change` event for file field.
     * We should call `render` method when change event is triggered if:
     * 1. it is not duplicate-merge view and field isn't in edit mode. If it is
     * in edit mode we cannot set a value of a type `file` input.
     * 2. it is duplicate-merge view and field is in edit mode. Because
     * for this view we display file field as label (not input[type=file])
     * in edit mode we should update view on change.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.model.on('change:' + this.name, function() {
            // Clear any errors on the field if we are changing the value.
            this._errors = {};
            this.clearErrorDecoration();
            if (_.isUndefined(this.options.viewName) || this.options.viewName !== 'edit') {
                this.render();
            }
            // check if other fields want use the name of the file
            if (!_.isUndefined(this.def.populate_list)) {
                _.each(this.def.populate_list, function(field) {
                    if (!this.model.get(field) && app.acl.hasAccessToModel('edit', this.model, field)) {
                        this.model.set(field, this.model.get(this.name));
                    }
                }, this);
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Because input file uses full local path to file as value,
     * value can contains directory names.
     * Unformat value to have file name only in it.
     */
    unformat: function (value) {
        return value.split('/').pop().split('\\').pop();
    },

    /**
     * Check if input mime type is an image or not.
     *
     * @param {String} mime type.
     * @return {Boolean} true if mime type is an image.
     * @private
     */
    _isImage: function(mimeType) {
        return !!this.supportedImageExtensions[mimeType];
    }
}) },
"rowactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsField
 * @alias SUGAR.App.view.fields.BaseRowactionsField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Rowactions Field (base) 

    extendsFrom: 'ActiondropdownField',

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        //FIXME: SC-3372 Actions should not be based on `this.view.action`

        // check to see if this is a create subpanel
        var isCreate = this.context.get('isCreateSubpanel') || false,
            shouldHide = (this.view.action === 'list' && this.action === 'edit');
        // if this is a create subpanel, trump other logic as rowactions needs to be shown on edit
        if (isCreate || !shouldHide) {
            this.show();
        } else {
            this.hide();
        }
    }
}) },
"module": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ModuleField
 * @alias SUGAR.App.view.fields.BaseModuleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Module Field (base) 

    format: function(value){
        value = app.lang.getModuleName(value, {plural: true});
        return value;
    }
}) },
"follow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FollowField
 * @alias SUGAR.App.view.fields.BaseFollowField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Follow Field (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        'click [data-event="list:follow:fire"]': 'toggleFollowing'
    },

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.format();
    },
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:following", this.resetLabel, this);
        }

        // when the record is marked as favorite, it is subsequently followed by the current user (on server-side)
        // need to sync the client-side model, so an event is fired on the context from the favorite field upon success
        // set following on the model so we don't have to make a server request to get the latest value
        this.model.on("favorite:active", function() {
            this.model.set("following", true);
        }, this);
    },
    /**
     * Set current label and value since the follow button relates to the following
     *
     * @param value
     */
    format: function(value) {
        value = this.model.get("following");

        //For record view, the label should be diffent from other views
        //It also needs to have mouseover handlers for updating text
        if(this.tplName === "detail") {
            var label = value ? "LBL_FOLLOWING" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        } else {
            var label = value ? "LBL_UNFOLLOW" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        }
        return value;
    },
    /**
     * Reset label and triggers "show" handler to update parent controller dom
     */
    resetLabel: function() {
        this.render();
        //It should trigger the handler "show" to update parent controller
        //i.e. actiondropdown
        this.trigger("show");
    },
    unbindDom: function() {
        this.$("[data-hover=true]").off();
        this._super("unbindDom");
    },
    _render: function () {
        var module, mouseoverText, mouseoverClass, self = this;

        module = app.metadata.getModule(this.model.module);
        if (!module.activityStreamEnabled) {
            this.hide();
        } else {
            this._super("_render");

            if (this.tplName !== "detail") {
                return;
            }

            if (this.model.get("following")) {
                mouseoverText = app.lang.get("LBL_UNFOLLOW");
                mouseoverClass = "label-important";
            } else {
                mouseoverText = app.lang.get("LBL_FOLLOW");
                mouseoverClass = "label-success";
            }

            this.$("[data-hover=true]").on("mouseover",function () {
                $(this).text(mouseoverText).attr("class", "label").addClass(mouseoverClass);
            }).on("mouseout", function () {
                    var kls = self.model.get("following") ? "label-success" : "";
                    $(this).text(self.label).attr("class", "label").addClass(kls);
                });
        }
    },
    /**
     * Call REST API for subscribe and unsubscribe
     *
     * @param {Event} event The `click` event.
     */
    toggleFollowing: function(event) {
        var isFollowing = this.model.get("following");

        if(!_.isUndefined(isFollowing)) {
            var options = {
                alerts: false
            };
            if (this.model.follow(!isFollowing, options) === false) {
                app.logger.error('Unable to follow "' + this.model.module + '" record "' + this.model.id);
                return;
            }
        }
    }
}) },
"participants": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ParticipantsField is a field for Meetings/Calls that manages the invitees of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ParticipantsField
 * @alias SUGAR.App.view.fields.BaseParticipantsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Participants Field (base) 

    fieldTag: 'input.select2',

    plugins: ['EllipsisInline', 'SearchForMore', 'Tooltip'],

    events: {
        'click button[data-action=addRow]': 'addRow',
        'click button[data-action=removeRow]:not(.disabled)': 'removeRow',
        'click button[data-action=previewRow]:not(.disabled)': 'previewRow',
        'click button[data-action=show-more]': 'showMore'
    },

    placeholder: 'LBL_SEARCH_SELECT',

    // Number of hours before the meeting start datetime that will be the beginning
    // of the free/busy schedule timeline.
    timelineStart: 4,
    // Number of hours to display on free/busy schedule timeline.
    timelineLength: 9,
    // Regular Expression that parses module and ID from url
    moduleAndIdParserRegExp: new RegExp('/v\\d+/([^/]+)/([^/]+)/freebusy'),

    /**
     * @inheritdoc
     *
     * View.Fields.Base.ParticipantsField#placeholder can be overridden via
     * options.
     *
     * Adds a delay to the View.Fields.Base.ParticipantsField#addRow,
     * View.Fields.Base.ParticipantsField#removeRow,
     * View.Fields.Base.ParticipantsField#previewRow, and
     * View.Fields.Base.ParticipantsField#search methods so that these event
     * handlers do not execute too frequently.
     */
    initialize: function(options) {
        var fieldValue;

        this._super('initialize', [options]);

        // translate the placeholder
        this.placeholder = app.lang.get(this.def.placeholder || this.placeholder, this.module);

        this.addRow = _.debounce(this.addRow, 200);
        this.removeRow = _.debounce(this.removeRow, 200);
        this.previewRow = _.debounce(this.previewRow, 200);
        this.search = _.debounce(this.search, app.config.requiredElapsed || 500);

        if (this.model.isNew()) {
            try {
                fieldValue = this.getFieldValue();
            } catch (e) {
                // create a new virtual collection
                this.model.set(this.name, []);
            }
        }

        // get template for timeline header
        this.timelineHeaderTemplate = app.template.getField(this.type, 'timeline-header.partial', this.module);

        // get template for search result formatting
        this.searchResultTemplate = app.template.getField(this.type, 'search-result.partial', this.module);

        // caches the string "More {{field label}}..." for use in the template
        this.showMoreTemplate = app.lang.get('LBL_SHOW_MORE_GENERIC', this.module, {name: this.label});

        // adjust the start and end date/time indicator on the scheduler to fit the resized window
        $(window).on('resize.' + this.cid, _.bind(this.adjustStartAndEnd, this));
    },

    /**
     * @inheritdoc
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * Returns the collection stored for this field.
     *
     * @throws An exception when the value is not a collection
     * @return {VirtualCollection}
     */
    getFieldValue: function() {
        var value = this.model.get(this.name);

        if (!(value instanceof app.BeanCollection)) {
            throw 'the value must be a BeanCollection';
        }

        return value;
    },

    /**
     * @inheritdoc
     *
     * Renders the field anytime the collection is changed. Updates the
     * scheduler UI anytime the start date or end date changes on the model.
     * Attempts to hide the show more button anytime the collection is
     * synchronized.
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, this.render, this);
        this.model.on('change:date_start', function() {
            this.clearFreeBusyInformationCache();
            this.renderTimelineInfo();
        }, this);
        this.model.on('change:date_end', this.adjustStartAndEnd, this);
        this.model.on('sync:' + this.name, this.hideShowMoreButton, this);

        // Fetch free/busy information again on save to get the latest.
        this.model.on('sync', function() {
            this.clearFreeBusyInformationCache();
            this.fetchFreeBusyInformation();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Adds the selected record to the collection.
     */
    bindDomChange: function() {
        var onChange = _.bind(function(event) {
            try {
                this.getFieldValue().add(event.added.attributes);
            } catch (e) {
                app.logger.warn(e);
            }
        }, this);

        this.getFieldElement().on('change', onChange);
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this._super('unbindDom');
        this.getFieldElement().select2('destroy');
    },

    /**
     * @inheritdoc
     *
     * @chainable
     * @private
     */
    _render: function() {
        var $el;

        this._super('_render');

        $el = this.getFieldElement();
        $el.select2({
            allowClear: false,
            formatInputTooShort: '',
            formatSearching: app.lang.get('LBL_LOADING', this.module),
            formatResult: _.bind(this.formatSearchResult, this),
            minimumInputLength: 1,
            query: _.bind(this.search, this),
            selectOnBlur: false
        });
        this.addSearchForMoreButton($el);

        this._renderWithNewRow();

        this.renderTimelineInfo();

        this.hideShowMoreButton();

        return this;
    },

    /**
     * Called by {@link #_render} to handle the visibility of the new
     * participant row during rendering of the field.
     *
     * The select2 widget is hidden by default and never shown unless in edit
     * mode. The select2 widget is shown after render if in edit mode and the
     * collection is empty.
     *
     * If the select2 widget is shown, the delete button is disabled to prevent
     * users from deleting the row and putting the field in a state where new
     * participants cannot be added without re-rendering.
     */
    _renderWithNewRow: function() {
        var value;

        this.$('[name=newRow]').hide();

        if (this.action !== 'edit') {
            return;
        }

        try {
            value = this.getFieldValue();

            if (value.length === 0) {
                this.addRow();
                this.$('button[data-action=removeRow]').addClass('disabled');
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Render timeline header, meeting start and end lines, and fill in busy
     * schedule timeslots.
     */
    renderTimelineInfo: function() {
        var startAndEndDates = this.getStartAndEndDates();

        if ((this.getTimelineBlocks().length > 0) && (!_.isEmpty(startAndEndDates))) {
            this.renderTimelineHeader();
            this.adjustStartAndEnd();
            this.fetchFreeBusyInformation();
        }
    },

    /**
     * Render timeline header. It begins 4 hours before the meeting start datetime
     * and ends 5 hours after.
     */
    renderTimelineHeader: function() {
        var timelineHeader = [],
            startAndEndDates = this.getStartAndEndDates(),
            timeFormat,
            timelineStart;

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        timeFormat = this.getTimeFormat();
        timelineStart = startAndEndDates.timelineStart;

        for (var index = 0; index < this.timelineLength; index++) {
            timelineHeader.push({
                hour: timelineStart.format(timeFormat),
                alt: (index % 2 === 0)
            });
            timelineStart.add('hours', 1);
        }

        this.$('[data-render=timeline-header]').html(this.timelineHeaderTemplate(timelineHeader));
    },

    /**
     * Get the time display format for timeline header.
     * @return {string}
     */
    getTimeFormat: function() {
        var timeFormat = app.date.getUserTimeFormat(),
            hourFormat = timeFormat.charAt(0),
            meridiem = '';

        if (hourFormat === 'h') {
            meridiem = timeFormat.substr(-1, 1);
        }

        return (hourFormat + meridiem);
    },

    /**
     * Adjust the start and end overlay on the timeline for all users.
     */
    adjustStartAndEnd: function() {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineBlockStartIndex, //index of timeline block when the meeting starts
            timelineBlockEndIndex, //index of timeline block when the meeting ends
            $timelineBlocks, //all timeline blocks in a given timeline
            $startBlock, //timeline block when the meeting starts
            $endBlock, //timeline block when the meeting ends
            overlayLeft, //left position of the overlay
            overlayWidth = 1, //width of the overlay
            $startEndOverlays = this.$('.start_end_overlay'), //all overlays
            firstUserOverlay, //first user overlay
            firstUserData; //first user module and ID

        if (_.isEmpty(startAndEndDates) || ($startEndOverlays.length === 0)) {
            return;
        }

        // Get timeline blocks that represents the start and end datetime for the meeting
        firstUserOverlay = $startEndOverlays.first();
        firstUserData = firstUserOverlay.closest('.participant').data();
        $timelineBlocks = this.getTimelineBlocks(firstUserData.module, firstUserData.id);
        timelineBlockStartIndex = startAndEndDates.meetingStart.diff(startAndEndDates.timelineStart, 'hours', true) * 4;
        timelineBlockEndIndex = (startAndEndDates.meetingEnd.diff(startAndEndDates.timelineStart, 'hours', true) * 4) - 1;
        $startBlock = $timelineBlocks.eq(timelineBlockStartIndex);
        $endBlock = $timelineBlocks.eq(timelineBlockEndIndex);

        if ($endBlock.length === 0) {
            $endBlock = $timelineBlocks.last();
            $startEndOverlays.removeClass('right_border');
        } else {
            $startEndOverlays.addClass('right_border');
        }

        // calculate the left position of the overlay
        overlayLeft = $startBlock.position().left;

        // calculate the width of the overlay for meetings that last more than 0 minutes
        if (timelineBlockEndIndex - timelineBlockStartIndex >= 0) {
            // Note: Need to use getBoundingClientRect() so that we can get subpixel measurements.
            overlayWidth = $endBlock.position().left - overlayLeft + $endBlock.get(0).getBoundingClientRect().width;
            // subtract left and right border width
            overlayWidth -= parseInt(firstUserOverlay.css('border-left-width'), 10) + parseInt(firstUserOverlay.css('border-right-width'), 10);
        }

        $startEndOverlays.css({
            left: overlayLeft + 'px',
            width: overlayWidth + 'px'
        });
    },

    /**
     * Fetch schedules for Users.
     */
    fetchFreeBusyInformation: function() {
        var self = this,
            requests = [],
            startAndEndDates = this.getStartAndEndDates(),
            participants = this.getFieldValue();

        if (this.freebusy.isFetching() || _.isEmpty(startAndEndDates)) {
            return;
        }

        participants.each(function(participant) {
            var url,
                freeBusyFromCache,
                moduleName = participant.module,
                id = participant.get('id');

            if (moduleName === 'Users') {
                freeBusyFromCache = self.getFreeBusyInformationFromCache(moduleName, id);

                if (freeBusyFromCache) {
                    self.fillInFreeBusyInformation(freeBusyFromCache);
                } else {
                    url = app.api.buildURL(moduleName, 'freebusy', {id: id}, {
                        start: startAndEndDates.timelineStart.formatServer(),
                        end: startAndEndDates.timelineEnd.formatServer()
                    });
                    requests.push({
                        url: url.substring(4) //need to remove "rest" from the URL to be compatible with the bulk API
                    });

                    self.showLoadingOnTimeline(moduleName, id);
                }
            }
        });

        this.freebusy.fetch(requests, {
            success: function(data) {
                if (!self.disposed) {
                    _.each(data, function(response) {
                        self.fillInFreeBusyInformation(response.contents);
                    });
                }
            },
            error: function() {
                app.logger.warn('Error received from server while retrieving free/busy information.');
                app.alert.show('freebusy-error', {
                    level: 'warning',
                    autoClose: true,
                    messages: 'LBL_ERROR_RETRIEVING_FREE_BUSY'
                });
            },
            complete: function(request) {
                var data;
                if (!self.disposed && request.params.data) {
                    data = JSON.parse(request.params.data);
                    _.each(data.requests, function(requestData) {
                        var moduleAndId = self.parseModuleAndIdFromUrl(requestData.url);
                        self.hideLoadingOnTimeline(moduleAndId.module, moduleAndId.id);
                    });
                }
            }
        });
    },

    freebusy: (function() {
        var fetching = false;

        return {
            /**
             * Calls the bulk api to make multiple free/busy GET requests in a single call.
             * @param {Array} requests
             * @param {Object} options
             */
            fetch: function(requests, options) {
                var self = this;
                if (!_.isEmpty(requests)) {
                    options.complete = _.wrap(options.complete, function(func, request) {
                        func(request);
                        self.isFetching(false);
                    }, this);
                    app.api.call('create', app.api.buildURL(null, 'bulk'), {requests: requests}, options);
                    this.isFetching(true);
                }
            },

            /**
             * Is it currently in the process of fetching?
             * @param {boolean} [isFetching] Set whether or not it is currently fetching
             * @return {boolean}
             */
            isFetching: function(isFetching) {
                if (_.isUndefined(isFetching)) {
                    return fetching;
                } else {
                    fetching = isFetching;
                }
            }
        }
    })(),

    /**
     * Fill in the busy slots on the timeline.
     * @param {Object} scheduleInfo - free/busy info from the server
     */
    fillInFreeBusyInformation: function(scheduleInfo) {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineStart = startAndEndDates.timelineStart,
            timelineEnd = startAndEndDates.timelineEnd;

        if (!scheduleInfo || _.isEmpty(startAndEndDates)) {
            return;
        }

        this.cacheFreeBusyInformation(scheduleInfo);
        this.getTimelineBlocks(scheduleInfo.module, scheduleInfo.id).removeClass('busy');

        _.each(scheduleInfo.freebusy, function(busy) {
            var busyStartDate = app.date(busy.start),
                busyEndDate = app.date(busy.end);

            if (busyStartDate.isBefore(timelineEnd) && !busyEndDate.isBefore(timelineStart)) {
                this.setAsBusy(busy, scheduleInfo.module, scheduleInfo.id);
            }
        }, this);
    },

    /**
     * Mark the timeslot as busy.
     * @param {Object} busy - start and end datetime that should be marked as busy
     * @param {string} moduleName
     * @param {string} id
     */
    setAsBusy: function(busy, moduleName, id) {
        var startAndEndDates = this.getStartAndEndDates(),
            busyStartDate = app.date(busy.start),
            busyEndDate = app.date(busy.end),
            diffInHours,
            $timelineBlocks = this.getTimelineBlocks(moduleName, id);

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        // To optimize, we set the busyStartDate as the beginning of the timeline.
        if (busyStartDate.isBefore(startAndEndDates.timelineStart)) {
            busyStartDate = app.date(startAndEndDates.timelineStart);
        }

        while (busyStartDate.isBefore(busyEndDate) && busyStartDate.isBefore(startAndEndDates.timelineEnd)) {
            diffInHours = busyStartDate.diff(startAndEndDates.timelineStart, 'hours', true);

            if (diffInHours >= 0) {
                $timelineBlocks.eq(diffInHours * 4).addClass('busy');
            }

            busyStartDate.add('minutes', 15);
        }
    },

    /**
     * Get timeline start and end datetime and meeting start and end datetimes.
     * Returns empty object if the meeting start and end datetimes are invalid.
     * @return {Object}
     */
    getStartAndEndDates: function() {
        var dateStartString = this.model.get('date_start'),
            dateEndString = this.model.get('date_end'),
            durationHours = this.model.get('duration_hours'),
            durationMins = this.model.get('duration_minutes'),
            meetingStart,
            meetingEnd,
            result = {};

        // must have date_start, but if we don't have date_end we need to have at least
        // duration_hours or duration_minutes to judge an end time
        if (!dateStartString ||
            (!dateEndString && !(_.isFinite(durationHours) || _.isFinite(durationMins)))) {
            return result;
        }

        meetingStart = app.date(dateStartString);

        // if we don't have the date_end string, create it from the duration times
        if (dateEndString) {
            meetingEnd = app.date(dateEndString);
        } else {
            meetingEnd = app.date(meetingStart)
                .add(durationHours || 0, 'hours')
                .add(durationMins || 0, 'minutes');
        }


        if (!meetingStart.isAfter(meetingEnd)) {
            result.meetingStart = meetingStart;
            result.meetingEnd = meetingEnd;
            result.timelineStart = app.date(meetingStart).subtract(this.timelineStart, 'hours').minutes(0);
            result.timelineEnd = app.date(result.timelineStart).add(this.timelineLength, 'hours').minutes(0);
        }

        return result;
    },

    /**
     * Get timeline timeslots for a given module and ID. If moduleName and ID are
     * not specified, return timeslots for all timelines.
     * @param {string} moduleName (optional)
     * @param {string} id (optional)
     * @return {jQuery}
     */
    getTimelineBlocks: function(moduleName, id) {
        var selector;

        if (moduleName && id) {
            selector = '[data-module=' + moduleName + '][data-id=' + id + ']';
        } else {
            selector = '.participant';
        }

        selector += ' .times .timeblock span';

        return this.$(selector);
    },

    /**
     * Cache free/busy data received from the server.
     * @param {Object} data - the free/busy data from the server
     */
    cacheFreeBusyInformation: function(data) {
        if (_.isUndefined(this._freeBusyCache)) {
            this._freeBusyCache = [];
        } else {
            this._freeBusyCache = _.reject(this._freeBusyCache, function(freebusy) {
                return (freebusy.id === data.id) && (freebusy.module === data.module);
            });
        }

        this._freeBusyCache.push(data);
    },

    /**
     * Get free/busy data from cache.
     * @param {string} moduleName
     * @param {string} id
     * @return {Object}
     */
    getFreeBusyInformationFromCache: function(moduleName, id) {
        return _.findWhere(this._freeBusyCache, {
            module: moduleName,
            id: id
        });
    },

    /**
     * Clear free/busy data cache.
     */
    clearFreeBusyInformationCache: function() {
        this._freeBusyCache = [];
    },

    /**
     * Show loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    showLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .addClass('loading')
            .find('[data-toggle=loading]')
            .removeClass('hide');
    },

    /**
     * Hide loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    hideLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .removeClass('loading')
            .find('[data-toggle=loading]')
            .addClass('hide');
    },

    /**
     * Get module name and ID from URL.
     * @param {string} url
     * @return {Object}
     */
    parseModuleAndIdFromUrl: function(url) {
        var moduleAndId = {},
            parsed = this.moduleAndIdParserRegExp.exec(url);

        if (parsed) {
            moduleAndId.module = parsed[1];
            moduleAndId.id = parsed[2];
        }

        return moduleAndId;
    },

    /**
     * @inheritdoc
     *
     * Converts the models found in the collection to ones that can be used in
     * the templates.
     *
     * @param {VirtualCollection} value
     * @return {Object} Array of models with view properties defined
     * @return {string} return.accept_status The translated string
     * indicating the model's accept status
     * @return {string} return.accept_class The CSS class representing
     * the model's accept status per Twitter Bootstrap's label component
     * @return {string} return.avatar The URL where the model's avatar
     * can be downloaded or undefined if one does not exist
     * @return {boolean} return.deletable Whether or not the model can
     * be removed from the collection
     * @return {boolean} return.last Whether or not the model is the
     * last one in the collection
     * @return {Object} return.preview Preview information for model
     * @return {boolean} return.preview.enabled Whether or not preview
     * is enabled for the model
     * @return {string} return.preview.label The tooltip to be shown for
     * the model when hovering over the preview button
     */
    format: function(value) {
        var acceptStatus, acceptStatusFieldName, deletable, i, preview, rows, self;

        self = this;

        acceptStatusFieldName = 'accept_status_' + this.module.toLowerCase();
        acceptStatus = function(participant) {
            var status = {};

            switch (participant.get(acceptStatusFieldName)) {
                case 'accept':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_ACCEPT';
                    status.css_class = 'success';
                    break;
                case 'decline':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_DECLINE';
                    status.css_class = 'important';
                    break;
                case 'tentative':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_TENTATIVE';
                    status.css_class = 'warning';
                    break;
                default:
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_NONE';
                    status.css_class = '';
            }

            return status;
        };

        deletable = function(participant) {
            if (participant.deletable === false) {
                return false;
            }

            return participant.id !== self.model.get('assigned_user_id');
        };

        preview = function(participant) {
            var isBwc, moduleMetadata, preview;

            isBwc = false;
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            };

            moduleMetadata = app.metadata.getModule(participant.module);
            if (moduleMetadata) {
                isBwc = moduleMetadata.isBwcEnabled;
            }

            if (isBwc) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
            } else if (_.isEmpty(participant.module) || _.isEmpty(participant.id)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
            } else if (!app.acl.hasAccess('view', participant.module)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
            }

            return preview;
        };

        try {
            i = 1;
            rows = value.length;
            value = value.map(function(participant) {
                var attributes;

                attributes = {
                    accept_status: acceptStatus(participant),
                    deletable: deletable(participant),
                    last: (rows === i++),
                    name: app.utils.getRecordName(participant),
                    preview: preview(participant),
                    module: participant.module
                };

                if (!_.isEmpty(participant.get('picture'))) {
                    attributes.avatar = app.api.buildFileURL({
                        module: participant.module,
                        id: participant.id,
                        field: 'picture'
                    });
                }

                return _.extend(attributes, participant.attributes);
            });
        } catch (e) {
            app.logger.warn(e);
            value = [];
        }

        return value;
    },

    /**
     * Displays the search and select to add a new participant.
     *
     * Hides the [+] button.
     *
     * @param {Event} [event]
     */
    addRow: function(event) {
        this.$('.participants-schedule').addClass('new');
        this.$('[name=newRow]').css('display', 'table-row');

        if (event) {
            $(event.currentTarget).hide();
        }

        this.getFieldElement().select2('open');
        this.adjustStartAndEnd();
    },

    /**
     * Removes the row where the [-] button was clicked.
     *
     * The participant is removed from the collection if it is an participant
     * row. Otherwise, the search and select row is hidden and the [+] is shown
     * again.
     *
     * @param {Event} event
     */
    removeRow: function(event) {
        var id, participants;

        id = $(event.currentTarget).data('id');

        if (id) {
            try {
                participants = this.getFieldValue();
                participants.remove(participants.get(id));
            } catch (e) {
                app.logger.warn(e);
            }
        } else {
            this.$('[name=newRow]').hide();
            this.$('button[data-action=addRow]').show();
            this.$('.participants-schedule').removeClass('new');
            this.adjustStartAndEnd();
        }
    },

    /**
     * Shows or hides the preview of the participant.
     *
     * @param {Event} event
     */
    previewRow: function(event) {
        var data, model, success;

        success = _.bind(function(model) {
            model.module = data.module;
            app.events.trigger('preview:render', model);
        }, this);

        data = $(event.currentTarget).data();
        if (data && data.module && data.id) {
            model = app.data.createBean(data.module, {id: data.id});
            model.fetch({
                showAlerts: true,
                success: success
            });
        }
    },

    /**
     * Loads the next set of participants.
     *
     * The new participants will be rendered once they are added to the
     * collection.
     *
     * @param {Event} event
     */
    showMore: function(event) {
        var options;

        options = {
            fields: this._getRelatedFieldNames(),
            order_by: 'name:asc'
        };

        try {
            this.getFieldValue().paginate(options);
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Hides the pagination button if creating a new record -- because there is
     * no need for it -- or if the virtual collection indicates that there are
     * no additional participants to fetch.
     */
    hideShowMoreButton: function() {
        try {
            if (this.model.isNew() || !this.getFieldValue().hasMore()) {
                this.$('[data-action=show-more]').hide();
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Searches for more participants that match the query.
     *
     * Matches that already exist in the collection are suppressed. See
     * [Select2](http://ivaynberg.github.io/select2/) for documentation on
     * using the query function.
     *
     * Pagination is disabled.
     *
     * @param {Object} query
     * @param {string} query.term The search term
     * @param {Function} query.callback The callback where data should be
     * passed once it has been loaded
     */
    search: function(query) {
        var data, fields, participants, success;

        data = {
            results: [],
            more: false
        };

        success = function(result) {
            result.each(function(record) {
                var participant = participants.get(record.id);

                if (participant) {
                    app.logger.debug(record.module + '/' + record.id + ' is already in the collection');
                } else {
                    record.text = record.get('name');
                    data.results.push(record);
                }
            });
        };

        try {
            fields = _.union(
                // fields that are needed for the detail, edit, and preview templates
                this._getRelatedFieldNames(),
                // fields for which there may be a match to show
                ['full_name', 'first_name', 'last_name', 'email', 'account_name']
            );

            participants = this.getFieldValue();
            participants.search({
                query: query.term,
                success: success,
                search_fields: ['full_name', 'email', 'account_name'],
                fields: fields,
                complete: function() {
                    query.callback(data);
                }
            });
        } catch (e) {
            app.logger.warn(e);
            query.callback(data);
        }
    },

    /**
     * Returns an array of strings representing the names of related fields.
     *
     * The related fields are defined under `this.def.fields`. Some of these
     * fields may be objects, while others strings.
     *
     * @return {Array}
     * @private
     */
    _getRelatedFieldNames: function() {
        var fields = this.def.fields || [];

        if (fields.length === 0) {
            return [];
        }

        return _.map(fields, function(field) {
            return _.isObject(field) ? field.name : field;
        });
    },

    /**
     * Format the search result for display in select2 result list
     *
     * @param {Data.Bean} bean A bean result
     * @return {string}
     */
    formatSearchResult: function(bean) {
        var result = {
            module: bean.module,
            name: app.utils.getRecordName(bean)
        };

        _.each(bean.searchInfo.highlighted, function(field) {
            result.field_name = app.lang.get(field.label, field.module);
            result.field_value = field.text;
        });

        return this.searchResultTemplate(result);
    },

    /**
     * Remove resize event.
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview') {
            this.template = app.template.getField('participants', 'preview', this.model.module);
        }
    }
}) },
"badge-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeSelectField
 * @alias SUGAR.App.view.fields.BaseBadgeSelectField
 * @extends View.Fields.Base.EnumField
 */
({
	// Badge-select Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.view && this.view.layout) {
            this.view.layout.on('headerpane:adjust_fields', this.repositionDropdown, this);
        }
        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'important': 'label-important',
            'warning': 'label-warning',
            'pending': 'label-pending',
            'success': 'label-success',
            'info': 'label-info',
            'inverse': 'label-inverse',
            'unknown': 'label-unknown',
            'log': 'label-log'
        };
    },

    /**
     * Resets position of status dropdown if Select2 is active and open
     * and the position of the Select2 container is shifted, which happens
     * when other fields in the headerpane are hidden on status edit
     */
    repositionDropdown: function() {
        var $el = this.$(this.fieldTag).select2('container');

        if ($el.hasClass('select2-dropdown-open')) {
            this.$(this.fieldTag).data('select2').dropdown.css({'left': $el.offset().left});
        }
    },

    /**
     * @inheritdoc
     *
     * This field renders as a badge when not in edit mode and as an enum when
     * in edit mode.
     *
     * @private
     */
    _loadTemplate: function() {
        if (this.action === 'edit') {
            this.type = 'enum';
        }

        this._super('_loadTemplate');
        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     *
     * Convert model value to dropdown value based on key.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} the formatted value based on view name.
     */
    format: function(value) {
        this.statusClass = this.styleLabel(value);

        return value;
    },

    /**
     * Returns the appropriate CSS class on the label based on the value of the
     * status.
     *
     * It is a noop when the field is in edit mode.
     *
     * @param {string} status
     */
    styleLabel: function(status) {
        if (this.action === 'edit') {
            return;
        }
        if (this.action === 'disabled') {
            return 'label-disabled';
        }
        return this.statusClasses[status];
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.view && this.view.layout) {
            this.view.layout.off(null, null, this);
        }

        this._super('_dispose');
    }
}) },
"float": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FloatField
 * @alias SUGAR.App.view.fields.BaseFloatField
 * @extends View.Fields.Base.BaseField
 */
({
	// Float Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * Unformats the float based on userPreferences (grouping/decimal separator).
     * If we weren't able to parse the value, the original value is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|String} the unformatted value, or original string if invalid.
     */
    unformat: function(value) {
        var unformattedValue = app.utils.unformatNumberStringLocale(value);

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue) && this.def && this.def.precision) {
            unformattedValue = app.math.round(unformattedValue, this.def.precision, true);
        }
        // if unformat failed, return original value
        return _.isFinite(unformattedValue) ? unformattedValue : value;

    },

    /**
     * @inheritdoc
     *
     * Formats the float based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite float it will
     * return `undefined`.
     *
     * @param {Number} value the float value to format as per user preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        if (this.def.disable_num_format || _.isNull(value)|| _.isUndefined(value) || _.isNaN(value)) {
            return value;
        }

        var number_grouping_separator = app.user.getPreference('number_grouping_separator') || ',';
        var decimal_separator = app.user.getPreference('decimal_separator') || '.';

        if (_.isUndefined(this.def.precision) || !this.def.precision) {
            return app.utils.addNumberSeparators(
                value.toString(),
                number_grouping_separator,
                decimal_separator
            );
        }

        return app.utils.formatNumber(
            value,
            this.def.precision,
            this.def.precision,
            number_grouping_separator,
            decimal_separator
        );
    }
}) },
"badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeField
 * @alias SUGAR.App.view.fields.BaseBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Badge Field (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @inheritdoc
     *
     * The badge is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        app.view.Field.prototype.initialize.call(this, options);
    }
}) },
"parent": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ParentField
 * @alias SUGAR.App.view.fields.BaseParentField
 * @extends View.Fields.Base.RelateField
 */
({
	// Parent Field (base) 

    extendsFrom: 'RelateField',
    fieldTag: 'input.select2[name=parent_name]',
    typeFieldTag: 'select.select2[name=parent_type]',
    plugins: ['FieldDuplicate'],

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * A hash of available modules in the parent type dropdown matching
         * the modules names with their label.
         *
         * @property {Object}
         * @private
         */
        this._modules = app.lang.getAppListStrings(this.def.options);

        /**
         * The hash of available modules in the parent type dropdown, filtered
         * according to list acls.
         *
         * @property {Object}
         */
        this.moduleList = {};

        this._filterModuleList(this._modules);
    },

    /**
     * Calls {@link View.Fields.Base.RelateField#_render} and renders the select2
     * module dropdown.
     *
     * @inheritDoc
     */
    _render: function() {
        var self = this;
        var moduleName = this.getSearchModule();
        var module = _.pick(this._modules, moduleName);
        if (module && !app.acl.hasAccess('list', moduleName)) {
            this.noAccessModule = {key: moduleName, value: module[moduleName]};
        }

        this._super("_render");

        /**
         * Only allow modification of the select2 functionality under the specified templates
         */
        var allowedTpls = ['edit', 'massupdate'];
        if (_.contains(allowedTpls, this.tplName)) {
            var inList = (this.view.name === 'recordlist') ? true : false;

            this.$(this.typeFieldTag).select2({
                dropdownCssClass: inList?'select2-narrow':'',
                containerCssClass: inList?'select2-narrow':'',
                width: inList?'off':'100%',
                minimumResultsForSearch: 5
            }).on('change', function(e) {
                var module = e.val;
                if (self.noAccessModule && module !== self.noAccessModule) {
                    delete self.noAccessModule;
                }
                self.setValue({
                    id: '',
                    value: '',
                    module: module
                });
                self.$(self.fieldTag).select2('val', '');
            }).on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));

            var domParentTypeVal = this.$(this.typeFieldTag).val();
            if(this.model.get(this.def.type_name) !== domParentTypeVal) {
                this.model.setDefault(this.def.type_name, domParentTypeVal);
                this._createSearchCollection();
            }

            if(app.acl.hasAccessToModel('edit', this.model, this.name) === false) {
                this.$(this.typeFieldTag).select2("disable");
            } else {
                this.$(this.typeFieldTag).select2("enable");
            }
        } else if(this.tplName === 'disabled'){
            this.$(this.typeFieldTag).select2('disable');
        }
        return this;
    },
    _getRelateId: function() {
        return this.model.get("parent_id");
    },
    format: function(value) {
        var module;
        this.def.module = this.getSearchModule();

        if (this.def.module) {
            module = app.lang.getModuleName(this.def.module);
        }

        this.context.set('record_label', {
            field: this.name,
            label: (this.tplName === 'detail') ? module : app.lang.get(this.def.label, this.module)
        });

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            this._valueSetOnce = true;
        }

        setFromCtx = !value && !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            _.contains(_.keys(app.lang.getAppListStrings(this.def.parent_type)), parentCtx.get('module')) &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            // FIXME the setValue receives a model but not a backbone model...
            var attributes = model.toJSON();
            attributes.silent = true;
            this.setValue(attributes);
            value = this.model.get(this.name);

            // FIXME we need to iterate over the populated_ that isn't working now
        }

        return this._super('format', [value]);

    },

    /**
     * Enables or disables the module dropdown according to acls.
     *
     * @deprecated Since 7.7. Will be removed in 7.8.
     * @param {string} action The acl action.
     * @param {string} module the module to check access.
     */
    checkAcl: function(action, module) {
        app.logger.warn('checkAcl is deprecated, it will be removed in 7.8');
        if(app.acl.hasAccess(action, module) === false) {
            this.$(this.typeFieldTag).select2("disable");
        } else {
            this.$(this.typeFieldTag).select2("enable");
        }
    },

    /**
     * Filters the module list according to list acls.
     *
     * @param {Object} A hash of module names matching with their label.
     * @private
     */
    _filterModuleList: function(modules) {
        var filteredModules = _.filter(_.keys(modules), function(module) {
            return app.acl.hasAccess('list', module);
        });
        this.moduleList = _.pick(modules, filteredModules);
    },

    /**
     * @override
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        models = _.isArray(models) ? models : [models];
        _.each(models, _.bind(function(model) {

            var silent = model.silent || false,
            // FIXME we shouldn't make this assumption and this method should
            // receive a true Backbone.Model or Data.Bean
                module = model.module || model._module;


            if (app.acl.hasAccessToModel(this.action, this.model, this.name)) {
                if (module) {
                    this.model.set('parent_type', module, {silent: silent});
                    this._createSearchCollection();
                }
                // only set when we have an id on the model, as setting undefined
                // is causing issues with the warnUnsavedChanges() method
                if (!_.isUndefined(model.id)) {
                    this.model.set('parent_id', model.id, {silent: silent});
                    // FIXME we shouldn't rely on model.value... and hack the full_name here until we fix it properly
                    var value = model.value || model[this.def.rname || 'name'] || model['full_name'] ||
                        app.utils.formatNameLocale(model);
                    this.model.set('parent_name', value, {silent: silent});
                }
            }
        }, this));

        // TODO we should support the auto populate of other fields like we do on normal relate.js
    },
    /**
     * Is this module available as an option to be set as parent type?
     * @param module {string}
     * @return {boolean}
     */
    isAvailableParentType: function(module) {
        var moduleFound = _.find(this.$(this.typeFieldTag).find('option'), function(dom) {
            return $(dom).val() === module;
        });
        return !!moduleFound;
    },
    getSearchModule: function() {
        return this.model.get('parent_type') || this.$(this.typeFieldTag).val();
    },
    getPlaceHolder: function() {
        return  app.lang.get('LBL_SEARCH_SELECT', this.module);
    },
    unbindDom: function() {
        this.$(this.typeFieldTag).select2('destroy');
        this._super("unbindDom");
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        if (this.model) {
            this.model.on('change:parent_type', function() {
                var plugin = this.$(this.typeFieldTag).data('select2');
                if (_.isEmpty(plugin) || !plugin.searchmore) {
                    this.render();
                } else {
                    this.$(this.typeFieldTag).select2('val', this.model.get('parent_type'));
                }
            }, this);
        }
    },

    /**
     * Handler to refresh search collection when merging duplicates.
     *
     * Called from {@link app.plugins.FieldDuplicate#_onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (_.isEmpty(this.searchCollection) ||
            this.searchCollection.module !== this.getSearchModule()
        ) {
            this._createSearchCollection();
        }
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview') {
            this.template = app.template.getField('parent', 'detail', this.model.module);
        }
    }
}) },
"deleterecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DeleterecurrencesbuttonField is a field for Meetings/Calls for the ability to delete all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DeleterecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseDeleterecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Deleterecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     *  The field is hidden if event is not a recurring calendar event
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Renders the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for deleting all recurring calendar events of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        app.alert.show('delete_recurrence_confirmation', {
            title: app.lang.get('LBL_REMOVE_ALL_RECURRENCES', this.module),
            level: 'confirmation',
            messages: this.getDeleteMessages().confirmation,
            onConfirm: _.bind(this.deleteRecurrences, this)
        });
    },

    /**
     * Calls destroy on the model and makes api call to delete all recurring calendar events in a series.
     * Navigates to the list view on success.
     */
    deleteRecurrences: function() {
        this.model.destroy({
            params: {'all_recurrences': true},
            showAlerts: {
                'process': true,
                'success': {
                    messages: this.getDeleteMessages().success
                }
            },
            success: _.bind(function() {
                var route = '#' + this.module,
                    currentRoute = '#' + Backbone.history.getFragment();
                (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Formats the messages to display in the alerts when deleting recurrences.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = app.utils.getRecordName(model);
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name.trim();

        messages.confirmation = app.lang.get('LBL_CONFIRM_REMOVE_ALL_RECURRENCES', this.module);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    }
}) },
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.NameField
 * @alias SUGAR.App.view.fields.BaseNameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Name Field (base) 

    plugins: ['EllipsisInline', 'MetadataEventDriven'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;
    },

    _render: function() {
        // FIXME: This will be cleaned up by SC-3478.
        if (this.view.name === 'audit') {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = _.isUndefined(this.def.link) ? true : this.def.link;
            this.def.events = false;
        }
        this._super('_render');
    }
}) },
"html": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HtmlField
 * @alias SUGAR.App.view.fields.BaseHtmlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Html Field (base) 

    fieldSelector: '.htmlareafield', //iframe selector

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * The html area is always a readonly field.
     * (see htmleditable for an editable html field)
     */
    initialize: function(options) {
        options.def.readonly = true;
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Set the name of the field on the iframe as well as the contents
     *
     * @private
     */
    _render: function() {
        app.view.Field.prototype._render.call(this);

        this._getFieldElement().attr('name', this.name);
        this.setViewContent();
    },

    /**
     * Sets read only html content in the iframe
     */
    setViewContent: function(){
        var value = this.value || this.def.default_value;
        var field = this._getFieldElement();
        if(field && field.get(0) && !_.isEmpty(field.get(0).contentDocument)) {
            if(field.contents().find('body').length > 0){
                field.contents().find('body').html(value);
            }
        }
    },

    /**
     * Finds iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getFieldElement: function() {
        return this.$el.find(this.fieldSelector);
    }

}) },
"pdfaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PdfactionField
 * @alias SUGAR.App.view.fields.BasePdfactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Pdfaction Field (base) 

    extendsFrom: 'RowactionField',
    events: {
        'click [data-action=link]': 'linkClicked',
        'click [data-action=download]': 'downloadClicked',
        'click [data-action=email]': 'emailClicked'
    },

    /**
     * PDF Template collection.
     *
     * @type {Data.BeanCollection}
     */
    templateCollection: null,

    /**
     * Visibility property for available template links.
     *
     * @property {Boolean}
     */
    fetchCalled: false,

    /**
     * @inheritdoc
     * Create PDF Template collection in order to get available template list.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.templateCollection = app.data.createBeanCollection('PdfManager');
        this._fetchTemplate();
    },

    /**
     * @inheritdoc
     *
     * Prevents the "Email PDF" button from rendering if the user
     * doesn't have a valid email configuration or the user chooses to use an
     * external email client. RFC 2368 suggests only the "subject" and "body"
     * headers are safe headers and that other, unsafe headers do not need to
     * be supported by the "mailto" implementation. We cannot guarantee that
     * the "mailto" implementation for the user will allow for adding a PDF
     * attachment. To be consistent with existing application behavior, the
     * "Email PDF" option should be hidden for users when they cannot use the
     * internal email client.
     *
     * @private
     */
    _render: function() {
        var emailClientPreference = app.user.getPreference('email_client_preference');
        if (!this.templateCollection.length > 0 ||
            (this.def.action === 'email' && emailClientPreference.type !== 'sugar')) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Define proper filter for PDF template list.
     * Fetch the collection to get available template list.
     * @private
     */
    _fetchTemplate: function() {
        this.fetchCalled = true;
        var collection = this.templateCollection;
        collection.filterDef = {'$and': [{
            'base_module': this.module
        }, {
            'published': 'yes'
        }]};
        collection.fetch();
    },

    /**
     * Build download link url.
     *
     * @param {String} templateId PDF Template id.
     * @return {string} Link url.
     * @private
     */
    _buildDownloadLink: function(templateId) {
        var urlParams = $.param({
            'action': 'sugarpdf',
            'module': this.module,
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId
        });
        return '?' + urlParams;
    },

    /**
     * Build email pdf link url.
     *
     * @param {String} templateId PDF Template id.
     * @return {string} Email pdf url.
     * @private
     */
    _buildEmailLink: function(templateId) {
        return '#' + app.bwc.buildRoute(this.module, null, 'sugarpdf', {
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId,
            'to_email': '1'
        });
    },

    /**
     * Handle the button click event.
     * Stop event propagation in order to keep the dropdown box.
     *
     * @param {Event} evt Mouse event.
     */
    linkClicked: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        if (this.templateCollection.dataFetched) {
            this.fetchCalled = !this.fetchCalled;
        } else {
            this._fetchTemplate();
        }
        this.render();
    },

    /**
     * Handles email pdf link.
     *
     * @param {Event} evt Mouse event.
     */
    emailClicked: function(evt) {
        var templateId = this.$(evt.currentTarget).data('id');
        app.router.navigate(this._buildEmailLink(templateId), {
            trigger: true
        });
    },

    /**
     * Handles download pdf link.
     *
     * Authenticate in bwc mode before triggering the download.
     *
     * @param {Event} evt The `click` event.
     */
    downloadClicked: function(evt) {
        var templateId = this.$(evt.currentTarget).data('id');

        app.bwc.login(null, _.bind(function() {
            this._triggerDownload(this._buildDownloadLink(templateId));
        }, this));
    },

    /**
     * Download the file once authenticated in bwc mode.
     *
     * @param {String} url The file download url.
     * @protected
     */
    _triggerDownload: function(url) {
        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     * Bind listener for template collection.
     */
    bindDataChange: function() {
        this.templateCollection.on('reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     * Dispose safe for templateCollection listeners.
     */
    unbindData: function() {
        this.templateCollection.off(null, null, this);
        this.templateCollection = null;
        this._super('unbindData');
    },

    /**
     * @inheritdoc
     * Check additional access for PdfManager Module.
     */
    hasAccess: function() {
        var pdfAccess = app.acl.hasAccess('view', 'PdfManager');
        return pdfAccess && this._super('hasAccess');
    }
}) },
"datetimecombo-colorcoded": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DatetimecomboColorcodedField is a field for Meetings/Calls/Tasks that sets a background color for the field based on the value of the status field
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DatetimecomboColorcodedField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboColorcodedField
 * @extends View.Fields.Base.DatetimecomboField
 */
({
	// Datetimecombo-colorcoded Field (base) 

    extendsFrom: 'DatetimecomboField',

    colorCodeClasses: {
        overdue: 'label label-important',
        upcoming: 'label label-info'
    },

    /**
     * @inheritdoc
     *
     * Checks color code conditions to determine if field should have
     * color applied to it.
     */
    _render: function() {
        this.type = 'datetimecombo'; //use datetimecombo templates
        this._super('_render');
        this.setColorCoding();
    },

    /**
    * @inheritdoc
    *
    * Listen for status change - set color coding appropriately
    */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:status', this.setColorCoding, this);
    },

    /**
    * Set color coding based on completion status and date compared to today
    * This is only applied when the action is list (not inline edit on list view)
    */
    setColorCoding: function() {
        var colorCodeClass;

        this._clearColorCode();

        if (!this.model || this.action !== 'list') {
            return;
        }
        colorCodeClass = this._isCompletedStatus() ? null : this._getColorCodeClass();
        this._setColorCodeClass(colorCodeClass);
    },

    /**
    * Check if status is completed based on status value defined in the view def
    *
    * @return {Boolean}
    * @private
    */
    _isCompletedStatus: function() {
        if (_.isUndefined(this.def.completed_status_value)) {
            return false;
        }
        return (this.model.get('status') === this.def.completed_status_value);
    },

    /**
    * Get color code class based on the date compared to today
    * If event is today - use 'today' color code
    * If event is yesterday or earlier - use 'overdue' color code
    *
    * @return {String|null} One of the color codes or null if no color code
    * @private
    */
    _getColorCodeClass: function() {
        var eventDate,
            today,
            nextDay;

        if (_.isEmpty(this.model.get(this.name))) {
            return null;
        }

        eventDate = app.date(this.model.get(this.name));
        today = app.date();
        nextDay = app.date().add(1, 'days');

        if (eventDate.isBefore(today)) {
            return this.colorCodeClasses.overdue;
        } else if (eventDate.isBefore(nextDay)) {
            return this.colorCodeClasses.upcoming;
        } else {
            return null;
        }
    },

    /**
    * Set the color code class to the field tag or clear out if no
    * color code should be applied (colorCodeClass is null)
    *
    * @param {String|null} colorCodeClass
    * @private
    */
    _setColorCodeClass: function(colorCodeClass) {
        if (!_.isNull(colorCodeClass)) {
            this.$el.addClass(colorCodeClass);
        }
    },

    /**
     * Clear color coding classes
     *
     * @private
     */
    _clearColorCode: function() {
        _.each(this.colorCodeClasses, function(colorCodeClass) {
            this.$el.removeClass(colorCodeClass);
        }, this);
    }
}) },
"shareaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Share row action.
 *
 * This allows an user to share a record that is currently mapped with this
 * field context.
 *
 * @class View.Fields.Base.ShareactionField
 * @alias SUGAR.App.view.fields.BaseShareactionField
 * @extends View.Fields.Base.EmailactionField
 */
({
	// Shareaction Field (base) 

    extendsFrom: 'EmailactionField',

    plugins: ['EmailClientLaunch'],

    /**
     * Share template for subject.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplSubject: null,

    /**
     * Share template for body.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBody: null,

    /**
     * Share template for body in HTML format.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBodyHtml: null,

    /**
     * @inheritdoc
     *
     * Adds the share options for use when launching the email client and
     * refreshes the share options if the model data changes. The contents
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'emailaction';
        this._initShareTemplates();
        this._setShareOptions();
        this.model.on('change', this._setShareOptions, this);
    },

    /**
     * Initializes the sharing feature templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/share/subject.hbs`
     * - `custom/clients/{platform}/view/share/body.hbs`
     * - `custom/clients/{platform}/view/share/body-html.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/subject.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body-html.hbs`
     *
     * @template
     * @protected
     */
    _initShareTemplates: function() {
        this.shareTplSubject = app.template.getView('share.subject', this.module) ||
            app.template.getView('share.subject');
        this.shareTplBody = app.template.getView('share.body', this.module) ||
            app.template.getView('share.body');
        this.shareTplBodyHtml = app.template.getView('share.body-html', this.module) ||
            app.template.getView('share.body-html');
    },

    /**
     * Set subject and body settings for the EmailClientLaunch plugin to use
     *
     * @protected
     */
    _setShareOptions: function() {
        var shareParams = this._getShareParams(),
            subject = this.shareTplSubject(shareParams),
            body = this.shareTplBody(shareParams),
            bodyHtml = this.shareTplBodyHtml(shareParams);

        this.addEmailOptions({
            subject: subject,
            html_body: bodyHtml || body,
            text_body: body
        });
    },

    /**
     * Get the params required by the templates defined on
     * {@link #_initShareTemplates}.
     *
     * Override this if your templates need more information to be sent on the
     * share email.
     *
     * @template
     * @protected
     */
    _getShareParams: function() {
        var moduleString = app.lang.getModuleName(this.module);

        return _.extend({}, this.model.attributes, {
            module: moduleString,
            appId: app.config.appId,
            url: window.location.href,
            name: new Handlebars.SafeString(app.utils.getRecordName(this.model))
        });
    },

    /**
     * Explicit share action to launch the sugar email client with share info
     * (used by bwc)
     */
    shareWithSugarEmailClient: function() {
        this.launchSugarEmailClient(this.emailOptions);
    },

    /**
     * Retrieve a mailto URL to launch an external mail client with share info
     * (used by bwc)
     */
    getShareMailtoUrl: function() {
        return this._buildMailToURL(this.emailOptions);
    }
}) },
"sidebartoggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sidebar toggle field that is used in the RHS layout toggle (show/hide).
 *
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `sidebarRendered` has been removed. Now, when the field renders it calls
 *    {@link Layout.Default#isSidePaneVisible} directly to get the current
 *    state.
 *
 * - `toggleSidebar` has been removed. Triggers `sidebar:toggle` instead.
 *
 * - `toggleSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - `openSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - The app event `app:toggle:sidebar` has been removed. Listen to
 *   `sidebar:state:changed` instead.
 *
 * @class View.Fields.Base.SidebartoggleField
 * @alias SUGAR.App.view.fields.BaseSidebartoggleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Sidebartoggle Field (base) 

    events: {
        'click': 'toggle'
    },

    /**
     * Store the current `open` or `close` state
     *
     * @type {String}
     */
    _state: 'open',

    /**
    * @inheritdoc
    */
    _render: function() {
        this._super('_render');

        /**
        * Stores tooltips placement value according to the direction of
        * language being used.
        *
        * @property {string}
        */
        this.dataPlacement = app.lang.direction === 'rtl' ? 'right' : 'left';

        return this;
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout && _.isFunction(defaultLayout.isSidePaneVisible)) {
            this.toggleState(defaultLayout.isSidePaneVisible() ? 'open' : 'close');
            this.listenTo(defaultLayout, 'sidebar:state:changed', this.toggleState);
        }

        //shortcut keys
        app.shortcuts.register('Sidebar:Toggle', 't', this.toggle, this);
    },

    /**
     * Toggle the `open` or `close` class of the icon.
     *
     * @param {String} [state] The state. Possible values: `open` or `close`.
     */
    toggleState: function(state) {
        if (state !== 'open' && state !== 'close') {
            state = (this._state === 'open') ? 'close' : 'open';
        }
        this._state = state;
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Toggle the sidebar.
     *
     * @param {Event} event The `click` event.
     */
    toggle: function(event) {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle');
        }
    }
}) },
"event-status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that show the status field of the model as a badge field.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EventStatusField
 * @alias SUGAR.App.view.fields.BaseEventStatusField
 * @extends View.Fields.Base.BadgeSelectField
 */
({
	// Event-status Field (base) 

    extendsFrom: 'BadgeSelectField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'Held': 'label-success',
            'Not Held': 'label-important',
            'Planned': 'label-pending'
        };

        this.type = 'badge-select';
    }
}) },
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Htmleditable_tinymceField
 * @alias SUGAR.App.view.fields.BaseHtmleditable_tinymceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Htmleditable_tinymce Field (base) 

    plugins: ['Tinymce', 'EllipsisInline'],

    fieldSelector: '.htmleditable', //iframe or textarea selector
    _htmleditor: null, // TinyMCE html editor
    _isDirty: false,
    // When the model already has the value being set, there is no need to trigger the "SetContent" event, which calls
    // our callback to save the content to the model. But we don't want to short-circuit events in TinyMCE's workflow,
    // so the following flag can be toggled to false to indicate that we don't need to save the content to the model
    // inside of the callback.
    _saveOnSetContent: true,

    /**
     * Render an editor for edit view or an iframe for others
     *
     * @private
     */
    _render: function() {

        this.destroyTinyMCEEditor();

        app.view.Field.prototype._render.call(this);

        this._getHtmlEditableField().attr('name', this.name);
        if (this._isEditView()) {
            this._renderEdit(this.def.tinyConfig || null);
        } else {
            this._renderView();
        }
    },

    /**
     * Populate the editor or textarea with the value from the model
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function(model, value) {
            if (this._isEditView()) {
                this._saveOnSetContent = false; // the model already has the value being set, so don't set it again
                this.setEditorContent(value);
            } else {
                this.setViewContent(value)
            }
        }, this);
    },

    /**
     * Sets the content displayed in the non-editor view
     *
     * @param {String} value Sanitized HTML to be placed in view
     */
    setViewContent: function(value){
        var editable = this._getHtmlEditableField();
        if (!editable) {
            return;
        }
        if (!_.isUndefined(editable.get(0)) && !_.isEmpty(editable.get(0).contentDocument)) {
            if (editable.contents().find('body').length > 0) {
                editable.contents().find('body').html(value);
            }
        } else {
            editable.html(value);
        }
    },

    /**
     * Render editor for edit view
     *
     * @param {Array} value TinyMCE config settings
     * @private
     */
    _renderEdit: function(options) {
        var self = this;
        this.initTinyMCEEditor(options);
        this._getHtmlEditableField().on('change', function(){
            self.model.set(self.name, self._getHtmlEditableField().val());
        });


    },

    /**
     * Render read-only view for other views
     *
     * @private
     */
    _renderView: function() {
        this.setViewContent(this.value);
    },

    /**
     * Is this an edit view?  If the field contains a textarea, it will assume that it's in an edit view.
     *
     * @return {Boolean}
     * @private
     */
    _isEditView: function() {
        return (this._getHtmlEditableField().prop('tagName') === 'TEXTAREA');
    },

    /**
     * Returns a default TinyMCE init configuration for the htmleditable widget.
     * This function can be overridden to provide a custom TinyMCE configuration.
     *
     * See [TinyMCE Configuration Documentation](http://www.tinymce.com/wiki.php/Configuration)for details.
     *
     * @return {Object} TinyMCE configuration to use with this widget
     */
    getTinyMCEConfig: function(){
        return {
            // Location of TinyMCE script
            script_url: 'include/javascript/tiny_mce/tiny_mce.js',

            // General options
            theme: "advanced",
            skin: "sugar7",
            plugins: "style,table,advhr,advimage,advlink,iespell,inlinepopups,media,searchreplace,print,contextmenu,paste,noneditable,visualchars,nonbreaking,xhtmlxtras",
            entity_encoding: "raw",
            browser_spellcheck: true,

            // Theme options
            theme_advanced_buttons1: "code,|,bold,italic,underline,|,justifyleft,justifycenter,justifyright,justifyfull,fontsizeselect,|,insertlayer,moveforward,movebackward,absolute,|,styleprops,|,cite,abbr,acronym,del,ins,attribs,|,iespell,media,advhr,|,print,|",
            theme_advanced_buttons2: "cut,copy,paste,|,search,replace,|,bullist,numlist,|,outdent,indent,blockquote,|,undo,redo,|,link,unlink,anchor,image,|,forecolor,backcolor,tablecontrols,|,",
            theme_advanced_toolbar_location: "top",
            theme_advanced_toolbar_align: "left",
            theme_advanced_statusbar_location: "none",
            theme_advanced_resizing: true,
            schema: "html5",

            // Drop lists for link/image/media/template dialogs
            template_external_list_url: "lists/template_list.js",
            media_external_list_url: "lists/media_list.js",

            //plugin theme settings
            theme_advanced_path: false,
            theme_advanced_source_editor_width: 500,
            theme_advanced_source_editor_height: 400,
            inlinepopups_skin: "sugar7modal",
            relative_urls: false,
            remove_script_host: false
        };
    },

    /**
     * Initializes the TinyMCE editor.
     *
     * @param {Object} optConfig Optional TinyMCE config to use when initializing editor.  If none provided, will load config provided from {@link getTinyMCEConfig}.
     */
    initTinyMCEEditor: function(optConfig) {
        var self = this;
        if(_.isEmpty(this._htmleditor)){
            var config = _.extend({}, this.getTinyMCEConfig(), optConfig || {});
            var __superSetup__ = config.setup;
            // Preserve custom setup if it exists, add setup function needed for widget to work properly
            config.setup = function(editor){
                if(_.isFunction(__superSetup__)){
                    __superSetup__.call(this, editor);
                }
                self._htmleditor = editor;
                self._htmleditor.onInit.add(function(ed) {
                    self.setEditorContent(self.getFormattedValue());
                    $(ed.getWin()).blur(function(e){ // Editor window lost focus, update model immediately
                        self._saveEditor();
                    });
                });
                self._htmleditor.onDeactivate.add(function(ed){
                    self._saveEditor();
                });
                self._htmleditor.onSetContent.add(function(ed) {
                    if (self._saveOnSetContent) {
                        self._saveEditor(true);
                    }
                    self._saveOnSetContent = true; // flip it back so that we're sure we save the next time
                });
                self._htmleditor.onChange.add(function(ed, l) {
                    // Changes have been made, mark widget as dirty so we don't lose them
                    self._isDirty = true;
                });
            };
            config.oninit = function(inst) {
                self.context.trigger('tinymce:oninit', inst);
            };

            this._getHtmlEditableField().tinymce(config);
        }
    },

    /**
     * Destroy TinyMCE Editor instance
     */
    destroyTinyMCEEditor: function() {
        // Clean up existing TinyMCE editor
        if(!_.isNull(this._htmleditor)){
            this._saveEditor(true);
            this._htmleditor.remove();
            this._htmleditor.destroy();
            this._htmleditor = null;
        }
    },

    /**
     * Save the TinyMCE editor's contents to the model
     * @private
     */
    _saveEditor: function(force){
        var save = force | this._isDirty;
        if(save){
            this.model.set(this.name, this.getEditorContent(), {silent: true});
            this._isDirty = false;
        }
    },

    /**
     * Finds textarea or iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getHtmlEditableField: function() {
        return this.$el.find(this.fieldSelector);
    },

    /**
     * Sets TinyMCE editor content
     *
     * @param {String} value HTML content to place into HTML editor body
     */
    setEditorContent: function(value) {
        if(_.isEmpty(value)){
            value = "";
        }
        if (this._isEditView() && this._htmleditor && this._htmleditor.dom) {
            this._htmleditor.setContent(value);
        }
    },

    /**
     * Retrieves the  TinyMCE editor content
     *
     * @return {String} content from the editor
     */
    getEditorContent: function() {
        return this._htmleditor.getContent({format: 'raw'});
    },

    /**
     * Destroy TinyMCE Editor on dispose
     *
     * @private
     */
    _dispose: function() {
        this.destroyTinyMCEEditor();
        app.view.Field.prototype._dispose.call(this);
    }

}) },
"dnbenum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EnumField
 * @alias SUGAR.App.view.fields.BaseEnumField
 * @extends View.Fields.Base.BaseField
 */
({
	// Dnbenum Field (base) 

    extendsFrom: 'EnumField',
    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.def && this.def.options) {
            this.items = app.lang.get(this.def.options, 'Connectors');
        }

    }
}) },
"duration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DurationFieldView is a fieldset for Meetings/Calls for managing duration of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DurationField
 * @alias SUGAR.App.view.fields.BaseDurationField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Duration Field (base) 

    extendsFrom: 'FieldsetField',

    plugins: ['EllipsisInline'],

    detailViewNames: ['record', 'create', 'create-nodupecheck', 'preview', 'pmse-case'],

    /**
     * Set default start date time if date_start has not been set. Add custom validation
     * to make sure that the date range is valid before saving.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.model.isNew() && (!this.model.get('date_start'))) {
            this.setDefaultStartDateTime();
            this.modifyEndDateToRetainDuration();
            this.updateDurationHoursAndMinutes();

            // Values for date_start, date_end, duration_hours, and duration_minutes
            // should be set as the default on the model.
            this.model.setDefault({
                'date_start': this.model.get('date_start'),
                'date_end': this.model.get('date_end'),
                'duration_hours': this.model.get('duration_hours'),
                'duration_minutes': this.model.get('duration_minutes')
            });
        }

        // Date range should be valid before saving the record.
        this.model.addValidationTask('duration_date_range_' + this.cid, _.bind(function(fields, errors, callback) {
            _.extend(errors, this.validate());
            callback(null, fields, errors);
        }, this));
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // Change the end date when start date changes.
        this.model.on('change:date_start', this.modifyEndDateToRetainDuration, this);

        // Check for valid date range on edit. If not valid, show a validation error.
        // In detail mode, re-render the field if either start or end date changes.
        this.model.on('change:date_start change:date_end', function(model) {
            var dateStartField,
                dateEndField,
                errors;

            this.updateDurationHoursAndMinutes();

            if (this.action === 'edit') {
                dateStartField = this.view.getField('date_start');
                dateEndField = this.view.getField('date_end');

                if (dateStartField && !dateStartField.disposed && dateEndField && !dateEndField.disposed) {
                    dateStartField.clearErrorDecoration();
                    dateEndField.clearErrorDecoration();
                    errors = this.validate();

                    if (errors) {
                        dateStartField.decorateError(errors.date_start);
                        dateEndField.decorateError(errors.date_end);
                    }
                }
            } else {
                this.render();
            }
        }, this);

        this._super('bindDataChange');
    },

    /**
     * Check to see if there are any errors on the field. Returns undefined if it is valid.
     * @return {Object} Errors
     */
    validate: function() {
        var errors,
            dateStartField = this.view.getField('date_start'),
            dateEndField = this.view.getField('date_end');

        if (!this.isDateRangeValid()) {
            errors = {};
            errors.date_start = {
                isBefore: dateEndField.label
            };
            errors.date_end = {
                isAfter: dateStartField.label
            };
        }

        return errors;
    },

    /**
     * @override
     *
     * Return the display string for the start and date, along with the duration.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} The duration string
     */
    format: function(value) {
        var displayString = '',
            startDateString = this.model.get('date_start'),
            endDateString = this.model.get('date_end'),
            startDate,
            endDate,
            duration,
            durationString;

        if (startDateString && endDateString) {
            startDate = app.date(startDateString);
            endDate = app.date(endDateString);
            duration = app.date.duration(endDate - startDate);
            durationString = duration.format() || ('0 ' + app.lang.get('LBL_DURATION_MINUTES'));

            if ((startDate.date() === endDate.date())
                && (startDate.month() === endDate.month())
                && (startDate.year() === endDate.year())) {
                // Should not display the date twice when the start and the end dates are the same.
                displayString = app.lang.get('LBL_START_AND_END_DATE_SAME_DAY', this.module, {
                    date: startDate.formatUser(true),
                    start: startDate.format(app.date.getUserTimeFormat()),
                    end: endDate.format(app.date.getUserTimeFormat()),
                    duration: durationString
                });
            } else {
                displayString = app.lang.get('LBL_START_AND_END_DATE', this.module, {
                    start: startDate.formatUser(false),
                    end: endDate.formatUser(false),
                    duration: durationString
                });
            }
        }

        return displayString;
    },

    /**
     * Set the default start date time to the upcoming hour or half hour,
     * whichever is closest.
     * @param {Utils.Date} currentDateTime (optional) - current date time
     */
    setDefaultStartDateTime: function(currentDateTime) {
        var defaultDateTime = currentDateTime || app.date().seconds(0);

        if (defaultDateTime.minutes() > 30) {
            defaultDateTime
                .add('h', 1)
                .minutes(0);
        } else if (defaultDateTime.minutes() > 0) {
            defaultDateTime.minutes(30);
        }

        this.model.set('date_start', defaultDateTime.formatServer());
    },

    /**
     * Set duration_hours and duration_minutes based upon date_start and date_end.
     */
    updateDurationHoursAndMinutes: function() {
        var diff = app.date(this.model.get('date_end')).diff(this.model.get('date_start'));
        this.model.set('duration_hours', Math.floor(app.date.duration(diff).asHours()));
        this.model.set('duration_minutes', app.date.duration(diff).minutes());
    },

    /**
     * If the start and end date has been set and the start date changes,
     * automatically change the end date to maintain duration.
     */
    modifyEndDateToRetainDuration: function() {
        var startDateString = this.model.get('date_start'),
            originalStartDateString = this.model.previous('date_start'),
            originalStartDate,
            endDateString = this.model.get('date_end'),
            endDate,
            duration,
            changedAttributes = this.model.changedAttributes();

        // Do not change the end date if the start date has not been set or if the start date
        // and the end date have been changed at the same time.
        if (!startDateString || (changedAttributes.date_start && changedAttributes.date_end)) {
            return;
        }

        if (endDateString && originalStartDateString) {
            // If end date has been set, maintain duration when the start
            // date changes.
            originalStartDate = app.date(originalStartDateString);
            duration = app.date(endDateString).diff(originalStartDate);

            // Only set the end date if start date is before the end date.
            if (duration >= 0) {
                endDate = app.date(startDateString).add(duration).formatServer();
                this.model.set('date_end', endDate);
            }
        } else {
            // Set the end date to be an hour from the start date if the end
            // date has not been set yet.
            endDate = app.date(startDateString).add('m', 30).formatServer();
            this.model.set('date_end', endDate);
        }
    },

    /**
     * Is this date range valid? It returns true when start date is before end date.
     * @return {boolean}
     */
    isDateRangeValid: function() {
        var start = this.model.get('date_start'),
            end = this.model.get('date_end'),
            isValid = false;

        if (start && end) {
            if (app.date.compare(start, end) < 1) {
                isValid = true;
            }
        }

        return isValid;
    },

    /**
     * Inherit fieldset templates for edit.
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        // Use detail view if the view.name is in list of views defined in detailViewNames
        if ((_.indexOf(this.detailViewNames, this.view.name) > -1) && (this.action === 'edit')) {
            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('duration_date_range_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Special case for duration fields on preview view
     *
     * @inheritdoc
     */
    setMode: function(name) {
        //on preview view, we use the preview action instead of detail
        if (this.view.name === 'preview' && name === 'detail') {
            name = 'preview';
        }

        this._super('setMode', [name]);
    }
}) },
"actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actionmenu is an {@link View.Fields.Base.ActiondropdownField actiondropdown}
 * with a checkbox as the default action.
 *
 * Supported Properties:
 *
 * - {Boolean} disable_select_all_alert Boolean telling if we should show the
 *   'select all' and 'clear all' alerts when all checkboxes are checked.
 *   `true` to hide alerts. `false` to display them. Defaults to `false`.
 *
 * @class View.Fields.Base.ActionmenuField
 * @alias SUGAR.App.view.fields.BaseActionmenuField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Actionmenu Field (base) 

    extendsFrom: 'ActiondropdownField',

    /** Initializes the actionmenu field.
     *
     * Sets the property no_default_action to `true` because the checkbox will
     * always be the default action and it's handled separately.
     * See {@link View.Fields.Base.ActiondropdownField} for properties
     * documentation.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click [data-check=all]': 'checkAll',
            'click [data-check=one]': 'check'
        });

        this.def.no_default_action = true;
        this.def.css_class = this.def.css_class + ' actionmenu';
        /**
         * The checkbox tag.
         *
         * @property {string}
         */
        this.fieldTag = 'input[type=checkbox]';

        /**
         * The mass collection the actionmenu field is related to.
         *
         * @property {Data.BeanCollection} massCollection
         */
        this.massCollection = this.context.get('mass_collection');

        this.def.disable_select_all_alert = !!this.def.disable_select_all_alert;

        if (this.options.viewName === 'list-header') {
            this.isCheckAllCheckbox = true;
        }

        if (this.isCheckAllCheckbox) {
            app.shortcuts.register('SelectAll:Checkbox', 'ctrl+a', function() {
                if (!this.isDisabled()) {
                    this.$('[data-check=all]:visible').click();
                }
            }, this);
            app.shortcuts.register('SelectAll:Dropdown', 'm', function() {
                var $dropdown = this.$(this.actionDropDownTag);
                if ($dropdown.is(':visible') && !$dropdown.hasClass('disabled')) {
                    $dropdown.click();
                }
            }, this);
        }
    },

    /**
     * Calls {@link #toggleSelect} to help pass the information to the context.
     */
    check: function() {
        var $checkbox = this.$(this.fieldTag);
        var isChecked = $checkbox.is(':checked');
        this.toggleSelect(isChecked);
    },

    /**
     * Sends an event to the context to add or remove the model from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass the model to the mass collection,
     *   `false` to remove it.
     */
    toggleSelect: function(checked) {
        var event = !!checked ? 'mass_collection:add' : 'mass_collection:remove';
        this.context.trigger(event, this.model);
    },

    /**
     * Selects or unselects all records that are in the current collection.
     *
     * @param {Event} The `click` or `keydown` event.
     */
    checkAll: function(event) {
        var $checkbox = this.$(this.fieldTag);
        if ($(event.target).hasClass('checkall') || event.type === 'keydown') {
            $checkbox.prop('checked', !$checkbox.is(':checked'));
        }
        var isChecked = $checkbox.is(':checked');
        this.toggleAll(isChecked);
    },

    /**
     * Sends an event to the context to add or remove all models from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass all models in the collection to
     *   the mass collection, `false` to remove them.
     *
     *
     * FIXME : Doing this way is slow to check all checkboxes when there
     * are more than 20. We should check checkboxes before adding records to
     * the mass collection SC-4079 will address this problem.
     */
    toggleAll: function(checked) {
        var event = checked ? 'mass_collection:add:all' : 'mass_collection:remove:all';
        this.context.trigger(event, this.model);
    },

    /**
     * Binds mass collection events to a record row checkbox.
     *
     * @private
     */
    _bindModelChangeEvents: function() {
        this.massCollection.on('add', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).attr('checked', true);
            }
        }, this);

        this.massCollection.on('remove', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).attr('checked', false);
            }
        }, this);

        this.massCollection.on('reset', function() {
            this.$(this.fieldTag).attr('checked', !!this.massCollection.get(this.model.id));
        }, this);
    },

    /**
     * Binds mass collection events to 'select-all' checkbox, the one used to check/
     * uncheck all record row checkboxes.
     *
     * @private
     */
    _bindAllModelChangeEvents: function() {
        // Checks/selects the actionmenu checkbox if the checkboxes of each
        // row are all checked.
        this.massCollection.on('all:checked', function() {
            if (this.collection.length !== 0) {
                this.$(this.fieldTag).attr('checked', true);
            }
        }, this);

        // Unchecks/deselects the actionmenu checkbox if the checkboxes of
        // each row are NOT all checked.
        this.massCollection.on('not:all:checked', function() {
            this.$(this.fieldTag).attr('checked', false);
        }, this);

        this.massCollection.on('add', this._onMassCollectionAddAll, this);
        this.massCollection.on('remove reset', this._onMassCollectionRemoveResetAll, this);
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `add` event.
     *
     * @private
     */
    _onMassCollectionAddAll: function() {
        this.setDropdownDisabled(false);
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `remove` and
     * `reset` events.
     *
     * @private
     */
    _onMassCollectionRemoveResetAll: function() {
        var massCollectionIds = _.pluck(this.massCollection.models, 'id');
        var viewCollectionIds = _.pluck(this.collection.models, 'id');
        if (this.massCollection.length === 0) {
            this.setDropdownDisabled(true);
            //massCollection.models could only have 'id' as an attribute,
            //so we need to compare ids instead of models directly.
        } else if (_.intersection(massCollectionIds, viewCollectionIds).length !== 0) {
            this.setDropdownDisabled(false);
            this.$(this.fieldTag).attr('checked', true);
        }
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * @override
     *
     * Binds events on the collection, and updates the checkboxes
     * consequently.
     */
    bindDataChange: function() {
        if (this.isCheckAllCheckbox) {
            // Listeners on the checkAll/uncheckAll checkbox.
            this._bindAllModelChangeEvents();
            this.action_enabled = this.massCollection.length > 0;
        } else {
            // Listeners for each record selection.
            this._bindModelChangeEvents();
        }

        this.massCollection.on('massupdate:estimate', this.onTotalEstimate, this);
    },

    /**
     * Toggles the actionmenu buttons according to the buttons definition and
     * the number of selected records.
     *
     * @param {Object} fields List of the view's fields.
     * @param {number} massCollectionLength The number of selected records.
     */
    setButtonsDisabled: function(fields) {
        _.each(fields, function(field) {
            if (field.def.minSelection || field.def.maxSelection) {
                var min = field.def.minSelection || 0,
                    max = field.def.maxSelection || this.massCollection.length;
                if (this.massCollection.length < min || this.massCollection.length > max) {
                    field.setDisabled(true);
                } else {
                    field.setDisabled(false);
                }
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.action === 'list' && this.action === 'edit') {
            this.template = app.template.empty;
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isCheckAllCheckbox) {
            // If the model is in the mass collection, make sure the checkbox
            // is checked.
            if (this.massCollection.get(this.model.id)) {
                this.selected = true;
            } else {
                delete this.selected;
            }
        }

        this._super('_render');

        if (this.isCheckAllCheckbox && !this.def.disable_select_all_alert) {
            this.setButtonsDisabled(this.dropdownFields);
            this.setDropdownDisabled(this.massCollection.length === 0);
        }
    },

    /**
     * Since we don't have a default action button we don't need
     * to render anything here. See {@link View.Fields.Base.ActiondropdownField#_renderFields}.
     *
     * @override
     * @protected
     */
    _renderFields: $.noop,

    /**
     * Update the dropdown usability while the total count is estimating.
     */
    onTotalEstimate: function() {
        this.setDropdownDisabled(!this.massCollection.fetched);
    },

    /**
     * Disable the dropdown action.
     *
     * @param {Boolean} [disable] `true` to disable the dropdown action, `false`
     * to enable it.
     */
    setDropdownDisabled: function(disable) {
        this.$(this.actionDropDownTag).toggleClass('disabled', disable);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        // We only get the fields (the dropdown actions) metadata for the
        // checkAll/uncheckAll checkbox. Actionmenu fields tied to a model are
        // a simple checkbox and don't have metadata.
        if (this.model.id) {
            return;
        }
        return this._super('_getChildFieldsMeta');
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.massCollection) {
            var modelId = this.model.cid,
                cid = this.view.cid;
            this.massCollection.off(null, null, this);
            if (modelId) {
                this.massCollection.off(null, null, modelId);
            }
            if (cid) {
                this.massCollection.off(null, null, cid);
            }
        }
        this._super('unbindData');
    }
}) },
"invitation-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.InvitationActionsField
 * @alias SUGAR.App.view.fields.BaseInvitationActionsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Invitation-actions Field (base) 


    plugins: ['Tooltip'],

    events: {
        'click [data-action]': 'toggleStatus'
    },

    /**
     * Toggle invitation acceptance status.
     *
     * This will fire the save automatically to the server since it is a toggle
     * button and won't make sense to do save from the view (same as favorite).
     *
     * @param {Event} evt The click event that triggered the change.
     */
    toggleStatus: function(evt) {
        var attr = {};

        attr[this.name] = $(evt.currentTarget).data('action');

        this.model.save(attr, {relate: true});
    }
}) },
"timeperiod": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseTimeperiodField
 * @extends View.Fields.Base.EnumField
 */
({
	// Timeperiod Field (base) 

    /**
     * Who we should extend
     */
    extendsFrom: 'EnumField',

    /**
     * Plugins
     */
    plugins: ['EllipsisInline', 'Tooltip'],

    /**
     * The template for the tooltip
     */
    tooltipTemplate: '',

    /**
     * Mapping of ID's with the start ane end dates formatted for use when the tooltip is displayed
     */
    tpTooltipMap: {},

    /**
     * The selector we use to find the dropdown since it's appended to the body and not the current element
     */
    cssClassSelector: '',

    /**
     * Flag to use if Select2 tries to format the tooltips before timeperiod data returns from the server
     */
    updateDefaultTooltip: false,

    /**
     * Tooltip placement direction for the template
     */
    tooltipDir: 'right',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (app.lang.direction === 'rtl') {
            this.tooltipDir = 'left';
        }


        var collectionParams = {
            limit: 100,
            params: {}
        };

        this._super('initialize', [options]);

        if (this.def.use_generic_timeperiods) {
            collectionParams.params.use_generic_timeperiods = true;
        }

        /**
         * Collection for fetching all the Timeperiods.
         *
         * @property {Data.BeanCollection}
         */
        this.tpCollection = app.data.createBeanCollection('TimePeriods');
        this.tpCollection.once('reset', this.formatTooltips, this);
        this.tpCollection.on('sync', this.render, this);
        this.tpCollection.fetch(collectionParams);

        // load the tooltip template
        this.tooltipTemplate = app.template.getField('timeperiod', 'tooltip', this.module);

        // if forecast is not setup, then we need to use the generic options
        var config = app.metadata.getModule('Forecasts', 'config');
        if (!config || config.is_setup === 0) {
            this.def.options = 'generic_timeperiod_options';
        }
    },

    /**
     * @inheritdoc
     *
     * Add a change event handler for initializing all the plugin tooltips again
     */
    bindDataChange: function() {
        this._super("bindDataChange");
        if (this.model) {
            // when the value changes on the model, we need to initialize the Tooltips again
            this.model.on('change:' + this.name, function() {
                this.initializeAllPluginTooltips();
            }, this);
        }
    },

    /**
     * Utility method to take the TimePeriod collection and parse our the start and end dates to be in the user
     * date preference and store them for when the enum is actually opened
     * @param data
     */
    formatTooltips: function(data) {
        var usersDatePrefs = app.user.getPreference('datepref');
        data.each(function(model) {
          this.tpTooltipMap[model.id] = {
              start :app.date.format(app.date.parse(model.get('start_date')), usersDatePrefs),
              end: app.date.format(app.date.parse(model.get('end_date')), usersDatePrefs)
          }
        }, this);
        // since we don't need it any more, destroy it
        this._destroyTplCollection();

        if(this.updateDefaultTooltip) {
            this.updateDefaultTooltip = false;
            // manually update the default selected item's tooltip
            var tooltipText = app.lang.get('LBL_DROPDOWN_TOOLTIP', 'TimePeriods', this.tpTooltipMap[this.value[0]]);
            this.$('[rel="tooltip"]').attr('data-original-title', tooltipText);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super("_render");
        if (this.tplName == 'noaccess') {
            return this;
        }

        var $el = this.$(this.fieldTag);
        $el.on('select2-selected', _.bind(this.onSelectClear, this));
        $el.on('select2-open', _.bind(this.onSelectOpen, this));
        $el.on('select2-close', _.bind(this.onSelectClear, this));

        this.initializeAllPluginTooltips();

        return this;
    },

    /**
     * On select open, we need to bind the tool tips
     */
    onSelectOpen: function() {
        var $el = $('div.' + this.cssClassSelector);
        this.removePluginTooltips();
        this.addPluginTooltips($el);
    },

    /**
     * When an item is selected of or the select is closed, we need to clean up the tool tips
     */
    onSelectClear: function() {
        var $el = $('div.' + this.cssClassSelector);
        this.removePluginTooltips($el);
        this.addPluginTooltips();
    },

    /**
     * @inheritdoc
     */
    getSelect2Options: function(optionsKeys) {
        var options = this._super("getSelect2Options", [optionsKeys]);

        // this is to format the results
        options.formatResult = _.bind(this.formatOption, this);

        // this is to format the currently selected option
        options.formatSelection = _.bind(this.formatOption, this);

        if (_.isEmpty(options.dropdownCssClass)) {
            options.dropdownCssClass = 'select2-timeperiod-dropdown-' + this.cid;
        }

        this.cssClassSelector = options.dropdownCssClass;

        return options;
    },

    /**
     * Format Option for the results and the selected option to bind the tool tip data into the html
     * that gets output
     *
     * @param {Object} object
     * @return {string}
     */
    formatOption: function(object) {
        // check once if the tpTooltipMap has been built yet
        this.updateDefaultTooltip = _.isUndefined(this.tpTooltipMap[object.id]);
        return this.tooltipTemplate({
            tooltip: this.tpTooltipMap[object.id],
            value: object.text,
            tooltipDir: this.tooltipDir
        });
    },

    /**
     * Disposes the {@link #tplCollection} properly.
     *
     * @private
     */
    _destroyTplCollection: function() {
        if (this.tpCollection) {
            this.tpCollection.off(null, null, this);
            this.tplCollection = null;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._destroyTplCollection();
        this._super('_dispose');
    }
}) },
"actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Create a dropdown button that contains multiple
 * {@link View.Fields.Base.RowactionField} fields.
 *
 * Supported Properties:
 *
 * - {Boolean} primary True if the entire dropdown group shows as primary.
 * - {String} icon Css icon that places on dropdown caret.
 * - {Boolean} switch_on_click True if the selected action needs to switch
 *   against the default action.
 * - {Boolean} no_default_action True if the default action should be empty and
 *   all buttons place under the dropdown action.
 * - {Array} buttons List of actions.
 *   First action goes to the default action (unless no_default_action set as `true`)
 *
 * Example usage:
 *
 *      array(
 *          'type' => 'actiondropdown',
 *          'primary' => true,
 *          'switch_on_click' => true,
 *          'no_default_action' => false,
 *          'icon' => 'fa-cog',
 *          'buttons' => array(
 *              ...
 *          )
 *      )
 *
 * @class View.Fields.Base.ActiondropdownField
 * @alias SUGAR.App.view.fields.BaseActiondropdownField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Actiondropdown Field (base) 

    extendsFrom: 'FieldsetField',

    events: {
        'click [data-toggle=dropdown]' : 'renderDropdown'
    },
    plugins: ['Tooltip'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * A subset of {@link #fields}.
         * Contains ACL accessible fields that are part of the dropdown.
         *
         * @property {Array}
         */
        this.dropdownFields = [];

        /**
         * Dom element selector for dropdown action.
         *
         * @property {string}
         */
        this.actionDropDownTag = '[data-toggle=dropdown]';

        /**
         * Dom element selector for mobile dropdown selector.
         *
         * @property {string}
         */
        this.selectDropdownTag = '[data-toggle=dropdownmenu]';

        /**
         * The dropdown tag to append the dropdown list to.
         *
         * @property {string}
         */
        this.dropdownTag = '[data-menu=dropdown]';

        /**
         * The default action button. An item in {@link #fields}.
         * This is a readonly property. Use {@link #_setDefaultBtn} to modify.
         *
         * @property {Object}
         */
        this.defaultActionBtn = {};

        /**
         * @inheritdoc
         *
         * This field doesn't support `showNoData`.
         */
        this.showNoData = false;

        this._super('initialize', [options]);

        /**
         * The caret icon class.
         *
         * @property {string}
         */
        this.caretIcon = this.def.icon || 'fa-caret-down';

        this.def.css_class = this.def.css_class ?
            this.def.css_class + ' actions' : 'actions';

        if (this.def.no_default_action) {
            this.def.switch_on_click = false;
        }

        //shortcut keys
        app.shortcuts.register('Dropdown:More', 'm', function() {
            var $primaryDropdown = this.$('.btn-primary[data-toggle=dropdown]');
            if ($primaryDropdown.is(':visible') && !$primaryDropdown.hasClass('disabled')) {
                $primaryDropdown.click();
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * @inheritdoc
     *
     * Calls {@link #_reorganizeButtons} if creating fields for the first time.
     * @return {Array} Array of accessible fields, a subset of {@link #fields}.
     */
    _getChildFields: function() {
        if (_.isEmpty(this.fields)) {
            var fields = this._super('_getChildFields');
            this._orderButtons(fields);
        }
        return !_.isEmpty(this.defaultActionBtn) ?
            [this.defaultActionBtn].concat(this.dropdownFields) :
            this.dropdownFields;
    },

    /**
     * Orders the fields according to order given and places the ACL accessible
     * fields in {@link #defaultActionBtn} and {@link #dropdownFields}.
     *
     * @param {Array} [fields=this.fields] Buttons in a specific order.
     * @private
     */
    _orderButtons: function(fields) {
        //Set to `true` to avoid starting the list with a divider.
        var prevIsDivider = true,
            orderedFields = fields || this.fields;
        this.dropdownFields = _.filter(orderedFields, function(field) {
            var actionHidden = (_.isFunction(field.hasAccess) && !field.hasAccess()) ||
                (_.isFunction(field.isVisible) && !field.isVisible());

            if (actionHidden || (field.type === 'divider' && prevIsDivider)) {
                return false;
            }
            prevIsDivider = field.type === 'divider';
            return true;
        });

        if (!this.def.no_default_action && !_.isEmpty(this.dropdownFields)) {
            this._setDefaultBtn(_.first(this.dropdownFields));
            this.dropdownFields = _.rest(this.dropdownFields);
        }
    },

    /**
     * Gets the dropdown template and caches it to `this.dropdownTpl`.
     *
     * @return {Function} The handlebars dropdown template.
     * @protected
     */
    _getDropdownTpl: function() {
        this.dropdownTpl = this.dropdownTpl ||
            app.template.getField('actiondropdown', 'dropdown', this.module);
        return this.dropdownTpl;
    },

    /**
     * Appends the dropdown from `dropdown.hbs` and binds the
     * {@link #switchButton} method to the dropdown buttons if necessary.
     *
     * @param {Event} evt The `click` event.
     */
    renderDropdown: function(evt) {
        var $dropdown = this.$(this.dropdownTag);

        if (_.isEmpty(this.dropdownFields) || this.isDisabled() || !$dropdown.is(':empty')) {
            return;
        }
        var dropdownTpl = this._getDropdownTpl();

        $dropdown.append(dropdownTpl(this));

        _.each(this.dropdownFields, function(field) {
            field.setElement(this.$('span[sfuuid="' + field.sfId + '"]'));
            if (this.def['switch_on_click'] && !this.def['no_default_action']) {
                field.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
            }
            field.render();
        }, this);
    },

    /**
     * Sets a button to {@link #defaultActionBtn} and to have default-button
     * properties. Unsets the previous {@link #defaultActionBtn}.
     *
     * @param {Object} button The button of interest.
     * @private
     */
    _setDefaultBtn: function(button) {
        if (!button || button.disposed) {
            return;
        }
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.def.primary = this.defaultActionBtn.def.button = false;
        }
        this.defaultActionBtn = button;
        this.defaultActionBtn.def.primary = this.def.primary;
        this.defaultActionBtn.def.button = true;
    },

    /**
     * Switch the default button against one that is clicked.
     *
     * @param {Event} evt The `click` event
     */
    switchButton: function(evt) {
        var sfId = parseInt(this.$(evt.currentTarget).attr('sfuuid'), 10),
            index = -1;

        if (sfId === this.defaultActionBtn.sfId) {
            return;
        }
        var selectedField = _.find(this.dropdownFields, function(field, idx) {
            if (field.sfId === sfId) {
                index = idx;
                return true;
            }
            return false;
        });

        if (!selectedField) {
            return;
        }

        //rebuild `dropdownFields` with the new ordering
        this.dropdownFields.splice(index, 1, this.defaultActionBtn);
        this._setDefaultBtn(selectedField);
        this.render();
    },

    /**
     * @inheritdoc
     *
     * Rendering an `ActiondropdownField` will always force the dropdown to be
     * re-rendered.
     */
    _render: function() {
        this.$(this.dropdownTag).empty();

        this._super('_render');
        this._updateCaret();
        this._renderDefaultActionBtn();
        this.$el.toggleClass('btn-group', !_.isEmpty(this.dropdownFields));

        return this;
    },

    /**
     * Renders the default action button only.
     * The fields in the dropdown will be rendered on click on the dropdown
     * button with {@link #renderDropdown}.
     *
     * @override
     * @protected
     */
    _renderFields: function() {
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.setElement(this.$('span[sfuuid="' + this.defaultActionBtn.sfId + '"]'));
            this.defaultActionBtn.render();
        }
    },

    /**
     * Formats the default action button if it exists.
     * Sets the mode of the button to `small` if it is in a subpanel.
     *
     * A button is in `small` mode when it contains only the icon, with the label
     * shown as a tooltip.
     *
     * @protected
     */
    _renderDefaultActionBtn: function() {
        if (_.isEmpty(this.defaultActionBtn)) {
            return;
        }
        //FIXME: SC-3366 Should not explicitly look for `closestComponent`
        if (this.defaultActionBtn.def.icon &&
            this.defaultActionBtn.closestComponent('subpanel')) {
            this.defaultActionBtn.setMode('small');
        }

        if (!this.def['switch_on_click'] || this.def['no_default_action']) {
            return;
        }

        this.defaultActionBtn.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
        app.accessibility.run(this.defaultActionBtn.$el, 'click');
    },

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     * @private
     */
    _updateCaret: function() {
        if (_.isEmpty(this.dropdownFields)) {
            return;
        }
        //FIXME: SC-3365 Should not need to check for 'disabled' in css_class
        var caretEnabled = _.some(this.dropdownFields, function(field) {
            if (_.isFunction(field.hasAccess) && field.hasAccess()) {
                if (field.def.css_class && field.def.css_class.indexOf('disabled') > -1) {
                    //If action disabled in metadata
                    return false;
                } else if (field.isDisabled()) { //Or disabled via field controller
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        });
        this.$('.' + this.caretIcon).closest('a').toggleClass('disabled', !caretEnabled);
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        this._super('setDisabled', [disable]);
        disable = _.isUndefined(disable) ? true : disable;
        this.$(this.actionDropDownTag).toggleClass('disabled', disable);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.fields, function(field) {
            field.$el.off('click.' + this.cid);
        }, this);
        this.defaultActionBtn = null;
        this.dropdownFields = null;
        this._super('_dispose');
    }
}) },
"password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PasswordField
 * @alias SUGAR.App.view.fields.BasePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Password Field (base) 

    direction: 'ltr'
}) },
"url": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UrlField
 * @alias SUGAR.App.view.fields.BaseUrlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Url Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    plugins: ['EllipsisInline'],
    initialize: function(options) {
        this._super("initialize", arguments);
        //Generated URL's should not be editable
        if (app.utils.isTruthy(this.def.gen)) {
            this.def.readonly = true;
        }
    },

    format:function(value){
        if (value && !value.match(/^([a-zA-Z]+):\/\//)) {
            value = "http://" + value;
        }
        return value;
    },
    unformat:function(value){
        value = (value!='' && value!='http://') ? value.trim() : "";
        return value;
    },
    getFieldElement: function() {
        return this.$('a');
    },
    _render: function() {
        this.def.link_target = _.isUndefined(this.def.link_target) ? '_blank' : this.def.link_target;
        app.view.Field.prototype._render.call(this);
    }
}) },
"overdue-badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that shows a date field as a badge when event is overdue
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.OverdueBadgeField
 * @alias SUGAR.App.view.fields.BaseOverdueBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Overdue-badge Field (base) 

    _render: function() {
        var now = new Date(),
            due_date = this.model.get(this.name),
            date = new Date(due_date);
        this.model.set('overdue', !_.isNull(due_date) && date < now);
        this._super('_render');
    }
}) },
"language": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LanguageField
 * @alias SUGAR.App.view.fields.BaseLanguageField
 * @extends View.Fields.Base.EnumField
 */
({
	// Language Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.setDefault(this.name, this._getDefaultOption());
    },

    /**
     * Ensure we load enum templates
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'enum';
        app.view.Field.prototype._loadTemplate.call(this);
        this.type = 'language';
    },

    /**
     * @inheritdoc
     * If no value, set the application default language as default value.
     * If edit mode, set the application default language on the model.
     */
    format: function(value) {
        if (!this.items[value]) {
            value = this._getDefaultOption();
            this.model.set(this.name, value);
        }

        return value;
    },

    /**
     * @override
     *
     * @return {string}  The default language as the default value
     */
    _getDefaultOption: function(optionsKeys) {
        return app.lang.getDefaultLanguage();
    },
}) },
"fullname": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FullnameField
 * @alias SUGAR.App.view.fields.BaseFullnameField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Fullname Field (base) 

    extendsFrom: 'FieldsetField',

    plugins: ['EllipsisInline'],

    /**
     * Mapping name field name to format initial
     *
     * @property {Object}
     */
    formatMap: {
        'f': 'first_name',
        'l': 'last_name',
        's': 'salutation'
    },

    /**
     * @inheritdoc
     * Sort the dependant fields by the user locale format order.
     */
    initialize: function(options) {
        var formatPlaceholder = app.user.getPreference('default_locale_name_format') || '';
        this._super('initialize', [options]);
        if (!this.module) {
            app.logger.error('Fullname field requires a module');
            this.dispose();
            return;
        }

        var meta = app.metadata.getModule(this.module);
        this.formatMap = meta.formatMap || this.formatMap;

        this.def.fields = _.reduce(formatPlaceholder.split(''), function(fields, letter) {
            // only letters a-z may be significant in the format,
            // everything else is translated verbatim
            if (letter >= 'a' && letter <= 'z' && this.formatMap[letter]) {
                var fieldMeta = meta.fields[this.formatMap[letter]];
                if (fieldMeta) {
                    // clone because we'd rewrite it later and we don't want to mess with actual metadata
                    fields.push(_.clone(fieldMeta));
                }
            }
            return fields;
        }, [], this);
        this.def.fields = app.metadata._patchFields(this.module, meta, this.def.fields);

        if (this.def && this.def.link && app.acl.hasAccessToModel('view', this.model)) {
            var action = this.def.route && this.def.route.action ? this.def.route.action : '';
            //If `this.template` resolves to `base/list.hbs`, that template expects an
            //initialized `this.href`. That's normally handled by the `base.js` controller,
            //but, in this case, since `fullname.js` is controller, we must handle here.
            this.href = '#' + app.router.buildRoute(this.module || this.context,
                this.model.id, action, this.def.bwcLink);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);
        //SP-1719: The view-combined template should also follow the view's custom template.
        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }
        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Format name parts to current user locale.
     */
    format: function() {
        return app.utils.formatNameModel(this.model.module, this.model.attributes);
    },

    /**
     * @override
     * Note that the parent bindDataChange (from FieldsetField) is an empty function
     */
    bindDataChange: function() {
        if (this.model) {
            // As detail templates don't contain Sidecar Fields,
            // we need to rerender this field in order to visualize the changes
            this.model.on("change:" + this.name, function() {
                if (this.action !== 'edit') {
                    this.render();
                }
            }, this);
            // When a child field changes, we need to update the full_name value
            _.each(this.def.fields, function(field) {
                this.model.on("change:" + field.name, this.updateValue, this);
            }, this);
        }
    },

    /**
     * Update the value of this parent field when a child changes
     */
    updateValue: function() {
        this.model.set(this.name, this.format());
    },

    /**
     * Called by record view to set max width of inner record-cell div
     * to prevent long names from overflowing the outer record-cell container
     */
    setMaxWidth: function(width) {
        this.$('.record-cell').children().css({'max-width': width});
    },

    /**
     * Return the width of padding on inner record-cell
     */
    getCellPadding: function() {
        var padding = 0,
            $cell = this.$('.record-cell');

        if (!_.isEmpty($cell)) {
            padding = parseInt($cell.css('padding-left'), 10) + parseInt($cell.css('padding-right'), 10);
        }

        return padding;
    }
}) },
"mass-email-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This field uses the `EmailClientLaunch` plugin to launch the appropriate
 * email client.
 *
 * Recipients to pre-populate are pulled from the mass_collection.
 * For external email client: Changes to the mass_collection will rebuild the mailto: link
 * For internal email client: Recipients are gathered from the mass_collection on click.
 * In order for the recipients to be prepopulated, this field requires the models in the
 * mass_collection contain the email field - if not, recipients will simply be blank (no error).
 *
 * @class View.Fields.Base.MassEmailButtonField
 * @alias SUGAR.App.view.fields.BaseMassEmailButtonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Mass-email-button Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     *
     * Add the `EmailClientLaunch` plugin and force use of `ButtonField`
     * templates.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['EmailClientLaunch']);
        this._super('initialize', [options]);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can render this button appropriately whenever the mass collection changes.
     */
    bindDataChange: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * Clean up listener on mass_collection updates
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');
        if (massCollection) {
            massCollection.off(null, null, this);
        }
        this._super('unbindData');
    },

    /**
     * Map mass collection models to the appropriate format
     * required to prepopulate the to_addresses on email compose
     *
     * @return {Object} options to prepopulate on the email compose
     * @private
     */
    _retrieveEmailOptionsFromLink: function() {
        var massCollection = this.context.get('mass_collection'),
            toAddresses = _.map(massCollection.models, function(model) {
                return {bean: model};
            }, this);
        return {
            to_addresses: toAddresses
        };
    }
}) },
"collection-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CollectionCountField
 * @alias SUGAR.App.view.fields.BaseCollectionCountField
 * @extends View.Fields.Base.BaseField
 */
({
	// Collection-count Field (base) 

    plugins: ['Tooltip'],

    events: {
        'click [data-action="count"]': 'fetchCount'
    },

    /**
     * Fetches the total amount of filtered records from the collection, and
     * renders the field to show the new (or cached) total.
     */
    fetchCount: function() {
        if (_.isNull(this.collection.total)) {
            app.alert.show('fetch_count', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
        }

        this.collection.fetchTotal({
            success: _.bind(function() {
                if (!this.disposed) {
                    this.updateCount();
                }
            }, this),
            complete: function() {
                app.alert.dismiss('fetch_count');
            }
        });
    },

    /**
     * Updates {@link #countLabel the count label} and renders this field.
     *
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything.
     */
    updateCount: function(options) {
        this._setCountLabel(options);
        this.render();
    },

    /**
     * Returns the label for the count in the headerpane.
     *
     * If you would like to customize these, the following labels are being
     * used: `TPL_LIST_HEADER_COUNT`, `TPL_LIST_HEADER_COUNT_PARTIAL`,
     * `TPL_LIST_HEADER_COUNT_TOTAL`, and `TPL_LIST_HEADER_COUNT_TOOLTIP`.
     *
     * There are several ways the total count label is represented, depending on
     * the state of `this.collection`. If the collection contains all the
     * records, the label will display `this.collection.length`, for example:
     *
     *     (17)
     *
     * If `this.collection.total` exists and is cached, the label will display
     * in the form:
     *
     *     (20 of 50)
     *
     * Otherwise, the returned label will include the link to fetch the total:
     *
     *     (20 of <a data-action="count">21+</a>)
     *
     * @protected
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values. Defaults to
     *   `this.collection.length`.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything. Defaults to
     *   `false`.
     * @return {string|Handlebars.SafeString} The label to use for the list view
     *   count.
     */
    _setCountLabel: function(options) {
        // Default properties.
        options = options || {};
        var length = this.collection.length;
        var fullyFetched = this.collection.next_offset <= 0;
        // Override default properties with passed-in values.
        length = !_.isUndefined(options.length) ? options.length : length;
        fullyFetched = !_.isUndefined(options.hasMore) ? !options.hasMore : fullyFetched;

        if (!length && !this.collection.dataFetched) {
            return this.countLabel = '';
        }

        var tplKey = 'TPL_LIST_HEADER_COUNT_TOTAL';
        var context = {num: length};

        if (fullyFetched) {
            tplKey = 'TPL_LIST_HEADER_COUNT';
        } else if (!_.isNull(this.collection.total)) {
            context.total = this.collection.total;
        } else {
            var tooltipLabel = app.lang.get('TPL_LIST_HEADER_COUNT_TOOLTIP', this.module);
            // FIXME: When SC-3681 is ready, we will no longer have the need for
            // this link, since the total will be displayed by default.
            context.total = new Handlebars.SafeString(
                '<a data-action="count" rel="tooltip" data-placement="right" title="' + tooltipLabel +'">' +
                Handlebars.Utils.escapeExpression(
                    app.lang.get('TPL_LIST_HEADER_COUNT_PARTIAL', this.module, {num: context.num + 1})
                ) + '</a>'
            );
        }

        // FIXME: When SC-3681 is ready, remove the SafeString call.
        return this.countLabel = new Handlebars.SafeString(app.lang.get(tplKey, this.module, context));
    },

    /**
     * @override
     *
     * Re-renders the field when the attached collection is `reset`. Also
     * handles executing a request for the total count when a `pagination` event
     * occurs on the context. We do this on `pagination` because it is a
     * user-initiated action - if we request the count on `reset` as well it
     * would decrease performance.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }

        this.listenTo(this.collection, 'remove reset', function() {
            if (!this.disposed) {
                this.updateCount();
            }
        });
        this.listenTo(this.context, 'paginate', function() {
            if (!this.disposed) {
                this.fetchCount();
            }
        });
        this.listenTo(this.context, 'refresh:count', function(hasAmount, properties) {
            if (!this.disposed) {
                this.updateCount(properties);
            }
        });
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CurrencyField
 * @alias SUGAR.App.view.fields.BaseCurrencyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Currency Field (base) 

    /**
     * list of events to listen for
     * @type {Object}
     */
    'events': {
        'click': 'updateCss'
    },
    /**
     * @type {String}
     * field value non-formatted or converted
     */
    transactionValue: '',
    /**
     * @type {Object}
     * reference to the currency dropdown field object
     */
    _currencyField: null,
    /**
     * @type {Boolean}
     * whether or not the currency dropdown is hidden from view
     */
    hideCurrencyDropdown: false,
    /**
     * @type {String}
     * last known record currency id
     */
    _lastCurrencyId: null,

    plugins: [
        'EllipsisInline',
        'Tooltip'
    ],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Do we have edit access to this field?
     */
    hasEditAccess: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var currencyField = this.def.currency_field || 'currency_id',
            currencyFieldValue, baseRateField, baseRateFieldValue;

        if (this.model.isNew() && (!this.model.isCopy())) {
            // new records are set the user's preferred currency
            currencyFieldValue = app.user.getPreference('currency_id');
            this.model.set(currencyField, currencyFieldValue);

            // set the base rate for the user's preferred currency
            baseRateField = this.def.base_rate_field || 'base_rate';
            baseRateFieldValue = app.metadata.getCurrency(currencyFieldValue).conversion_rate;
            this.model.set(baseRateField, baseRateFieldValue);

            // Modules such as `Forecasts` uses models that aren't `Data.Bean`
            if (_.isFunction(this.model.setDefault)) {
                var defaults = {};
                defaults[currencyField] = currencyFieldValue;
                defaults[baseRateField] = baseRateFieldValue;
                this.model.setDefault(defaults);
            }
        }
        this.hasEditAccess = app.acl.hasAccess('edit', this.model.module, undefined, this.name);
        // hide currency dropdown on list views
        this.hideCurrencyDropdown = this.view.action === 'list';
        // track the last currency id to convert the value on change
        this._lastCurrencyId = this.model.get(currencyField);
    },

    /**
     * @inheritdoc
     *
     * Setup transactional amount if flag is present and transaction currency
     * is not base.
     * On edit view render the currency enum field associated with this field on
     * the correct placeholder
     *
     * @return {Object} this
     * @private
     */
    _render: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('_render');
        if (this.hideCurrencyDropdown === false && this.tplName === 'edit') {
            this.getCurrencyField().setElement(this.$('span[sfuuid="' + this.currencySfId + '"]'));
            this.$el.find('div.select2-container').css('min-width', '8px');
            this.getCurrencyField().render();
        }
        return this;
    },

    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.clearErrorDecoration();
            field.decorateError(errors);

        }, this);
    },

    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     *
     * If the incoming value is the same as the value on the model
     * then just set the currency value so it's formatted correctly
     * otherwise, set the new value on the model
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var self = this;
        var el = this.$el.find(this.fieldTag);
        el.on('change', function() {
            var val = self.unformat(el.val());
            if (_.isEqual(val, self.model.get(self.name))) {
                self.setCurrencyValue(val);
            } else {
                self.model.set(self.name, val);
            }
        });
    },

    /**
     * When currency changes, we need to make appropriate silent changes to the base rate.
     */
    bindDataChange: function() {
        // we do not call the parent which re-renders,
        // but instead update the value on the field directly
        this.model.on('change:' + this.name, this._valueChangeHandler, this);

        if (this.def.is_base_currency) {
            // do not add change handler to _usdollar fields
            return;
        }

        var currencyField = this.def.currency_field || 'currency_id';
        var baseRateField = this.def.base_rate_field || 'base_rate';
        // if the current_user doesn't have edit access to the field
        // don't add these listeners
        if (this.hasEditAccess && this.view.action !== 'list') {
            // if the base rate changes, it should trigger a field re-render
            this.model.on('change:' + baseRateField, function(model, baseRate, options) {
                // lets actually make sure this really changed before triggering the deferModelChange method.
                // that way if base_rate is a integer we can actually make sure it didn't change
                // eg: 1 to "1.000000"
                var newValue = app.math.round(baseRate, 6, true),
                    previousValue = app.math.round(model.previous(baseRateField), 6, true);
                if (!_.isEqual(newValue, previousValue)) {
                    if (options && _.isUndefined(options.revert)) {
                        this._deferModelChange();
                    }
                }
            }, this);
            this.model.on('change:' + currencyField, function(model, currencyId, options) {
                //When model is reset, it should not be called
                if (!currencyId || !this._lastCurrencyId || options.revert === true) {
                    this._lastCurrencyId = currencyId;
                    return;
                }

                // update the base rate in the model, set it silently since we are already going to do a re-render
                this.model.set(baseRateField, app.metadata.getCurrency(currencyId).conversion_rate, {silent: true});

                if (!_.isUndefined(this.view.getField('base_rate'))) {
                    this.view.getField('base_rate').render();
                }

                // convert the value to new currency on the model
                if (model.has(this.name)) {
                    var val = model.get(this.name);
                    if (val) {
                        this.model.set(
                            this.name,
                            app.currency.convertAmount(
                                val,
                                this._lastCurrencyId,
                                currencyId
                            ),
                            // we don't want to affect other bindings like sugar logic
                            // when updating a value upon a currency_id change,
                            // so set the model silently, then update the field value
                            // directly (see next func call)
                            {silent: true}
                        );
                    }
                    // now defer changes to the end of the thread to avoid conflicts
                    // with other events (from SugarLogic, etc.)
                    this._deferModelChange();
                }
                this._lastCurrencyId = currencyId;
            }, this);
        }
    },

    /**
     * Trigger the model change, but only if the current user has edit access to it.
     *
     * @private
     */
    _deferModelChange: function() {
        if (this.hasEditAccess) {
            _.defer(_.bind(function() {
                if (!this.disposed) {
                    this.model.trigger('change:' + this.name, this.model, this.model.get(this.name));
                }
            }, this));
        }
    },

    /**
     * Handler for when the value changes on the model.
     *
     * If action does not match edit, field is re-rendered, otherwise the field
     * value is updated, plus, if the currency of the given model is different
     * from the one we have, the supplied amount is also converted to the new
     * currency.
     *
     * @param {Data.Bean} model Model.
     * @param {String} value Amount.
     * @private
     */
    _valueChangeHandler: function(model, value) {
        if (this.action != 'edit') {
            this.render();
            return;
        }

        if (model.get('currency_id') !== this.model.get('currency_id')) {
            value = app.currency.convertAmount(
                value,
                model.get('currency_id'),
                this.model.get('currency_id')
            );
        }

        this.setCurrencyValue(value);
    },

    /**
     * set the currency value on the field directly
     *
     * @param {String} value
     */
    setCurrencyValue: function(value) {
        this.$('[name=' + this.name + ']').val(app.utils.formatNumberLocale(value));
    },

    /**
     * @inheritdoc
     *
     * Convert to base currency if flag is present.
     *
     * @param {Array/Object/String/Number/Boolean} value The value to format.
     * @return {String} the formatted value based on view name.
     */
    format: function(value) {
        if (_.isNull(value) || _.isUndefined(value) || _.isNaN(value)) {
            value = '';
        }

        if (this.tplName === 'edit') {
            this.currencySfId = this.getCurrencyField().sfId;
            return app.utils.formatNumberLocale(value);
        }

        var baseRate = this.model.get(this.def.base_rate_field || 'base_rate');
        var transactionalCurrencyId = this.model.get(this.def.currency_field || 'currency_id'),
            convertedCurrencyId = transactionalCurrencyId,
            origTransactionValue = value;

        // TODO review this forecasts requirement and make it work with css defined on metadata
        // force this to recalculate the transaction value if needed
        // and more importantly, clear out previous transaction value
        this.transactionValue = '';
        if (value === '') {
            return value;
        }
        if (this.def.is_base_currency) {
            // usdollar field, treat the field as base currency
            transactionalCurrencyId = convertedCurrencyId = app.currency.getBaseCurrencyId();
        } else {
            if (this.def.convertToBase && transactionalCurrencyId !== app.currency.getBaseCurrencyId()) {
                if (this.def.showTransactionalAmount) {
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                }
                value = app.currency.convertWithRate(value, baseRate) || 0;
                convertedCurrencyId = app.currency.getBaseCurrencyId();
            }
        }
        // convert value to user preferred currency
        if ((this.def.is_base_currency || this.def.convertToBase) &&
            !this.def.skip_preferred_conversion &&
            app.user.get('preferences').currency_show_preferred) {
                var userPreferredCurrencyId = app.user.getPreference('currency_id');
                if (userPreferredCurrencyId !== transactionalCurrencyId) {
                    convertedCurrencyId = userPreferredCurrencyId;

                    // when we are displaying in the user preferred currency, the transactional
                    // amount should equal the row amount
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                    value = app.currency.convertWithRate(
                        value,
                        '1.0',
                        app.metadata.getCurrency(userPreferredCurrencyId).conversion_rate
                    );
                } else {
                    // user preferred same as transactional, no conversion required
                    this.transactionValue = '';
                    convertedCurrencyId = transactionalCurrencyId;
                    value = origTransactionValue;
                }
        }
        return app.currency.formatAmountLocale(value, convertedCurrencyId);
    },

    /**
     * @inheritdoc
     *
     * @param {String} value The value to unformat.
     * @return {Number} Unformatted value.
     */
    unformat: function(value) {
        var unformattedValue;
        if (this.tplName === 'edit') {
            unformattedValue = app.utils.unformatNumberStringLocale(value);
        } else {
            unformattedValue = app.currency.unformatAmountLocale(value);
        }

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue)) {
            // if no precision is defined, default to 6 which is the system default
            var precision = this.def && this.def.precision || 6;
            return app.math.round(unformattedValue, precision, true);
        }

        return value;
    },

    /**
     * update dropdown css to active state
     */
    updateCss: function() {
        $('div.select2-drop.select2-drop-active').width('auto');
    },

    /**
     * Get the currency field related to this currency amount.
     *
     * @return {View.Field} the currency field associated.
     */
    getCurrencyField: function() {

        if (!_.isNull(this._currencyField)) {
            return this._currencyField;
        }

        var currencyDef = this.model.fields[this.def.currency_field || 'currency_id'];
        currencyDef.type = 'enum';
        currencyDef.options = app.currency.getCurrenciesSelector(Handlebars.compile('{{symbol}} ({{iso4217}})'));
        currencyDef.enum_width = '100%';
        currencyDef.searchBarThreshold = this.def.searchBarThreshold || 7;

        this._currencyField = app.view.createField({
            def: currencyDef,
            view: this.view,
            viewName: this.tplName,
            model: this.model
        });
        this._currencyField.defaultOnUndefined = false;

        return this._currencyField;
    },

    /**
     * set the mode of the dropdown field
     * @param {String} the mode name.
     */
    setMode: function(name) {
        this._super('setMode', [name]);
        if (this.action === 'edit') {
            this.getCurrencyField().setMode(name);
        }
    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('dispose');
    }
}) },
"email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailField
 * @alias SUGAR.App.view.fields.BaseEmailField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email Field (base) 

    events: {
        'change .existingAddress': 'updateExistingAddress',
        'click  .btn-edit':        'toggleExistingAddressProperty',
        'click  .removeEmail':     'removeExistingAddress',
        'click  .addEmail':        'addNewAddress',
        'change .newEmail':        'addNewAddress'
    },
    _flag2Deco: {
        primary_address: {lbl: "LBL_EMAIL_PRIMARY", cl: "primary"},
        opt_out: {lbl: "LBL_EMAIL_OPT_OUT", cl: "opted-out"},
        invalid_email: {lbl: "LBL_EMAIL_INVALID", cl: "invalid"}
    },
    plugins: ['Tooltip', 'ListEditable', 'EmailClientLaunch'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};

        // By default, compose email link should be allowed
        if (_.isUndefined(options.def.emailLink)) {
            options.def.emailLink = true;
        }

        // Check if the email1 field was made required, if-so copy that property to the dynamic field.
        if (options.model &&
            options.model.fields &&
            options.model.fields.email1 &&
            options.model.fields.email1.required) {
            options.def.required = options.model.fields.email1.required;
        }

        if (options.view.action === 'filter-rows') {
            options.viewName = 'filter-rows-edit';
        }

        this._super('initialize', [options]);

        //set model as the related record when composing an email (copy is made by plugin)
        this.addEmailOptions({related: this.model});

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;
    },

    /**
     * When data changes, re-render the field only if it is not on edit (see MAR-1617).
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function() {
            if (this.action !== 'edit') {
                this.render();
            }
        }, this);
    },

    /**
     * In edit mode, render email input fields using the edit-email-field template.
     * @inheritdoc
     * @private
     */
    _render: function() {
        var emailsHtml = '';

        this._super("_render");

        if (this.tplName === 'edit') {
            // Add email input fields for edit
            _.each(this.value, function(email) {
                emailsHtml += this._buildEmailFieldHtml(email);
            }, this);
            this.$el.prepend(emailsHtml);
        }
    },

    /**
     * Get HTML for email input field.
     * @param {Object} email
     * @return {Object}
     * @private
     */
    _buildEmailFieldHtml: function(email) {
        var editEmailFieldTemplate = app.template.getField('email', 'edit-email-field'),
            emails = this.model.get(this.name),
            index = _.indexOf(emails, email);

        return editEmailFieldTemplate({
            max_length: this.def.len,
            index: index === -1 ? emails.length-1 : index,
            email_address: email.email_address,
            primary_address: email.primary_address,
            opt_out: email.opt_out,
            invalid_email: email.invalid_email
        });
    },

    /**
     * Event handler to add a new address field.
     * @param {Event} evt
     */
    addNewAddress: function(evt){
        if (!evt) return;

        var email = this.$(evt.currentTarget).val() || this.$('.newEmail').val(),
            currentValue,
            emailFieldHtml,
            $newEmailField;

        email = $.trim(email);

        if ((email !== '') && (this._addNewAddressToModel(email))) {
            // build the new email field
            currentValue = this.model.get(this.name);
            emailFieldHtml = this._buildEmailFieldHtml({
                email_address: email,
                primary_address: currentValue && (currentValue.length === 1),
                opt_out: false,
                invalid_email: false
            });

            // append the new field before the new email input
            $newEmailField = this._getNewEmailField()
                .closest('.email')
                .before(emailFieldHtml);

            // add tooltips
            this.addPluginTooltips($newEmailField.prev());

            if (this.def.required && this._shouldRenderRequiredPlaceholder()) {
                // we need to remove the required place holder now
                var label = app.lang.get('LBL_REQUIRED_FIELD', this.module),
                    el = this.$(this.fieldTag).last(),
                    placeholder = el.prop('placeholder').replace('(' + label + ') ', '');

                el.prop('placeholder', placeholder.trim()).removeClass('required');
            }
        }

        this._clearNewAddressField();
    },

    /**
     * Event handler to update an email address.
     * @param {Event} evt
     */
    updateExistingAddress: function(evt) {
        if (!evt) return;
        var $inputs = this.$('.existingAddress'),
            $input = this.$(evt.currentTarget),
            index = $inputs.index($input),
            newEmail = $input.val(),
            emails = this.model.get(this.name) || [],
            primaryRemoved;

        newEmail = $.trim(newEmail);

        if (newEmail === '') {
            // remove email if email is empty
            primaryRemoved = this._removeExistingAddressInModel(index);

            $input
                .closest('.email')
                .remove();

            if (primaryRemoved) {
                // on list views we need to set the current value on the input
                if (this.view && this.view.action === 'list') {
                    var primaryAddress = _.filter(emails, function(address) {
                        if (address.primary_address) {
                            return true;
                        }
                    });
                    if(primaryAddress[0] && primaryAddress[0].email_address) {
                        app.alert.show('list_delete_email_info', {
                            level: 'info',
                            autoClose: true,
                            messages: app.lang.get('LBL_LIST_REMOVE_EMAIL_INFO')
                        });
                        $input.val(primaryAddress[0].email_address);
                    }
                }
                this.$('[data-emailproperty=primary_address]')
                    .first()
                    .addClass('active');
            }
            return;
        }
        if (this.tplName === 'list-edit') {
            // In list-edit mode the index is not always at the index of the current target.
            _.find(emails, function(email, i) {
                if (email.primary_address) {
                    index = i;
                    return true;
                }
            });
        }
        this._updateExistingAddressInModel(index, newEmail);
    },

    /**
     * Event handler to remove an email address.
     * @param {Event} evt
     */
    removeExistingAddress: function(evt) {
        if (!evt) return;

        var $deleteButtons = this.$('.removeEmail'),
            $deleteButton = this.$(evt.currentTarget),
            index = $deleteButtons.index($deleteButton),
            primaryRemoved,
            $removeThisField;

        primaryRemoved = this._removeExistingAddressInModel(index);

        $removeThisField = $deleteButton.closest('.email');
        this.removePluginTooltips($removeThisField); // remove tooltips
        $removeThisField.remove();

        if (primaryRemoved) {
            // If primary has been removed, the first email address is the primary address.
            this.$('[data-emailproperty=primary_address]')
                .first()
                .addClass('active');
        }

        // if this field is required, and there is nothing in the model, then we should decorate it as required
        if (this.def.required && _.isEmpty(this.model.get(this.name))) {
            this.decorateRequired();
        }
    },

    /**
     * Event handler to toggle email address properties.
     * @param {Event} evt
     */
    toggleExistingAddressProperty: function(evt) {
        if (!evt) return;

        var $property = this.$(evt.currentTarget),
            property = $property.data('emailproperty'),
            $properties = this.$('[data-emailproperty='+property+']'),
            index = $properties.index($property);

        if (property === 'primary_address') {
            $properties.removeClass('active');
        }

        this._toggleExistingAddressPropertyInModel(index, property);
    },

    /**
     * Add the new email address to the model.
     * @param {String} email
     * @return {boolean} Returns true when a new email is added.  Returns false if duplicate is found,
     *          and was not added to the model.
     * @private
     */
    _addNewAddressToModel: function(email) {
        var existingAddresses = this.model.get(this.name) ? app.utils.deepCopy(this.model.get(this.name)) : [],
            dupeAddress = _.find(existingAddresses, function(address){
                return (address.email_address === email);
            }),
            success = false;

        if (_.isUndefined(dupeAddress)) {
            existingAddresses.push({
                email_address: email,
                primary_address: (existingAddresses.length === 0)
            });
            this.model.set(this.name, existingAddresses);
            success = true;
        }

        return success;
    },

    /**
     * Update email address in the model.
     * @param {Number} index
     * @param {String} newEmail
     * @private
     */
    _updateExistingAddressInModel: function(index, newEmail) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));
        //Simply update the email address
        existingAddresses[index].email_address = newEmail;
        if (this.tplName === 'edit') {
            this.model.set(this.name + (index + 1), newEmail);
        }
        this.model.set(this.name, existingAddresses);
    },

    /**
     * Toggle email address properties: primary, opt-out, and invalid.
     * @param {Number} index
     * @param {String} property
     * @private
     */
    _toggleExistingAddressPropertyInModel: function(index, property) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));

        //If property is primary_address, we want to make sure one and only one primary email is set
        //As a consequence we reset all the primary_address properties to 0 then we toggle property for this index.
        if (property === 'primary_address') {
            existingAddresses[index][property] = false;
            _.each(existingAddresses, function(email, i) {
                if (email[property]) {
                    existingAddresses[i][property] = false;
                }
            });
        }

        // Toggle property for this email
        if (existingAddresses[index][property]) {
            existingAddresses[index][property] = false;
        } else {
            existingAddresses[index][property] = true;
        }

        this.model.set(this.name, existingAddresses);
    },

    /**
     * Remove email address from the model.
     * @param {Number} index
     * @return {boolean} Returns true if the removed address was the primary address.
     * @private
     */
    _removeExistingAddressInModel: function(index) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name)),
            primaryAddressRemoved = !!existingAddresses[index]['primary_address'];

        //Reject this index from existing addresses
        existingAddresses = _.reject(existingAddresses, function (emailInfo, i) { return i == index; });

        // If a removed address was the primary email, we still need at least one address to be set as the primary email
        if (primaryAddressRemoved) {
            //Let's pick the first one
            var address = _.first(existingAddresses);
            if (address) {
                address.primary_address = true;
            }
        }

        this.model.set(this.name, existingAddresses);
        return primaryAddressRemoved;
    },

    /**
     * Clear out the new email address field.
     * @private
     */
    _clearNewAddressField: function() {
        this._getNewEmailField()
            .val('');
    },

    /**
     * Get the new email address input field.
     * @return {jQuery}
     * @private
     */
    _getNewEmailField: function() {
        return this.$('.newEmail');
    },

    /**
     * Need to call `decorateError` after all email fields are rendered.
     * @inheritdoc
     *
     * FIXME This is a temporary fix due to time constraints, a proper solution will be implemented in SC-4358
     */
    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.decorateError(errors);
        }, this);
    },

    /**
     * Custom error styling for the e-mail field
     * @param {Object} errors
     * @override BaseField
     */
    decorateError: function(errors){
        var emails;

        this.$el.closest('.record-cell').addClass("error");

        //Select all existing emails
        emails = this.$('input:not(.newEmail)');

        _.each(errors, function(errorContext, errorName) {
            //For `email` validator the error is specific to an email
            if (errorName === 'email' || errorName === 'duplicateEmail') {

                // For each of our `sub-email` fields
                _.each(emails, function(e) {
                    var $email = this.$(e),
                        email = $email.val();

                    var isError = _.find(errorContext, function(emailError) { return emailError === email; });
                    // if we're on an email sub field where error occurred, add error styling
                    if(!_.isUndefined(isError)) {
                        this._addErrorDecoration($email, errorName, [isError]);
                    }
                }, this);
            //For required or primaryEmail we want to decorate only the first email
            } else {
                var $email = this.$('input:first');
                this._addErrorDecoration($email, errorName, errorContext);
            }
        }, this);
    },

    _addErrorDecoration: function($input, errorName, errorContext) {
        var isWrapped = $input.parent().hasClass('input-append');
        if (!isWrapped)
            $input.wrap('<div class="input-append error '+this.fieldTag+'">');
        $input.next('.error-tooltip').remove();
        $input.after(this.exclamationMarkTemplate([app.error.getErrorString(errorName, errorContext)]));
        this.createErrorTooltips($input.next('.error-tooltip'));
    },

    /**
     * Binds DOM changes to set field value on model.
     * @param {Backbone.Model} model model this field is bound to.
     * @param {String} fieldName field name.
     */
    bindDomChange: function() {
        if(this.tplName === 'list-edit') {
            this._super("bindDomChange");
        }
    },

    /**
     * To display representation
     * @param {String|Array} value single email address or set of email addresses
     */
    format: function(value) {
        value = app.utils.deepCopy(value);
        if (_.isArray(value) && value.length > 0) {
            // got an array of email addresses
            _.each(value, function(email) {
                // On render, determine which e-mail addresses need anchor tag included
                // Needed for handlebars template, can't accomplish this boolean expression with handlebars
                email.hasAnchor = this.def.emailLink && !email.opt_out && !email.invalid_email;
            }, this);
        } else if ((_.isString(value) && value !== "") || this.view.action === 'list') {
            // expected an array with a single address but got a string or an empty array
            value = [{
                email_address:value,
                primary_address:true,
                hasAnchor:true
            }];
        }

        value = this.addFlagLabels(value);
        return value;
    },

    /**
     * Build label that gets displayed in tooltips.
     * @param {Object} value
     * @return {Object}
     */
    addFlagLabels: function(value) {
        var flagStr = "", flagArray;
        _.each(value, function(emailObj) {
            flagStr = "";
            flagArray = _.map(emailObj, function (flagValue, key) {
                if (!_.isUndefined(this._flag2Deco[key]) && this._flag2Deco[key].lbl && flagValue) {
                    return app.lang.get(this._flag2Deco[key].lbl);
                }
            }, this);
            flagArray = _.without(flagArray, undefined);
            if (flagArray.length > 0) {
                flagStr = flagArray.join(", ");
            }
            emailObj.flagLabel = flagStr;
        }, this);
        return value;
    },

    /**
     * To API representation
     * @param {String|Array} value single email address or set of email addresses
     */
    unformat: function(value) {
        if (this.view.action === 'list') {
            var emails = app.utils.deepCopy(this.model.get(this.name));

            if (!_.isArray(emails)) { // emails is empty, initialize array
                emails = [];
            }

            emails = _.map(emails, function(email) {
                if (email.primary_address && email.email_address !== value) {
                    email.email_address = value;
                }
                return email;
            }, this);

            // Adding a new email
            if (emails.length == 0) {
                emails.push({
                    email_address: value,
                    primary_address: true
                });
            }

            return emails;
        }

        if (this.view.action === 'filter-rows') {
            return value;
        }
    },

    /**
     * Apply focus on the new email input field.
     */
    focus: function () {
        if(this.action !== 'disabled') {
            this._getNewEmailField().focus();
        }
    },

    /**
     * Retrieve link specific email options for launching the email client
     * Builds upon emailOptions on this
     *
     * @param $link
     * @private
     */
    _retrieveEmailOptionsFromLink: function($link) {
        return {
            to_addresses: [
                {
                    email: $link.data('email-to'),
                    bean: this.emailOptions.related
                }
            ]
        };
    }
}) },
"editrecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EditrecurrencesbuttonField is a field for Meetings/Calls for the ability editing all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EditrecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseEditrecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Editrecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if meeting displayed is not recurring
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for editing all recurring records of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        this.context.trigger('all_recurrences:edit');
    }
}) },
"repeat-dow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Day of Week is a custom field for Meetings/Calls used to set
 * days of the week for a Weekly recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatDowField
 * @alias SUGAR.App.view.fields.BaseRepeatDowField
 * @extends View.Fields.Base.EnumField
 */
({
	// Repeat-dow Field (base) 

    extendsFrom: 'EnumField',

    defaultOnUndefined: false, //custom default behavior defined below

    /**
     * @inheritdoc
     *
     * Set default value for this field and
     * add validation (required if `repeat_type` is weekly)
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'enum';

        this.def['default'] = this.getDefaultDayOfWeek();

        this.model.addValidationTask(
            'repeat_dow_validator_' + this.cid,
            _.bind(this._doValidateRepeatDow, this)
        );
    },

    /**
     * Get the default day of week (current day of the week)
     *
     * @return {String} Day of the week
     */
    getDefaultDayOfWeek: function() {
        var isoDayOfWeek = app.date().isoWeekday(),
            sugarDayOfWeek = (isoDayOfWeek === 7) ? 0 : isoDayOfWeek;
        return sugarDayOfWeek.toString();
    },

    /**
     * @inheritdoc
     *
     * Model day of week format is a string of numeric characters ('1'-'7')
     * Select2 needs an array of these numeric strings
     */
    format: function(value) {
        return (_.isString(value)) ? value.split('').sort() : value;
    },

    /**
     * @inheritdoc
     *
     * Select2 array of numeric strings to Model numeric string format
     */
    unformat: function(value) {
        return (_.isArray(value)) ? value.sort().join('') : value;
    },

    /**
     * Custom required validator for the `repeat_dow` field.
     *
     * This validates `repeat_dow` based on the value of `repeat_type` -
     * if Weekly repeat type, repeat day of week must be specified
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatDow: function(fields, errors, callback) {
        var repeatType = this.model.get('repeat_type'),
            repeatDow = this.model.get(this.name);

        if (repeatType === 'Weekly' && (!_.isString(repeatDow) || repeatDow.length < 1)) {
            errors[this.name] = {'required': true};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_dow_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"radioenum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RadioenumField
 * @alias SUGAR.App.view.fields.BaseRadioenumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Radioenum Field (base) 

    // On list-edit template,
    // we want the radio buttons to be replaced by a select so each method must call the EnumField method instead.
    extendsFrom: 'EnumField',
    plugins: ["ListEditable"],
    fieldTag: "input",

    _render: function(){
        this.loadEnumOptions(false, function() {
                if (!this.disposed) {
                    this.render();
                }
            }
        );
        app.view.Field.prototype._render.call(this);
        if(this.tplName === 'list-edit') {
            this._super("_render");
        }
    },
    bindDomChange: function() {
        if (this.tplName === 'list-edit') {
            this._super("bindDomChange");
        } else {
            if (!(this.model instanceof Backbone.Model)) return;
            var self = this;
            var el = this.$el.find(this.fieldTag);
            el.on("change", function() {
                self.model.set(self.name, self.unformat(self.$(self.fieldTag+":radio:checked").val()));
            });
        }
    },
    format: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("format", [value]);
        } else {
            return app.view.Field.prototype.format.call(this, value);
        }
    },
    unformat: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("unformat", [value]);
        } else {
            return app.view.Field.prototype.unformat.call(this, value);
        }
    },
    decorateError: function(errors) {
        if (this.tplName === 'list-edit') {
            return this._super("decorateError", [errors]);
        } else {

            var errorMessages = [],
                $tooltip;

            // Add error styling
            this.$el.closest('.record-cell').addClass('error');
            this.$el.addClass('error');
            // For each error add to error help block
            _.each(errors, function(errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
            this.$(this.fieldTag).last().closest('p').append(this.exclamationMarkTemplate(errorMessages));
            $tooltip = this.$('.error-tooltip');
            if (_.isFunction($tooltip.tooltip)) {
                var tooltipOpts = { container: 'body', placement: 'top', trigger: 'click' };
                $tooltip.tooltip(tooltipOpts);
            }
        }
    },
    clearErrorDecoration: function() {
        if (this.tplName === 'list-edit') {
            return this._super("clearErrorDecoration");
        } else {
            var ftag = this.fieldTag || '';
            // Remove previous exclamation then add back.
            this.$('.add-on').remove();
            this.$el.removeClass(ftag);
            this.$el.removeClass("error");
            this.$el.closest('.record-cell').removeClass("error");
        }
    }
}) },
"phone": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PhoneField
 * @alias SUGAR.App.view.fields.BasePhoneField
 * @extends View.Fields.Base.BaseField
 */
({
	// Phone Field (base) 

    plugins: ['EllipsisInline'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @override
     * @param options
     */
    initialize: function (options) {
        var serverInfo = app.metadata.getServerInfo();

        this.skypeEnabled = serverInfo.system_skypeout_on ? true : false;

        this._super('initialize', [options]);

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;
    },
    /**
     * @override
     * @param value
     * @return {Mixed}
     */
    format: function (value) {
        if ((this.action === 'list' || this.action === 'detail' || this.action === 'record')
            && this.isSkypeFormatted(value)
            && this.skypeEnabled) {
            this.skypeValue = this.skypeFormat(value);
        }
        return value;
    },
    /**
     * checks if value should be skype formatted + 00 or 011 leading is necessary
     * @param value {String}
     * @return {boolean}
     */
    isSkypeFormatted: function (value) {
        if (_.isString(value)) {
            return value.substr(0, 1) === '+' || value.substr(0, 2) === '00' || value.substr(0, 3) === '011';
        } else {
            return false;
        }
    },
    /**
     * strips extra characters from phone number for skype
     *
     * Document: https://support.skype.com/en/faq/FA12006/how-do-i-script-webpages-to-find-phone-numbers-using-click-to-call
     *
     * @param value {String}
     * @return {string}
     */
    skypeFormat: function (value) {
        if (_.isString(value)) {
            var number = value.replace(/[^\d\(\)\.\-\/ ]/g, '');

            if(null !== number.match(/[\-]/g) && number.match(/[\-]/g).length >= 2) {
                // ensure format is "+CC-NDC-SN"
                number = number.replace(/[^\d\-]/g, '')
                    .replace(/(\d+)\-(\d+)\-([\d\-]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('-');
                    });
            } else if(null !== number.match(/[\.]/g) && number.match(/[\.]/g).length >= 2) {
                // ensure format is "+CC.NDC.SN"
                number = number.replace(/[^\d\.]/g, '')
                    .replace(/(\d+)\.(\d+)\.([\d\.]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('.');
                    });
            } else if(null !== number.match(/\(\D*\d+\D*\)/g)) {
                // ensure format is "+CC(NDC)SN"
                number = number.replace(/[^\d\(\)]+/g, '')
                    .replace(/(\d+)\((\d+)\)([0-9\(\)]+)/g, function($0, $1, $2, $3) {
                        return $1 + '(' + $2 + ')' + $3.replace(/\D/g, '');
                    })
            } else if(null !== number.match(/[\/]/g) && number.match(/[\/]/g).length >= 2) {
                // ensure format is "+CC/NDC/SN"
                number = number.replace(/[^\d\/]/g, '')
                    .replace(/(\d+)\/(\d+)\/([\d\/]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('/');
                    });
            } else if(null !== number.match(/\S+\s+\S+\s+[\S\s]+/g)) {
                // ensure format is "+CC NDC SN"
                number = number.replace(/(\S+)\s+(\S+)\s+([\S\s]+)/g, function($0, $1, $2, $3) {
                    return _.map([$1, $2, $3], function(s) {
                        return s.replace(/\D/g, '');
                    }).join(' ');
                })
            } else {
                number = number.replace(/\D/g, '');
            }
            if(value.substr(0, 1) === '+' || (number.substr(0, 2) !== '00' && number.substr(0, 3) !== '011')) {
                number = '+' + number;
            }
            return number;

        } else if (_.isNumber(value)) {
            if(value.substr(0, 2) !== '00' && value.substr(0, 3) !== '011') {
                value = '+' + value;
            }
        }
        return value;
    }
}) },
"status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.StatusField
 * @alias SUGAR.App.view.fields.BaseStatusField
 * @extends View.Fields.Base.BaseField
 */
({
	// Status Field (base) 

    /**
     * Additional CSS Classes to be added to hbs
     */
    cssClasses: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.buildCSSClasses();
    },

    /**
     * Gets the field value and sets cssClasses
     */
    buildCSSClasses: function() {
        var status = this.model.get(this.name);
        if (status) {
            status = status.replace(' ', '_');
            this.cssClasses = 'field_' + this.name + '_' + status;
        }
    }
}) },
"email-text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailTextField
 * @alias SUGAR.App.view.fields.BaseEmailTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-text Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    // The purpose of email-text is to provide a simpler textfield email
    // when our main email widget is overkill. For example, the first time
    // login wizard uses email-text. Note that the email mutated is the
    // primary_address email.
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};
        if (_.isUndefined(options.def.link)) {
            options.def.link = true;
        }

        this._super('initialize', [options]);
    },
   /**
     * Formats for display
     * If we have a proper email value from model we parse out just
     * the primary address part since we're using a simple text field.
     * @param  {Object} value The value retrieved from model for email
     * @return {Object}       Normalized email value for simple field
     */
    format: function(value) {
        if(_.isArray(value)) {
            var primaryEmail = _.find(value, function(email) {
                return email.primary_address && email.primary_address !== "0";
            });
            return primaryEmail ? primaryEmail.email_address : '';
        }
        return value;
    },
    /**
     * Prepares email for going back to API
     * @param  {Object} value The value
     * @return {Object}       API ready value for email
     */
    unformat: function(value) {
        var self = this,
            emails = this.model.get('email'),
            changed = false;
        if(!_.isArray(emails)){emails = [];}
        _.each(emails, function(email, index) {
            // If we find a primary address and its email_address is different
            if(email.primary_address &&
                email.primary_address !== "0" &&
                email.email_address !== value)
            {
                changed = true;
                emails[index].email_address = value;
            }
        }, this);
        // If brand new email we push a primary address
        if (emails.length == 0) {
            emails.push({
                email_address:   value,
                primary_address: "1",
                hasAnchor:       false,
                _wasNotArray:    true
            });
            changed = true;
        }
        if (changed) {
            this.model.set(this.name, emails);
            this.model.trigger('change:' + this.name, this, emails);
        }
        return emails;
    }
}) },
"text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextField
 * @alias SUGAR.App.view.fields.BaseTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Text Field (base) 

    /**
     * @inheritdoc
     *
     * Format the value to a string.
     * Return an empty string for undefined, null and object types.
     * Convert boolean to 1 or 0.
     * Convert array, int and other types to a string.
     *
     * @param {mixed} value to format
     * @return {string} the formatted value
     */
    format: function(value) {
        if (_.isString(value)) {
            return value;
        }

        if (_.isUndefined(value) || 
            _.isNull(value) ||
            (_.isObject(value) && !_.isArray(value))
        ) {
            return '';
        }

        if (_.isBoolean(value)) {
            return value === true ? '1' : '0';
        }

        return value.toString();
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value.
     */
    unformat: function(value) {
        return value.trim();
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Rowaction is a button that when selected will trigger a Backbone Event.
 *
 * @class View.Fields.Base.RowactionField
 * @alias SUGAR.App.view.fields.BaseRowactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Rowaction Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.options.def.events = _.extend({}, this.options.def.events, {
            'click .rowaction': 'rowActionSelect'
        });
        this._super('initialize', [options]);
    },

    /**
     * Triggers event provided at this.def.event on the view's context object by default.
     * Can be configured to trigger events on 'view' itself or the view's 'layout'.
     *
     * @see View.Fields.Base.RowactionField#getTarget
     * @param {Event} evt The click event.
     */
    rowActionSelect: function(evt) {
        var eventName = $(evt.currentTarget).data('event') || this.def.event;

        if (eventName) {
            this.getTarget().trigger(eventName, this.model, this, evt);
        }
    },

    /**
     * Returns the target on which the event should be triggered.
     *
     * @return {Core.Context} By default, the event should be triggered on the
     * context.
     * @return {View.View} The event should be triggered on the view.
     * @return {View.Layout} The event should be triggered on the layout.
     */
    getTarget: function() {
        var target;

        switch (this.def.target) {
            case 'view':
                target = this.view;
                break;
            case 'layout':
                target = this.view.layout;
                break;
            default:
                target = this.view.context;
        }

        return target;
    }
}) },
"related-contact": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RelatedContactField is needed because BaseField specifically gets values from specific keys
 * on the model, and for the HistorySummaryView list, we need to set values on the model
 * that are different from what BaseField uses so it doesn't conflict with the other values
 * on BaseField's model
 *
 * @class View.Fields.Base.RelatedContactField
 * @alias SUGAR.App.view.fields.BaseRelatedContactField
 * @extends View.Fields.Base.BaseField
 */
({
	// Related-contact Field (base) 

    events: {
        'click a': 'onLinkClicked'
    },

    /**
     * Holds the href for the field link
     */
    linkRoute: '',

    /**
     * @inheritdoc
     * @override
     *
     * Overriding since the parent buildHref would use 'id' not 'contact_id'
     * to create the href link
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module'),
            id = this.model.get('contact_id');
        this.linkRoute = '#' + app.router.buildRoute(module, id, defRoute.action);
        return this.linkRoute;
    },

    /**
     * Intercepts the clicked link, if the user clicked on the Contact
     * that the user was already viewing, refresh the page, because otherwise
     * the url will not change
     *
     * @param {jQuery.Event} evt The click event from the link
     */
    onLinkClicked: function(evt) {
        var currentRoute = '#' + Backbone.history.getFragment();
        if (currentRoute === this.linkRoute) {
            app.router.refresh();
        }
    }
}) }
}}
,
"views": {
"base": {
"filtered-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredListView
 * @alias SUGAR.App.view.views.BaseFilteredListView
 * @extends View.Views.Base.ListView
 */
({
	// Filtered-list View (base) 

    extendsFrom: 'ListView',

    /**
     * Filtered and sorted collection set.
     * @property
     */
    filteredCollection: [],

    /**
     * Typed search keyword.
     * @property
     */
    searchTerm: '',

    /**
     * Convert the available filter to the regular expression.
     * @property
     */
    _patternToReg: {
        startsWith: '^(term)',
        endsWith: '(term)$',
        contains: '(term)'
    },

    /**
     * Filter the metadata in order to initiate the searchable fields.
     * @protected
     */
    _initFilter: function() {
        var filter = this._filter || _.chain(this.getFields())
            .filter(function(field) {
                return field.filter;
            })
            .map(function(field) {
                return {
                    name: field.name,
                    label: app.lang.get(field.label, this.module),
                    filter: field.filter
                };
            }, this)
            .value();
        this.context.trigger('filteredlist:filter:set', _.pluck(filter, 'label'));

        if (_.isEmpty(filter)) {
            return;
        }
        this._filter = filter;
    },

    /**
     * Filtering collection that matches with search term.
     * In order to activate filtering on the field,
     * the filter term should be defined in the metadata.
     * There are three type of filter type (startsWith, contains, endsWith).
     *
     * Examples:
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'filter' => 'startsWith',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'before_field_value',
     *     'filter' => 'contains',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'datetime',
     *     'filter' => 'endsWith',
     *     ),
     * </code></pre>
     */
    filterCollection: function() {
        var term = this.searchTerm,
            filter = this._filter;

        if (!_.isEmpty(term) && _.isString(term)) {
            this.filteredCollection = this.collection.filter(function(model) {
                return _.some(filter, function(params) {
                    var pattern = this._patternToReg[params.filter].replace('term', term),
                        tester = new RegExp(pattern, 'i');
                    return tester.test(model.get(params.name));
                }, this);
            }, this);
        }
    },

    /**
     * Set the current search term and then reload the table.
     * @param {String} term Search term.
     */
    setSearchTerm: function(term) {
        this.searchTerm = term;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * Sort the collection based on user input.
     * In order to activate sorting on the field,
     * 'sortable' should be defined in the metadata.
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'sortable' => true,
     *     ),
     * </code></pre>
     */
    setOrderBy: function(event) {
        this._super('setOrderBy', [event]);
        this.collection.comparator = function(model) {
            return model.get(this.orderBy.field);
        };
        if (this.orderBy.direction === 'desc') {
            this.collection.sort({silent: true});
            this.collection.models.reverse();
            this.collection.trigger('sort', this.collection);
        } else {
            this.collection.sort();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.on('render', this._initFilter, this);
        if (this.collection) {
            this.collection.on('reset sort', this._renderData, this);
        }
        this.context.on('filteredlist:search:fired', this.setSearchTerm, this);
    },

    /**
     * Refresh the filtered collection and then refresh the html.
     * @protected
     */
    _renderData: function() {
        this.filteredCollection = this.collection.models;
        this.filterCollection();
        this.render();
    }
}) },
"news": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.NewsView
 * @alias SUGAR.App.view.views.BaseNewsView
 * @extends View.View
 */
({
	// News View (base) 

    plugins: ['Dashlet'],
    initDashlet: function() {
        if(this.meta.config) {
            var limit = this.settings.get("limit") || "5";
            this.settings.set("limit", limit);
        }
        this.model.on("change:name", this.loadData, this);
    },
    loadData: function (options) {
        var name, limit;

        if(_.isUndefined(this.model)){
            return;
        }
        var name = this.model.get("account_name") || this.model.get('name') || this.model.get('full_name'),
            limit = parseInt(this.settings.get('limit') || 5, 10);
        if (_.isEmpty(name)) {
            return;
        }
        $.ajax({
            url: 'https://ajax.googleapis.com/ajax/services/search/news?v=1.0&q=' +
                name.toLowerCase() + '&rsz=' + limit,
            dataType: 'jsonp',
            success: function (data) {
                if (this.disposed) {
                    return;
                }
                _.extend(this, data);
                this.render();
            },
            context: this,
            complete: options ? options.complete : null
        });
    }
}) },
"active-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Active tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Active tasks
 * dashlet also supports other properties:
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.ActiveTasksView
 * @alias SUGAR.App.view.views.BaseActiveTasksView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// Active-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);

        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('active-tasks:close-task:fire', this.closeTask, this);
        this.on('linked-model:create', this.loadData, this);
        this.on('render:rows', this._renderAvatars, this);
        return this;
    },

    /**
     * Completes the selected task.
     *
     * Shows a confirmation alert and sets the task as `Completed` on confirm.
     *
     * @param {Data.Bean} model The task to be marked as completed.
     */
    closeTask: function(model){
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('complete_task_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_ACTIVE_TASKS_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Completed'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super("_initTabs");

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }

    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        this._super('_renderHtml');

        this._renderAvatars();
    }
}) },
"notifications": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Notifications will pull information from the server based on a given delay.
 *
 * Supported properties:
 *
 * - {Number} delay How often (minutes) should the pulling mechanism run.
 * - {Number} limit Limit imposed to the number of records pulled.
 *
 * Example:
 * <pre><code>
 * // ...
 *     array(
 *         'delay' => 5,
 *         'limit' => 4,
 *     ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.NotificationsView
 * @alias SUGAR.App.view.views.BaseNotificationsView
 * @extends View.View
 */
({
	// Notifications View (base) 

    plugins: ['Dropdown', 'RelativeTime', 'EllipsisInline', 'Tooltip'],

    /**
     * Notifications bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * Collections for additional modules.
     */
    _alertsCollections: {},

    /**
     * @property {Number} Interval ID for checking reminders.
     */
    _remindersIntervalId: null,

    /**
     * @property {Number} Timestamp of last time when we checked reminders.
     */
    _remindersIntervalStamp: 0,

    /**
     * Interval ID defined when the pulling mechanism is running.
     *
     * @property {Number}
     * @protected
     */
    _intervalId: null,

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - delay: How often (minutes) should the pulling mechanism run.
     * - limit: Limit imposed to the number of records pulled.
     * - enable_favicon: Enables/disables notifications in favicon, enabled by default.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        delay: 5,
        limit: 4,
        enable_favicon: true
    },

    events: {
        'click [data-action=is-read-handler]': 'isReadHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.module = 'Notifications';

        this._super('initialize', [options]);
        app.events.on('app:sync:complete', this._bootstrap, this);
        app.events.on('app:logout', this.stopPulling, this);
    },

    /**
     * Bootstrap feature requirements.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _bootstrap: function() {
        this._initOptions();
        this._initCollection();
        this._initReminders();
        this._initFavicon();
        this.startPulling();

        this.collection.on('change:is_read', this.render, this);
        return this;
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        var options = _.extend({}, this._defaultOptions, this.meta || {});

        this.delay = options.delay * 60 * 1000;
        this.limit = options.limit;
        this.enableFavicon = options.enable_favicon;

        return this;
    },

    /**
     * Initialize feature collection.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initCollection: function() {
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.options = {
            params: {
                order_by: 'date_entered:desc'
            },
            limit: this.limit,
            myItems: true,
            fields: [
                'date_entered',
                'id',
                'is_read',
                'name',
                'severity'
            ],
            apiOptions: {
                skipMetadataHash: true
            }
        };

        this.collection.filterDef = [{
            is_read: {$equals: false}
        }];

        return this;
    },

    /**
     * Initialize reminders for Calls and Meetings.
     *
     * Setup the reminderMaxTime that is based on maximum reminder time option
     * added to the pulls delay to get a big interval to grab for possible
     * reminders.
     * Setup collections for each module that we support with reminders.
     *
     * FIXME this will be removed when we integrate reminders with
     * Notifications on server side. This is why we have modules hardcoded.
     * We also don't check for meta as optional because it is required.
     * We will keep all this code private because we don't want to support it
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @private
     */
    _initReminders: function() {

        var timeOptions = _.keys(app.lang.getAppListStrings('reminder_time_options')),
            max = _.max(timeOptions, function(key) {
            return parseInt(key, 10);
        });

        this.reminderMaxTime = parseInt(max, 10) + this.delay / 1000;
        this.reminderDelay = 30 * 1000;

        _.each(['Calls', 'Meetings'], function(module) {
            this._alertsCollections[module] = app.data.createBeanCollection(module);
            this._alertsCollections[module].options = {
                limit: this.meta && parseInt(this.meta.remindersLimit, 10) || 100,
                fields: ['date_start', 'id', 'name', 'reminder_time', 'location', 'parent_name']
            };
        }, this);

        return this;
    },

    /**
     * Initializes the favicon using the Favico library.
     *
     * This will listen to the collection reset and update the favicon badge to
     * match the value of the notification element.
     *
     * @private
     */
    _initFavicon: function() {

        if (!this.enableFavicon) {
            return;
        }

        this.favicon = new Favico({animation: 'none'});
        this.collection.on('reset', function() {
            var badge = this.collection.length;
            if (this.collection.next_offset > 0) {
                badge = badge + '+';
            }
            this.favicon.badge(badge);
        }, this);

        this.on('render', function(){
            if (!app.api.isAuthenticated() || app.config.appStatus === 'offline') {
                this.favicon.reset();
            }
        });
    },

    /**
     * Start pulling mechanism, executes an immediate pull request and defines
     * an interval which is responsible for executing pull requests on time
     * based interval.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    startPulling: function() {
        if (!_.isNull(this._intervalId)) {
            return this;
        }
        this._remindersIntervalStamp = new Date().getTime();

        this.pull();
        this._pullReminders();
        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), this.reminderDelay);
        return this;
    },

    /**
     * Pulling functionality.
     *
     * @protected
     */
    _pullAction: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return;
        }

        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);

        this.pull();
        this._pullReminders();
    },

    /**
     * Stop pulling mechanism.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    stopPulling: function() {
        if (!_.isNull(this._intervalId)) {
            window.clearTimeout(this._intervalId);
            this._intervalId = null;
        }
        if (!_.isNull(this._remindersIntervalId)) {
            window.clearTimeout(this._remindersIntervalId);
            this._remindersIntervalId = null;
        }
        return this;
    },

    /**
     * Pull and render notifications, if view isn't disposed or dropdown isn't
     * open.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    pull: function() {
        if (this.disposed || this.isOpen()) {
            return this;
        }

        var self = this;

        this.collection.fetch({
            success: function() {
                if (self.disposed || self.isOpen()) {
                    return this;
                }

                self.render();
            }
        });

        return this;
    },

    /**
     * Pull next reminders from now to the next remindersMaxTime.
     *
     * This will give us all the reminders that should be triggered during the
     * next maximum reminders time (with pull delay).
     */
    _pullReminders: function() {

        if (this.disposed || !_.isFinite(this.reminderMaxTime)) {
            return this;
        }

        var date = new Date(),
            startDate = date.toISOString(),
            endDate;

        date.setTime(date.getTime() + this.reminderMaxTime * 1000);
        endDate = date.toISOString();

        _.each(['Calls', 'Meetings'], function(module) {

            this._alertsCollections[module].filterDef = _.extend({},
                this.meta.remindersFilterDef || {},
                {
                    'date_start': {'$dateBetween': [startDate, endDate]},
                    'users.id': {'$equals': app.user.get('id')}
                }
            );
            this._alertsCollections[module].fetch({
                silent: true,
                merge: true,
                //Notifications should never trigger a metadata refresh
                apiOptions: {skipMetadataHash: true}
            });
        }, this);

        return this;
    },

    /**
     * Check if there is a reminder we should show in the near future.
     *
     * If the reminder exists we immediately show it.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    checkReminders: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return this;
        }
        var date = (new Date()).getTime(),
            diff = this.reminderDelay - (date - this._remindersIntervalStamp) % this.reminderDelay;
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), diff);
        _.each(this._alertsCollections, function(collection) {
            _.chain(collection.models)
                .filter(function(model) {
                    var needDate = (new Date(model.get('date_start'))).getTime() - parseInt(model.get('reminder_time'), 10) * 1000;
                    return needDate > this._remindersIntervalStamp && needDate - this._remindersIntervalStamp <= diff;
                }, this)
                .each(this._showReminderAlert, this);
        }, this);
        this._remindersIntervalStamp = date + diff;
        return this;
    },

    /**
     * Show reminder alert based on given model.
     *
     * @param {Backbone.Model} model Model that is triggering a reminder.
     *
     * @private
     */
    _showReminderAlert: function(model) {
        var url = app.router.buildRoute(model.module, model.id),
            dateFormat = app.user.getPreference('datepref') + ' ' + app.user.getPreference('timepref'),
            dateValue = app.date.format(new Date(model.get('date_start')), dateFormat),
            template = app.template.getView('notifications.notifications-alert'),
            message = template({
                title: new Handlebars.SafeString(app.lang.get('LBL_REMINDER_TITLE', model.module)),
                module: model.module,
                name: new Handlebars.SafeString(model.get('name')),
                location: new Handlebars.SafeString(model.get('location')),
                description: model.get('description'),
                dateStart: dateValue,
                parentName: new Handlebars.SafeString(model.get('parent_name'))
            });
        _.defer(function() {
            if (confirm(message)) {
                app.router.navigate(url, {trigger: true});
            }
        });
    },

    /**
     * Check if dropdown is open.
     *
     * @return {Boolean} `True` if dropdown is open, `false` otherwise.
     */
    isOpen: function() {
        return this.$('[data-name=notifications-list-button]').hasClass('open');
    },

    /**
     * Event handler for notifications.
     *
     * Whenever the user clicks a notification, its `is_read` property is
     * defined as read.
     *
     * We're doing this instead of a plain save in order to
     * prevent the case where an error could occur before the notification get
     * rendered, thus making it as read when the user didn't actually see it.
     *
     * @param {Event} event Click event.
     */
    isReadHandler: function(event) {
        var element = $(event.currentTarget),
            id = element.data('id'),
            notification = this.collection.get(id),
            isRead = notification.get('is_read');

        if (!isRead) {
            notification.set({is_read: true});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() ||
            app.config.appStatus === 'offline' ||
            !app.acl.hasAccess('view', this.module)) {
            return;
        }

        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Stops pulling for new notifications and disposes all reminders.
     */
    _dispose: function() {
        this.stopPulling();
        this._alertsCollections = {};

        this._super('_dispose');
    }
}) },
"bubblechart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BubblechartView
 * @alias SUGAR.App.view.views.BaseBubblechartView
 * @extends View.View
 */
({
	// Bubblechart View (base) 

    plugins: ['Dashlet', 'Tooltip', 'Chart'],

    tooltiptemplate: null,
    params: null,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * What module are we forecasting by
     */
    forecastBy: null,

    /**
     * Which field holds the likely case value
     */
    likelyField: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        var config = app.metadata.getModule('Forecasts', 'config');
        this.forecastBy = config && config.forecast_by || 'Opportunities';

        // set the title label in meta the same way the dashlet title is set on render
        options.meta.label = app.lang.get(options.meta.label, this.forecastBy);

        this._super('initialize', [options]);

        var fields = [
            'id',
            'name',
            'account_name',
            'base_rate',
            'currency_id',
            'assigned_user_name',
            'date_closed',
            'probability',
            'account_id',
            'sales_stage',
            'commit_stage'
        ];

        var orderBy = '';
        if (this.forecastBy === 'Opportunities') {
            fields.push('amount');
            orderBy = 'amount:desc';
            this.likelyField = 'amount';
        } else {
            fields.push('likely_case');
            orderBy = 'likely_case:desc';
            this.likelyField = 'likely_case';
        }

        this.params = {
            'fields': fields.join(','),
            'max_num': 10,
            'order_by': orderBy
        };

        this.tooltiptemplate = app.template.getView(this.name + '.tooltiptemplate');
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        var self = this;

        if (this.settings.get('filter_duration') == 0) {
            this.settings.set({'filter_duration':'current'}, {'silent':true});
        }

        this.setDateRange();

        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is loaded from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }

        this.chart = nv.models.bubbleChart()
            .x(function(d) {
                return d3.time.format('%Y-%m-%d').parse(d.x);
            })
            .y(function(d) {
                return d.y;
            })
            .margin({top: 0})
            .tooltipContent(function(key, x, y, e, graph) {
                e.point.close_date = d3.time.format('%x')(d3.time.format('%Y-%m-%d').parse(e.point.x));
                e.point.amount = app.currency.formatAmountLocale(e.point.base_amount, e.point.currency_id);
                return self.tooltiptemplate(e.point).replace(/(\r\n|\n|\r)/gm, '');
            })
            .showTitle(false)
            .tooltips(true)
            .showLegend(true)
            .direction(app.lang.direction)
            .bubbleClick(function(e) {
                self.chart.dispatch.tooltipHide(e);
                app.router.navigate(app.router.buildRoute(self.forecastBy, e.point.id), {trigger: true});
            })
            .colorData('class', {step: 2})
            .groupBy(function(d) {
                return (self.isManager && self.getVisibility() === 'user') ?
                    d.sales_stage_short :
                    d.assigned_user_name;
            })
            .filterBy(function(d) {
                return d.probability;
            })
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA')
            });

        this.on('data-changed', function() {
            this.renderChart();
        }, this);
        this.settings.on('change:filter_duration', this.changeFilter, this);

        this.layout.on('render', function() {
            if (!this.disposed && !this.settings.get('config')) {
                this.layout.setTitle(app.lang.get(this.meta.label, this.forecastBy));
            }
        }, this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {View.Views.BaseBubbleChart} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Clear out the current chart before a re-render
        this.$('svg#' + this.cid).children().remove();

        // Load data into chart model and set reference to chart
        d3.select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.render);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * bubblechart nvd3 model uses render instead of update.
     */
    chartResize: function() {
        this.chart.render();
    },

    /**
     * Filter out records that don't meet date criteria
     * and convert into format convenient for d3
     */
    evaluateResult: function(data) {
        this.total = data.records.length;

        var statusOptions = 'sales_stage_dom',
            fieldMeta = app.metadata.getModule(this.forecastBy, 'fields');

        if (fieldMeta) {
            statusOptions = fieldMeta.sales_stage.options || statusOptions;
        }

        this.chartCollection = {
            data: data.records.map(function(d) {
                var sales_stage = app.lang.getAppListStrings(statusOptions)[d.sales_stage] || d.sales_stage;

                // if probability is null or empty set to 0
                if(_.isNull(d.probability) || d.probability === '') {
                    d.probability = 0;
                }

                // if likely is null or empty set to 0, for customers that do not require likely
                if(_.isNull(d[this.likelyField]) || d[this.likelyField] === '') {
                    d[this.likelyField] = 0;
                }

                return {
                    id: d.id,
                    x: d.date_closed,
                    y: Math.round(parseInt(d[this.likelyField], 10) / parseFloat(d.base_rate)),
                    shape: 'circle',
                    account_name: d.account_name,
                    assigned_user_name: d.assigned_user_name,
                    sales_stage: sales_stage,
                    sales_stage_short: sales_stage,
                    probability: parseInt(d.probability, 10),
                    base_amount: d[this.likelyField],
                    currency_symbol: app.currency.getCurrencySymbol(d.currency_id),
                    currency_id: d.currency_id
                };
            }, this),
            properties: {
                title: app.lang.get('LBL_DASHLET_TOP10_SALES_OPPORTUNITIES_NAME'),
                value: data.records.length
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            _filter = [
                {
                    'date_closed': {
                        '$gte': self.dateRange.begin
                    }
                },
                {
                    'date_closed': {
                        '$lte': self.dateRange.end
                    }
                }
            ];

        if (!this.isManager || this.getVisibility() === 'user') {
            _filter.push({'$owner': ''});
        }

        var _local = _.extend({'filter': _filter}, this.params);
        var url = app.api.buildURL(this.forecastBy, null, null, _local, this.params);

        // Request data from REST endpoint, evaluate result and trigger data change event
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    self.trigger('data-changed');
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Calculate date range based on date range dropdown control
     */
    setDateRange: function() {
        var now = new Date(),
            mapping = {
                'current' : 0,
                'next' : 3,
                'year' : 12
            },
            duration = mapping[this.settings.get('filter_duration')],
            startMonth = Math.floor(now.getMonth() / 3) * 3,
            startDate = new Date(now.getFullYear(), (duration === 12 ? 0 : startMonth + duration), 1),
            addYear = 0,
            addMonth = duration === 12 ? 12 : 3,
            endDate;

        // if "Next Quarter" is selected and the current month is Oct/Nov/Dec, add 1 to the year
        if(duration === 3 && now.getMonth() >= 9) {
            addYear = 1;
        }
        endDate = new Date(now.getFullYear() + addYear, startDate.getMonth() + addMonth, 0);

        this.dateRange = {
            'begin': app.date.format(startDate, 'Y-m-d'),
            'end': app.date.format(endDate, 'Y-m-d')
        };
    },

    /**
     * Trigger data load event based when date range dropdown changes
     */
    changeFilter: function() {
        this.setDateRange();
        this.loadData();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.off('data-changed');
        this.settings.off('change:filter_duration');
        this._super('_dispose');
    }
}) },
"vcard-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportHeaderpaneView
 * @alias SUGAR.App.view.views.BaseVcardImportHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Vcard-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=vcard_cancel_button]': 'initiateCancel'
    },

    /**
     * Add listener for toggling the disabled state of the finish button
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('vcard:import-finish-button:toggle', this._toggleFinishButton, this);
    },

    /**
     * Toggle the state of the finish button (enabled/disabled)
     *
     * @param {boolean} enabled Whether the button should be enabled
     * @private
     */
    _toggleFinishButton: function(enabled) {
        this.getField('vcard_finish_button').setDisabled(!enabled);
    },

    /**
     * Handle cancel action - closing the drawer
     */
    initiateCancel: function() {
        app.drawer.close();
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuickcreateView
 * @alias SUGAR.App.view.views.BaseQuickcreateView
 * @extends View.View
 */
({
	// Quickcreate View (base) 

    plugins: ['Dropdown', 'Tooltip'],

    /**
     * @param {Object} options
     * @inheritdoc
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.view.View.prototype.initialize.call(this, options);

        //shortcut keys
        app.shortcuts.register(app.shortcuts.GLOBAL + 'Create', 'c', function() {
            this.$('[data-toggle=dropdown]').click();
        }, this);
    },

    /**
     * @inheritdoc
     * @private
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() || app.config.appStatus == 'offline') {
            return;
        }
        // loadAdditionalComponents fires render before the private metadata is ready, check for this
        if (app.isSynced) {
            this.createMenuItems = this._getMenuMeta(
                app.metadata.getModuleNames({filter: ['visible', 'quick_create'], access: 'create'})
            );
            app.view.View.prototype._renderHtml.call(this);
        }
    },

    /**
     * Retrieve the quickcreate metadata from each module in the list
     * Uses the visible flag on the metadata to determine if admin has elected to hide the module from the list
     *
     * @param {Array} module The module names
     * @return {Array} list of visible menu item metadata
     */
    _getMenuMeta: function(modules) {
        var returnList = [];
        _.each(modules, function(name) {
            var meta = app.metadata.getModule(name);
            if (meta && meta.menu && meta.menu.quickcreate) {
                var menuItem = _.clone(meta.menu.quickcreate.meta);
                if (menuItem.visible === true) {
                    menuItem.module = name;
                    menuItem.type = menuItem.type || 'quickcreate';
                    // apply default icon for compatibility with customizations from previous versions
                    // but leave the possibility to turn icon off by specifying empty value
                    if (!("icon" in menuItem)) {
                        menuItem.icon = "fa fa-plus";
                    }
                    //TODO: refactor sidecar field hbs helper so it can accept the module name directly
                    menuItem.model = app.data.createBean(name);
                    returnList.push(menuItem);
                }
            }
        }, this);
        return this._sortByOrder(returnList);
    },

    /**
     * Sorts the module list based upon the value of the order attribute.
     *
     * @param {Array} moduleList
     * @return {Array}
     * @private
     */
    _sortByOrder: function(moduleList) {
        return moduleList.sort(function(a, b) {
            var order = a['order'] - b['order'];
            return (order == 0) ? (a['label'] > b['label']) : order;
        });
    }
}) },
"multi-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The MultiSelectionListView extends SelectionListView and adds the ability to
 * select multiple records in the list and get the selected items as the output.
 * The way to use it is similar to the SelectionListView.
 *
 * It adds the following properties which have to be set in the context:
 *
 * - `maxSelectedRecords` The max number of records the user can select in the
 *    case of multiselect selection list.
 * - `independentMassCollection` {boolean} `true` if the selected records should
 *   be handled independently from the view collection. If `false` selected
 *   records are tied to the view collection, which means they are reset if the
 *   view collection is reset.
 *
 * @class View.Views.Base.MultiSelectionListView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListView
 * @extends View.Views.Base.SelectionListView
 */
({
	// Multi-selection-list View (base) 

    extendsFrom: 'SelectionListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);

        /**
         * Maximum number of records a user can select.
         *
         * @property {number}
         */
        this.maxSelectedRecords = options.context.get('maxSelectedRecords');

        /**
         * Boolean to know whether the selected records called `mass collection`
         * should be tied to the view collection or independent.
         *
         * If tied, selected records would have to be in the current view collection.
         * As soon as the view collection is reset, the mass collection would be
         * reset.
         *
         * @property {boolean} `true` for an independent mass collection. `false`
         *   for the mass collection to be tied to the view collection.
         */
        this.independentMassCollection = options.context.get('independentMassCollection') || true;
        // if no metadata defined for `multi-selection-list`, use `selection-list`
        options.meta = _.extend({}, app.metadata.getView(options.module, 'selection-list'), options.meta);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'multi',
            isSearchAndSelectAction: true,
            disable_select_all_alert: !!this.maxSelectedRecords
        };
    },

    /**
     * Sets up events.
     *
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection:select:fire', this._validateSelection, this);
    },

    /**
     * Closes the drawer passing the selected models attributes to the callback.
     *
     * @protected
     */
    _validateSelection: function() {
        var selectedModels = this.context.get('mass_collection');
        if (selectedModels.length > this.maxSelectedRecords) {
            this._showMaxSelectedRecordsAlert();
            return;
        }
        app.drawer.close(this._getCollectionAttributes(selectedModels));
    },

    /**
     * Displays error message since the number of selected records exceeds the
     * maximum allowed.
     *
     * @private
     */
    _showMaxSelectedRecordsAlert: function() {
        var msg = app.lang.get('TPL_FILTER_MAX_NUMBER_RECORDS', this.module, {
            maxRecords: this.maxSelectedRecords
        });
        app.alert.show('too-many-selected-records', {
            level: 'error',
            messages: msg,
            autoClose: false
        });
    },

    /**
     * Returns an array of attributes given a collection.
     *
     * @param {Data.BeanCollection} collection A collection of records.
     * @return {Object[]} attributes An array containing the attribute object of
     *   each model.
     *
     * @private
     */
    _getCollectionAttributes: function(collection) {
        var attributes = _.map(collection.models, this._getModelAttributes, this);
        return attributes;
    }
}) },
"user-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Profile wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserWizardPageView
 * @alias SUGAR.App.view.views.BaseUserWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// User-wizard-page View (base) 

    extendsFrom: "WizardPageView",

    /**
     * Always show the page at start.
     *
     * @inheritdoc
     */
    showPage: true,

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        //Load the default wizard page template, if you want to.
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        this.action = 'edit';
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return this.areAllRequiredFieldsNonEmpty;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.listenTo(this.model, 'sync', this.render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.model.dataFetched) {
            return this;
        }
        this._super('_render');
    },

    /**
     * Prepares HTTP payload
     * @return {Object} Payload with fields we want to update
     * @protected
     */
    _prepareRequestPayload: function() {
        var payload = {},
            self = this,
            fields = _.keys(this.fieldsToValidate);
        _.each(fields, function(key) {
            payload[key] = self.model.get(key);
        });
        return payload;
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and profile update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        var self = this;
        this.getField("next_button").setDisabled(true); // temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = self._prepareRequestPayload();
                    app.alert.show('wizardprofile', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});
                    app.user.updateProfile(payload, function(err) {
                        app.alert.dismiss('wizardprofile');
                        self.updateButtons(); //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard profile update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, self)
        );
    }

}) },
"error": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ErrorView
 * @alias SUGAR.App.view.views.BaseErrorView
 * @extends View.View
 */
({
	// Error View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    initialize: function(options) {
        // Adds the metadata for the Error module
        app.metadata.set(this._metadata);
        app.data.declareModels();

        // Reprepare the context because it was initially prepared without metadata
        app.controller.context.prepare(true);

        // Attach the metadata to the view
        this.options.meta = this._metadata.modules[this.options.module].views[this.options.name].meta;
        app.view.View.prototype.initialize.call(this, options);
    },
    _render: function() {
        if(this.context.get('errorType')) {
            var attributes = this.getErrorAttributes();
            this.model.set(attributes);
        }
        app.view.View.prototype._render.call(this);
    },
    getErrorAttributes: function() {
        var errorType = this.context.get('errorType'),
            attributes;

        switch (errorType) {
            case '400':
                attributes = {
                    title: 'ERR_HTTP_400_TITLE',
                    type: 'ERR_HTTP_400_TYPE',
                    messages: ['ERR_HTTP_400_TEXT_LINE1', 'ERR_HTTP_400_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_400_ACTION')
                };
                break;
            case '404':
                attributes = {
                    title: 'ERR_HTTP_404_TITLE',
                    type: 'ERR_HTTP_404_TYPE',
                    messages: ['ERR_HTTP_404_TEXT_LINE1', 'ERR_HTTP_404_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_404_ACTION')
                };
                break;
            case '422':
                attributes = {
                    title: 'ERR_HTTP_DEFAULT_TEXT',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: ['ERR_CONTACT_TECH_SUPPORT'],
                    linkText: app.lang.get('ERR_HTTP_DEFAULT_ACTION')
                };
                break;
            case '500':
                attributes = {
                    title: 'ERR_HTTP_500_TITLE',
                    type: 'ERR_HTTP_500_TYPE',
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_500_ACTION')
                };
                break;
            default:
                var error = this.context.get('error') || {};
                var title = null;
                if (error.status && error.errorThrown) {
                    title = 'HTTP: ' + error.status + ' ' + error.errorThrown;
                }
                attributes = {
                    title: title || 'ERR_HTTP_DEFAULT_TITLE',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: [error.message || 'ERR_HTTP_DEFAULT_TEXT']
                };
                break;
        }
        return attributes;
    },

    _metadata : {
        "modules": {
            "Error": {
                "views": {
                    "error": {
                        "meta": {}
                    }
                },
                "layouts": {
                    "error": {
                        "meta": {
                            "type": "simple",
                            "components": [
                                {view: "error"}
                            ]
                        }
                    }
                }
            }
        },
        'module_tab_map': {
            'Error': ''
        }
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"dashlet-toolbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletToolbarView
 * @alias SUGAR.App.view.views.BaseDashletToolbarView
 * @extends View.View
 */
({
	// Dashlet-toolbar View (base) 

    className: 'dashlet-header',
    cssIconDefault: 'fa-cog',
    cssIconRefresh: 'fa-refresh fa-spin',
    defaultActions: {
        'dashlet:edit:clicked' : 'editClicked',
        'dashlet:refresh:clicked' : 'refreshClicked',
        'dashlet:delete:clicked' : 'removeClicked',
        'dashlet:toggle:clicked' : 'toggleMinify'
    },
    plugins: ['Tooltip'],
    initialize: function (options) {
        _.extend(options.meta, app.metadata.getView(null, 'dashlet-toolbar'), options.meta.toolbar);
        app.view.View.prototype.initialize.call(this, options);
    },

    /**
     * Change to the spinning icon to indicate that loading process is triggered
     */
    refreshClicked: function() {
        var $el = this.$("[data-action=loading]"),
            self = this,
            options = {};
        if($el.length > 0) {
            $el.removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
            options.complete = function() {
                if(self.disposed) {
                    return;
                }
                $el.removeClass(self.cssIconRefresh).addClass(self.cssIconDefault);
            };
        }
        this.layout.reloadDashlet(options);
    },

    /**
     * Remove a dashlet.
     *
     * @param {Event} evt Mouse event.
     */
    removeClicked: function(evt) {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.layout.removeDashlet();
            }, this)
        });
    },

    editClicked: function(evt) {
        this.layout.editDashlet();
    },
    /**
     * Toggle current dashlet frame when user clicks the toolbar action
     *
     * @param {Event} mouse event.
     */
    toggleClicked: function(evt) {
        var $btn = $(evt.currentTarget),
            expanded = _.isUndefined($btn.data('expanded')) ? true : $btn.data('expanded'),
            label = expanded ? 'LBL_DASHLET_MAXIMIZE' : 'LBL_DASHLET_MINIMIZE';

        $btn.html(app.lang.get(label, this.module));
        this.layout.collapse(expanded);
        $btn.data('expanded', !expanded);
    },
    /**
     * Toggle current dashlet frame when user clicks chevron icon
     *
     * @param {Window.Event} mouse event.
     */
    toggleMinify: function(evt) {
        var $el = this.$('.dashlet-toggle > i'),
            collapsed = $el.is('.fa-chevron-up');
        this.layout.collapse(collapsed);
        //firing an event to notify dashlet expand / collapse
        this.layout.trigger('dashlet:collapse',collapsed);
    }
}) },
"history-summary-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryHeaderpaneView
 * @alias SUGAR.App.view.views.BaseHistorySummaryHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// History-summary-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.model = this.context.parent && this.context.parent.get('model') || this.model;
    },

    /**
     * @override
     */
    _formatTitle: function(title) {
        var parent = this._getParentModel();
        var recordName = this._getParentModelName();
        if (parent && recordName) {
            return new Handlebars.SafeString(app.lang.get(title, parent.module, {name: recordName}));
        }
        return title;
    },

    /**
     * Gets the parent model of this historical summary view.
     *
     * @return {Data.Bean} The parent model.
     * @private
     */
    _getParentModel: function() {
        return this.context.parent.get('model');
    },

    /**
     * Gets the name of the parent model.
     *
     * @return {string} The parent model name.
     * @protected
     */
    _getParentModelName: function() {
        var parent = this._getParentModel();
        return app.utils.formatNameModel(parent.module, parent.attributes) || parent.get('name');
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    }
}) },
"forgotpassword": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forgot password form view.
 *
 * @class View.Views.Base.ForgotpasswordView
 * @alias SUGAR.App.view.views.BaseForgotpasswordView
 * @extends View.View
 */
({
	// Forgotpassword View (base) 

    plugins: ['ErrorDecoration'],

    events: {
        'click [name=cancel_button]': 'cancel',
        'click [name=forgotPassword_button]': 'forgotPassword',
        'change select[name=country]': 'render'
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * {@link View.Views.Base.LoginView}
     *
     * @param {Object} meta The view's metadata supplied.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        /**
         * Fields metadata needs to be converted to this format for App.data.declareModel
         *  {
          *     "first_name": { "name": "first_name", ... },
          *     "last_name": { "name": "last_name", ... },
          *      ...
          * }
         */
        app.data.declareModel('Forgotpassword', {fields: fields});
    },

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        app.view.View.prototype.initialize.call(this, options);
        this._showResult = false;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (!(app.config && app.config.forgotpasswordON === true)) {
            return;
        }
        this.logoUrl = app.metadata.getLogoUrl();
        app.view.View.prototype._render.call(this);

        return this;
    },

    /**
     * Basic cancel button
     */
    cancel: function() {
        app.router.goBack();
    },

    /**
     * Handles forgot password request
     */
    forgotPassword: function() {
        var self = this;

        self.model.doValidate(null, function(isValid) {
            if (isValid) {

                // a robot has reached into the honey pot. do not submit
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="first_name"]').val() || self.model.get('first_name'))) return;

                app.$contentEl.hide();
                app.alert.show('forgotPassword', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});

                var emails = self.model.get('email');
                var params = {
                    username: self.model.get('username')
                };

                if (emails && emails[0] && emails[0].email_address) {
                    params.email =  emails[0].email_address;
                }

                var url = app.api.buildURL('password/request','',{},params);
                app.api.call('READ', url,{},{
                    success: function(response){
                        // result flags
                        self._showSuccess = true;
                        self._showResult = true;
                        self.resultLabel = "LBL_PASSWORD_REQUEST_SENT";
                        self.model.clear();
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(err){
                        // result flags
                        self._showSuccess = false;
                        self._showResult = true;

                            self.resultLabel = err.message || 'LBL_PASSWORD_REQUEST_ERROR';

                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    complete: function() {
                        app.alert.dismiss('forgotPassword');
                        app.$contentEl.show();
                    }
                })
            }
        }, self);
    },

    /**
     * Really basic metadata for the Back button displayed on password reset
     */
    _backButton: [
        {
            name: 'cancel_button',
            type: 'button',
            label: 'LBL_BACK',
            value: 'forgotPassword',
            primary: false
        }
    ]
}) },
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseModuleMenuView
 * @extends View.View
 */
({
	// Module-menu View (base) 

    tagName: 'span',
    plugins: ['EllipsisInline'],
    events: {
        'click [data-event]': 'handleMenuEvent',
        'click [data-route]': 'handleRouteEvent',
        'shown.bs.dropdown': 'populateMenu'
    },

    /**
     * The possible actions that this module menu provides.
     *
     * This comes from the metadata files, like:
     *
     * - {custom}/modules/&lt;Module&gt;/clients/base/menus/header/header.php
     */
    actions: [],

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} favorites Number of records to show on the favorites
     *   container. Pass 0 if you don't want to support favorites.
     * - {Number} recently_viewed Number of records to show on the recently
     *   viewed container. Pass 0 if you don't want to support recently viewed.
     *
     * Example:
     * ```
     * // ...
     * 'settings' => array(
     *     'favorites' => 5,
     *     'recently_viewed' => 9,
     *     //...
     * ),
     * //...
     * ```
     *
     * @protected
     */
    _defaultSettings: {
        favorites: 3,
        recently_viewed: 3
    },

    /**
     * Settings after applied metadata settings on top of
     * {@link View.Views.BaseModuleMenuView#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     *
     * Adds listener for bootstrap drop down show even (`shown.bs.dropdown`).
     * This will trigger menuOpen method.
     */
    initialize: function(options) {

        options.meta = _.extend(
            {},
            options.meta,
            app.metadata.getView(null, options.name),
            app.metadata.getView(options.module, options.name)
        );

        this._super('initialize', [options]);
        this._initSettings();

        /**
         * The internal array of collections for favorites and recent.
         * The collections shouldn't be reused with different filters when
         * fetching in parallel.
         *
         * @property {Object}
         * @private
         */
        this._collections = {};
    },


    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseModuleMenuView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    /**
     * @inheritdoc
     *
     * Retrieves possible menus from the metadata already inSync.
     * Filters all menu actions based on ACLs to prevent user to click them and
     * get a `403` after click.
     */
    _renderHtml: function() {
        var meta = app.metadata.getModule(this.module) || {};

        this.actions = this.filterByAccess(meta.menu && meta.menu.header && meta.menu.header.meta);

        this._super('_renderHtml');

        if (!this.meta.short) {
            this.$el.addClass('btn-group');
        }
    },

    /**
     * Filters menu actions by ACLs for the current user.
     *
     * @param {Array} meta The menu metadata to check access.
     * @return {Array} Returns only the list of actions the user has access.
     */
    filterByAccess: function(meta) {

        var result = [];

        _.each(meta, function(menuItem) {
            if (app.acl.hasAccess(menuItem.acl_action, menuItem.acl_module)) {
                result.push(menuItem);
            }
        });

        return result;
    },

    /**
     * Method called when a `show.bs.dropdown` event occurs.
     *
     * Populate the favorites and recently viewed records every time we open
     * the menu. This is only supported on modules that have fields.
     */
    populateMenu: function() {

        var meta = app.metadata.getModule(this.module) || {};

        if (_.isEmpty(_.omit(meta.fields, '_hash'))) {
            return;
        }

        if (meta.favoritesEnabled) {
            this.populate('favorites', [{
                '$favorite': ''
            }], this._settings.favorites);
        }

        this.populate('recently-viewed', [{
            '$tracker': '-7 DAY'
        }], this._settings.recently_viewed);
    },


    /**
     * Return `true` if this menu is open, `false` otherwise.
     * @return {Boolean} `true` if this menu is open, `false` otherwise.
     */
    isOpen: function() {
        return !!this.$el.hasClass('open');
    },

    /**
     * Populates records templates based on filter given.
     *
     * @param {String} tplName The template to use to populate data.
     * @param {String} filter The filter to be applied.
     * @param {Number} limit The number of records to populate. Needs to be an
     *   integer `> 0`.
     */
    populate: function(tplName, filter, limit) {
        if (limit <= 0) {
            return;
        }

        this.getCollection(tplName).fetch({
            'showAlerts': false,
            'fields': ['id', 'name'],
            // TODO SC-3696 this filter can be initialized once in the
            // getCollection() and be metadata driven.
            'filter': filter,
            'limit': limit,
            'success': _.bind(function() {
                this._renderPartial(tplName);
            }, this)
        });
    },

    /**
     * Get the collection for the partial (favorites or recently viewed).
     *
     * @param {string} tplName The name of the partial template that will use
     *   this collection.
     * @return {Data.BeanCollection} The collection of this module.
     */
    getCollection: function(tplName) {
        if (!this._collections[tplName]) {
            this._collections[tplName] = app.data.createBeanCollection(this.module);
            // TODO SC-3696 create the initial filter based on metadata for the
            // partials
        }

        return this._collections[tplName];
    },

    /**
     * Renders the data in the partial template given.
     *
     * The partial template can receive more data from the options parameter.
     *
     * @param {String} tplName The template to use to render the partials.
     * @param {Object} [options] Other optional data to pass to the template.
     * @protected
     */
    _renderPartial: function(tplName, options) {
        var tpl, $placeholder, $old, focusedRoute, focusSelector, $new, $newFocus;

        if (this.disposed || !this.isOpen()) {
            return;
        }

        this.destroyEllipsisTooltips();

        options = options || {};
        tpl = app.template.getView(this.name + '.' + tplName, this.module) ||
            app.template.getView(this.name + '.' + tplName);
        $placeholder = this.$('[data-container="' + tplName + '"]');
        $old = $placeholder.nextUntil('.divider');

        //grab the focused element's route (if exists) for later re-focusing
        focusedRoute = $old.find(document.activeElement).data('route');

        //replace the partial using newly updated collection
        $old.remove();
        $placeholder.after(tpl(_.extend({
            'collection': this.getCollection(tplName)
        }, options)));

        //if there was a focused element previously, restore its focus
        if (focusedRoute) {
            $new = $placeholder.nextUntil('.divider');
            focusSelector = '[data-route="' + focusedRoute + '"]';
            $newFocus = $new.find(focusSelector);
            if ($newFocus.length > 0) {
                $newFocus.focus();
            }
        }

        this.initializeEllipsisTooltips();

    },

    /**
     * This gives support to any events that might exist in the menu actions.
     *
     * Out of the box we don't have any use case for actions that are event
     * driven. Since it was already provided since 7.0.0 we will keep it util
     * further notice.
     *
     * @param {Event} evt The event that triggered this (normally a click
     *   event).
     */
    handleMenuEvent: function(evt) {
        var $currentTarget = this.$(evt.currentTarget);
        app.events.trigger($currentTarget.data('event'), this.module, evt);
    },

    /**
     * This triggers router navigation on both menu actions and module links.
     *
     * Since we normally trigger the drawer for some actions, we prevent it
     * when using the click with the `ctrlKey` (or `metaKey` in Mac OS).
     * We also prevent the routing to be fired when this happens.
     *
     * When we are triggering the same route that we already are in, we just
     * trigger a {@link Core.Routing#refresh}.
     *
     * @param {Event} event The event that triggered this (normally a click
     *   event).
     */
    handleRouteEvent: function(event) {
        var currentRoute,
            $currentTarget = this.$(event.currentTarget),
            route = $currentTarget.data('route');

        event.preventDefault();
        if ((!_.isUndefined(event.button) && event.button !== 0) || event.ctrlKey || event.metaKey || $currentTarget.data('openwindow') === true) {
            event.stopPropagation();
            window.open(route, '_blank');
            return false;
        }

        currentRoute = '#' + Backbone.history.getFragment();
        (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
    }

}) },
"themerollerpreview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This view is used in Administration > Studio Portal > Theme Portal
 * in order to show a preview of the custom theme being edited.
 *
 * @class View.Views.Base.ThemerollerpreviewView
 * @alias SUGAR.App.view.views.BaseThemerollerpreviewView
 * @extends View.View
 */
({
	// Themerollerpreview View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The name of the theme being edited.
         *
         * @property {string}
         */
        this.customTheme = 'default';
        this.context.on('change:colors', this.reloadIframeBootstrap, this);
    },

    /**
     * Makes a request to get new CSS based on the themeable colors, and updates
     * the theme preview on success.
     */
    reloadIframeBootstrap: function() {
        var self = this;
        var params = {
            preview: new Date().getTime(),
            platform: app.config.platform,
            themeName: this.customTheme
        };
        _.extend(params, this.context.get('colors'));
        var cssLink = app.api.buildURL('css/preview', '', {}, params);
        var $iframe = this.$('iframe#previewTheme');
        var $alert = this.$('.ajaxLoading');

        $iframe.hide();
        $alert.show();

        $.get(cssLink)
            .success(function(data) {
                if (self.disposed) {
                    return;
                }
                $iframe.contents().find('style').text(data);
                $alert.hide();
                $iframe.show();
            });
        $iframe.contents().find('body').css('backgroundColor', 'transparent');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.acl.hasAccess('admin', 'Administration')) {
            return;
        }
        this._super('_renderHtml');
    }
}) },
"audit-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditFooterView
 * @alias SUGAR.App.view.views.BaseAuditFooterView
 * @extends View.View
 */
({
	// Audit-footer View (base) 

    /**
     * @inheritdoc
     * Initialize the audited fields on the parent model.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.context.parent) {
            var baseModule = this.context.parent.get('module');
            this.auditedFields = this._getAuditedFields(baseModule);
            this.hasCurrencyFields = this._hasCurrencyFields(baseModule);
        }
    },

    /**
     * Parse the parent module metadata and determine audited fields.
     *
     * @param {String} baseModule Name of parent module.
     * @return {Array} List of audited field's name.
     * @protected
     */
    _getAuditedFields: function(baseModule) {
        return _.chain(app.metadata.getModule(baseModule, 'fields'))
            .filter(function(o) {return o.audited;})
            .map(function(o) {return app.lang.get(o.vname, baseModule);})
            .value();
    },

    /**
     *  Look to see if the baseModule has any currency fields
     *
     *  @return {boolean}
     *  @protected
     */
    _hasCurrencyFields: function(baseModule) {
        return _.some(app.metadata.getModule(baseModule, 'fields'), function(field) {
           return field.audited && field.type && field.type == 'currency';
        });
    }
}) },
"panel-top-readonly": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopReadonlyView
 * @alias SUGAR.App.view.views.BasePanelTopReadonlyView
 * @extends View.PanelTopView
 */
({
	// Panel-top-readonly View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
    }
}) },
"sweetspot-config-list-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigListRowView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigListRowView
 * @extends View.View
 */
({
	// Sweetspot-config-list-row View (base) 

    tagName: 'tr',

    className: 'config-list-row',

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.model = app.data.createBean();
        this._super('initialize', [options]);
        this.prepareActionDropdown();
        this.collection.add(options.model);
    },

    /**
     * This method adds all possible Sweet Spot actions to the `action` enum
     * field, so they can be configured by the user.
     */
    prepareActionDropdown: function() {
        var field = _.find(this.meta.fields, function(field) {
            return field.name === 'action';
        });
        var actions = app.metadata.getSweetspotActions();
        var options = {};
        _.each(actions, function(action, id) {
            options[id] = action.name;
        });
        field.options = options;
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     */
    addRow: function() {
        this.context.trigger('sweetspot:config:addRow', this);
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     */
    removeRow: function() {
        this.context.trigger('sweetspot:config:removeRow', this);
    }
}) },
"resolve-conflicts-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsHeaderpaneView
 * @alias SUGAR.App.view.views.BaseResolveConflictsHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Resolve-conflicts-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * Register event handlers for the buttons and set the title.
     * @param options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, {
            'click [name=select_button]': 'selectClicked',
            'click [name=cancel_button]': 'cancelClicked'
        });

        this._super('initialize', [options]);

        this.context.on("change:selection_model", this.enableSelectButton, this);
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var modelToSave = this.context.get('modelToSave'),
            name = modelToSave.get('name') || modelToSave.get('full_name');

        return app.lang.get(title, this.module, {name: name});
    },

    /**
     * Perform action according to whether the client's or database's data was selected.
     * @param event
     */
    selectClicked: function(event) {
        var selected = this.context.get('selection_model'),
            modelToSave = this.context.get('modelToSave'),
            dataInDb = this.context.get('dataInDb'),
            origin;

        if (selected instanceof Backbone.Model) {
            origin = selected.get('_dataOrigin');
            if (origin === 'client') {
                modelToSave.set('date_modified', dataInDb.date_modified);
                app.drawer.close(modelToSave, false);
            } else if (origin === 'database') {
                modelToSave.set(dataInDb);
                // trigger sync so that synced attributes are reset
                modelToSave.trigger('sync');
                app.drawer.close(modelToSave, true);
            }
        }
    },

    /**
     * Enable select button when a row has been selected.
     * @param context
     * @param selected
     */
    enableSelectButton: function(context, selected) {
        if (selected) {
            this.$('[name=select_button]').removeClass('disabled');
        }
    },

    /**
     * Close the drawer when cancel is clicked.
     * @param event
     */
    cancelClicked: function(event) {
        app.drawer.close();
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordlistView
 * @alias SUGAR.App.view.views.BaseRecordlistView
 * @extends View.Views.Base.FlexListView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'FlexListView',
    plugins: [
        'SugarLogic',
        'ReorderableColumns',
        'ResizableColumns',
        'ListColumnEllipsis',
        'ErrorDecoration',
        'Editable',
        'MergeDuplicates',
        'Pagination',
        'MassCollection'
    ],

    /**
     * List of current inline edit models.
     *
     * @property
     */
    toggledModels: null,

    rowFields: {},

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:deleterow:fire": "warnDelete"
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        //Grab the record list of fields to display from the base metadata
        var recordListMeta = this._initializeMetadata(options.context);
        //Allows sub-views to override and use different view metadata if desired
        options.meta = this._filterMeta(_.extend({}, recordListMeta, options.meta || {}), options);
        this._super("initialize", [options]);

        //Extend the prototype's events object to setup additional events for this controller
        this.events = _.extend({}, this.events, {
            'click [name=inline-cancel]' : 'resize',
            'keydown': '_setScrollPosition'
        });

        this.toggledModels = {};

        this.context._recordListFields = this.getFieldNames(null, true);

        this._currentUrl = Backbone.history.getFragment();

        this._bindEvents();
    },

    /**
     * Bind various events that are associated with this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.on('render render:rows', this._setRowFields, this);

        //fire resize scroll-width on column add/remove
        this.on('list:toggle:column', this.resize, this);
        this.on('mergeduplicates:complete', this.refreshCollection, this);
        this.on('field:focus:location', this.setPanelPosition, this);

        if (this.layout) {
            this.layout.on('list:mergeduplicates:fire', this.mergeDuplicatesClicked, this);

            // We listen for if the search filters are opened or not. If so, when
            // user clicks show more button, we treat this as a search, otherwise,
            // normal show more for list view.
            this.layout.on('list:filter:toggled', this.filterToggled, this);

            // The `MassCollection` plugin triggers these events when it shows an
            // alert and the table height changes.
            this.layout.on('list:alert:show list:alert:hide', this._refreshReorderableColumns, this);
        }

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Update the filter enable status.
     *
     * @param {Boolean} isOpened Value whether the filter is opened.
     */
    filterToggled: function(isOpened) {
        this.context.set('filterOpened', isOpened);
    },

    /**
     * Add the opened filter options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        // If in "search mode" (the search filter is toggled open) set q:term param
        var options = this.context.get('filterOpened') ? this.getSearchOptions() : {};

        return options;
    },

    /**
     * Add the previous typed search term.
     *
     * @return {Object} Pagination fetch options.
     */
    getSearchOptions: function() {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params: {
                q: term
            },
            fields: collection.fields ? collection.fields : this.collection
        };
        return options;
    },

    /**
     * Retrieve the metadata of the recordlist view
     *
     * @return {Object}
     * @private
     */
    _initializeMetadata: function() {
        return app.metadata.getView(null, 'recordlist') || {};
    },

    /**
     * Filters the given meta removing non-applicable portions
     * @param {Object} meta data to be filtered
     * @return {Object}
     * @private
     */
    _filterMeta : function(meta, options) {
        // Don't show the update calc field option if the module has no calculated
        // fields or the user is not a dev for that module
        var context = options.context;
        var isDeveloper = app.acl.hasAccess("developer", context.get("module"));
        var hasCalcFields = context && context.get("model") && !!_.find(context.get("model").fields, function(def) {
            return def && def.calculated && def.calculated != "false";
        });
        // Used in sanitizing subpanel row actions for Tags module
        var isTagsParent = options.context.get('parentModule') === 'Tags';

        if ((!isDeveloper || !hasCalcFields) && meta.selection && meta.selection.actions) {
            meta.selection.actions = _.reject(meta.selection.actions, function(action) {
                return action.name == "calc_field_button";
            });
        }

        // Handle Tags module specific rules. Yes, this is dirty, but given how
        // Subpanels on Tags need to be treated, this is just about the only way
        // to do this
        if (isTagsParent && meta.rowactions && meta.rowactions.actions) {
            // Tags does not support Unlinking of records in subpanels, so we
            // need to traverse the row actions array of options.meta and, if
            // any of the rowactions is a type unlink-action we need to remove
            // it from the rowactions array
            meta.rowactions.actions = _.reject(meta.rowactions.actions, function(row) {
                return row.type === 'unlink-action';
            });
        }

        return meta;
    },

    /**
     * Refresh the current collection set.
     */
    refreshCollection: function() {
        this.collection.fetch();
    },

    addActions:function () {
        if (this.actionsAdded) return;
        this._super("addActions");
        if(_.isUndefined(this.leftColumns[0])){
            //Add blank left column to contain favorite and inline-cancel buttons
            this.leftColumns.push({
                'type':'fieldset',
                'label': '',
                'sortable': false,
                'fields': []
            });
        }
        //Add Favorite to left
        this.addFavorite();

        //Add Save & Cancel
        var firstLeftColumn = this.leftColumns[0];
        if (firstLeftColumn && _.isArray(firstLeftColumn.fields)) {
            //Add Cancel button to left
            firstLeftColumn.fields.push({
                type:'editablelistbutton',
                label:'LBL_CANCEL_BUTTON_LABEL',
                name:'inline-cancel',
                css_class:'btn-link btn-invisible inline-cancel'
            });
            this.leftColumns[0] = firstLeftColumn;
        }
        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Add Save button to right
            firstRightColumn.css_class = 'overflow-visible';
            firstRightColumn.fields.push({
                type:'editablelistbutton',
                label:'LBL_SAVE_BUTTON_LABEL',
                name:'inline-save',
                css_class:'btn-primary'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    },

    /**
     * Add favorite column
     */
    addFavorite: function() {
        var favoritesEnabled = app.metadata.getModule(this.module, "favoritesEnabled");
        if (favoritesEnabled !== false
            && this.meta.favorite && this.leftColumns[0] && _.isArray(this.leftColumns[0].fields)) {
            this.leftColumns[0].fields.push({type:'favorite'});
        }
    },

    /**
     * Set, or reset, the collection of fields that contains each row.
     *
     * This function is invoked when the view renders. It will update the row
     * fields once the `Pagination` plugin successfully fetches new records.
     *
     * @private
     */
    _setRowFields: function() {
        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model && field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
    },

    /**
     * Stores the current scrolling position of the list content when tab key is
     * pressed.
     *
     * @param {Event} event The keydown event.
     * @private
     */
    _setScrollPosition: function(event) {
        if (event.keyCode === 9) {
            var $flexListContent = this.$('.flex-list-view-content');
            $flexListContent.data('previousScrollLeftValue', $flexListContent.scrollLeft());
        }
    },

    /**
     * Retrieves the location of the edges of the list viewport and caches it
     * to `this._bordersPosition`.
     *
     * @return {Object} Object with properties:
     * @return {number} return.left the position left edge.
     * @return {number} return.right the position right edge.
     * @private
     */
    _getBordersPosition: function() {
        if (!this._bordersPosition) {

            /**
             * Object containing the location of left and right edges of the
             * list viewport.
             *
             * @property {Object} _bordersPosition
             * @property {number} _bordersPosition.left The left offset of the
             *   left edge of the viewport.
             * @property {number} _bordersPosition.right The left offset of the
             *   right edge of the viewport.
             * @private
             */
            this._bordersPosition = {};
            var thSelector = {};
            var $scrollPanel = this.$('.flex-list-view-content');
            var rtl = app.lang.direction === 'rtl';

            thSelector.left = rtl ? 'last' : 'first';
            thSelector.right = rtl ? 'first' : 'last';
            this._bordersPosition.left = $scrollPanel.find('thead tr:first th:' + thSelector.left).outerWidth();
            this._bordersPosition.right = $scrollPanel.find(
                'thead tr:first th:' + thSelector.right).children().position().left;
        }
        return this._bordersPosition;
    },

    /**
     * Sets the position of the current list panel.
     *
     * Doesn't adjust panel position if the focused field is fully visible in
     * the viewport.
     *
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     */
    setPanelPosition: function(location) {
        var bordersPosition = this._getBordersPosition();
        var fieldLeft = location.left;
        var fieldRight = location.right;
        if (fieldRight <= bordersPosition.right && fieldLeft >= bordersPosition.left) {
            return;
        }
        this._scrollToMakeFieldVisible(bordersPosition.left, bordersPosition.right, location);
    },

    /**
     * Scrolls the list horizontally to make the clicked field fully visible.
     *
     * @param {number} leftBorderPosition Position of the left edge of the
     *   list viewport.
     * @param {number} rightBorderPosition Position of the right edge of the
     *   list viewport.
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     * @private
     */
    _scrollToMakeFieldVisible: function(leftBorderPosition, rightBorderPosition, location) {
        var $scrollPanel = this.$('.flex-list-view-content');
        var scrollPosition = $scrollPanel.scrollLeft();
        var fieldLeft = location.left;
        var fieldRight = location.right;
        var fieldPadding = location.fieldPadding;
        var distanceToScroll;

        if (fieldLeft < leftBorderPosition) {
            distanceToScroll = fieldLeft - leftBorderPosition - fieldPadding;
        } else if (rightBorderPosition < fieldRight) {
            distanceToScroll = fieldRight - rightBorderPosition + fieldPadding;
        } else {
            return;
        }
        if (app.lang.direction === 'rtl' && $.support.rtlScrollType === 'reverse') {
            distanceToScroll = - distanceToScroll;
        }
        $scrollPanel.scrollLeft(scrollPosition + distanceToScroll);
    },

    /**
     * Set the position of scrollable panel
     * at the left border of the focused element.
     *
     * @param {number} left Left position of the focused element.
     * @deprecated 7.7 and will be removed in 7.8.
     */
    setScrollAtLeftBorder: function(left) {
        var $scrollPanel = this.$('.flex-list-view-content'),
            leftBorderPosition = this._getBordersPosition().left,
            scrollLeft = $scrollPanel.scrollLeft();

        left += scrollLeft - leftBorderPosition;
        $scrollPanel.scrollLeft(left);
        app.logger.warn('"setScrollAtLeftBorder" method is deprecated and will be removed in 7.8');
    },

    /**
     * Set the position of scrollable panel
     * at the right border of the focused element.
     *
     * @param {number} right Right position of the focused element.
     * @deprecated 7.7 and will be removed in 7.8.
     */
    setScrollAtRightBorder: function(right) {
        var $scrollPanel = this.$('.flex-list-view-content'),
            rightBorderPosition = this._getBordersPosition().right,
            scrollLeft = $scrollPanel.scrollLeft();

        right += scrollLeft - rightBorderPosition;
        $scrollPanel.scrollLeft(right);
        app.logger.warn('"setScrollAtRightBorder" method is deprecated and will be removed in 7.8');
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this,
            model = this._modelToDelete;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages(self._modelToDelete).success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToDelete = null;
                self.collection.remove(model, { silent: redirect });
                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }
                app.events.trigger("preview:close");
                if (!self.disposed) {
                    self.render();
                }

                self.layout.trigger("list:record:deleted", model);
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Popup dialog message to confirm delete action
     *
     * @param {Backbone.Model} model the bean to delete
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages(model).confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages(this._modelToDelete).confirmation;
        }
    },

    /**
     * {@link app.plugins.view.editable}
     * Compare with last fetched data and return true if model contains changes.
     * if model contains changed attributes,
     * check whether those are among the editable fields or not.
     *
     * @return {Boolean} True if current inline edit model contains unsaved changes.
     */
    hasUnsavedChanges: function() {
        var firstKey = _.first(_.keys(this.rowFields)),
            formFields = [];

        _.each(this.rowFields[firstKey], function(field) {
            if (field.name) {
                formFields.push(field.name);
            }
            //Inspect fieldset children fields
            if (field.def.fields) {
                formFields = _.chain(field.def.fields)
                    .pluck('name')
                    .compact()
                    .union(formFields)
                    .value();
            }
        }, this);
        return _.some(_.values(this.toggledModels), function(model) {
            var changedAttributes = model.changedAttributes(model.getSynced());

            if (_.isEmpty(changedAttributes)) {
                return false;
            }
            var unsavedFields = _.intersection(_.keys(changedAttributes), formFields);
            return !_.isEmpty(unsavedFields);
        }, this);
    },

    /**
     * Handles merge button.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'));
    },

    /**
     * Toggle the selected model's fields when edit is clicked.
     *
     * @param {Backbone.Model} model Selected row's model.
     */
    editClicked: function(model, field) {
        if (field.def.full_form) {
            var parentModel = this.context.parent.get('model');
            var link = this.context.get('link');

            // `app.bwc.createRelatedRecord` navigates to the BWC EditView if an
            // id is passed to it.
            app.bwc.createRelatedRecord(this.module, parentModel, link, model.id);
        } else {
            this.toggleRow(model.id, true);
            //check to see if horizontal scrolling needs to be enabled
            this.resize();
        }
        if (!_.isEqual(model.attributes, model._syncedAttributes)) {
            model.setSyncedAttributes(model.attributes);
        }
    },

    /**
     * Toggle editable selected row's model fields.
     *
     * @param {String} modelId Model Id.
     * @param {Boolean} isEdit True for edit mode, otherwise toggle back to list mode.
     */
    toggleRow: function(modelId, isEdit) {
        if (isEdit) {
            this.toggledModels[modelId] = this.collection.get(modelId);
        } else {
            delete this.toggledModels[modelId];
        }
        this.$('tr[name=' + this.module + '_' + modelId + ']').toggleClass('tr-inline-edit', isEdit);
        this.toggleFields(this.rowFields[modelId], isEdit);
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function(){
        this.unbindBeforeRouteDelete();
        this._super('_dispose');
        this.rowFields = null;
    },

    /**
     * Adds the favorite field to app.view.View.getFieldNames() if meta.favorites is true
     * so my_favorite is part of the field list and is fetched
     */
    getFieldNames: function(module, onlyDataFields) {
        //Start with an empty set of fields since the view name in the request will load all fields from the metadata.
        var fields = onlyDataFields ? [ ] : this._super('getFieldNames', arguments);
        if (this.meta.favorite) {
            fields = _.union(fields, ['my_favorite']);
        }
        if (this.meta.following) {
            fields = _.union(fields, ['following']);
        }
        return fields;
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        var clickButton = function($button) {
            if ($button.is(':visible') && !$button.hasClass('disabled')) {
                $button.click();
            }
        };

        this._super('registerShortcuts');

        app.shortcuts.register('List:Inline:Edit', 'e', function() {
            var self = this;
            if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                this.$('.selected [data-toggle=dropdown]:visible').click();
                this.$('.selected [name=edit_button]:visible').click();
                _.defer(function() {
                    self.$('.selected input:first').focus();
                });
            }
        }, this);

        app.shortcuts.register('List:Delete', 'd', function() {
            if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                this.$('.selected [data-toggle=dropdown]:visible').click().blur();
                this.$('.selected [name=delete_button]:visible').click();
            }
        }, this);

        app.shortcuts.register('List:Inline:Cancel', ['esc','ctrl+alt+l'], function(event) {
            var $cancelButton = this.$('.selected [name=inline-cancel]'),
                $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

            if ($cancelButton.length > 0) {
                clickButton($cancelButton);
            } else if ($focusedInlineEditRow.length > 0) {
                clickButton($focusedInlineEditRow.find('[name=inline-cancel]'));
            }
        }, this, true);

        app.shortcuts.register('List:Inline:Save', ['ctrl+s','ctrl+alt+a'], function(event) {
            var $saveButton = this.$('.selected [name=inline-save]'),
                $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

            if ($saveButton.length > 0) {
                clickButton($saveButton);
            } else if ($focusedInlineEditRow.length > 0) {
                clickButton($focusedInlineEditRow.find('[name=inline-save]'));
            }
        }, this, true);

        app.shortcuts.register('List:Favorite', 'f a', function() {
            this.$('.selected .fa-favorite:visible').click();
        }, this);

        app.shortcuts.register('List:Follow', 'f o', function() {
            this.$('.selected [data-toggle=dropdown]:visible').click().blur();
            this.$('.selected [name=follow_button]:visible').click();
        }, this);

        app.shortcuts.register('List:Preview', 'p', function() {
            clickButton(this.$('.selected [data-event="list:preview:fire"]:visible'));
        }, this);

        app.shortcuts.register('List:Select', 'x', function() {
            var $checkbox = this.$('.selected input[type=checkbox]:first');
            if ($checkbox.is(':visible') && !$checkbox.hasClass('disabled')) {
                $checkbox.get(0).click();
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Unsets `_bordersPosition` because the value changes on resize and will
     * have to be recalculated if the user toggles inline edit mode.
     */
    resize: function() {
        this._super('resize');
        this._bordersPosition = null;
    },

    /**
     * Refreshes the `ReorderableColumns` when the table height changes.
     *
     * The `ReorderableColumns` plugin listens to the window `resize` event to
     * update and position the handlers correctly.
     *
     * @private
     */
    _refreshReorderableColumns: function() {
        $(window).resize();
    }
}) },
"dashablelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashablelist is a dashlet representation of a module list view. Users can
 * build dashlets of this type for any accessible and approved module with
 * their choice of columns from the list view for their chosen module.
 *
 * Options:
 * {String}  module             The module from which the records are
 *                              retrieved.
 * {String}  label              The string (i18n or hard-coded) representing
 *                              the dashlet name that the user sees.
 * {Array}   display_columns    The field names of the columns to include in
 *                              the list view.
 * {String}  filter_id          Filter to be applied, defaults to:
 *                              'assigned_to_me'.
 * {Integer} limit              The number of records to retrieve for the list
 *                              view.
 * {Integer} auto_refresh       How frequently (in minutes) that the dashlet
 *                              should refresh its data collection.
 *
 * Example:
 * <pre><code>
 * // ...
 * array(
 *     'module'          => 'Accounts',
 *     'label'           => 'LBL_MODULE_NAME',
 *     'display_columns' => array(
 *         'name',
 *         'phone_office',
 *         'billing_address_country',
 *     ),
 *     'filter_id'       => 'assigned_to_me',
 *     'limit'           => 15,
 *     'auto_refresh'    => 5,
 * ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.DashablelistView
 * @alias SUGAR.App.view.views.BaseDashablelistView
 * @extends View.Views.Base.ListView
 */
({
	// Dashablelist View (base) 

    extendsFrom: 'ListView',

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet', 'Pagination'],

    /**
     * We want to load field `list` templates
     */
    fallbackFieldTemplate: 'list',

    /**
     * The default settings for a list view dashlet.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        filter_id: 'assigned_to_me',
        intelligent: '0'
    },

    /**
     * Modules that are permanently blacklisted so users cannot configure a
     * dashlet for these modules.
     *
     * @property {Array}
     */
    moduleBlacklist: ['Home', 'Forecasts', 'ProductCategories', 'ProductTemplates'],

    /**
     * Module Additions
     *
     * When a specific module is allowed, we should add these other modules that are
     * not first class modules.
     *
     * @property {Array}
     */
    additionalModules: {
        'Project': ['ProjectTask']
    },

    /**
     * Cache of the modules a user is allowed to see.
     *
     * The keys are the module names and the values are the module names after
     * resolving them against module and/or app strings. The cache logic can be
     * seen in {@link BaseDashablelistView#_getAvailableModules}.
     *
     * @property {Object}
     */
    _availableModules: {},

    /**
     * Cache of the fields found in each module's list view definition.
     *
     * This hash is multi-dimensional. The first set of keys are the module
     * names and the values are objects where the keys are the field names and
     * the values are the field names after resolving them against module
     * and/or app strings. The cache logic can be seen in
     * {@link BaseDashablelistView#_getAvailableColumns}.
     *
     * @property {Object}
     */
    _availableColumns: {},

    /**
     * Flag indicates if dashlet is intelligent.
     */
    intelligent: null,

    /**
     * Flag indicates if a module is available for display.
     */
    moduleIsAvailable: true,

    /**
     * @inheritdoc
     *
     * Append lastStateID on metadata in order to active user cache.
     */
    initialize: function(options) {
        options.meta = _.extend({}, options.meta, {
            last_state: {
                id: 'dashable-list'
            }
        });
        this.checkIntelligence();
        this._super('initialize', [options]);
        this._noAccessTemplate = app.template.get(this.name + '.noaccess');
    },

    /**
     * Check if dashlet can be intelligent.
     *
     * A dashlet is considered intelligent when the data relates to the current
     * record.
     *
     * @return {String} Whether or not the dashlet can be intelligent.
     */
    checkIntelligence: function() {
        var isIntelligent = app.controller.context.get('layout') === 'record' &&
            !_.contains(this.moduleBlacklist, app.controller.context.get('module'));
        this.intelligent = isIntelligent ? '1' : '0';
        return this.intelligent;
    },

    /**
     * Show/hide `linked_fields` field.
     *
     * @param {String} visible '1' to show the field, '0' to hide it.
     * @param {String} [intelligent='1'] Whether the dashlet is in intelligent
     *   mode or not.
     */
    setLinkedFieldVisibility: function(visible, intelligent) {
        var field = this.getField('linked_fields'),
            fieldEl;
        if (!field) {
            return;
        }
        intelligent = (intelligent === false || intelligent === '0') ? '0' : '1';
        fieldEl = this.$('[data-name=linked_fields]');
        if (visible === '1' && intelligent === '1' && !_.isEmpty(field.items)) {
            fieldEl.show();
        } else {
            fieldEl.hide();
        }
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {String} view The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(view) {
        if (this.meta.config) {
            // keep the display_columns and label fields in sync with the selected module when configuring a dashlet
            this.settings.on('change:module', function(model, moduleName) {
                var label = (model.get('filter_id') === 'assigned_to_me') ? 'TPL_DASHLET_MY_MODULE' : 'LBL_MODULE_NAME';
                model.set('label', app.lang.get(label, moduleName, {
                    module: app.lang.getModuleName(moduleName, {plural: true})
                }));

                // Re-initialize the filterpanel with the new module.
                this.dashModel.set('module', moduleName);
                this.dashModel.set('filter_id', 'assigned_to_me');
                this.layout.trigger('dashlet:filter:reinitialize');

                this._updateDisplayColumns();
                this.updateLinkedFields(moduleName);
            }, this);
            this.settings.on('change:intelligent', function(model, intelligent) {
                this.setLinkedFieldVisibility('1', intelligent);
            }, this);
            this.on('render', function() {
                var isVisible = !_.isEmpty(this.settings.get('linked_fields')) ? '1' : '0';
                this.setLinkedFieldVisibility(isVisible, this.settings.get('intelligent'));
            }, this);
        }
        this._initializeSettings();
        this.metaFields = this._getColumnsForDisplay();

        if (this.settings.get('intelligent') == '1') {

            var link = this.settings.get('linked_fields'),
                model = app.controller.context.get('model'),
                module = this.settings.get('module'),
                options = {
                    link: {
                        name: link,
                        bean: model
                    },
                    relate: true
                };
            this.collection = app.data.createBeanCollection(module, null, options);
            this.context.set('collection', this.collection);
            this.context.set('link', link);
        } else {
            this.context.unset('link');
        }

        this.before('render', function() {
            if (!this.moduleIsAvailable) {
                this.$el.html(this._noAccessTemplate());
                return false;
            }
        });

        // the pivot point for the various dashlet paths
        if (this.meta.config) {
            this._configureDashlet();
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.listenTo(this.layout.context, 'filter:add', this.updateDashletFilterAndSave);
            this.layout.before('dashletconfig:save', function() {
                this.saveDashletFilter();
                // NOTE: This prevents the drawer from closing prematurely.
                return false;
            }, this);

        } else if (this.moduleIsAvailable) {
            var filterId = this.settings.get('filter_id');
            if (!filterId || this.meta.preview) {
                this._displayDashlet();
                return;
            }

            var filters = app.data.createBeanCollection('Filters');
            filters.setModuleName(this.settings.get('module'));
            filters.load({
                success: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    var filter = filters.collection.get(filterId);
                    var filterDef = filter && filter.get('filter_definition');
                    this._displayDashlet(filterDef);
                }, this),
                error: _.bind(function(err) {
                    if (this.disposed) {
                        return;
                    }
                    this._displayDashlet();
                }, this)
            });
        }
    },

    /**
     * Fetch the next pagination records.
     */
    showMoreRecords: function() {
        // Show alerts for this request
        this.getNextPagination();
    },

    /**
     * Returns a custom label for this dashlet.
     *
     * @return {string}
     */
    getLabel: function() {
        var module = this.settings.get('module') || this.context.get('module'),
            moduleName = app.lang.getModuleName(module, {plural: true});
        return app.lang.get(this.settings.get('label'), module, {module: moduleName});
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. If the dashlet
     * we are saving is a dashable list, it initiates the save process for a new
     * filter on the appropriate module's list view, otherwise, it takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet model.
     */
    saveDashletFilter: function() {
        // Accessing the dashableconfiguration context.
        var context = this.layout.context;

        if (context.editingFilter) {
            // We are editing/creating a new filter
            if (!context.editingFilter.get('name')) {
                context.editingFilter.set('name', app.lang.get('LBL_DASHLET') +
                    ': ' + this.settings.get('label'));
            }
            // Triggers the save on `filter-rows` which then triggers
            // `filter:add` which then calls `updateDashletFilterAndSave`
            context.trigger('filter:create:save');
        } else {
            // We are saving a dashlet with a predefined filter
            var filterId = context.get('currentFilterId'),
                obj = {id: filterId};
            this.updateDashletFilterAndSave(obj);
        }
    },

    /**
     * This function is invoked by the `filter:add` event. It saves the
     * filter ID on the dashlet model prior to saving it, for later reference.
     *
     * @param {Bean} filterModel The saved filter model.
     */
    updateDashletFilterAndSave: function(filterModel) {
        // We need to save the filter ID on the dashlet model before saving
        // the dashlet.
        var id = filterModel.id || filterModel.get('id');
        this.settings.set('filter_id', id);
        this.dashModel.set('filter_id', id);

        var componentType = this.dashModel.get('componentType') || 'view';

        // Adding a new dashlet requires componentType to be set on the model.
        if (!this.dashModel.get('componentType')) {
            this.dashModel.set('componentType', componentType);
        }

        app.drawer.close(this.dashModel);
        // The filter collection is not shared amongst views and therefore
        // changes to this collection on different contexts (list views and
        // dashlets) need to be kept in sync.
        app.events.trigger('dashlet:filter:save', this.dashModel.get('module'));
    },

    /**
     * Certain dashlet settings can be defaulted.
     *
     * Builds the available module cache by way of the
     * {@link BaseDashablelistView#_setDefaultModule} call. The module is set
     * after "filter_id" because the value of "filter_id" could impact the value
     * of "label" when the label is set in response to the module change while
     * in configuration mode (see the "module:change" listener in
     * {@link BaseDashablelistView#initDashlet}).
     *
     * @private
     */
    _initializeSettings: function() {
        if (this.intelligent === '0') {
            _.each(this.dashletConfig.panels, function(panel) {
                panel.fields = panel.fields.filter(function(el) {return el.name !== 'intelligent'; });
            }, this);
            this.settings.set('intelligent', '0');
            this.dashModel.set('intelligent', '0');
        } else {
            if (_.isUndefined(this.settings.get('intelligent'))) {
                this.settings.set('intelligent', this._defaultSettings.intelligent);
            }
        }
        this.setLinkedFieldVisibility('1', this.settings.get('intelligent'));
        if (!this.settings.get('limit')) {
            this.settings.set('limit', this._defaultSettings.limit);
        }
        if (!this.settings.get('filter_id')) {
            this.settings.set('filter_id', this._defaultSettings.filter_id);
        }
        this._setDefaultModule();
        if (!this.settings.get('label')) {
            this.settings.set('label', 'LBL_MODULE_NAME');
        }
    },

    /**
     * Sets the default module when a module isn't defined in the dashlet's
     * view definition.
     *
     * If the module was defined but it is not in the list of available modules
     * in config mode, then the view's module will be used.
     * @private
     */
    _setDefaultModule: function() {
        var availableModules = _.keys(this._getAvailableModules()),
            module = this.settings.get('module') || this.context.get('module');

        if (_.contains(availableModules, module)) {
            this.settings.set('module', module);
        } else if (this.meta.config) {
            module = this.context.parent.get('module');
            if (_.contains(this.moduleBlacklist, module)) {
                module = _.first(availableModules);
            }
            this.settings.set('module', module);
        } else {
            this.moduleIsAvailable = false;
        }
    },

    /**
     * Update the display_columns attribute based on the current module defined
     * in settings.
     *
     * This will mark, as selected, all fields in the module's list view
     * definition. Any existing options will be replaced with the new options
     * if the "display_columns" DOM field ({@link EnumField}) exists.
     *
     * @private
     */
    _updateDisplayColumns: function() {
        var availableColumns = this._getAvailableColumns(),
            columnsFieldName = 'display_columns',
            columnsField = this.getField(columnsFieldName);
        if (columnsField) {
            columnsField.items = availableColumns;
        }
        this.settings.set(columnsFieldName, _.keys(availableColumns));
    },

    /**
     * Update options for `linked_fields` based on current selected module.
     * If there are no options field is hidden.
     *
     * @param {String} moduleName Name of selected module.
     */
    updateLinkedFields: function(moduleName) {
        var linked = this.getLinkedFields(moduleName),
            displayColumn = this.getField('linked_fields'),
            intelligent = this.dashModel.get('intelligent');
        if (displayColumn) {
            displayColumn.items = linked;
            this.setLinkedFieldVisibility('1', intelligent);
        } else {
            this.setLinkedFieldVisibility('0', intelligent);
        }
        this.settings.set('linked_fields', _.keys(linked)[0]);
    },

    /**
     * Returns object with linked fields.
     *
     * @param {String} moduleName Name of module to find linked fields with.
     * @return {Object} Hash with linked fields labels.
     */
    getLinkedFields: function(moduleName) {
        var fieldDefs  = app.metadata.getModule(this.layout.module).fields;
        var relates =  _.filter(fieldDefs, function(field) {
                if (!_.isUndefined(field.type) && (field.type === 'link')) {
                    if (app.data.getRelatedModule(this.layout.module, field.name) === moduleName) {
                        return true;
                    }
                }
                return false;
            }, this),
            result = {};
        _.each(relates, function(field) {
            result[field.name] = app.lang.get(field.vname || field.name, [this.layout.module, moduleName]);
        }, this);
        return result;
    },

    /**
     * Perform any necessary setup before the user can configure the dashlet.
     *
     * Modifies the dashlet configuration panel metadata to allow it to be
     * dynamically primed prior to rendering.
     *
     * @private
     */
    _configureDashlet: function() {
        var availableModules = this._getAvailableModules(),
            availableColumns = this._getAvailableColumns(),
            relates = this.getLinkedFields(this.module);
        _.each(this.getFieldMetaForView(this.meta), function(field) {
            switch(field.name) {
                case 'module':
                    // load the list of available modules into the metadata
                    field.options = availableModules;
                    break;
                case 'display_columns':
                    // load the list of available columns into the metadata
                    field.options = availableColumns;
                    break;
                case 'linked_fields':
                    field.options = relates;
                    break;
            }
        });
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('dashablelist-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'dashablelist-filter'
        }]);
    },

    /**
     * Gets all of the modules the current user can see.
     *
     * This is used for populating the module select and list view columns
     * fields. Filters any modules that are blacklisted.
     *
     * @return {Object} {@link BaseDashablelistView#_availableModules}
     * @private
     */
    _getAvailableModules: function() {
        if (_.isEmpty(this._availableModules) || !_.isObject(this._availableModules)) {
            this._availableModules = {};
            var visibleModules = app.metadata.getModuleNames({filter: 'visible', access: 'read'}),
                allowedModules = _.difference(visibleModules, this.moduleBlacklist);
            
            _.each(this.additionalModules, function(extraModules, module) {
                if (_.contains(allowedModules, module)) {
                    allowedModules = _.sortBy(_.union(allowedModules, extraModules), function(name) {return name});
                }
            });
            _.each(allowedModules, function(module) {
                var hasListView = !_.isEmpty(this.getFieldMetaForView(app.metadata.getView(module, 'list')));
                if (hasListView) {
                    this._availableModules[module] = app.lang.getModuleName(module, {plural: true});
                }
            }, this);
        }
        return this._availableModules;
    },

    /**
     * Gets the correct list view metadata.
     *
     * Returns the correct module list metadata
     *
     * @param  {String} module
     * @return {Object}
     */
    _getListMeta: function(module) {
        return app.metadata.getView(module, 'list');
    },

    /**
     * Gets all of the fields from the list view metadata for the currently
     * chosen module.
     *
     * This is used for the populating the list view columns field and
     * displaying the list.
     *
     * @return {Object} {@link BaseDashablelistView#_availableColumns}
     * @private
     */
    _getAvailableColumns: function() {
        var columns = {},
            module = this.settings.get('module');
        if (!module) {
            return columns;
        }

        _.each(this.getFieldMetaForView(this._getListMeta(module)), function(field) {
            columns[field.name] = app.lang.get(field.label || field.name, module);
        });

        return columns;
    },

    /**
     * Perform any necessary setup before displaying the dashlet.
     *
     * @param {Array} [filterDef] The filter definition array.
     * @private
     */
    _displayDashlet: function(filterDef) {
        // Get the columns that are to be displayed and update the panel metadata.
        var columns = this._getColumnsForDisplay();
        this.meta.panels = [{fields: columns}];

        this.context.set('skipFetch', false);
        this.context.set('limit', this.settings.get('limit'));
        this.context.set('fields', this.getFieldNames());

        if (filterDef) {
            this._applyFilterDef(filterDef);
            this.context.reloadData({'recursive': false});
        }
        this._startAutoRefresh();
    },

    /**
     * Sets the filter definition on the context collection to retrieve records
     * for the list view.
     *
     * @param {Array} filterDef The filter definition array.
     * @private
     */
    _applyFilterDef: function(filterDef) {
        if (filterDef) {

            filterDef = _.isArray(filterDef) ? filterDef : [filterDef];
            /**
             * Filter fields that don't exist either on vardefs or search definition.
             *
             * Special fields (fields that start with `$`) like `$favorite` aren't
             * cleared.
             *
             * TODO move this to a plugin method when refactoring the code (see SC-2555)
             * TODO we should support cleanup on all levels (currently made on 1st
             * level only).
             */
            var specialField = /^\$/,
                meta = app.metadata.getModule(this.module);
            filterDef = _.filter(filterDef, function(def) {
                var fieldName = _.keys(def).pop();
                return specialField.test(fieldName) || meta.fields[fieldName];
            }, this);

            this.context.get('collection').filterDef = filterDef;
        }
    },

    /**
     * Gets the columns chosen for display for this dashlet list.
     *
     * The display_columns setting might not have been defined when the dashlet
     * is being displayed from a metadata definition, like is the case for
     * preview and the default dashablelist's that are defined. All columns for
     * the selected module are shown in these cases.
     *
     * @return {Object[]} Array of objects defining the field metadata for
     *   each column.
     * @private
     */
    _getColumnsForDisplay: function() {
        var columns = [];
        var fields = this.getFieldMetaForView(this._getListMeta(this.settings.get('module')));
        var moduleMeta = app.metadata.getModule(this.module);
        if (!this.settings.get('display_columns')) {
            this._updateDisplayColumns();
        }
        if (!this.settings.get('linked_fields')) {
            this.updateLinkedFields(this.model.module);
        }
        _.each(this.settings.get('display_columns'), function(name) {
            var field = _.find(fields, function(field) {
                return field.name === name;
            }, this);
            // It's possible that a column is on the dashlet and not on the
            // main list view (thus was never patched by metadata-manager).
            // We need to fix up the columns in that case.
            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in.
            field = field || app.metadata._patchFields(this.module, moduleMeta, [name]);

            // Handle setting of the sortable flag on the list. This will not
            // always be true
            var sortableFlag,
                column,
                fieldDef = app.metadata.getModule(this.module).fields[field.name];

            // If the module's field def says nothing about the sortability, then
            // assume it's ok to sort
            if (_.isUndefined(fieldDef) || _.isUndefined(fieldDef.sortable)) {
                sortableFlag = true;
            } else {
                // Get what the field def says it is supposed to do
                sortableFlag = !!fieldDef.sortable;
            }

            column = _.extend({sortable: sortableFlag}, field);

            columns.push(column);
        }, this);
        return columns;
    },

    /**
     * Starts the automatic refresh of the dashlet.
     *
     * @private
     */
    _startAutoRefresh: function() {
        var refreshRate = parseInt(this.settings.get('auto_refresh'), 10);
        if (refreshRate) {
            this._stopAutoRefresh();
            this._timerId = setInterval(_.bind(function() {
                this.context.resetLoadFlag();
                this.layout.loadData();
            }, this), refreshRate * 1000 * 60);
        }
    },

    /**
     * Cancels the automatic refresh of the dashlet.
     *
     * @private
     */
    _stopAutoRefresh: function() {
        if (this._timerId) {
            clearInterval(this._timerId);
        }
    },

    /**
     * @inheritdoc
     *
     * Calls {@link BaseDashablelistView#_stopAutoRefresh} so that the refresh will
     * not continue after the view is disposed.
     *
     * @private
     */
    _dispose: function() {
        this._stopAutoRefresh();
        this._super('_dispose');
    },

    /**
     * Gets the fields metadata from a particular view's metadata.
     *
     * @param {Object} meta The view's metadata.
     * @return {Object[]} The fields metadata or an empty array.
     */
    getFieldMetaForView: function(meta) {
        meta = _.isObject(meta) ? meta : {};
        return !_.isUndefined(meta.panels) ? _.flatten(_.pluck(meta.panels, 'fields')) : [];
    },

    /**
     * ListView sort will close previews, but this is not needed for dashablelists
     * In fact, closing preview causes problem when previewing this list dashlet
     * from dashlet-select
     */
    sort: $.noop
}) },
"history-summary-preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryPreviewHeaderView
 * @alias SUGAR.App.view.views.BaseHistorySummaryPreviewHeaderView
 * @extends View.Views.Base.PreviewHeaderView
 */
({
	// History-summary-preview-header View (base) 

    extendsFrom: 'PreviewHeaderView'
}) },
"selection-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SelectionHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSelectionHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Selection-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    initialize: function(options) {
        this._super('initialize', [options]);

        var moduleMeta = app.metadata.getModule(options.module),
            isBwcEnabled = (moduleMeta && moduleMeta.isBwcEnabled),
            multiSelect = options.context.get('isMultiSelect'),
            buttonsToRemove = [],
            additionalEvents = {};

        this.isMultiLink = options.context.has('recLink');

        if (isBwcEnabled || multiSelect || this.isMultiLink) {
            buttonsToRemove.push('create_button');
        } else {
            additionalEvents['click [name=create_button]'] = 'createAndSelect';
            this.events = _.extend({}, this.events, additionalEvents);
        }


        if (this.isMultiLink) {
            //FIXME: This will be removed with SC-4073.
            var linkTitleLabel = _.find(this.meta.fields, function(field) {
                return field.name === 'title';
            }, this);
            linkTitleLabel.default_value = 'TPL_SEARCH_AND_ADD';
        } else {
            buttonsToRemove.push('link_button');
        }

        if (!multiSelect) {
            buttonsToRemove.push('select_button');
        }

        this._removeButtons(buttonsToRemove);
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');

        this.layout.on('selection:closedrawer:fire', _.once(_.bind(function() {
            this.$el.off();
            app.drawer.close();
        }, this)));

        if (this.isMultiLink) {
            this.layout.on('selection:link:fire', function() {
                this.context.trigger('selection-list:link:multi');
            });
        }
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var moduleName = app.lang.get('LBL_MODULE_NAME', this.module);
        return app.lang.get(title, this.module, {module: moduleName});
    },

    /**
     * Open create inline modal with no dupe check
     * On save, set the selection model which will close the selection-list inline modal
     */
    createAndSelect: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                module: this.module,
                create: true
            }
        }, _.bind(function(context, model) {
            if (model) {
                this.context.trigger('selection-list:select', context, model);
            }
        }, this));
    },

    /**
     * Removes buttons from main_dropdown
     *
     * @param {Array} buttons The names of the buttons to remove.
     * @private
     */
    _removeButtons: function(buttons) {
        if (!buttons.length) {
            return;
        }

        var mainDropdown = _.find(this.meta.buttons, function(button) {
            return button.name === 'main_dropdown';
        });

        if (!mainDropdown) {
            return;
        }

        mainDropdown.buttons = _.filter(mainDropdown.buttons, function(button) {
            return !_.contains(buttons, button.name);
        });
    }
}) },
"dnb-bal-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dnb-bal-results View (base) 

    extendsFrom: 'DnbView',

    plugins: ['Connector'],

    events: {
        'click .importContacts': 'importContacts',
        'click .backToContactsList': 'backToContactsList',
        'click .dnb-cnt-prem': 'baseGetContactDetails',
        'click .dnb-cnt-std': 'baseGetContactDetails',
        'click [data-action="show-more"]': 'invokePagination'
    },

    selectors: {
        'load': '#dnb-bal-result-loading',
        'rslt': '#dnb-bal-result',
        'rsltList': 'ul#dnb-results-list',
        'contactrslt': '#dnb-bal-contact-list'
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.initDashlet();
        app.events.on('dnbbal:invoke', this.invokeBAL, this);
        var originalMeta = app.metadata.getView('','dnb-bal-results');
        if (originalMeta.import_enabled_modules) {
            this.import_enabled_modules = originalMeta.import_enabled_modules;
        }
        this.paginationCallback = this.baseContactsBAL;
        this.rowTmpl = app.template.get(this.name + '.dnb-contact-row');
        this.resultTemplate = app.template.get(this.name + '.dnb-bal-contacts-rslt');
        this.resultCountTmpl = app.lang.get('LBL_DNB_BAL_RSLT_CNT', this.module);
    },

    /**
     * Overriding the render function to populate the import type drop down
     */
    _render: function() {
        //TODO: Investigate why using this._super('_renderHtml');
        //we get Unable to find method _renderHtml on parent class of dnb-bal-results
        app.view.View.prototype._renderHtml.call(this);
        this.$('#importType').select2();
    },

    loadData: function(options) {
        this.checkConnector('ext_rest_dnb',
            _.bind(this.loadDataWithValidConnector, this),
            _.bind(this.handleLoadError, this),
            ['test_passed']);
    },

    /**
     * Success callback to be run when Connector has been verified and validated
     */
    loadDataWithValidConnector: function() {
        this.template = app.template.get(this.name + '.dnb-bal-hint');
        this.render();
        this.dnbError = null;
        //placed here instead of initialize
        //so that pagination params are reset when
        //reset is clicked on dnb-bal-params view
        this.initPaginationParams();
    },

    /**
     * Failure callback to be run if Connector verification fails
     * @param {object} connector that failed
     */
    handleLoadError: function(connector) {
        //checks if the current user has admin access
        var showAdmin = app.acl.hasAccess('admin', 'Administration');
        if (showAdmin) {
            this.dnbError = {
                'errMsg': 'LBL_DNB_NOT_CONFIGURED',
                'errorLink': this.commonConst.connectorSettingsURL,
                'label': 'LBL_DNB_BAL'
            };
        } else {
            this.dnbError = {
                'errMsg': 'LBL_DNB_CONNECTOR_ERR',
                'label': 'LBL_DNB_BAL'
            };
        }
        this.template = app.template.get('dnb.dnb-sidepane-error');
        this.render();
    },

    /**
     * Listens for model change for certain attributes
     * Captures these attributes and invokes bal
     * @param {Object} balParams
     */
    invokeBAL: function(balParams) {
        if (!_.isEmpty(balParams)) {
            //resetting the pagination parameters every time a new bal call is made
            this.initPaginationParams();
            //setting the balParams to context
            //this is required to invoke the api with the altered
            //pagination parameters
            this.balParams = balParams;
            this.buildAList(this.setApiPaginationParams(balParams));
        } else {
            this.loadData();
        }
    },

    /**
     * Build a list of accounts
     * @param {Object} balParams
     */
    buildAList: function(balParams) {
        if (this.disposed) {
            return;
        }
        this.template = this.resultTemplate;
        if (this.listData && this.listData.count) {
            delete this.listData['count'];
        }
        this.render();
        this.$(this.selectors.load).removeClass('hide');
        this.$(this.selectors.rslt).addClass('hide');
        //this is required for duplicate check
        balParams.contactType = this.module;
        this.baseContactsBAL(balParams, this.renderBAL);
    },

    /**
     * Renders the list of D&B Contacts
     * @param {Object} dnbApiResponse
     */
    renderBAL: function(dnbApiResponse) {
        var dnbContactsList = {},
            appendRecords = false;
        if (this.resetPaginationFlag) {
            this.initPaginationParams();
        }
        if (dnbApiResponse.product) {
            var apiContactList = this.getJsonNode(dnbApiResponse.product, this.contactConst.contactsPath);
            //setting the formatted set of records to context
            //will be required when we paginate from the client side itself
            this.formattedRecordSet = this.formatContactList(apiContactList, this.contactsListDD);
            //setting the api recordCount to context
            //will be used to determine if the pagination controls must be displayed
            this.recordCount = this.getJsonNode(dnbApiResponse.product, this.contactConst.srchCount);
            var nextPage = this.paginateRecords();
            //currentPage is set to null by initPaginationParams
            if (_.isNull(this.currentPage)) {
                this.currentPage = nextPage;
                dnbContactsList.product = this.currentPage;
            } else {
                //this loop gets executed when api is called again to obtain more records
                dnbContactsList.product = nextPage;
                appendRecords = true;
            }
            if (this.recordCount) {
                dnbContactsList.count = this.recordCount;
            }
        } else if (dnbApiResponse.errmsg) {
            dnbContactsList.errmsg = dnbApiResponse.errmsg;
        }
        this.renderPage(dnbContactsList, appendRecords);
    },

    /**
     * Back to contacts list functionality
     */
    backToContactsList: function() {
        if (this.disposed) {
            return;
        }
        this.template = this.resultTemplate;
        if (this.listData && this.listData.count) {
            delete this.listData['count'];
        }
        this.render();
        this.$(this.selectors.load).removeClass('hide');
        this.$(this.selectors.rslt).addClass('hide');
        var dupeCheckParams = {
            'type': this.module,
            'apiResponse': this.currentPage,
            'module': 'contactsPage'
        };
        this.baseDuplicateCheck(dupeCheckParams, this.renderPage);
    },

    importContacts: function() {
        var module = this.$('#importType').val();
        this.baseImportContact(module);
    },

    /**
     * Event handler for pagination controls
     * Renders next page from context if available
     * else invokes the D&B API to get the next page
     */
    invokePagination: function() {
        this._super('invokePagination', [this.paginationCallback, this.balParams, this.renderBAL]);
    }
}) },
"opportunity-metrics": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OpportunityMetricsView
 * @alias SUGAR.App.view.views.BaseOpportunityMetricsView
 * @extends View.View
 */
({
	// Opportunity-metrics View (base) 

    plugins: ['Dashlet', 'Chart'],
    className: 'opportunity-metrics-wrapper',

    metricsCollection: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.chart = nv.models.pieChart()
                .x(function(d) {
                    return d.key;
                })
                .y(function(d) {
                    return d.value;
                })
                .margin({top: 0, right: 0, bottom: 5, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .colorData('data')
                .direction(app.lang.direction)
                .tooltipContent(function(key, x, y, e, graph) {
                    return '<p><b>' + key + ' ' + parseInt(y, 10) + '</b></p>';
                })
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA')
                });
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);

        d3.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        var total = 0,
            userConversionRate = 1 / app.metadata.getCurrency(app.user.getPreference('currency_id')).conversion_rate,
            userCurrencyPreference = app.user.getPreference('currency_id');
        _.each(data, function(value, key) {
            // parse currencies, format to user preference and attach the correct delimiters/symbols etc
            data[key].formattedAmount = app.currency.formatAmountLocale(app.currency.convertWithRate(value.amount_usdollar, userConversionRate), userCurrencyPreference, 0);
            data[key].icon = key === 'won' ? 'caret-up' : (key === 'lost' ? 'caret-down' : 'minus');
            data[key].cssClass = key === 'won' ? 'won' : (key === 'lost' ? 'lost' : 'active');
            data[key].dealLabel = key;
            data[key].stageLabel = app.lang.getAppListStrings('opportunity_metrics_dom')[key];
            total += value.count;
        });

        this.total = total;
        this.metricsCollection = data;

        this.chartCollection = {
            data: _.map(this.metricsCollection, function(value, key) {
                return {
                    'key': value.stageLabel,
                    'value': value.count,
                    'classes': key
                };
            }),
            properties: {
                title: app.lang.get('LBL_DASHLET_OPPORTUNITY_NAME'),
                value: 3,
                label: total
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            url;
        if (this.meta.config) {
            return;
        }
        url = app.api.buildURL(this.model.module, 'opportunity_stats', {
            id: this.model.get('id')
        });
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on metricsCollection
                    self.render();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Add a dashlet" view.
 * Displays a list of dashlets filtered according to current module and layout.
 *
 * @class View.Views.Base.DashletselectView
 * @alias SUGAR.App.view.views.DashletselectView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Dashletselect View (base) 

    extendsFrom: 'FilteredListView',

    /**
     * @inheritdoc
     *
     * Displays a filtered list of dashlets.
     * Uses client-generated collection with disabled load state, custom
     * preview and select actions.
     */
    initialize: function(options) {
        var meta = app.metadata.getView(null, 'dashletselect') || {};
        options.meta = _.extend({}, meta, options.meta || {});

        this._super('initialize', [options]);

        // To avoid reset while sorting.
        this.context = _.extend(_.clone(this.context), {
            resetLoadFlag: function() {
                return;
            }
        });

        this.context.on('dashletlist:select-and-edit', function(model) {
            this.selectDashlet(model.get('metadata'));
        }, this);

        this.context.on('dashletlist:preview:fire', function(model) {
            this.previewDashlet(model.get('metadata'));
        }, this);
    },

    /**
     * Load dashlet preview by passing preview metadata
     *
     * @param {Object} metadata Preview metadata.
     */
    previewDashlet: function(metadata) {
        var layout = this.layout,
            previewLayout;
        while (layout) {
            if (layout.getComponent('preview-pane')) {
                previewLayout = layout.getComponent('preview-pane').getComponent('dashlet-preview');
                previewLayout.showPreviewPanel();
                break;
            }
            layout = layout.layout;
        }

        if (previewLayout) {
            // If there is no preview property, use the config property
            if (!metadata.preview) {
                metadata.preview = metadata.config;
            }
            var previousComponent = _.last(previewLayout._components);
            if (previousComponent.name !== 'dashlet-preview') {
                var index = previewLayout._components.length - 1;
                previewLayout._components[index].dispose();
                previewLayout.removeComponent(index);
            }

            var contextDef,
                component = {
                    label: app.lang.get(metadata.label, metadata.preview.module),
                    type: metadata.type,
                    preview: true
                };
            if (metadata.preview.module || metadata.preview.link) {
                contextDef = {
                    skipFetch: false,
                    forceNew: true,
                    module: metadata.preview.module,
                    link: metadata.preview.link
                };
            } else if (metadata.module) {
                contextDef = {
                    module: metadata.module
                };
            }

            component.view = _.extend({module: metadata.module}, metadata.preview, component);
            if (contextDef) {
                component.context = contextDef;
            }

            previewLayout.initComponents([
                {
                    layout: {
                        type: 'dashlet',
                        label: app.lang.get(metadata.preview.label || metadata.label, metadata.preview.module),
                        preview: true,
                        components: [
                            component
                        ]
                    }
                }
            ], this.context.parent);
            previewLayout.loadData();
            previewLayout.render();
        }
    },

    /**
     * Load dashlet configuration view by passing configuration metadata
     *
     * @param {Object} metadata Configuration metadata.
     */
    selectDashlet: function(metadata) {
        var model = new app.Bean();

        app.drawer.load({
            layout: {
                type: 'dashletconfiguration',
                components: [
                    {
                        view: _.extend({}, metadata.config, {
                            label: app.lang.get(metadata.label, metadata.config.module),
                            type: metadata.type,
                            config: true,
                            module: metadata.config.module || metadata.module
                        })
                    }
                ]
            },
            context: {
                module: metadata.config.module || metadata.module,
                model: model,
                forceNew: true,
                skipFetch: true
            }
        });
    },

    /**
     * Filtering the available dashlets with the current page's module and
     * layout view.
     *
     * @param {Array} dashlets A list of dashlet components.
     * @return {Array} A list of filtered dashlet set.
     */
    getFilteredList: function(dashlets) {
        var parentModule = app.controller.context.get('module'),
            parentView = app.controller.context.get('layout'),
            parentDashboard = this.model.get('dashboard_type') || this.context.get('dashboard_type') || 'dashboard';

        return _.chain(dashlets)
            .filter(function(dashlet) {
                var filter = dashlet.filter;
                if (_.isUndefined(filter)) {
                    // if filter is undefined
                    return (parentDashboard === 'dashboard');
                }

                var filterModules = filter.module || [parentModule],
                    filterViews = filter.view || [parentView],
                    filterDashboard = filter.dashboard || ['dashboard'];

                if (_.isString(filterModules)) {
                    filterModules = [filterModules];
                }
                if (_.isString(filterViews)) {
                    filterViews = [filterViews];
                }
                if (_.isString(filterDashboard)) {
                    filterDashboard = [filterDashboard];
                }

                //if the filter is matched, then it returns true
                return _.contains(filterModules, parentModule)
                    && _.contains(filterViews, parentView)
                    && _.contains(filterDashboard, parentDashboard);
            })
            .value();
    },

    /**
     * Iterates dashlets metadata and extract the dashlet components among them.
     *
     * @param {String} type The component type (layout|view).
     * @param {String} name The component name.
     * @param {String} module The module name.
     * @param {Object} meta The metadata.
     * @return {Array} list of available dashlets.
     * @private
     */
    _getDashlets: function(type, name, module, meta) {
        var dashlets = [],
            hadDashlet = meta && meta.dashlets &&
                app.view.componentHasPlugin({
                    type: type,
                    name: name,
                    module: module,
                    plugin: 'Dashlet'
                });
        if (!hadDashlet) {
            return dashlets;
        }
        _.each(meta.dashlets, function(dashlet) {
            if (!dashlet.config) {
                return;
            }
            var description = app.lang.get(dashlet.description, dashlet.config.module);
            if (!app.acl.hasAccess('access', module || dashlet.config.module)) {
                return;
            }
            dashlets.push({
                type: name,
                filter: dashlet.filter,
                metadata: _.extend({
                    component: name,
                    module: module,
                    type: name
                }, dashlet),
                title: app.lang.get(dashlet.label, dashlet.config.module),
                description: description
            });
        }, this);
        return dashlets;
    },

    /**
     * Retrieves all base view's metadata.
     *
     * @return {Array} All base view's metadata.
     * @private
     */
    _addBaseViews: function() {
        var components = [];
        _.each(app.metadata.getView(), function(view, name) {
            var dashlets = this._getDashlets('view', name, null, view.meta);
            if (!_.isEmpty(dashlets)) {
                components = _.union(components, dashlets);
            }
        }, this);
        return components;
    },

    /**
     * Retrieves all module view's metadata.
     *
     * @return {Array} The module view's metadata.
     * @private
     */
    _addModuleViews: function() {
        var components = [];
        _.each(app.metadata.getModuleNames({filter: 'visible'}), function(module) {
            _.each(app.metadata.getView(module), function(view, name) {
                var dashlets = this._getDashlets('view', name, module, view.meta);
                if (!_.isEmpty(dashlets)) {
                    components = _.union(components, dashlets);
                }
            }, this);
        }, this);
        return components;
    },

    /**
     * @inheritdoc
     *
     * Instead of fetching context, it will retrieve all dashable components
     * based on metadata. Sorts the components by `title` alphabetically.
     */
    loadData: function() {
        if (this.collection.length) {
            this.filteredCollection = this.collection.models;
            return;
        }

        var dashletCollection = _.union(this._addBaseViews(), this._addModuleViews()),
            filteredDashletCollection = this.getFilteredList(dashletCollection);

        this.collection.comparator = function(model) {
            return model.get('title');
        };

        this.collection.add(filteredDashletCollection);
        this.collection.dataFetched = true;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * DashletSelect isn't a read module, no need to compare fields with defs.
     */
    getFields: function() {
        return _.flatten(_.pluck(this.meta.panels, 'fields'));
    }

}) },
"activitystream-omnibar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamOmnibarView
 * @alias SUGAR.App.view.views.BaseActivitystreamOmnibarView
 * @extends View.View
 */
({
	// Activitystream-omnibar View (base) 

    events: {
        'click .addPost': 'addPost',
        'keyup .sayit': '_handleContentChange', //type text
        'change .sayit': '_handleContentChange', //drag text in
        'paste .sayit': '_handleContentPaste' //for IE - right click, paste
    },

    className: "omnibar",

    plugins: ['DragdropAttachments', 'QuickSearchFilter', 'Taggable', 'Tooltip'],

    initialize: function(options) {
        // regular expression to find all non-breaking spaces
        this.nbspRegExp = new RegExp(String.fromCharCode(160), 'g');

        app.view.View.prototype.initialize.call(this, options);

        // Assets for the activity stream post avatar
        this.user_id = app.user.get('id');
        this.full_name = app.user.get('full_name');
        this.picture_url = app.user.get('picture') ? app.api.buildFileURL({
            module: 'Users',
            id: this.user_id,
            field: 'picture'
        }) : '';

        this.toggleSubmitButton = _.debounce(this.toggleSubmitButton, 200);
        this.on('attachments:add attachments:remove attachments:end', this.toggleSubmitButton, this);
        this.on('attachments:start', this.disableSubmitButton, this);
    },

    /**
     * Initialize Taggable plugin so that it knows which record the tags are
     * associated with.
     */
    bindDataChange: function() {
        if (this.context.parent) {
            this.context.parent.on('change', function(context) {
                var moduleName = context.get('module'),
                    modelId = context.get('model').get('id');

                this.setTaggableRecord(moduleName, modelId);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    /**
     * Remove events added in bindDataChange().
     */
    unbindData: function() {
        if (this.context.parent) {
            this.context.parent.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Creates a new post.
     */
    addPost: function() {
        var self = this,
            parentId = this.context.parent.get("model").id,
            parentType = this.context.parent.get("model").module,
            attachments = this.$('.activitystream-pending-attachment'),
            $submitButton = this.$('button.addPost'),
            bean;

        // Process "Home" and "Activity" layouts as global activity stream types
        if (parentType == 'Home' || parentType == 'Activities') {
            parentType = null;
            parentId = null;
        }

        var payload = {
            activity_type: "post",
            parent_id: parentId || null,
            parent_type: parentType,
            data: {}
        };

        if (!$submitButton.hasClass('disabled')) {
            payload.data = this.getPost();

            if (payload.data.value && (payload.data.value.length > 0)) {
                $submitButton.addClass('disabled');
                bean = app.data.createBean('Activities');
                bean.save(payload, {
                    success: function(model) {
                        self.$('div.sayit')
                            .empty()
                            .trigger('change')
                            .focus();

                        model.set('picture', app.user.get('picture'));
                        self.collection.add(model);
                        self.context.trigger('activitystream:post:prepend', model);
                    },
                    complete: function() {
                        $submitButton.removeClass('disabled');
                    },
                    showAlerts: true
                });
            }

            this.trigger("attachments:process");
        }
    },

    /**
     * Retrieve the post entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getPost: function() {
        var post = this.unformatTags(this.$('div.sayit'));

        // Need to replace all non-breaking spaces with a regular space because the EmbedLinkService.php
        // treats spaces and non-breaking spaces differently. Having non-breaking spaces causes to parse
        // URLs incorrectly.
        post.value = post.value.replace(this.nbspRegExp, ' ');

        return post;
    },

    /**
     * Check to see if the Submit button should be disabled/enabled.
     */
    toggleSubmitButton: function() {
        var post = this.getPost(),
            attachments = this.getAttachments();

        if ((post.value.length === 0) && (_.size(attachments) === 0)) {
            this.disableSubmitButton();
        } else {
            this.enableSubmitButton();
        }
    },

    /**
     * Enable Submit button
     */
    enableSubmitButton: function() {
        this.$('.addPost').removeClass('disabled');
    },

    /**
     * Disable Submit button
     */
    disableSubmitButton: function() {
        this.$('.addPost').addClass('disabled');
    },

    /**
     * Show or hide the placeholder and toggle the submit button in response to
     * a content change in the input field.
     *
     * @param e
     * @private
     */
    _handleContentChange: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
        } else {
            el.removeAttribute('data-hide-placeholder');
        }
        this.toggleSubmitButton();
    },

    /**
     * Wrapper around _handleContentChange to defer until paste event completes
     * Paste event needed for IE (right click, paste)
     *
     * @param e
     * @private
     */
    _handleContentPaste: function(e) {
        _.defer(_.bind(this._handleContentChange, this), e);
    }
}) },
"inactive-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Inactive tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * @class View.Views.Base.InactiveTasksView
 * @alias SUGAR.App.view.views.BaseInactiveTasksView
 * @extends View.Views.BaseTabbedDashletView
 */
({
	// Inactive-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    }
}) },
"panel-top-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top-create View (base) 

    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('collapsed', false);
    },

    /**
     * @inheritdoc
     *
     * Overrides the default related-record create to add the new item inline
     *
     * @override
     */
    createRelatedClicked: function(event) {},

    /**
     * @inheritdoc
     *
     * Overrides the parent togglePanel since we don't allow panel toggling in create
     *
     * @override
     */
    togglePanel: function() {}
}) },
"create-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateActionsView
 * @alias SUGAR.App.view.views.BaseCreateActionsView
 * @extends View.Views.Base.CreateView
 *
 * @deprecated 7.7.0 Will be removed in 7.8.0. Use
 *   {@link View.Views.Base.CreateView} instead.
 */
({
	// Create-actions View (base) 

    extendsFrom: 'CreateView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'create-actions'), options.meta);
        this._super('initialize', [options]);
        app.logger.warn('Warning: View.Views.Base.CreateActionsView is deprecated since 7.7.0 and will be removed ' +
            'in 7.8.0. Use View.Views.Base.CreateView instead.');
    }
}) },
"rssfeed": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RSS Feed dashlet consumes an RSS Feed URL and displays it's content as a list
 * of entries.
 * 
 * The following items are configurable.
 *
 * - {Integer} limit Limit imposed to the number of records pulled.
 * - {Integer} refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.RssfeedView
 * @alias SUGAR.App.view.views.BaseRssfeedView
 * @extends View.View
 */
({
	// Rssfeed View (base) 

    plugins: ['Dashlet'],

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        this._super('initialize', [options]);
        this.loadData(options.meta);
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function() {
        // We only need to handle this if we are NOT in the configure screen
        if (!this.meta.config) {
            var options = {};
            var self = this;
            var refreshRate;

            // Get and set values for limits and refresh
            options.limit = this.settings.get('limit') || this._defaultOptions.limit;
            this.settings.set('limit', options.limit);

            options.auto_refresh = this.settings.get('auto_refresh') || this._defaultOptions.auto_refresh;
            this.settings.set('auto_refresh', options.auto_refresh);

            // There is no default for this so there's no pointing in setting from it
            options.feed_url = this.settings.get('feed_url');

            // Set the refresh rate for setInterval so it can be checked ahead
            // of time. 60000 is 1000 miliseconds times 60 seconds in a minute.
            refreshRate = options.auto_refresh * 60000;

            // Only set up the interval handler if there is a refreshRate higher
            // than 0
            if (refreshRate > 0) {
                if (this.timerId) {
                    clearInterval(this.timerId);
                }
                this.timerId = setInterval(_.bind(function() {
                    if (self.context) {
                        self.context.resetLoadFlag();
                        self.loadData(options);
                    }
                }, this), refreshRate);
            }
        }

        // Validation handling for individual fields on the config
        this.layout.before('dashletconfig:save', function() {
            // Fields on the metadata
            var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

            // Grab all non-valid fields from the model
            var notValid = _.filter(fields, function(field) {
                return field.required && !this.dashModel.get(field.name);
            }, this);

            // If there no invalid fields we are good to go
            if (notValid.length === 0) {
                return true;
            }

            // Otherwise handle notification of invalidation
            _.each(notValid, function(field) {
                 var fieldOnView = _.find(this.fields, function(comp, cid) { 
                    return comp.name === field.name;
                 });

                 fieldOnView.model.trigger('error:validation:' + field.name, {required: true});
            }, this);

            // False return tells the drawer that it shouldn't close
            return false;
        }, this);
    },

    /**
     * Handles the response of the feed consumption request and sets data from 
     * the result
     * 
     * @param {Object} data Response from the rssfeed API call
     */
    handleFeed: function (data) {
        if (this.disposed) {
            return;
        }

        // Load up the template
        _.extend(this, data);
        this.render();
    },

    /**
     * Loads an RSS feed from the RSS Feed endpoint.
     * 
     * @param {Object} options The metadata that drives this request
     */
    loadData: function(options) {
        if (options && options.feed_url) {
            var callbacks = {success: _.bind(this.handleFeed, this), error: _.bind(this.handleFeed, this)},
                limit = options.limit || this._defaultOptions.limit,
                params = {feed_url: options.feed_url, limit: limit},
                apiUrl = app.api.buildURL('rssfeed', 'read', '', params);

            app.api.call('read', apiUrl, {}, callbacks);
        }
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        this._super('_renderHtml');
    }
}) },
"pmse-case": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Pmse-case View (base) 

    extendsFrom: 'RecordView',

    events: {
        'click .record-edit-link-wrapper': 'handleEdit'
    },

    initialize: function(options) {

        this.case = this.options.context.get('case');
        _.bindAll(this);
        options.meta = _.extend({}, app.metadata.getView(this.options.module, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        options.meta.buttons = this.case.buttons;
        this._super('initialize', [options]);
        this.context.set("layout", "record");
        this.buttons = {};
        this.createMode = this.context.get('create') ? true : false;
        this.action = 'detail';
        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        this.context.set('dataView', 'record');
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);
        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);

        $(window).on('resize.' + this.cid, this.overflowTabs);

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
                        });

    },

    validationComplete: function(isValid) {
        if (isValid) {
            this.setButtonStates(this.STATE.VIEW);
            this.handleSave();
        }
    },

    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);

        this.context.on('case:cancel', this.cancelCase, this);
        this.context.on('case:claim', this.caseClaim, this);
        this.context.on('case:approve', this.caseApprove, this);
        this.context.on('case:reject', this.caseReject, this);
        this.context.on('case:route', this.caseRoute, this);

        this.context.on('case:history', this.caseHistory, this);
        this.context.on('case:status', this.caseStatus, this);
        this.context.on('case:add:notes', this.caseAddNotes, this);
        this.context.on('case:change:owner', this.caseChangeOwner, this);
        this.context.on('case:reassign', this.caseReassign, this);
    },

    cancelCase: function () {
        this.redirectCase();
    },

    caseClaim: function () {
        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
        var frm_action = 'Claim';
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        value.cas_id = this.case.flow.cas_id;
        value.cas_index = this.case.flow.cas_index;
        value.taskName = this.case.title.activity;
        var self = this;
        var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_claim','',{},{});
        app.api.call('update', pmseInboxUrl, value,{
            success: function (){
                app.alert.dismiss('upload');
                self.redirectCase(frm_action);
            }
        });
    },

    caseApprove: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteApprove, this));
    },

    validationCompleteApprove: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_approve', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_APPROVE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Approve';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_approve', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_APPROVED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseReject: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteReject, this));
    },

    validationCompleteReject: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_reject', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_REJECT_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Reject';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_reject', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_REJECTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseRoute: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteRoute, this));
    },

    validationCompleteRoute: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_route', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_ROUTE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    var value = this.model.attributes;
                    value.frm_action = 'Route';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    if (this.case.taskContinue) {
                        value.taskContinue = true;
                    }
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_route', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_ROUTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    redirectCase: function(isRoute){
        app.alert.dismiss('upload');
        switch(isRoute){
            case 'Claim':
                window.location.reload();
                break;
            default:
                app.router.list("Home");
                break;
        };
    },

    caseHistory: function(){
        showHistory(this.case.flow.cas_id, this.case.flow.cas_index);
    },

    caseStatus: function(){
        showImage(this.case.flow.cas_id);
    },

    caseAddNotes: function(){
        showNotes(this.case.flow.cas_id, this.case.flow.cas_index);
    },

    caseChangeOwner: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'adhoc', this.model);
    },

    caseReassign: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'reassign', this.model);
    },


    setEditableFields: function() {
        delete this.editableFields;
        this.editableFields = [];
        var previousField, firstField;
        _.each(this.fields, function(field) {
            if(this.checkReadonly(field)){
                field.def.readonly = true;
            }
            if (field.fields && _.isArray(field.fields)) {
                var that = this;
                var basefield = field;
                _.each(field.fields, function (field) {
                    if (that.checkReadonly(field)) {
                        field.action = "disabled";
                        // Some fields use shouldDisable to enable readonly property,
                        // like 'body' in KBContents
                        if (!_.isUndefined(field.shouldDisable)) {
                            field.setDisabled(true);
                            basefield.def.readonly = true;
                        }
                        return;
                    }
                    // If the field is not readonly, verify if it's required
                    if (that.checkRequired(field)) {
                        field.def.required = true;
                    }
                });
            }
            var readonlyField = field.def.readonly ||
                _.indexOf(this.noEditFields, field.def.name) >= 0 ||
                field.parent || (field.name && this.buttons[field.name]);

            if (readonlyField) {
                // exclude read only fields
                return;
            }
            if(this.checkRequired(field)){
                field.def.required = true;
            }
            if (previousField) {
                previousField.nextField = field;
                field.prevField = previousField;
            } else {
                firstField = field;
            }
            previousField = field;
            this.editableFields.push(field);

        }, this);

        if (previousField) {
            previousField.nextField = firstField;
            firstField.prevField = previousField;
        }

    },

    handleSave: function() {
        var self = this;
        self.inlineEditMode = false;

        app.file.checkFileFieldsAndProcessUpload(self, {
                success: function(response) {
                    if (response.record && response.record.date_modified) {
                        self.model.set('date_modified', response.record.date_modified);
                    }
                    self._saveModel();
                }
            }, {
                deleteIfFails: false
            }
        );

        self.$('.record-save-prompt').hide();
        if (!self.disposed) {
            self.render();
        }
    },
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane span[data-type="badge"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="favorite"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="follow"]').toggleClass('hide', isEdit);
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                // Loop through the visible subpanels and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    if (!_.isUndefined(child.attributes) && !_.isUndefined(child.attributes.isSubpanel)) {
                        if (child.attributes.isSubpanel && !child.attributes.hidden) {
                            child.attributes.collection.fetch();
                        }
                    }
                });
                if (this.createMode) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed) {
                    this.render();
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else {
                    this.editClicked();
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },


    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if(this.checkReadonly(field)){
                    field.readonly = true;
                }
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span')  {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.type === 'fieldset') {
                    if (field.readonly || _.every(field.fields, function(field) {
                        return !app.acl.hasAccessToModel('edit', this.model, field.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },


    getFieldNames: function(module) {

        var fields = app.view.View.prototype.getFieldNames.call(this, module);
        var favorite = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'favorite';
             });
        });
        var follow = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'follow';
             });
        });
        if (favorite) {
            fields = _.union(fields, ['my_favorite']);
        }
        if (follow) {
            fields = _.union(fields, ['following']);
        }
        return fields;
    },


    checkReadonly: function(field){
        var isReadonly = false;
        _.each(this.case.readonly, function(caseField){
            if(field.name=== caseField){
                isReadonly = true;
            }
        }, this);
        return isReadonly;
    },

    checkRequired: function(field){
        var isRequired = false;
        _.each(this.case.required, function(caseField){
            if(field.name=== caseField){
                isRequired = true;
            }
        }, this);
        return isRequired;
    }

}) },
"quicksearch-bar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchBarView
 * @alias SUGAR.App.view.views.BaseQuicksearchBarView
 * @extends View.View
*/
({
	// Quicksearch-bar View (base) 


    className: 'table-cell quicksearch-bar-wrapper',
    /**
     * The minimum number of characters before the search bar attempts to
     * retrieve results.
     *
     * @property {number}
     */
    minChars: 1,

    searchModules: [],
    events: {
        'focus input[data-action=search_bar]': 'requestFocus',
        'click input[data-action=search_bar]': 'searchBarClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * The default number of maximum results to display.
         *
         * You can override this value by providing a `limit` property in the
         * metadata.
         *
         * @type {number}
         * @property
         */
        this.limit = 5;
        if (this.meta && this.meta.limit) {
            this.limit = this.meta.limit;
        }

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = true;


        /**
         * The current search term.
         * When a search term is typed, the term is immediately stored to this variable. After the 500ms debounce, the
         * term is used to execute a search.
         * @type {string}
         * @private
         */
        this._searchTerm = '';

        /**
         * The previous search term.
         * This is stored to check against `this._searchTerm`. If `this._searchTerm === this._oldSearchTerm`, we do
         * not need to retrieve new results. This protects us against keystrokes that do not change the search term.
         * @type {string}
         * @private
         */
        this._oldSearchTerm = '';

        /**
         * The previous query term.
         * This is the last search term used to get results, and as such, is the term that produced the currently
         * displayed results. If `this._searchTerm === this._currentQueryTerm` when the search is executed (after
         * the 500ms debounce), we do not need to execute a new search.
         * @type {string}
         * @private
         */
        this._currentQueryTerm = '';

        app.events.on('app:sync:complete', this.populateModules, this);

        // Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            // if the input doesn't have focus, give it focus.
            var inputBox = this.$input[0];
            if (inputBox !== $(document.activeElement)[0]) {
                inputBox.focus();
            } else {
                this.attachKeyEvents();
            }
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.disposeKeyEvents();
        }, this);

        // Listener for `quicksearch:close`. This aborts in progress
        // searches
        this.layout.on('quicksearch:close', function() {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            this.collection.abortFetchRequest();
            this.$input.blur();
        }, this);

        this.layout.on('quicksearch:bar:clear', this.clearSearch, this);

        this.layout.on('quicksearch:bar:clear:term', this.clearSearchTerm, this);

        this.layout.on('quicksearch:bar:search', this.goToSearchPage, this);

        this.layout.on('route:search', this.populateSearchTerm, this);

        this.layout.on('quicksearch:fire:search', function() {
            // In case we are already in the middle of a search
            this.collection.abortFetchRequest();
            this._oldSearchTerm = null;
            this._currentQueryTerm = null;
            this._validateAndSearch();
        }, this);
    },

    /**
     * Renders a view onto the page.
     *
     * @protected
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.$input = this.$('input[data-action=search_bar]');
    },

    /**
     * Checks to see if we're in the search context. If we are, populate the search
     * bar with the search term.
     */
    populateSearchTerm: function() {
        var inputBar = this.$input;
        var searchTerm = this.context.get('searchTerm');
        if (inputBar.val() !== searchTerm) {
            inputBar.val(searchTerm);
        }
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Function to attach the keydown and keyup events.
     */
    attachKeyEvents: function() {
        var searchBarEl = this.$input;
        // for arrow key navigation
        searchBarEl.on('keydown', _.bind(this.keydownHandler, this));

        // for searchbar typeahead
        searchBarEl.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Function to dispose the keydown and keyup events.
     */
    disposeKeyEvents: function() {
        this.$input.off('keydown keyup');
    },

    /**
     * Handles the keydown event for up, down, and ignores tab.
     *
     * @param {Event} e The `keydown` event
     * @private
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                e.stopPropagation();
                break;
            case 38: // up arrow
                e.preventDefault();
                e.stopPropagation();
                break;
            case 37: // left arrow
            case 8:  //backspace
                // If there's text in the input bar, don't add any special handling
                var term = this.$input.val();
                if (term === '') {
                    this.moveBackward();
                    // Prevent double event calling when element to the left attaches its keydown handler
                    e.stopPropagation();
                    e.preventDefault();
                }
                break;
        }
    },

    /**
     * Handles the keyup event for typing, and ignores tab
     *
     * @param {Event} e The `keyup event
     */
    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                break;
            case 38: // up arrow
                break;
            case 9: // tab
                break;
            case 16: // shift
                break;
            case 13: // enter
                this.goToSearchPage();
                break;
            case 27: // esc
                this.layout.trigger('quicksearch:close');
                break;
            default:
                this._validateAndSearch();
        }
    },

    /**
     * Goes to the search page and displays results.
     */
    goToSearchPage: function() {
        // navigate to the search results page
        var term = this.$input.val();
        var route = '';
        this._searchTerm === this._currentQueryTerm;
        this._currentQueryTerm = term;
        if (this.layout.v2) {
            route = app.utils.GlobalSearch.buildSearchRoute(term, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
        } else {
            var moduleString = this.collection.selectedModules.join(',');
            route = 'bwc/index.php?module=Home&append_wildcard=true&action=spot&full=true' +
                '&q=' + term +
                '&m=' + moduleString;
        }
        this.collection.abortFetchRequest();
        app.router.navigate(route, {trigger: true});
    },
    /**
     * Handler for clicks on the search bar.
     *
     * Expands the bar and toggles the search icon.
     */
    searchBarClickHandler: function() {
        this.requestFocus();
        _.defer(_.bind(this.layout.expand, this.layout));
    },

    /**
     * Navigate to the next component
     */
    moveForward: function() {
        if (this.layout.triggerBefore('navigate:next:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:next:component');
        }
    },

    /**
     * Navigate to the previous component
     */
    moveBackward: function() {
        if (this.layout.triggerBefore('navigate:previous:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:previous:component');
        }
    },

    /**
     * Waits & debounces for 0.5 seconds before firing a search. This is primarily used on the
     * keydown event for the typeahead functionality.
     *
     * @param {string} term The search term.
     * @private
     * @method
     */
    _debounceSearch: _.debounce(function() {
        // Check if the search term is falsy (empty string)
        // or the search term is the same as the previously searched term
        // If either of those conditions are met, we do not need to execute a new search.
        if ((!this._searchTerm && this.selectedTags.length === 0)
            || this._searchTerm === this._currentQueryTerm) {
            return;
        }
        this._currentQueryTerm = this._searchTerm;
        this.fireSearchRequest();
    }, 500),


    /**
     * Collects the search term, validates that a search is appropriate, and executes a debounced search.
     * First, it checks the search term length, to ensure it meets the minimum length requirements.
     * Second, it checks the search term against the previously typed search term. If the search term hasn't changed
     * (for example, for keyboard shortcuts) then there is no need to rerun the search.
     * If the above conditions are met, `_validateAndSearch` runs a debounced search.
     *
     * @private
     */
    _validateAndSearch: function() {
        var term = this.$input.val();
        this._searchTerm = term;

        // if the term is too short, don't search
        if (term.length < this.minChars && this.selectedTags.length === 0) {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            // We trigger `quicksearch:results:close` instead of
            // `quicksearch:close` because we only want to close the dropdown
            // and keep the bar expanded. That means we only want the listener
            // in `quicksearch-results.js` to be called, not the other ones.
            this.collection.abortFetchRequest();
            this.layout.trigger('quicksearch:results:close');
            this.collection.abortFetchRequest();
            return;
        }

        // shortcuts might trigger multiple `keydown` events, to do some actions like blurring the input, but since the
        // input value didn't change we don't want to trigger a new search.
        var hasInputChanged = (this._searchTerm !== this._oldSearchTerm);
        if (hasInputChanged) {
            this.collection.dataFetched = false;
            this.layout.trigger('quicksearch:search:underway');
            this.layout.expand();
            this._oldSearchTerm = term;
            this._debounceSearch();
        }
    },

    /**
     * Executes a search using `this._searchTerm`.
     * TODO: Move this function into the layout so that we can sandbox out tags from the bar
     */
    fireSearchRequest: function() {
        var term = this._searchTerm;
        // FIXME: SC-4254 Remove this.layout.v2
        var limit = this.layout.v2 ? this.limit : 5;
        limit = app.config && app.config.maxSearchQueryResult || limit;
        var options = {
            query: term,
            module_list: this.collection.selectedModules,
            limit: limit,
            params: {
                tags: true
            },
            apiOptions: {
                useNewApi: true
            }
        };

        if (this.selectedTags.length > 0) {
            _.extend(options.apiOptions, {
                    data: {
                        tag_filters: _.pluck(this.selectedTags, 'id')
                    },
                    fetchWithPost: true
            });
        }

        // FIXME: SC-4254 Remove this.layout.v2
        if (!this.layout.v2) {
            options.fields = ['name', 'id'];
        }
        this.collection.query = term;
        this.collection.fetch(options);
    },

    /**
     * Clears out search upon user following search result link in menu
     */
    clearSearch: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
        this.layout.trigger('quicksearch:tags:remove');
        this.disposeKeyEvents();
    },

    clearSearchTerm: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseConfigHeaderButtonsView
 * @extends  View.View
 */
({
	// Config-header-buttons View (base) 

    events: {
        'click a[name="cancel_button"]': 'cancelConfig',
        'click a[name="save_button"]:not(.disabled)': 'saveConfig'
    },

    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        Object.defineProperty(this, 'currentModule', {
            /**
             * @property {string}
             * @deprecated since 7.7.0.0 and will be removed in 7.8.0.0.
             *   Please use {@link #module} instead.
             */
            get: function () {
                app.logger.warn('ConfigHeaderButtonsView\'s `currentModule` property is deprecated since 7.7.0 and will be removed in 7.8.0. ' +
                    'Please use `module` instead.');
                return this.module;
            }
        });

        this.moduleLangObj = {
            // get the actual plural module name
            module: app.lang.getModuleName(this.module, { plural: true })
        };

        /**
         * todo: when backbone.js gets updated to > 0.9.10 this will not be necessary
         * THIS WHOLE SECTION IS A BACKBONE SYNC/FETCH/PARSE HACK
         *
         * TODO: SIDECAR-404
         */
        var model = this.context.get('model');
        model.url = app.api.buildURL(this.module, 'config');
        model.sync = function(method, model, options) {
            this.trigger('data:sync:start', method, model, options);
            var url = _.isFunction(model.url) ? model.url() : model.url;
            return app.api.call(method, url, model, options);
        };

        model.fetch = function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var model = this,
                success = options.success;
            options.success = function(resp) {
                if (!model.set(model.parse(resp, options), options)) {
                    return false;
                }
                if (success) {
                    success(model, resp, options);
                }
                model.trigger('sync', model, resp, options);
            };
            var error = options.error;
            options.error = function(resp) {
                if (error) {
                    error(model, resp, options);
                }
                model.trigger('error', model, resp, options);
            };
            return this.sync('read', this, options);
        };
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        model.save = function(key, val, options) {
            var attrs, method, xhr, attributes = this.attributes;

            // Handle both `'key', value` and `{key: value}` -style arguments.
            if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
            if (attrs && (!options || !options.wait) && !this.set(attrs, options)) {
                return false;
            }

            options = _.extend({validate: true}, options);

            // Do not persist invalid models.
            if (!this._validate(attrs, options)) {
                return false;
            }

            // Set temporary attributes if `{wait: true}`.
            if (attrs && options.wait) {
                this.attributes = _.extend({}, attributes, attrs);
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            if (options.parse === void 0) options.parse = true;
            var model = this,
                success = options.success;
            options.success = function(resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = model.parse(resp, options);
                if (options.wait) {
                    serverAttrs = _.extend(attrs || {}, serverAttrs);
                }
                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                    return false;
                }
                if (success) {
                    success(model, resp, options);
                }
                model.trigger('sync', model, resp, options);
            };

            method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch') {
                options.attrs = attrs;
            }
            xhr = this.sync(method, this, options);

            // Restore attributes.
            if (attrs && options.wait) {
                this.attributes = attributes;
            }

            return xhr;
        };

        // push the model back to the context model
        this.context.set({model: model});
        /**
         * END HACK
         */

        this.before('save', this._beforeSaveConfig, this);
        this.before('cancel', this._beforeCancelConfig, this);
    },

    /**
     * Click handler for the save button, triggers save event
     */
    saveConfig: function() {
        if (this.triggerBefore('save')) {
            this.getField('save_button').setDisabled(true);
            this._saveConfig();
        }
    },

    /**
     * Calls the context model save and saves the config model in case
     * the default model save needs to be overwritten
     *
     * @protected
     */
    _saveConfig: function() {
        this.context.get('model').save({}, {
            // getting the fresh model with correct config settings passed in as the param
            success: _.bind(function(model) {
                // If we're inside a drawer and Forecasts is setup and this isn't the first time, otherwise refresh
                if (app.drawer.count()) {
                    this.showSavedConfirmation();
                    // close the drawer and return to Forecasts
                    app.drawer.close(this.context, this.context.get('model'));
                }
            }, this),
            error: _.bind(function() {
                this.getField('save_button').setDisabled(false);
            }, this)
        });
    },

    /**
     * Noop for use if model needs updating before save.
     * Gets called before the model actually saves.
     *
     * Override this method to provide custom logic.
     *
     * @private
     * @template
     * @return {boolean} The default implementation returns `true` allowing the save.
     */
    _beforeSaveConfig: function() {
        return true;
    },

    /**
     * Show the saved confirmation alert
     *
     * @param {Object|Undefined} [onClose] the function fired upon closing.
     */
    showSavedConfirmation: function(onClose) {
        onClose = onClose || function() {};
        var alert = app.alert.show('module_config_success', {
            level: 'success',
            title: app.lang.get('LBL_CONFIG_TITLE_MODULE_SETTINGS', this.module, this.moduleLangObj) + ':',
            messages: app.lang.get('LBL_CONFIG_MODULE_SETTINGS_SAVED', this.module, this.moduleLangObj),
            autoClose: true,
            autoCloseDelay: 10000,
            onAutoClose: _.bind(function() {
                alert.getCloseSelector().off();
                onClose();
            })
        });
        var $close = alert.getCloseSelector();
        $close.on('click', onClose);
        app.accessibility.run($close, 'click');
    },

    /**
     * Cancels the config setup process and redirects back
     */
    cancelConfig: function() {
        if (this.triggerBefore('cancel')) {
            // If we're inside a drawer
            if (app.drawer.count()) {
                // close the drawer
                app.drawer.close(this.context, this.context.get('model'));
            } else {
                app.router.navigate(this.module, {trigger: true});
            }
        }
    },

    /**
     * Noop for use if model needs updating before cancel
     * Gets called before the model actually cancels
     *
     * Override this method to provide custom logic.
     *
     * @private
     * @template
     * @return {boolean} The default implementation returns `true` allowing the cancel.
     */
    _beforeCancelConfig: function() {
        return true;
    }
}) },
"setup-complete-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Setup Complete wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.SetupCompleteWizardPageView
 * @alias SUGAR.App.view.views.BaseSetupCompleteWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// Setup-complete-wizard-page View (base) 

    extendsFrom: "WizardPageView",
    /**
     * Name of wizard being displayed
     */
    wizardName : "",
    /**
     * Set flag for admin or user wizard so we can render the correct template
     * @override
     * @param options
     */
    initialize: function(options){
        //Extend default events to add listener for click events on links
        //FIXME: events should be data action driven instead of tied to css
        //TY-573 will address this problem
        this.events = _.extend({}, this.events, {
            "click a.thumbnail": "linkClicked",
            "click [name=start_sugar_button]:not(.disabled)": "next"
        });
        this._super("initialize", [options]);
        this.wizardName = this.context.get("wizardName") || "user";
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Event handler whenever a link is clicked that makes sure wizard is finished
     * We need to use app router for Sugar app links on complete page.
     * External links should always open onto new pages.
     *
     * @param ev
     */
    //FIXME: Each link should have its own handler. Will be addressed in TY-573
    linkClicked: function(ev){
        var href, redirectUrl,
            target = this.$(ev.currentTarget);
        if(this.$(target).attr("target") !== "_blank") {
            app.user.unset('show_wizard');
            ev.preventDefault();
            //Show the header bar since it is likely hidden
            $("#header").show();
            href = this.$(target).attr("href");
            // Check if bwc link; if so, we need to do bwc.login first
            if (href.indexOf('#bwc/') === 0) {
                redirectUrl = href.split('#bwc/')[1];
                app.bwc.login(redirectUrl);
            } else {
                // Not bwc, so use router navigate instead
                app.router.navigate($(ev.currentTarget).attr("href"), {trigger: true});
            }
        }
    },

    /**
     * @inheritdoc
     *
     * When the setup complete page is disposed, we can update user object since
     * the user setup is complete, to prevent routing to the setup wizard.
     */
    _dispose: function() {
        this._super('_dispose');
        app.user.unset('show_wizard');
    }
}) },
"learning-resources": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Learning resources dashlet that will contain the content and links to
 * SugarCRM training material.
 *
 * The resources information is populated through metadata. More can be added:
 * ```
 * // ...
 * 'resources' => array(
 *     'resource_id' => array(
 *         'css_class' => 'resource-class',
 *         'color' => 'resource-color',
 *         'icon' => 'fa-resource-icon',
 *         'url' => 'http://url.for.resource.com/',
 *         'link' => 'LBL_LEARNING_RESOURCES_RESOURCE_LINK',
 *         'teaser' => 'LBL_LEARNING_RESOURCES_RESOURCE_TEASER',
 *     ),
 *     //...
 * ),
 * //...
 * ```
 *
 * @class View.Views.Base.LearningResourcesView
 * @alias SUGAR.App.view.views.BaseLearningResourcesView
 * @extends View.View
 *
 * @deprecated Since 7.7. Will be removed in 7.9.
 */
({
	// Learning-resources View (base) 

    tagName: 'ul',
    className: 'resource-list',

    plugins: ['Dashlet'],

    /**
     * The resources map that are metadata driven.
     */
    resources: {},

    initialize: function(options) {
        this._super('initialize', [options]);
        app.logger.warn('View.Views.Base.LearningResourcesView is deprecated since 7.7. Will be removed in 7.9.');
    },

    /**
     * @inheritdoc
     *
     * Define the {@link #resources} directly from the metadata.
     *
     * FIXME this is on `_renderHtml` instead of `initialize` because
     * `dashletConfig` (metadata) is only available at this time.
     * This needs to be reviewed after the SC-1373 refactor goes in.
     */
    _renderHtml: function() {
        this.resources = this.dashletConfig.resources;
        this._super('_renderHtml');
    }
}) },
"quicksearch-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchResultsView
 * @alias SUGAR.App.view.views.BaseQuicksearchResultsView
 * @extends View.View
 */
({
	// Quicksearch-results View (base) 

    events: {
        'click .view-all-results': 'viewAllResultsClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // Listener for when a search is triggered. Show "Searching..."
        this.layout.on('quicksearch:search:underway', function() {
            this.close();
            this.render();
            this.open();
        }, this);

        // If the layout has `quicksearch:results:close` called on it, we
        // need to hide just the quicksearch results
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.close();
        }, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.countRecordElements() - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', this._clearFieldsMeta, this);
    },

    /**
     * Clear the cached fields metadata
     * @private
     */
    _clearFieldsMeta: function() {
        this._fieldsMeta = {};
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        // On a collection sync, format the search results and display
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var gsUtils = app.utils.GlobalSearch;

            gsUtils.formatRecords(collection, false);

            _.each(this.collection.models, function(model) {

                model.link = '#' + app.router.buildRoute(model.module, model.id);
                // FIXME: SC-4254 Remove this.layout.v2
                if (this.layout.v2) {
                    var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module, {linkablePrimary: false});
                    this._fieldsMeta[model.module] = moduleMeta;
                    model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
                    model.secondaryFields = gsUtils.highlightFields(model, {}, true);

                    model.primaryFields = _.values(model.primaryFields);
                    model.secondaryFields = _.values(model.secondaryFields).slice(0, 3);
                } else {
                    if (model.searchInfo.highlighted) {
                        // Get the highlighted fields. If one is the name, highlight the name. Also, highlight the first
                        // non-name field. If there are multiple non-name highlighted fields, we only use the first.
                        _.find(model.searchInfo.highlighted, function(val, key) {
                            if (key === 'name') {
                                model.name = new Handlebars.SafeString(val.text);
                            } else { // found in a related field
                                model.field_name = app.lang.get(val.label, val.module);
                                model.field_value = new Handlebars.SafeString(val.text);
                                return true;
                            }
                        });
                    }
                }
            }, this);

            // build the link for View all results
            this.searchLink = app.utils.GlobalSearch.buildSearchRoute(collection.query, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
            this.activeIndex = null;
            this.render();
            this.open();

            // If the tags view is shown, move this one down
            var shownTags = _.pluck(collection.tags, 'name');
            var selectedTags = _.pluck(this.selectedTags, 'name');
            shownTags = _.difference(shownTags, selectedTags);
            this.$('.typeahead').toggleClass('tagsShown', shownTags.length > 0);
            this.layout.trigger('quicksearch:tag:' + shownTags.length > 0 ? 'open' : 'close');
        }, this);
    },

    /**
     * Show the quickresults dropdown
     */
    open: function() {
        this.$('.typeahead').show();
    },

    /**
     * Hide the quickresults dropdown
     */
    close: function() {
        this.clearActive();
        this.collection.reset();
        this.$('.typeahead').hide();
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.active').removeClass('active');
        this.disposeKeydownEvent();
    },

    /**
     * If we have search results, the view is focusable.
     */
    isFocusable: function() {
        return this.collection.models.length > 0;
    },

    /**
     * Move to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.countRecordElements() - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nthChild = this.activeIndex + 1;
        this.$('li:nth-child(' + nthChild + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Retrieve the count of record elements. This can be either the number of records or the number of records plus
     * a 'view all results' element.
     * @return {number}
     * @private
     */
    countRecordElements: function() {
        // If there is no next_offset, it means there are no "see more" option that we need to include.
        var hasMore = (this.collection.next_offset > -1) ? 1 : 0;
        return this.collection.models.length + hasMore;
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        this.$el.off();
    },

    /**
     * Handle the keydown events.
     * @param {event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                break;
            case 38: // up arrow
                this.moveBackward();
                break;
            case 9: // tab
                this.close();
                this.trigger('navigate:focus:lost');
        }
    },

    /**
     * click event handler for the view all results link
     * @param e
     */
    viewAllResultsClicked: function(e) {
        this.close();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"dnb-family-tree": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbFamilyTreeView
 * @alias SUGAR.App.view.views.DnbBaseFamilyTreeView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-family-tree View (base) 

    extendsFrom: 'DnbView',

    // idCounter used for jsTree metadata
    idCounter: 1,

    duns_num: null,

    //current family tree
    currentFT: null,

    events: {
        'click .backToList' : 'backToFamilyTree'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadFamilyTree, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadFamilyTree, this);
    },

    loadData: function(options) {
        if (this.model.get('duns_num'))
            this.duns_num = this.model.get('duns_num');
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated contact information from DNB service
     */
    refreshClicked: function() {
        this.loadFamilyTree(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadFamilyTree: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getDNBFamilyTree, 'LNK_FF', 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /** Obtain family tree for a given duns_num and product code
     * @param {String} duns_num for the given company
     * @param {String} prod_code possible values are LNK_FF | LNK_UPF
     */
    getDNBFamilyTree: function(duns_num, prod_code) {
        var self = this;
        self.duns_num = duns_num;
        self.idCounter = 1;
        self.template = app.template.get(self.name);
        if (!self.disposed) {
            self.render();
            self.$('#dnb-family-tree-loading').show();
            self.$('#dnb-family-tree-details').hide();
        }
        var ftParams = {
            'duns_num' : self.duns_num,
            'prod_code' : prod_code
        };
        //check if cache has this data already
        var cacheKey = 'dnb:familytree:' + ftParams.duns_num + ':' + ftParams.prod_code;
        var cacheContent = app.cache.get(cacheKey);
        if (cacheContent) {
            var dupeCheckParams = {
                'type': 'duns',
                'apiResponse': cacheContent,
                'module': 'familytree'
            };
            this.currentFT = cacheContent;
            this.baseDuplicateCheck(dupeCheckParams, this.renderFamilyTree);
        } else {
            var dnbFamilyTreeURL = app.api.buildURL('connector/dnb/familytree', '', {},{});
            var resultData = {'product': null, 'errmsg': null};
            app.api.call('create', dnbFamilyTreeURL, {'qdata': ftParams},{
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        resultData.product = data;
                        self.currentFT = data;
                        app.cache.set(cacheKey, data);
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderFamilyTree(resultData);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     * Back to Family Tree
     */
    backToFamilyTree: function() {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name);
        this.render();
        this.$('#dnb-family-tree-loading').show();
        this.$('#dnb-family-tree-details').hide();
        //hide import button when rendering the list
        if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
            this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().hide();
        }
        var dupeCheckParams = {
            'type': 'duns',
            'apiResponse': this.currentFT,
            'module': 'familytree'
        };
        this.baseDuplicateCheck(dupeCheckParams, this.renderFamilyTree);

    },

    /**
     * Convert Family Response to JSTree Plugin Format
     * @param {Object} data
     * @return {Object}
     */
    dnbToJSTree: function(data) {
        var jsTreeData = {};
        jsTreeData.data = [];
        var jsonPath = 'OrderProductResponse.OrderProductResponseDetail.Product.Organization';
        if (this.checkJsonNode(data, jsonPath)) {
            jsTreeData.data.push(this.getDataRecursive(data.OrderProductResponse.OrderProductResponseDetail.Product.Organization));
        }
        return jsTreeData;
    },

    /**
     * Recursively nested family trees and convert them to js tree plugin JSON data format
     * @param {Object} data
     * @return {Object}
     */
    getDataRecursive: function(data) {
        var intermediateData = {};
        var orgNamePath = 'OrganizationName.OrganizationPrimaryName.OrganizationName.$';
        var cityNamePath = 'Location.PrimaryAddress.PrimaryTownName';
        var countryNamePath = 'Location.PrimaryAddress.CountryISOAlpha2Code';
        var stateNamePath = 'Location.PrimaryAddress.TerritoryOfficialName';
        var dunsPath = 'SubjectHeader.DUNSNumber';
        var childrenPath = 'Linkage.FamilyTreeMemberOrganization';
        var orgName = this.checkJsonNode(data, orgNamePath) ? data.OrganizationName.OrganizationPrimaryName.OrganizationName['$'] : '';
        var dunsNum = this.checkJsonNode(data, dunsPath) ? data.SubjectHeader.DUNSNumber : '';
        var countryName = this.checkJsonNode(data, countryNamePath) ? data.Location.PrimaryAddress.CountryISOAlpha2Code : '';
        var stateName = this.checkJsonNode(data, stateNamePath) ? data.Location.PrimaryAddress.TerritoryOfficialName : '';
        var cityName = this.checkJsonNode(data, cityNamePath) ? data.Location.PrimaryAddress.PrimaryTownName : '';
        var dunsHTML = '&nbsp;&nbsp;<span class="label label-success pull-right">' + app.lang.get('LBL_DNB_DUNS') + '</span>',
            duplicateHTML = '&nbsp;&nbsp;<span class="label label-important pull-right">' + app.lang.get('LBL_DNB_DUPLICATE') + '</span>';
        intermediateData.metadata = {'id' : this.idCounter};
        intermediateData.attr = {'id' : this.idCounter, 'duns': dunsNum};
        this.idCounter++;
        intermediateData.data = orgName + ((stateName != '' && stateName != null) ? (', ' + stateName) : '')
            + (countryName != '' ? (', ' + countryName) : '');
        if (parseInt(dunsNum, 10) == parseInt(this.duns_num, 10)) {
            intermediateData.data = intermediateData.data + dunsHTML;
            intermediateData.state = 'open';
            this.initialSelect = [1, intermediateData.metadata.id];
            this.initialOpen = [1, intermediateData.metadata.id];
        } else if (data.isDupe) {
            intermediateData.data = intermediateData.data + duplicateHTML;
        }
        if (intermediateData.metadata.id === 1) {
            intermediateData.state = 'open';
        }
        if (this.checkJsonNode(data, childrenPath) && data.Linkage.FamilyTreeMemberOrganization.length > 0) {
            var childRootData = data.Linkage.FamilyTreeMemberOrganization;
            //for each child do a getDataRecursive
            intermediateData.children = _.map(childRootData, this.getDataRecursive, this);
        }
        return intermediateData;
    },

    /**
     *  renders the family tree using the jsTree plugin
     *  @param {Object} familyTreeData -- dnb api response for family tree call
     */
    renderFamilyTree: function(familyTreeData) {
        if (this.disposed) {
            return;
        }
        var self = this;
        self.template = app.template.get(self.name);
        self.render();
        if (!familyTreeData.errmsg && familyTreeData.product) {
            self.$('#dnb-family-tree').jstree({
                // generating tree from json data
                'json_data' : self.dnbToJSTree(familyTreeData.product),
                // plugins used for this tree
                'plugins' : ['json_data', 'ui', 'types'],
                'core' : {
                    'html_titles' : true
                }
            }).bind('loaded.jstree', function() {
                // do stuff when tree is loaded
                self.$('#dnb-family-tree').addClass('jstree-sugar');
                self.$('#dnb-family-tree > ul').addClass('list');
                self.$('#dnb-family-tree > ul > li > a').addClass('jstree-clicked');
            }).bind('select_node.jstree', function(e, data) {
                // do stuff when a node is selected
                if (data.rslt.e.target.getAttribute('href')) {
                    var duns_num = data.rslt.obj.attr('duns');
                    if (duns_num) {
                        self.getCompanyDetails(duns_num);
                    }
                } else {
                    data.inst.toggle_node(data.rslt.obj);
                }
            });
        } else if (familyTreeData.errmsg) {
            self.dnbFamilyTree = {};
            self.dnbFamilyTree.errmsg = familyTreeData.errmsg;
            self.render();
        }
        self.$('#dnb-family-tree-loading').hide();
        self.$('#dnb-family-tree-details').show();
        //hide import button when rendering the list
        if (self.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
            self.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().hide();
        }
    },

    /**
     * Gets D&B Company Details For A DUNS number
     * @param {String } duns_num
     */
    getCompanyDetails: function(duns_num) {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get('dnb.dnb-company-details');
        this.render();
        this.$('div#dnb-company-details').hide();
        this.baseCompanyInformation(duns_num, this.compInfoProdCD.lite, app.lang.get('LBL_DNB_FAMILY_TREE_BACK'), this.renderCompanyDetails);
    }
}) },
"mobile-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MobileActionView
 * @alias SUGAR.App.view.views.BaseMobileActionView
 * @extends View.View
 */
({
	// Mobile-action View (base) 

    tagName: 'span',
    events: {
        'click [data-action=mobile]': 'navigateToMobile'
    },
    navigateToMobile: function () {
        if (document.cookie.indexOf('sugar_mobile=') !== -1) {
            // kill sugar_mobile=0 cookie
            document.cookie = 'sugar_mobile=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
        }
        // navigate to the same route of mobile site
        window.location = app.utils.buildUrl('mobile/') + window.location.hash;
    }
}) },
"dnb-account-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbAccountCreateView
 * @alias SUGAR.App.view.views.BaseDnbAccountCreateView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-account-create View (base) 

    extendsFrom: 'DnbView',

    duns_num: '',

    //used to detect if import was clicked for the first time when company info was loaded
    //this flag is being used to avoid the warning message for account name
    //when the user clicks the import button first time when company info is loaded
    //a user clicks import
    importFlag: false,

    companyList: null,

    keyword: null,

    plugins: ['Connector'],

    events: {
        'click a.dnb-company-name': 'dunsClickHandler',
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData',
        'click .importDNBData': 'importAccount',
        'click .dnb_checkbox': 'importCheckBox',
        'click .clearDNBResults': 'clearDNBResults',
        'click .backToList' : 'backToCompanyList',
        'click [data-action="show-more"]': 'invokePagination'
    },

    selectors: {
        'load': 'div#dnb-company-list-loading',
        'rslt': 'div#dnb-search-results',
        'rsltList': 'ul#dnb-results-list'
    },

    configuredKey: 'dnb:account:create:configured',

    initialize: function(options) {
        this._super('initialize', [options]);
        this.initDashlet();
        this.loadData();
        this.initPaginationParams();
        this.rowTmpl = app.template.get('dnb.dnb-account-row');
        this.resultTemplate = app.template.get(this.name);
        this.resultCountTmpl = app.lang.get('LBL_DNB_BAL_ACCT_HEADER');
    },

    loadData: function() {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name + '.dnb-search-hint');
        this.render();
        this.checkConnector('ext_rest_dnb',
            _.bind(this.loadDataWithValidConnector, this),
            _.bind(this.handleLoadError, this),
            ['test_passed']);
    },

    /**
     * Success callback to be run when Connector has been verified and validated
     */
    loadDataWithValidConnector: function() {
        if (this.disposed) return;
        this.template = app.template.get(this.name + '.dnb-search-hint');
        this.render();
        // call .off first because loadDataWithValidConnector is called twice on account-create
        // we don't want to set the event listener twice
        this.context.off('update:account').on('update:account', this.dnbSearch, this);
        this.errmsg = null;
    },

    /**
     * Failure callback to be run if Connector verification fails
     * @param {object} connector that failed
     */
    handleLoadError: function(connector) {
        if (this.disposed) return;
        this.errmsg = 'LBL_DNB_NOT_CONFIGURED';
        this.template = app.template.get(this.name + '.dnb-need-configure');
        this.render();
        this.context.off('update:account', this.dnbSearch);
    },

    /**
     * Navigates from the company details screen to the search results screen
     */
    backToCompanyList: function() {
        if (this.disposed) {
            return;
        }
        this.template = this.resultTemplate;
        if (this.listData && this.listData.count) {
            delete this.listData['count'];
        }
        this.render();
        this.$(this.selectors.load).toggleClass('hide', false);
        this.$(this.selectors.rslt).toggleClass('hide', true);
        this.$('.importDNBData').hide();
        var dupeCheckParams = {
            'type': 'duns',
            'apiResponse': this.currentPage,
            'module': 'dunsPage'
        };
        this.baseDuplicateCheck(dupeCheckParams, this.renderPage);
    },

    /**
     * Render search results
     * @param  {Object} dnbSrchApiResponse
     */
    renderCompanyList: function(dnbSrchApiResponse) {
        var dnbSrchResults = {},
            appendRecords = false;
        if (this.resetPaginationFlag) {
            this.initPaginationParams();
        }
        if (dnbSrchApiResponse.product) {
            var apiCompanyList = this.getJsonNode(dnbSrchApiResponse.product, this.commonJSONPaths.srchRslt);
            //setting the formatted set of records to context
            //will be required when we paginate from the client side itself
            this.formattedRecordSet = this.formatSrchRslt(apiCompanyList, this.searchDD);
            //setting the api recordCount to context
            //will be used to determine if the pagination controls must be displayed
            this.recordCount = this.getJsonNode(dnbSrchApiResponse.product, this.commonJSONPaths.srchCount);
            var nextPage = this.paginateRecords();
            //currentPage is set to null by initPaginationParams
            if (_.isNull(this.currentPage)) {
                this.currentPage = nextPage;
                dnbSrchResults.product = this.currentPage;
            } else {
                //this loop gets executed when api is called again to obtain more records
                dnbSrchResults.product = nextPage;
                appendRecords = true;
            }
            if (this.recordCount) {
                dnbSrchResults.count = this.recordCount;
            }
        } else if (dnbSrchApiResponse.errmsg) {
            dnbSrchResults.errmsg = dnbSrchApiResponse.errmsg;
        }
        this.renderPage(dnbSrchResults, appendRecords);
    },

    /**
     * Event handler for pagination controls
     * Renders next page from context if available
     * else invokes the D&B API to get the next page
     */
    invokePagination: function() {
        this._super('invokePagination', [this.baseAccountsBAL, this.balParams, this.renderCompanyList]);
    },

    /** event listener for keyup / autocomplete feature
     */
    dnbSearch: function() {
        if (this.disposed) {
            return;
        }

        //Value of input in name field
        var searchString = this.closestComponent('sidebar').getComponent('main-pane').$('[data-fieldname=name] input').val()

        //only search if the searchString is at least 3 characters
        if (!searchString || searchString.length < 3) {
            return;
        }

        if (!this.keyword || (this.keyword && this.keyword !== searchString)) {
            this.keyword = searchString;
            this.template = this.resultTemplate;
            //deleting the count of the previous search results
            if (this.listData && this.listData.count) {
                delete this.listData['count'];
            }
            this.render();
            this.$('table#dnb_company_list').empty(); //empty results table
            this.$(this.selectors.load).toggleClass('hide', false);
            this.$(this.selectors.rslt).toggleClass('hide', true);
            this.$('.clearDNBResults').attr('disabled', 'disabled'); //disable clear button
            this.$('.clearDNBResults').removeClass('enabled');
            this.$('.clearDNBResults').addClass('disabled');
            this.companyList = null;
            var balParams = {
                'KeywordText': searchString
            };
            this.balParams = balParams;
            this.baseAccountsBAL(this.setApiPaginationParams(balParams), this.renderCompanyList);
        }
    },

    /**
     * Clear D&B Search Results
     */
    clearDNBResults: function() {
        this.$('table#dnb_company_list').empty();
        this.template = app.template.get(this.name + '.dnb-search-hint');
        this.render();
    },

    /**
     * Event handler for handling clicks on D&B Search Results
     * @param  {Object} evt
     */
    dunsClickHandler: function(evt) {
        var duns_num = evt.target.id;
        this.dnbProduct = null;
        if (duns_num) {
            this.template = app.template.get(this.name + '.dnb-company-details');
            this.render();
            this.$('div#dnb-company-detail-loading').show();
            this.$('div#dnb-company-details').hide();
            this.$('.importDNBData').hide();
            this.baseCompanyInformation(duns_num, this.compInfoProdCD.lite,
            app.lang.get('LBL_DNB_BACK_TO_SRCH'), this.renderCompanyDetails);
        }
    },


    /**
     * Renders the dnb company details with checkboxes
     * @param {Object} companyDetails
     */
    renderCompanyDetails: function(companyDetails) {
        if (this.disposed) {
            return;
        }
        this.dnbProduct = {};
        if (companyDetails.product) {
            var duns_num = this.getJsonNode(companyDetails.product, this.appendSVCPaths.duns);
            if (!_.isUndefined(duns_num)) {
                this.duns_num = duns_num;
                this.dnbProduct.product = this.formatCompanyInfo(companyDetails.product, this.accountsDD);
            }
        }
        if (companyDetails.errmsg) {
            this.dnbProduct.errmsg = companyDetails.errmsg;
        }
        this.render();
        this.$('div#dnb-company-detail-loading').hide();
        this.$('div#dnb-company-details').show();
        if (this.dnbProduct.errmsg) {
            this.$('.importDNBData').hide();
        } else {
            this.$('.importDNBData').show();
        }
    },

    /**
     * Import Account Information
     */
    importAccount: function() {
        this.importAccountsData(this.importFlag);
        this.importFlag = true;
    },

    /**
     * Checkbox change event handler
     */
    importCheckBox: function() {
        var dnbCheckBoxes = this.$('.dnb_checkbox:checked');
        this.$('.importDNBData').toggleClass('disabled', dnbCheckBoxes.length === 0);
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewView
 * @alias SUGAR.App.view.views.BasePreviewView
 * @extends View.Views.Base.RecordView
 */
({
	// Preview View (base) 

    extendsFrom: 'RecordView',

    plugins: ['ToggleMoreLess', 'Editable', 'ErrorDecoration'],
    fallbackFieldTemplate: 'detail',
    /**
     * Events related to the preview view:
     *  - preview:open                  indicate we must show the preview panel
     *  - preview:render                indicate we must load the preview with a model/collection
     *  - preview:collection:change     indicate we want to update the preview with the new collection
     *  - preview:close                 indicate we must hide the preview panel
     *  - preview:pagination:fire       (on layout) indicate we must switch to previous/next record
     *  - preview:pagination:update     (on layout) indicate the preview header needs to be refreshed
     *  - list:preview:fire             indicate the user clicked on the preview icon
     *  - list:preview:decorate         indicate we need to update the highlighted row in list view
     */

    // "binary semaphore" for the pagination click event, this is needed for async changes to the preview model
    switching: false,

    hiddenPanelExists: false,

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.action = 'detail';
        this._delegateEvents();
        this.delegateButtonEvents();
        this.collection = app.data.createBeanCollection(this.module);

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to get preview specific buttons
     */
    toggleButtons: function(enable) {
        if (this.layout.previewEdit) {
            var previewLayout = this.layout.getComponent('preview-header');
            previewLayout.getField('save_button').setDisabled(!enable);
            previewLayout.getField('cancel_button').setDisabled(!enable);
        }
    },

    /**
     * Runs when validation is successful
     * Returns the preview to detail view
     *
     * @override Overriding because we need to trigger 'preview:edit:complete'
     * and not do record view specific actions like: this.inlineEditMode = false;
     */
    handleSave: function() {
        if (this.disposed) {
            return;
        }
        this._saveModel();
        this.layout.trigger('preview:edit:complete');
        this.unsetContextAction();
        this.toggleFields(this.editableFields, false);
    },

    /**
     * When clicking cancel, return the preview view to detail state
     * and revert the model
     *
     * @override Overriding in order to trigger 'preview:edit:complete'
     */
    cancelClicked: function() {
        this.model.revertAttributes();
        this.toggleFields(this.editableFields, false);
        this._dismissAllAlerts();
        this.clearValidationErrors(this.editableFields);
        this.unsetContextAction();
        this.layout.trigger('preview:edit:complete');
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        app.events.on('preview:render', this._renderPreview, this);
        app.events.on('preview:collection:change', this.updateCollection, this);
        app.events.on('preview:close', this.closePreview, this);

        // TODO: Remove when pagination on activity streams is fixed.
        app.events.on('preview:module:update', this.updatePreviewModule, this);

        if (this.layout) {
            this.layout.on('preview:pagination:fire', this.switchPreview, this);
        }
    },

    /**
     * Setup event listeners for buttons
     *
     * @override Override because we only want to set events if
     * previewEdit is enabled
     */
    delegateButtonEvents: function() {
        if (this.layout && this.layout.previewEdit) {
            this.context.on('button:save_button:click', this.saveClicked, this);
            this.context.on('button:cancel_button:click', this.cancelClicked, this);
            this.layout.on('preview:edit', this.handleEdit, this);
        }
    },

    updateCollection: function(collection) {
        if( this.collection ) {
            this.collection.reset(collection.models);
            this.showPreviousNextBtnGroup();
       }
    },

    // TODO: Remove when pagination on activity streams is fixed.
    updatePreviewModule: function(module) {
        this.previewModule = module;
    },

    filterCollection: function() {
        this.collection.remove(_.filter(this.collection.models, function(model){
            return !app.acl.hasAccessToModel('view', model);
        }, this), { silent: true });
    },

    _renderHtml: function(){
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
    },

    /**
     * Show previous and next buttons groups on the view.
     *
     * This gets called everytime the collection gets updated. It also depends
     * if we have a current model or layout.
     *
     * TODO we should check if we have the preview open instead of doing a bunch
     * of if statements.
     */
    showPreviousNextBtnGroup: function () {
        if (!this.model || !this.layout || !this.collection) {
            return;
        }
        var collection = this.collection;
        if (!collection.size()) {
            this.layout.hideNextPrevious = true;
        }
        var recordIndex = collection.indexOf(collection.get(this.model.id));
        this.layout.previous = collection.models[recordIndex-1] ? collection.models[recordIndex-1] : undefined;
        this.layout.next = collection.models[recordIndex+1] ? collection.models[recordIndex+1] : undefined;
        this.layout.hideNextPrevious = _.isUndefined(this.layout.previous) && _.isUndefined(this.layout.next);

        // Need to rerender the preview header
        this.layout.trigger('preview:pagination:update');
    },

    /**
     * Renders the preview dialog with the data from the current model and collection.
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     * @param {Boolean} fetch Optional Indicates if model needs to be synched with server to populate with latest data
     * @param {Number|String} previewId Optional identifier use to determine event origin. If event origin is not the same
     * but the model id is the same, preview should still render the same model.
     * @private
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        var self = this;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if (this.model && model && (this.model.get('id') == model.get('id') && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));
            this.renderPreview(model, collection);
            fetch && model.fetch({
                showAlerts: true,
                view: viewName
            });
        }

        this.previewId = previewId;
    },
    /**
     * Use the given model to render preview.
     * @param {Bean} model Model to render preview
     */
    switchModel: function(model) {
        this.model && this.model.abortFetchRequest();
        this.stopListening(this.model);
        this.model = model;

        // Close preview when model destroyed by deleting the record
        this.listenTo(this.model, 'destroy', function() {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
        });
    },
    /**
     * Renders the preview dialog with the data from the current model and collection
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     */
    renderPreview: function(model, newCollection) {
        if(newCollection) {
            this.collection.reset(newCollection.models);
        }

        if (model) {
            this.switchModel(model);
            if (this.layout) {
                this.layout.trigger('previewheader:ACLCheck', model);
            }

            // TODO: Remove when pagination on activity streams is fixed.
            if (this.previewModule && this.previewModule === 'Activities') {
                // We need to set previewEdit to false before render but set
                // hideNextPreview and trigger 'preview:pagination:update' after
                this.layout.previewEdit = false;
                this.render();
                this.layout.hideNextPrevious = true;
                this.layout.trigger('preview:pagination:update');
            } else {
                // If we aren't on activitystream, then just render
                this.render();
            }
            // Open the preview panel
            app.events.trigger('preview:open', this);
            // Highlight the row
            app.events.trigger('list:preview:decorate', this.model, this);
        }
    },

    /**
     * Normalizes the metadata, and removes favorite/follow fields that gets
     * shown in Preview dialog.
     *
     * @param meta Layout metadata to be trimmed
     * @return Returns trimmed metadata
     * @private
     */
    _previewifyMetadata: function(meta){
        this.hiddenPanelExists = false; // reset
        _.each(meta.panels, function(panel){
            if(panel.header){
                panel.header = false;
                panel.fields = _.filter(panel.fields, function(field){
                    //Don't show favorite or follow in Preview, it's already on list view row
                    return field.type != 'favorite' && field.type != 'follow';
                });
            }
            //Keep track if a hidden panel exists
            if(!this.hiddenPanelExists && panel.hide){
                this.hiddenPanelExists = true;
            }
        }, this);
        return meta;
    },
    /**
     * Switches preview to left/right model in collection.
     * @param {Object} data
     * @param {String} data.direction Direction that we are switching to, either 'left' or 'right'.
     * @param index Optional current index in list
     * @param id Optional
     * @param module Optional
     */
    switchPreview: function(data, index, id, module) {
        var currID = id || this.model.get('id'),
            currIndex = index || _.indexOf(this.collection.models, this.collection.get(currID));

        if( this.switching || this.collection.models.length < 2) {
            // We're currently switching previews or we don't have enough models, so ignore any pagination click events.
            return;
        }
        this.switching = true;

        if (data.direction === 'left' && (currID === _.first(this.collection.models).get('id')) ||
            data.direction === 'right' && (currID === _.last(this.collection.models).get('id'))) {
            this.switching = false;
            return;
        } else {
            // We can increment/decrement
            data.direction === 'left' ? currIndex -= 1 : currIndex += 1;

            //Reset the preview
            app.events.trigger('preview:render', this.collection.models[currIndex], null, true);
            this.switching = false;
        }
    },

    closePreview: function() {
        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)){
            this.switching = false;
            delete this.model;
            this.collection.reset();
        }
    },

    bindDataChange: function() {
        if(this.collection) {
            this.collection.on('reset', this.filterCollection, this);
            // when remove active model from collection then close preview
            this.collection.on('remove', function(model) {
                if (model && this.model && (this.model.get('id') == model.get('id'))) {
                    // Remove the decoration of the highlighted row
                    app.events.trigger('list:preview:decorate', false);
                    // Close the preview panel
                    app.events.trigger('preview:close');
                }
            }, this);
        }
    },

    /**
     * When clicking on the pencil icon, toggle all editable fields
     * to edit mode
     */
    handleEdit: function() {
        this.setEditableFields();
        this.toggleFields(this.editableFields, true);
        this.toggleButtons(true);
    },

    /**
     * Set a list of editable fields
     *
     * @override Overriding to checking field def if preview edit
     * is allowed
     */
    setEditableFields: function() {
        var self = this;
        // we only want to edit non readonly fields
        this.editableFields = _.reject(this.fields, function(field) {
            return field.def.readOnly || field.def.calculated ||
                //Added for SugarLogic fields since they are not supported
                //Fixme: PAT-2241 will remove this
                field.def.previewEdit === false ||
                !app.acl.hasAccessToModel('edit', self.model, field.name);
        });
    },

    /**
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        if (_.isUndefined(this.model)) {
            return false;
        }
        return this._super('hasUnsavedChanges');
    }
}) },
"dnb": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbView
 * @alias SUGAR.App.view.views.BaseDnbView
 * @extends View.View
 */
({
	// Dnb View (base) 

    plugins: ['Dashlet'],
    currentCompany: null,
    //dnb api response codes
    responseCodes: {
        success: 'CM000'
    },
    //common constants
    commonConst: {
        'sic_code': 3599,
        'hoovers_ind_code': 25838,
        'sic_to_hic': 3599,
        'connectorSettingsURL': 'index.php#bwc/index.php?module=Connectors&action=ModifyProperties&active_tab=ext_rest_dnb',
        'systemSettingsURL': 'index.php#bwc/index.php?module=Configurator&action=EditView'
    },

    //mapping of sugar column names to dnb api response
    accountsMap: {
        'name': 'OrganizationName.OrganizationPrimaryName.0.OrganizationName.$', //account name
        'duns_num': 'SubjectHeader.DUNSNumber', //duns_num
        'billing_address_street': 'Location.PrimaryAddress.0.StreetAddressLine.0.LineText',
        'billing_address_city': 'Location.PrimaryAddress.0.PrimaryTownName',
        'billing_address_state': 'Location.PrimaryAddress.0.TerritoryAbbreviatedName',
        'billing_address_country': 'Location.PrimaryAddress.0.CountryISOAlpha2Code',
        'billing_address_postalcode': 'Location.PrimaryAddress.0.PostalCode',
        'website': 'Telecommunication.WebPageAddress.0.TelecommunicationAddress',
        'phone_office': 'Telecommunication.TelephoneNumber.0.TelecommunicationNumber',
        'employees': 'EmployeeFigures.IndividualEntityEmployeeDetails.TotalEmployeeQuantity',
        'annual_revenue': 'Financial.KeyFinancialFiguresOverview.0.SalesRevenueAmount.0.$',
        'ownership': 'OrganizationDetail.ControlOwnershipTypeText.$',
        'sic_code': 'primarySIC.IndustryCode.$'
    },
    //D&B Firmographic API product codes
    compInfoProdCD: {
        'lite': 'DCP_BAS',
        'std': 'DCP_STD',
        'prem': 'DCP_PREM'
    },

    /**
     * json_path -- refers to the json path to traverse to obtain the data element
     * label -- refers to the label to be used to name the data element
     * desc -- refers to the label used to describe the data element
     * case_fmt -- boolean -- when true specifies that this data element needs to be formatted to proper case
     * sub_array -- refers to meta data for nested json objects
     */
    compinfoDD: {
        'compname': {
            'json_path': 'OrganizationName.OrganizationPrimaryName.0.OrganizationName.$',
            'label': 'LBL_DNB_PRIM_NAME',
            'desc': 'LBL_DNB_PRIM_NAME_DESC',
            'case_fmt': true
        },
        'tradename': {
            'json_path': 'OrganizationName.TradeStyleName.0.OrganizationName.$',
            'label': 'LBL_DNB_TRD_NAME',
            'desc': 'LBL_DNB_TRD_NAME_DESC',
            'case_fmt': true
        },
        'locationtype': {
            'json_path': 'OrganizationDetail.FamilyTreeMemberRole.0.FamilyTreeMemberRoleText.$',
            'label': 'LBL_DNB_LOCATION_TYPE',
            'desc': 'LBL_DNB_LOCATION_TYPE_DESC',
            'case_fmt': true
        },
        'cntrowndate': {
            'json_path': 'OrganizationDetail.ControlOwnershipDate.$',
            'label': 'LBL_DNB_CNTRL_OWN_DATE',
            'desc': 'LBL_DNB_CNTRL_OWN_DATE_DESC'
        },
        'cntrowntype': {
            'json_path': 'OrganizationDetail.ControlOwnershipTypeText.$',
            'label': 'LBL_DNB_CNTRL_TYP_TEXT',
            'desc': 'LBL_DNB_CNTRL_TYP_TEXT_DESC',
            'case_fmt': true
        },
        'operstatus': {
            'json_path': 'OrganizationDetail.OperatingStatusText.$',
            'label': 'LBL_DNB_OPERL_STA_TEXT',
            'desc': 'LBL_DNB_OPERL_STA_TEXT_DESC',
            'case_fmt': true
        },
        'boneyardind': {
            'json_path': 'OrganizationDetail.BoneyardOrganizationIndicator',
            'label': 'LBL_DNB_BONE_ORG_IND',
            'desc': 'LBL_DNB_BONE_ORG_IND_DESC'
        },
        'orgstartyear': {
            'json_path': 'OrganizationDetail.OrganizationStartYear',
            'label': 'LBL_DNB_ORGS_STRT_YEAR',
            'desc': 'LBL_DNB_ORGS_STRT_YEAR_DESC'
        },
        'francoper': {
            'json_path': 'OrganizationDetail.FranchiseOperationTypeText.$',
            'label': 'LBL_DNB_FRAN_TYP_TEXT',
            'desc': 'LBL_DNB_FRAN_TYP_TEXT_DESC',
            'case_fmt': true
        },
        'primaddrstreet': {
            'json_path': 'Location.PrimaryAddress.0.StreetAddressLine.0.LineText',
            'label': 'LBL_DNB_PRIM_STREET',
            'desc': 'LBL_DNB_PRIM_STREET_DESC',
            'case_fmt': true
        },
        'primaddrcity': {
            'json_path': 'Location.PrimaryAddress.0.PrimaryTownName',
            'label': 'LBL_DNB_PRIM_CITY',
            'desc': 'LBL_DNB_PRIM_CITY_DESC',
            'case_fmt': true
        },
        'primaddrstateabbr': {
            'json_path': 'Location.PrimaryAddress.0.TerritoryAbbreviatedName',
            'label': 'LBL_DNB_PRIM_STATE_ABBR',
            'desc': 'LBL_DNB_PRIM_STATE_ABBR_DESC'
        },
        'primaddrstate': {
            'json_path': 'Location.PrimaryAddress.0.TerritoryOfficialName',
            'label': 'LBL_DNB_PRIM_STATE',
            'desc': 'LBL_DNB_PRIM_STATE_DESC'
        },
        'primaddrctrycd': {
            'json_path': 'Location.PrimaryAddress.0.CountryISOAlpha2Code',
            'label': 'LBL_DNB_PRIM_CTRY_CD',
            'desc': 'LBL_DNB_PRIM_CTRY_CD_DESC'
        },
        'primaddrctrygrp': {
            'json_path': 'Location.PrimaryAddress.0.CountryGroupName',
            'label': 'LBL_DNB_PRIM_CTRY_GRP',
            'desc': 'LBL_DNB_PRIM_CTRY_GRP_DESC'
        },
        'primaddrzip': {
            'json_path': 'Location.PrimaryAddress.0.PostalCode',
            'label': 'LBL_DNB_PRIM_ZIP',
            'desc': 'LBL_DNB_PRIM_ZIP_DESC'
        },
        'primaddrcountyname': {
            'json_path': 'Location.PrimaryAddress.0.CountyOfficialName',
            'label': 'LBL_DNB_PRIM_COUNTY_NAME',
            'desc': 'LBL_DNB_PRIM_COUNTY_NAME_DESC'
        },
        'uscensuscd': {
            'json_path': 'Location.PrimaryAddress.0.MetropolitanStatisticalAreaUSCensusCode.0',
            'label': 'LBL_DNB_PRIM_CEN_CD',
            'desc': 'LBL_DNB_PRIM_CEN_CD_DESC'
        },
        'mailingaddrstreet': {
            'json_path': 'Location.MailingAddress.0.StreetAddressLine.0.LineText',
            'label': 'LBL_DNB_MAIL_STREET',
            'desc': 'LBL_DNB_PRIM_STREET_DESC',
            'case_fmt': true
        },
        'mailingaddrcity': {
            'json_path': 'Location.MailingAddress.0.PrimaryTownName',
            'label': 'LBL_DNB_MAIL_CITY',
            'desc': 'LBL_DNB_PRIM_CITY_DESC',
            'case_fmt': true
        },
        'mailingaddrstateabbr': {
            'json_path': 'Location.MailingAddress.0.TerritoryAbbreviatedName',
            'label': 'LBL_DNB_MAIL_STATE_ABBR',
            'desc': 'LBL_DNB_PRIM_STATE_ABBR_DESC'
        },
        'mailingaddrzip': {
            'json_path': 'Location.MailingAddress.0.PostalCode',
            'label': 'LBL_DNB_MAIL_ZIP',
            'desc': 'LBL_DNB_PRIM_ZIP_DESC'
        },
        'mailingaddrctrycd': {
            'json_path': 'Location.MailingAddress.0.CountryISOAlpha2Code',
            'label': 'LBL_DNB_MAIL_CTRY_CD',
            'desc': 'LBL_DNB_PRIM_CTRY_CD_DESC'
        },
        'long': {
            'json_path': 'Location.PrimaryAddress.0.LongitudeMeasurement',
            'label': 'LBL_DNB_LAT',
            'desc': 'LBL_DNB_LAT_DESC'
        },
        'lat': {
            'json_path': 'Location.PrimaryAddress.0.LatitudeMeasurement',
            'label': 'LBL_DNB_LONG',
            'desc': 'LBL_DNB_LONG_DESC'
        },
        'phone': {
            'json_path': 'Telecommunication.TelephoneNumber.0',
            'desc': 'LBL_DNB_PHONE_DESC',
            'sub_object': {
                'data_type': 'phone_idc',
                'data_name': 'phone_office',
                'phone_no': 'TelecommunicationNumber',
                'id_code': 'InternationalDialingCode',
                'label': 'LBL_DNB_PHONE'
            }
        },
        'fax': {
            'json_path': 'Telecommunication.FacsimileNumber.0',
            'desc': 'LBL_DNB_FAX_DESC',
            'sub_object': {
                'data_type': 'phone_idc',
                'data_name': 'fax',
                'phone_no': 'TelecommunicationNumber',
                'id_code': 'InternationalDialingCode',
                'label': 'LBL_DNB_FAX'
            }
        },
        'webpage': {
            'json_path': 'Telecommunication.WebPageAddress.0.TelecommunicationAddress',
            'label': 'LBL_DNB_WEBPAGE',
            'desc': 'LBL_DNB_WEBPAGE_DESC',
            'type': 'link'
        },
        'indempcnt': {
            'json_path': 'EmployeeFigures.IndividualEntityEmployeeDetails.TotalEmployeeQuantity',
            'label': 'LBL_DNB_IND_EMP_CNT',
            'desc': 'LBL_DNB_IND_EMP_CNT_DESC'
        },
        'conempcnt': {
            'json_path': 'EmployeeFigures.ConsolidatedEmployeeDetails.TotalEmployeeQuantity',
            'label': 'LBL_DNB_CON_EMP_CNT',
            'desc': 'LBL_DNB_CON_EMP_CNT_DESC'
        },
        'empdet': {
            'json_path': 'PrincipalsAndManagement.CurrentPrincipal',
            'label': 'LBL_DNB_EMP_DET',
            'desc': 'LBL_DNB_EMP_DET_DESC',
            'sub_array': {
                'data_type': 'emp_det',
                'job_title': 'JobTitle.0.JobTitleText.$',
                'full_name': 'PrincipalName.FullName'
            }
        },
        'lob': {
            'json_path': 'ActivitiesAndOperations.LineOfBusinessDetails.0.LineOfBusinessDescription.$',
            'label': 'LBL_DNB_LOB',
            'desc': 'LBL_DNB_LOB_DESC'
        },
        'impind': {
            'json_path': 'ActivitiesAndOperations.ImportDetails.ImportIndicator',
            'label': 'LBL_DNB_IMP_IND',
            'desc': 'LBL_DNB_IMP_IND_DESC'
        },
        'expind': {
            'json_path': 'ActivitiesAndOperations.ExportDetails.ExportIndicator',
            'label': 'LBL_DNB_EXP_IND',
            'desc': 'LBL_DNB_EXP_IND_DESC'
        },
        'agentind': {
            'json_path': 'ActivitiesAndOperations.SubjectIsAgentDetails.AgentIndicator',
            'label': 'LBL_DNB_AGENT_IND',
            'desc': 'LBL_DNB_AGENT_IND_DESC'
        },
        'opertext': {
            'json_path': 'ActivitiesAndOperations.OperationsText.0',
            'label': 'LBL_DNB_OPER_TEXT',
            'desc': 'LBL_DNB_OPER_TEXT_DESC'
        },
        'histrat': {
            'json_path': 'Assessment.HistoryRatingText.$',
            'label': 'LBL_DNB_HIST_RAT',
            'desc': 'LBL_DNB_HIST_RAT_DESC'
        },
        'ccs': {
            'json_path': 'Assessment.CommercialCreditScore.0.MarketingRiskClassText.$',
            'label': 'LBL_DNB_CCS',
            'desc': 'LBL_DNB_CCS_DESC'
        },
        'uspatriskscr': {
            'json_path': 'Assessment.USPatriotActComplianceRiskScore.ComplianceRiskIndex',
            'label': 'LBL_DNB_USPAT_SCR',
            'desc': 'LBL_DNB_USPAT_SCR_DESC'
        },
        'tpa': {
            'json_path': 'ThirdPartyAssessment.ThirdPartyAssessment',
            'label': 'LBL_DNB_TPA',
            'desc': 'LBL_DNB_TPA_DESC',
            'sub_array': {
                'assmt_type': 'AssessmentTypeValue',
                'assmt': 'AssessmentValue',
                'data_type': 'tpa'
            }
        },
        'minind': {
            'json_path': 'SocioEconomicIdentification.MinorityOwnedIndicator',
            'label': 'LBL_DNB_MIN_IND',
            'desc': 'LBL_DNB_MIN_IND_DESC'
        },
        'smbind': {
            'json_path': 'SocioEconomicIdentification.SmallBusinessIndicator',
            'label': 'LBL_DNB_SMB_IND',
            'desc': 'LBL_DNB_SMB_IND_DESC'
        },
        'ethn': {
            'json_path': 'SocioEconomicIdentification.OwnershipEthnicity.0.EthnicityTypeText.$',
            'label': 'LBL_DNB_ETHN',
            'desc': 'LBL_DNB_ETHN_DESC',
            'case_fmt': true
        },
        'femind': {
            'json_path': 'SocioEconomicIdentification.FemaleOwnedIndicator',
            'label': 'LBL_DNB_FEM_IND',
            'desc': 'LBL_DNB_FEM_IND_DESC'
        },
        'smbdisadv': {
            'json_path': 'SocioEconomicIdentification.SmallDisadvantagedBusinessIndicator',
            'label': 'LBL_DNB_SMBDISADV_IND',
            'desc': 'LBL_DNB_SMBDISADV_IND_DESC'
        },
        'alasnat': {
            'json_path': 'SocioEconomicIdentification.AlaskanNativeCorporationIndicator',
            'label': 'LBL_DNB_ALASNAT_IND',
            'desc': 'LBL_DNB_ALASNAT_IND_DESC'
        },
        'smbcert': {
            'json_path': 'SocioEconomicIdentification.CertifiedSmallBusinessIndicator',
            'label': 'LBL_DNB_SMB_CERT',
            'desc': 'LBL_DNB_SMB_CERT_DESC'
        },
        'mincoll': {
            'json_path': 'SocioEconomicIdentification.MinorityCollegeIndicator',
            'label': 'LBL_DNB_MIN_COLL',
            'desc': 'LBL_DNB_MIN_COLL_DESC'
        },
        'disab': {
            'json_path': 'SocioEconomicIdentification.DisabledOwnedIndicator',
            'label': 'LBL_DNB_DISAB_IND',
            'desc': 'LBL_DNB_DISAB_IND_DESC'
        },
        'svcdisabvet': {
            'json_path': 'SocioEconomicIdentification.ServiceDisabledVeteranOwnedIndicator',
            'label': 'LBL_DNB_SVC_DISAB_VET',
            'desc': 'LBL_DNB_SVC_DISAB_VET_DESC'
        },
        'vietvet': {
            'json_path': 'SocioEconomicIdentification.VietnamVeteranOwnedIndicator',
            'label': 'LBL_DNB_VIET_VET',
            'desc': 'LBL_DNB_VIET_VET_DESC'
        },
        'airprtdisadvent': {
            'json_path': 'SocioEconomicIdentification.AirportConcessionDisadvantagedBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_AIRPRT_DISADV_ENT',
            'desc': 'LBL_DNB_AIRPRT_DISADV_ENT_DESC'
        },
        'disabvetent': {
            'json_path': 'SocioEconomicIdentification.DisabledVeteranBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_DISAB_VET_ENT',
            'desc': 'LBL_DNB_DISAB_VET_ENT_DESC'
        },
        'disadvent': {
            'json_path': 'SocioEconomicIdentification.DisadvantagedBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_DISADV_ENT',
            'desc': 'LBL_DNB_DISADV_ENT_DESC'
        },
        'disadvvetent': {
            'json_path': 'SocioEconomicIdentification.DisadvantagedVeteranEnterpriseIndicator',
            'label': 'LBL_DNB_DISADV_VET_ENT',
            'desc': 'LBL_DNB_DISADV_VET_ENT_DESC'
        },
        'minent': {
            'json_path': 'SocioEconomicIdentification.MinorityBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_MIN_ENT',
            'desc': 'LBL_DNB_MIN_ENT_DESC'
        },
        'fement': {
            'json_path': 'SocioEconomicIdentification.FemaleOwnedBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_FEM_ENT',
            'desc': 'LBL_DNB_FEM_ENT_DESC'
        },
        'hubcrt': {
            'json_path': 'SocioEconomicIdentification.HUBZoneCertifiedBusinessIndicator',
            'label': 'LBL_DNB_HUB_CRT',
            'desc': 'LBL_DNB_HUB_CRT_DESC'
        },
        'eightacrt': {
            'json_path': 'SocioEconomicIdentification.EightACertifiedBusinessIndicator',
            'label': 'LBL_DNB_EIGHTA_CRT',
            'desc': 'LBL_DNB_EIGHTA_CRT_DESC'
        },
        'vet_ind': {
            'json_path': 'SocioEconomicIdentification.VeteranOwnedIndicator',
            'label': 'LBL_DNB_VET_IND',
            'desc': 'LBL_DNB_VET_IND_DESC'
        },
        'lsind': {
            'json_path': 'SocioEconomicIdentification.LaborSurplusAreaIndicator',
            'label': 'LBL_DNB_LS_IND',
            'desc': 'LBL_DNB_LS_IND_DESC'
        },
        'vetent': {
            'json_path': 'SocioEconomicIdentification.VeteranBusinessEnterpriseIndicator',
            'label': 'LBL_DNB_VET_ENT',
            'desc': 'LBL_DNB_VET_ENT_DESC'
        },
        'inqcnt': {
            'json_path': 'SubjectHeader.TotalInquiriesCount',
            'label': 'LBL_DNB_INQ_CNT',
            'desc': 'LBL_DNB_INQ_CNT_DESC'
        },
        'transferdunsnbr': {
            'json_path': 'SubjectHeader.TransferDUNSNumberRegistration.0.TransferredFromDUNSNumber',
            'label': 'LBL_DNB_TRNS_DUNS',
            'desc': 'LBL_DNB_TRNS_DUNS_DESC'
        },
        'lastupddate': {
            'json_path': 'SubjectHeader.LastUpdateDate.$',
            'label': 'LBL_DNB_LAST_UPD_DATE',
            'desc': 'LBL_DNB_LAST_UPD_DATE_DESC'
        },
        'marketind': {
            'json_path': 'SubjectHeader.MarketabilityIndicator',
            'label': 'LBL_DNB_MARKET_IND',
            'desc': 'LBL_DNB_MARKET_IND_DESC'
        },
        'dunsselfind': {
            'json_path': 'SubjectHeader.DUNSSelfRequestIndicator',
            'label': 'LBL_DNB_DUNSSELF_IND',
            'desc': 'LBL_DNB_DUNSSELF_IND_DESC'
        },
        'nonmarkreastxt': {
            'json_path': 'SubjectHeader.NonMarketableReasonText.0.$',
            'label': 'LBL_DNB_NONMARK_REAS_TXT',
            'desc': 'LBL_DNB_NONMARK_REAS_TXT_DESC',
            'case_fmt': true
        },
        'orgid': {
            'json_path': 'RegisteredDetail.OrganizationIdentificationNumberDetail',
            'label': 'LBL_DNB_ORG_ID',
            'desc': 'LBL_DNB_ORG_ID_DESC',
            'sub_array': {
                'data_type': 'org_id',
                'org_id': 'OrganizationIdentificationNumber',
                'org_id_type': '@TypeText'
            }
        },
        'indcodes': {
            'json_path': 'IndustryCode.IndustryCode',
            'label': 'LBL_DNB_IND_CD',
            'desc': 'LBL_DNB_IND_CD_DESC',
            'sub_array': {
                'data_type': 'ind_codes',
                'ind_code_type': '@TypeText',
                'ind_code': 'IndustryCode.$',
                'ind_code_desc': 'IndustryCodeDescription.0.$',
                'disp_seq': 'DisplaySequence'
            }
        }
    },

    /*
     * @property {Object} searchDD Data Dictionary For D&B Search API Response
     */
    searchDD: {
        'companyname': {
            'json_path': 'OrganizationPrimaryName.OrganizationName.$',
            'case_fmt': true
        },
        'duns_num': {
            'json_path': 'DUNSNumber'
        },
        'locationtype': {
            'json_path': 'locationtype',
            'case_fmt': true
        },
        'streetaddr': {
            'json_path': 'PrimaryAddress.StreetAddressLine.0.LineText',
            'case_fmt': true
        },
        'town': {
            'json_path': 'PrimaryAddress.PrimaryTownName',
            'case_fmt': true
        },
        'territory': {
            'json_path': 'PrimaryAddress.TerritoryOfficialName',
            'case_fmt': true
        },
        'ctrycd': {
            'json_path': 'PrimaryAddress.CountryISOAlpha2Code'
        },
        'isDupe': {
            'json_path': 'isDupe'
        },
        'recordNum': {
            'json_path': 'DisplaySequence'
        }
    },
    accountsDD: null,
    //dnb append service json paths
    appendSVCPaths: {
        'responseCode': 'OrderProductResponse.TransactionResult.ResultID',
        'responseMsg': 'OrderProductResponse.TransactionResult.ResultText',
        'industry': 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.IndustryCode.IndustryCode',
        'product': 'OrderProductResponse.OrderProductResponseDetail.Product.Organization',
        'duns': 'OrderProductResponse.OrderProductResponseDetail.InquiryDetail.DUNSNumber',
        'idc': 'Telecommunication.TelephoneNumber.0.InternationalDialingCode'
    },
    //common json paths
    commonJSONPaths: {
        'industryCode': 'IndustryCode.$',
        'industryType': '@DNBCodeValue',
        'srchRespCode': 'FindCompanyResponse.TransactionResult.ResultID',
        'srchRespMsg': 'FindCompanyResponse.TransactionResult.ResultText',
        'srchRslt': 'FindCompanyResponse.FindCompanyResponseDetail.FindCandidate',
        'competitors': 'FindCompetitorResponse.FindCompetitorResponseDetail.Competitor',
        'industryprofile': 'OrderProductResponse.OrderProductResponseDetail.Product.IndustryProfile',
        'srchCount': 'FindCompanyResponse.FindCompanyResponseDetail.CandidateMatchedQuantity',
        'cmCount': 'GetCleanseMatchResponse.GetCleanseMatchResponseDetail.MatchResponseDetail.CandidateMatchedQuantity'
    },
    //common error codes with error labels
    commonErrorMap: {
        'ERROR_DNB_CONFIG': 'LBL_DNB_NOT_CONFIGURED',
        'ERROR_CURL_5': 'LBL_DNB_ERROR_CURL_RESOLVE_PROXY',
        'ERROR_CURL_6': 'LBL_DNB_ERROR_CURL_RESOLVE_HOST',
        'ERROR_CURL_7': 'LBL_DNB_ERROR_CURL_CONNECTION_FAIL',
        'ERROR_CURL_56': 'LBL_DNB_ERROR_CURL_NETWORK_FAIL',
        'ERROR_DNB_SVC_ERR': 'LBL_DNB_SVC_ERR',
        'ERROR_DNB_UNKNOWN': 'LBL_DNB_UNKNOWN_ERROR',
        'ERROR_EMPTY_PARAM': 'LBL_DNB_EMPTY_PARAM',
        'ERROR_BAD_REQUEST': 'EXCEPTION_MISSING_PARAMTER',
        'ERROR_INVALID_MODULE_NAME': 'LBL_DNB_INVALID_MODULE_NAME'
    },
    //formatting functions map
    formatTypeMap: null,

    contactConst: {
        'responseCode' : 'FindContactResponse.TransactionResult.ResultID',
        'responseMsg' : 'FindContactResponse.TransactionResult.ResultText',
        'contactsPath' : 'FindContactResponse.FindContactResponseDetail.FindCandidate',
        'contactsDetailPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.PrincipalsAndManagement.CurrentPrincipal.0',
        'premCntct' : 'dnb-cnt-prem',
        'stdCntct' : 'dnb-cnt-std',
        'srchCount': 'FindContactResponse.FindContactResponseDetail.CandidateMatchedQuantity',
        'orgName': 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.OrganizationName.OrganizationPrimaryName.0.OrganizationName.$'
    },

    //dashlets that occupy the full sidepane
    //account create and build a list for now
    sidePaneDashlets: {
        'dnb-account-create': 'LBL_DNB_ACC_CRT',
        'dnb-bal-results': 'LBL_DNB_BAL'
    },

    contactsListDD: {
        'jobTitle' : {
            'json_path' : 'JobTitle.0.JobTitleText.$'
        },
        'fullName' : {
            'json_path' : 'ContactName.FullName'
        },
        'principalId' : {
            'json_path' : 'PrincipalIdentificationNumberDetail.0.PrincipalIdentificationNumber'
        },
        'emailInd' : {
            'json_path': 'DirectEmailInformationAvailableIndicator'
        },
        'phoneInd' : {
            'json_path': 'DirectTelephoneInformationAvailableIndicator'
        },
        'isDupe' : {
            'json_path' : 'isDupe'
        },
        'companyName' : {
            'json_path' : 'OrganizationPrimaryName.OrganizationName.$'
        },
        'dunsNum' : {
            'json_path' : 'DUNSNumber'
        },
        'recordNum': {
            'json_path': 'DisplaySequence'
        }
    },

    //contacts detail data dictionary
    contactsDetailDD: {
        'full_name' : {
            'json_path' : 'PrincipalName.FullName',
            'label' : 'LBL_DNB_CONTACT_NAME'
        },
        'account_name': {
            'json_path' : 'orgName',
            'label' : 'LBL_DNB_BAL_ORG_NAME'
        },
        'dnb_principal_id': {
            'json_path': 'PrincipalIdentificationNumberDetail.PrincipalIdentificationNumber'
        },
        'title' : {
            'json_path' : 'JobTitle',
            'label' : 'LBL_DNB_CONTACT_JOBTITLE',
            'sub_object': {
                'data_type' : 'job_hist',
                'title' : 'JobTitleText.$',
                'start_date' : 'StartDate.$',
                'end_date' : 'EndDate.$'
            }
        },
        'department' : {
            'json_path' : 'CurrentManagementResponsibility.0.ManagementResponsibilityText.$',
            'label' : 'LBL_DNB_CONTACT_RESP'
        },
        'email' : {
            'json_path' : 'Telecommunication.EmailAddress.0.TelecommunicationAddress',
            'label' : 'LBL_DNB_CONTACT_EMAIL'
        },
        'phone_work' : {
            'json_path' : 'Telecommunication.TelephoneNumber.0.TelecommunicationNumber',
            'label' : 'LBL_DNB_CONTACT_PHONE'
        },
        'first_name': {
            'json_path': 'PrincipalName.FirstName'
        },
        'last_name': {
            'json_path': 'PrincipalName.LastName'
        },
        'salutation': {
            'json_path': 'PrincipalName.NamePrefix.NamePrefixText'
        },
        'emp_bio' : {
            'json_path' : 'EmploymentBiography.EmploymentBiographyText',
            'label' : 'LBL_DNB_CONTACT_BIO'
        },
        'comp_hist' : {
            'json_path' : 'FormerCompensation',
            'sub_object': {
                'data_type' : 'comp_hist',
                'comp_det' : 'CompensationDetail',
                'comp_date' : 'CompensationDate.$',
                'comp_type' : 'CompensationTypeText.$',
                'comp_amt' : 'CompensationAmount.$',
                'comp_curr' : 'CompensationAmount.@CurrencyISOAlpha3Code'
            }
        }
    },

    contactAttr: ['email', 'phone_work', 'dnb_principal_id', 'first_name', 'last_name', 'full_name', 'department', 'title', 'salutation'],

    //dashlet initialize
    initDashlet: function() {
        this.accountsDD = {
            'name': this.compinfoDD.compname,
            'billing_address_street': this.compinfoDD.primaddrstreet,
            'billing_address_city': this.compinfoDD.primaddrcity,
            'billing_address_state': this.compinfoDD.primaddrstateabbr,
            'billing_address_country': this.compinfoDD.primaddrctrycd,
            'billing_address_postalcode': this.compinfoDD.primaddrzip,
            'website': this.compinfoDD.webpage,
            'phone_office': this.compinfoDD.phone,
            'employees': this.compinfoDD.indempcnt,
            'annual_revenue': {
                'json_path': 'Financial.KeyFinancialFiguresOverview.0',
                'sub_object': {
                    'data_type': 'sales_rev',
                    'units': 'SalesRevenueAmount.0.@UnitOfSize',
                    'currency_cd': 'SalesRevenueAmount.0.@CurrencyISOAlpha3Code',
                    'financial_yr': 'StatementHeaderDetails.FinancialStatementToDate.$',
                    'amount': 'SalesRevenueAmount.0.$',
                    'label': 'LBL_DNB_SALES_REVENUE'
                }
            },
            'ownership': this.compinfoDD.cntrowntype,
            'sic_code': {
                'json_path': 'IndustryCode.IndustryCode',
                'sub_object': {
                    'data_type': 'prim_sic',
                    'sic_type_code' : 3599,
                    'ind_code': 'IndustryCode.$',
                    'label': 'LBL_DNB_SIC'
                }
            }
        };
        this.formatTypeMap = {
            'emp_det': this.formatEmployeeDet,
            'ind_codes': this.formatIndCodes,
            'tpa': this.formatTPA,
            'sales_rev': this.formatAnnualSales,
            'prim_sic': this.formatPrimSic,
            'org_id': this.formatOrgId,
            'phone_idc': this.formatPhone
        };
        this.leadsAttr = this.contactAttr.slice();
        this.leadsAttr.push('account_name');
        this.targetAttr = this.leadsAttr.slice();
        this.personTypeAttrList = {
            'Contacts': this.contactAttr,
            'Leads': this.leadsAttr,
            'Prospects': this.targetAttr
        };
    },

    /**
     * Check if a particular json path is valid
     * @param {Object} obj
     * @param {String} path
     * @return {Boolean}
     */
    checkJsonNode: function(obj, path) {
        var args = path.split('.');
        for (var i = 0; i < args.length; i++) {
            if (_.isNull(obj) || _.isUndefined(obj) || !obj.hasOwnProperty(args[i])) {
                return false;
            }
            obj = obj[args[i]];
        }
        return true;
    },

    /**
     * Checks if
     * 1. User has access to the field using the acl api
     * 2. Checks is the user layout has the field
     * @param {String} fieldName
     */
    checkFieldExists: function(fieldName) {
        var checkUserAccess = app.acl.hasAccess('view', this.module, null, fieldName);
        if (checkUserAccess) {
            var viewMeta = App.metadata.getView(this.module, 'record');
            var fieldExists = _.find(_.flatten(_.pluck(viewMeta.panels, 'fields')), function(fieldObj) {
                return fieldObj.name === fieldName;
            });
        } else {
            return false;
        }
        return fieldExists;
    },

    /**
     * Checks and Process the error
     * @param {Object} xhr
     * @param {Object} status
     * @param {Object} error
     */
    checkAndProcessError: function(xhr, status, error) {
        if (this.disposed) {
            return;
        }
        this.dnbError = {};
        var errorCode = xhr.code,
            errorMessage, errorLink;
        if (!_.isUndefined(errorCode)) {
            app.logger.error('D&B API Error:' + errorCode);
            errorMessage = this.commonErrorMap[errorCode];
            if (_.isUndefined(errorMessage)) {
                errorMessage = app.lang.get('LBL_DNB_API_ERR') + ':' + errorCode;
            }
            if (errorCode === 'ERROR_DNB_CONFIG') {
                errorLink = this.commonConst.connectorSettingsURL;
            } else if (errorCode.indexOf('ERROR_CURL_') !== -1) {
                errorLink = this.commonConst.systemSettingsURL;
            }
        } else {
            errorMessage = this.commonErrorMap['ERROR_DNB_UNKNOWN'];
        }
        this.dnbError.errMsg = errorMessage;
        if (!_.isUndefined(errorLink)) {
            this.dnbError.errorLink = errorLink;
        }
        var dashletLabel = this.sidePaneDashlets[this.name];
        //to handle dashlets that occupy the entire sidePane
        if (!_.isUndefined(dashletLabel)) {
            this.template = app.template.get('dnb.dnb-sidepane-error');
            this.dnbError.label = dashletLabel;
        } else {
            this.template = app.template.get('dnb.dnb-error');
        }

        this.renderErrorMessage();
    },

    /**
     * Renders the actual error message that has been set on the error template
     */
    renderErrorMessage: function() {
        this.render();
        this.$('div#error-display').show();
        this.$('.showLessData').hide();
    },

    /**
     * Check if a particular json path is valid and returns value if valid else return nothing
     * @param {Object} obj
     * @param {String} path
     * @return {Array|Object|null}
     */
    getJsonNode: function(obj, path) {
        var args = path.split('.');
        for (var i = 0; i < args.length; i++) {
            if (_.isNull(obj) || _.isUndefined(obj) || !obj.hasOwnProperty(args[i])) {
                return;
            }
            obj = obj[args[i]];
        }
        return obj;
    },

    /**
     * Gets company information for a DUNS number
     * @param {String} duns_num -- duns_num of the company
     * @param {String} prod_code -- DCP_BAS or DCP_STD or DCP_PREM (referring to the 3 types of comp info dashlets)
     * @param {String} backToListLabel -- label to be rendered to redirect to the previous view
     * @param {Function} renderFunction -- a function to be called to render the dnbapiresponse
     */
    baseCompanyInformation: function(duns_num, prod_code, backToListLabel, renderFunction) {
        var self = this;
        var firmoParams = {
            'duns_num': duns_num,
            'prod_code': prod_code
        };
        var cacheKey = 'dnb:' + firmoParams.duns_num + ':' + firmoParams.prod_code,
            resultData;
        var cacheContent = app.cache.get(cacheKey);
        if (cacheContent) {
            resultData = cacheContent;
            if (backToListLabel) {
                resultData.backToListLabel = backToListLabel;
            }
            renderFunction.call(self, resultData);
        } else {
            var dnbProfileUrl = app.api.buildURL('connector/dnb/firmographic', '', {}, {});
            resultData = {'product': null, 'errmsg': null, 'backToListLabel': null};
            app.api.call('create', dnbProfileUrl, {'qdata': firmoParams}, {
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (!_.isUndefined(responseCode) && responseCode === 'CM000') {
                        resultData.product = data;
                        //if primary sic is available set it
                        //TODO: move to js preprocessing
                        // as a part of the handlebars normalization
                        var industryCodeArray = self.getJsonNode(data, self.appendSVCPaths.industry);
                        if (!_.isUndefined(industryCodeArray)) {
                            //399 is the industry code type value for US SIC
                            resultData.product.primarySIC = self.getPrimaryIndustry(industryCodeArray, self.commonConst.sic_code);
                        }
                        app.cache.set(cacheKey, resultData);
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    if (!_.isUndefined(backToListLabel)) {
                        resultData.backToListLabel = backToListLabel;
                    }
                    renderFunction.call(self, resultData);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     * Gets the primary industry code from the array of industry codes
     * @param {Array} industryArray
     * @param {String} industryCode
     * @return {Object}
     */
    getPrimaryIndustry: function(industryArray, industryCode) {
        return _.find(industryArray, function(industryObj) {
            return industryObj['@DNBCodeValue'] === industryCode && industryObj['DisplaySequence'] === 1;
        });
    },

    /**
     * Preprocessing company information / handlebars normalization
     * @param  {Object} firmoResponse -- DNB API Response for Firmographics
     * @param  {Object} dataElementsMap -- Data Elements Map
     * @return {Array}  -- to be passed to the hbs file
     */
    formatCompanyInfo: function(firmoResponse, dataElementsMap) {
        var productDetails = this.getJsonNode(firmoResponse, this.appendSVCPaths.product);
        var formattedDataElements = [];
        if (productDetails) {
            //iterate thru the compinfo map
            _.each(dataElementsMap, function(value, key) {
                //extract the informtaion
                var dnbDataElement = null, dnbDataObj;
                if (key === 'orgid') {
                    //if the key is orgId
                    dnbDataElement = this.getJsonNode(productDetails, value.json_path);
                    var formattedOrgIds = this.formatOrgId(dnbDataElement, value.sub_array);
                    if (!_.isEmpty(formattedOrgIds)) {
                        formattedDataElements = formattedDataElements.concat(formattedOrgIds);
                    }
                } else if (value.sub_array) {
                    //if the data map is array then traverse the nested array
                    dnbDataElement = this.getJsonNode(productDetails, value.json_path);
                    _.each(dnbDataElement, function(dnbSubData) {
                        dnbDataObj = this.formatTypeMap[value.sub_array.data_type].call(this, dnbSubData, value.sub_array);
                        if (!_.isNull(dnbDataObj)) {
                            formattedDataElements.push(dnbDataObj);
                        }
                    }, this);
                } else if (value.sub_object) {
                    dnbDataElement = this.getJsonNode(productDetails, value.json_path);
                    dnbDataObj = this.formatTypeMap[value.sub_object.data_type].call(this, dnbDataElement, value.sub_object);
                    if (!_.isNull(dnbDataObj)) {
                        formattedDataElements.push(dnbDataObj);
                    }
                } else {
                    //else it is a straightforward data element
                    dnbDataElement = this.getJsonNode(productDetails, value.json_path);
                    dnbDataObj = {};
                    //populate a json object
                    if (dnbDataElement) {
                        if (value.case_fmt) {
                            dnbDataElement = this.properCase(dnbDataElement);
                        }
                        dnbDataObj.dataElement = dnbDataElement;
                        dnbDataObj.dataLabel = value.label;
                        dnbDataObj.dataName = key;
                        if (value.type === 'link') {
                            dnbDataObj.dataType = 'link';
                        }
                        //push it into an array
                        formattedDataElements.push(dnbDataObj);
                    }
                }
            }, this);
        }
        return formattedDataElements;
    },

    /**
     * Preprocesses employee details
     * @param {Object} employeeObj D&B Current Principal Object
     * @param {Object} empDD Data Dictionary
     * @return {Object}
     */
    formatEmployeeDet: function(employeeObj, empDD) {
        var dnbDataObj = null;
        var jobTitle = this.getJsonNode(employeeObj, empDD.job_title);
        var empName = this.getJsonNode(employeeObj, empDD.full_name);
        if (empName) {
            dnbDataObj = {};
            dnbDataObj.dataElement = this.properCase(empName);
            if (jobTitle) {
                jobTitle = '<i class="fa fa-user"></i>' + this.properCase(jobTitle);
            } else {
                jobTitle = '<i class="fa fa-user"></i>' + app.lang.get('LBL_DNB_ASSOCIATE');
            }
            dnbDataObj.dnbLabel = jobTitle;
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses third party assesment (tpa)
     * @param {Object} tpaObj D&B Current Principal Object
     * @param {Object} tpaDD from the Data Dictionary
     * @return {Object} with label and dataelement
     */
    formatTPA: function(tpaObj, tpaDD) {
        var dnbDataObj = null;
        var assmt = this.getJsonNode(tpaObj, tpaDD.assmt);
        var assmt_type = this.getJsonNode(tpaObj, tpaDD.assmt_type);
        if (assmt && assmt_type) {
            dnbDataObj = {};
            dnbDataObj.dataElement = this.properCase(assmt);
            dnbDataObj.dnbLabel = this.properCase(assmt_type);
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses industry code to get primary industry code
     * @param {Array} indCdArr industryCode Array
     * @param {Object} indSicDD industryCode data dic
     * @return {Object} with label and dataelement
     */
    formatPrimSic: function(indCdArr, indSicDD) {
        var dnbDataObj = null, primSicCode = null, primSicObj = this.getPrimaryIndustry(indCdArr, indSicDD.sic_type_code);
        if (primSicObj) {
            primSicCode = this.getJsonNode(primSicObj, indSicDD.ind_code);
            if (primSicCode) {
                dnbDataObj = {};
                dnbDataObj.dataElement = primSicCode;
                dnbDataObj.dataLabel = indSicDD.label;
                dnbDataObj.dataName = 'sic_code';
            }
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses employee details
     * @param {Object} indCodeObj D&B Current Principal Object
     * @param {Object} indDD Data Dictionary
     * @return {Object} with label and dataelement
     */
    formatIndCodes: function(indCodeObj, indDD) {
        var dnbDataObj = null;
        var ind_code_type = this.getJsonNode(indCodeObj, indDD.ind_code_type);
        var ind_code_desc = this.getJsonNode(indCodeObj, indDD.ind_code_desc);
        var ind_code = this.getJsonNode(indCodeObj, indDD.ind_code);
        var disp_seq = this.getJsonNode(indCodeObj, indDD.disp_seq);
        var primaryHTML = '<span class="label label-success pull-right" data-placement="right">' + app.lang.get('LBL_DNB_PRIMARY') + '</span>';
        if (ind_code_desc) {
            dnbDataObj = {};
            // ind_code_desc = this.properCase(ind_code_desc);
            if (disp_seq && disp_seq === 1) {
                dnbDataObj.dataElement = ind_code_desc + primaryHTML;
            } else {
                dnbDataObj.dataElement = ind_code_desc;
            }
            dnbDataObj.dnbLabel = ind_code_type + ':' + ind_code;
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses organization identification number
     * @param {Array} orgIdArr
     * @param {Object} orgIdDD Data Dictionary
     * @return {Array}
     */
    formatOrgId: function(orgIdArr, orgIdDD) {
        var uniqueOrgIds = _.uniq(_.pluck(orgIdArr,'OrganizationIdentificationNumber'));
        var uniqueOrgIdObjects = [],
            formattedObjects = [];
        _.each(uniqueOrgIds, function(orgId) {
            uniqueOrgIdObjects.push(_.find(orgIdArr, function(orgIdObj){
                return orgIdObj.OrganizationIdentificationNumber === orgId;
            }));
        });
        _.each(uniqueOrgIdObjects, function(orgIdObj){
            var dnbDataObj = null;
            var org_id_type = this.getJsonNode(orgIdObj, orgIdDD.org_id_type);
            var org_id = this.getJsonNode(orgIdObj, orgIdDD.org_id);
            if (!_.isUndefined(org_id_type) && org_id_type !== 'Unknown'
                && !_.isUndefined(org_id) ) {
                dnbDataObj = {};
                dnbDataObj.dataElement = org_id;
                dnbDataObj.dnbLabel = org_id_type;
                formattedObjects.push(dnbDataObj);
            }
        }, this);
        return formattedObjects;
    },

    /**
     * Preprocessing search results
     * @param {Object} srchResults DNB API Response for search results
     * @param {Object} searchDD Data Elements Map
     * @return {Array} of json objects -- to be passed to the hbs file
     */
    formatSrchRslt: function(srchResults, searchDD) {
        var formattedSrchRslts = [];
        //assigning location type
        _.each(srchResults, function(companyObj) {
            if (companyObj.FamilyTreeMemberRole) {
                //we are relying on DNBCodeValue
                //higher the code value more the precedence in the family tree role
                //hence we are using the _.max function
                var locationType = _.max(companyObj.FamilyTreeMemberRole, function(memberRole) {
                    return memberRole.FamilyTreeMemberRoleText['@DNBCodeValue'];
                });
                //if the location type is parent then we need not display it
                var ftRole = this.getJsonNode(locationType, 'FamilyTreeMemberRoleText.$');
                if (!_.isUndefined(ftRole) && ftRole !== 'Parent') {
                    companyObj.locationtype = ftRole;
                }
            }
        }, this);
        //iterate thru the search results, extract the necessary info
        //populate a js object
        //push it through an array
        _.each(srchResults, function(searchResultObj) {
            var frmtSrchRsltObj = {};
            _.each(searchDD, function(value, key) {
                var dataElement = this.getJsonNode(searchResultObj, value.json_path);
                if (value.sub_object) {
                    var dnbDataObj = this.formatTypeMap[value.sub_object.data_type].call(this, dataElement, value.sub_object);
                    if (!_.isNull(dnbDataObj)) {
                        frmtSrchRsltObj[key] = dnbDataObj;
                    }
                } else {
                    if (dataElement) {
                        if (value.case_fmt) {
                            dataElement = this.properCase(dataElement);
                        }
                        frmtSrchRsltObj[key] = dataElement;
                    }
                }
            }, this);
            formattedSrchRslts.push(frmtSrchRsltObj);
        }, this);
        return formattedSrchRslts;
    },

    /**
     * Preprocesses employee details
     * @param {Object} annsalesObj D&B Current Principal Object
     * @param {Object} annsalesDD Data Dictionary
     * @return {Object} with label and dataelement
     */
    formatAnnualSales: function(annsalesObj, annsalesDD) {
        var dnbDataObj = null;
        var amount = this.getJsonNode(annsalesObj, annsalesDD.amount);
        var units = this.getJsonNode(annsalesObj, annsalesDD.units);
        var currency_cd = this.getJsonNode(annsalesObj, annsalesDD.currency_cd);
        var financial_yr = this.getJsonNode(annsalesObj, annsalesDD.financial_yr);
        if (amount) {
            dnbDataObj = {};
            var finYrHTML = null, unitsStr = null, dnbLabel;
            if (financial_yr) {
                finYrHTML = '<span class="label label-success pull-right" data-placement="right">' + financial_yr + '</span>';
            }
            if (units && currency_cd) {
                unitsStr = '(' + app.lang.get('LBL_DNB_IN') + ' ' + units + ' ' + currency_cd + ')';
            }
            dnbDataObj.dataElement = this.formatSalesRevenue(amount);
            dnbLabel = app.lang.get(annsalesDD.label);
            if (unitsStr) {
                dnbLabel = dnbLabel + unitsStr;
            }
            if (finYrHTML) {
                dnbLabel = dnbLabel + finYrHTML;
            }
            dnbDataObj.dnbLabel = dnbLabel;
            dnbDataObj.dataName = 'annual_revenue';
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses search result
     * @param {Object} phoneObj D&B Current Principal Object
     * @param {Object} phoneDD Data Dictionary
     * @return {Object} with label and dataelement
     */
    formatPhone: function(phoneObj, phoneDD) {
        var dnbDataObj = null;
        var phoneNo = this.getJsonNode(phoneObj, phoneDD.phone_no);
        var idCode = this.getJsonNode(phoneObj, phoneDD.id_code);
        if (phoneNo) {
            dnbDataObj = {};
            dnbDataObj.dataElement = this.appendIDCPhone(phoneNo, idCode);
            dnbDataObj.dataName = phoneDD.data_name;
            dnbDataObj.dnbLabel = app.lang.get(phoneDD.label);
        }
        return dnbDataObj;
    },

    /**
     * Preprocesses search result
     * @param {Number} phoneNo Phone Number
     * @param {Number} idCode International Dailing Code
     * @return {String} phone Number with international dailing code
     */
    appendIDCPhone: function (phoneNo, idCode) {
        var retVal;
        if(idCode) {
            retVal = '+' + idCode + phoneNo.replace(/^0+/, '');
        } else {
            retVal = phoneNo;
        }
        return retVal;
    },

    /**
     * Renders the dnb company details for adding companies from dashlets
     * @param {Object} companyDetails dnb api response for company details
     */
    renderCompanyDetails: function(companyDetails) {
        if (this.disposed) {
            return;
        }
        var formattedFirmographics, dnbFirmo = {};
        //if there are no company details hide the import button
        if (companyDetails.errmsg) {
            if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
                this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().hide();
            }
        } else if (companyDetails.product) {
            if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
                this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().show();
            }
            if (companyDetails.product) {
                formattedFirmographics = this.formatCompanyInfo(companyDetails.product, this.accountsDD);
                dnbFirmo.product = formattedFirmographics;
                dnbFirmo.backToListLabel = companyDetails.backToListLabel;
            } else if (companyDetails.errmsg) {
                dnbFirmo.errmsg = companyDetails.errmsg;
            }
            this.currentCompany = companyDetails.product;
        }
        this.dnbFirmo = dnbFirmo;
        this.render();
        this.$('div#dnb-company-detail-loading').hide();
        this.$('div#dnb-company-details').show();
    },

    /**
     * Renders the dnb company information for Lite, Standard and Premium dashlets
     * @param {Object} companyDetails dnb api response for company details
     */
    renderCompanyInformation: function(companyDetails) {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get('dnb.dnb-comp-info');
        var formattedFirmographics, dnbFirmo = {};
        if (companyDetails.product) {
            formattedFirmographics = this.formatCompanyInfo(companyDetails.product, this.filteredDD);
            dnbFirmo.product = formattedFirmographics;
        } else if (companyDetails.errmsg) {
            dnbFirmo.errmsg = companyDetails.errmsg;
        }
        this.dnbFirmo = dnbFirmo;
        this.render();
        this.$('div#dnb-compinfo-loading').hide();
        this.$('div#dnb-compinfo-details').show();
        this.$('.showLessData').hide();
    },

    /**
     * Import D&B Accounts Data
     */
    importDNBData: function() {
        var accountsModel = this.getAccountsModel(this.currentCompany);
        if (!_.isUndefined(accountsModel)) {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: 'Accounts',
                    model: accountsModel
                }
            }, function(accountsModel) {
                if (!accountsModel) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                self.context.loadData();
            });
        }
    },

    /**
     * Creates and returns an Account bean
     * @param  {Object} companyApiResponse -- obj -- dnb api response for company information
     * @return {Object}
     */
    getAccountsModel: function(companyApiResponse) {
        var organizationDetails = this.getJsonNode(companyApiResponse, this.appendSVCPaths.product);
        var accountsModel = null;
        var idcode = this.getJsonNode(organizationDetails, this.appendSVCPaths.idc);
        if (!_.isUndefined(organizationDetails)) {
            var accountsBean = {};
            if (companyApiResponse.primarySIC) {
                organizationDetails.primarySIC = companyApiResponse.primarySIC;
            }
            _.each(this.accountsMap, function(dataElementPath, sugarColumnName) {
                var dnbDataElement = this.getJsonNode(organizationDetails, dataElementPath);
                if (dnbDataElement) {
                    if (sugarColumnName === 'annual_revenue') {
                        dnbDataElement = this.formatSalesRevenue(dnbDataElement);
                    } else if (sugarColumnName === 'phone_office') {
                        dnbDataElement = this.appendIDCPhone(dnbDataElement, idcode)
                    }
                    accountsBean[sugarColumnName] = dnbDataElement;
                }
            }, this);
            accountsModel = app.data.createBean('Accounts', accountsBean);
        }
        return accountsModel;
    },

    /**
     * Collapses the dashlet
     */
    collapseDashlet: function() {
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
    },

    /**
     * Expands the dashlets to reveal more data
     */
    showMoreData: function() {
        this.$('.dnb-show-less').attr('class', 'dnb-show-all');
        this.$('.showLessData').show();
        this.$('.showMoreData').hide();
    },

    /**
     * Truncates the dashlets
     */
    showLessData: function() {
        this.$('.dnb-show-all').attr('class', 'dnb-show-less');
        this.$('.showLessData').hide();
        this.$('.showMoreData').show();
    },

    /**
     * Formats the sales revenue amount
     * @param  {String} amount sales revenue
     * @return {String} formatted string
     */
    formatSalesRevenue: function(amount) {
        if (_.isNumber(amount)) {
            amount = amount.toFixed(0).replace(/(\d)(?=(\d{3})+\b)/g, '$1,');
        }
        return amount;
    },

    /**
     * Formats the string to proper case
     * @param {String}  strParam string to convert
     * @return {String}  properCase String
     */
    properCase: function(strParam) {
        // The following is provided for your convenience should you wish to learn more about
        // Convert string to title case with javascript.
        // For a list of the actual third party software used in this Sugar product,
        // please visit http://support.sugarcrm.com/06_Customer_Center/11_Third_Party_Software/.
        //
        // http://stackoverflow.com/a/196991/226906
        return strParam.replace(/\w\S*/g, function(txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    },

    /**
     * Imports data from dashlet to the sugar crm accounts
     * @param {Boolean} importFlag (When set to true indicates warning message must not be displayed for the first data import
     *                 This requirement was suggested by Wes in the Account creation screen
     *                 Where a user searches for a company name using a keyword
     *                 So when the user imports data for the first time
     *                 It is pretty obvious that he wants to override the keyword with the newly imported data
     *                 setting the flag to false prevents the warning message from being displayed
     *                )
     */
    importAccountsData: function(importFlag) {
        var setModelFlag = true;
        if (_.isUndefined(importFlag)) {
            importFlag = true;
            setModelFlag = false;
        } else if (_.isObject(importFlag)) {
            setModelFlag = false;
        }
        var dnbCheckBox = this.$('.dnb_checkbox:checked');
        var accountsModel = this.model;
        // iterate through checkboxes
        // values being overriden stored in updatedData
        // values that are newly being set store in newData
        var updatedData = [], newData = [], dnbPropertyName = null, dnbPropertyValue = null, dnbPropertySelector = null;
        _.each(dnbCheckBox, function(dataElement) {
            dnbPropertyName = dataElement.id;
            if (dnbPropertyName) {
                //we are cloning the selected property value
                //so that we can remove the nested html elements and retain the text alone
                dnbPropertySelector = this.$('#' + dnbPropertyName). parent().siblings('.importData').clone();
                dnbPropertyValue = $.trim(dnbPropertySelector.children().remove().end().text());
                if (!_.isUndefined(accountsModel.get(dnbPropertyName)) && accountsModel.get(dnbPropertyName) !== '' && importFlag) {
                    updatedData.push({propName: dnbPropertyName, propVal: dnbPropertyValue});
                } else if (dnbPropertyValue !== '') {
                    newData.push({propName: dnbPropertyName, propVal: dnbPropertyValue});
                }
            }
        }, this);

        // Import new data, but only if updated data is empty, otherwise the
        // next conditional block will handle it
        if (newData.length > 0) {
            this.updateAccountsModel(newData, setModelFlag);
        }

        // Update the model based on changes, making sure to not save the model
        if (updatedData.length > 0) {
            var confirmationMsgKey;
            var confirmationMsgData;

            // Import flag is true when we've already set the model based on an
            // import selection. If it comes in again as false, the model will
            // save when updated, which will save a new record in the database
            // without a save event being fired. This fixes that.
            var setModelOnlyFlag = importFlag === true;

            //show a detailed warning message about the single data element being imported
            if (updatedData.length === 1) {
                var fieldName = app.lang.get(accountsModel.fields[updatedData[0].propName].vname, 'Accounts');
                confirmationMsgKey = 'LBL_DNB_DATA_OVERRIDE_SINGLE_FIELD';
                confirmationMsgData = {
                    fieldName: fieldName.toLowerCase(),
                    value: updatedData[0].propVal
                };
            } else {
                var fieldList = [
                    app.lang.get(accountsModel.fields[updatedData[0].propName].vname, 'Accounts').toLowerCase(), app.lang.get(accountsModel.fields[updatedData[1].propName].vname, 'Accounts').toLowerCase()
                ];
                if (updatedData.length === 2) {
                    //list the two fields being imported
                    confirmationMsgKey = 'LBL_DNB_DATA_OVERRIDE_TWO_FIELDS';
                    confirmationMsgData = {
                        fields: fieldList.join(' ' + app.lang.get('LBL_DNB_AND') + ' ')
                    };
                } else {
                    //list the two first fields and append ` and other(s) field(s)`
                    confirmationMsgKey = 'LBL_DNB_DATA_OVERRIDE_MULTIPLE_FIELDS';
                    confirmationMsgData = {
                        fields: fieldList.join(', ')
                    };
                }
            }
            var confirmationMsgTpl = Handlebars.compile(app.lang.get(confirmationMsgKey));
            app.alert.show('dnb-import-warning', {
                level: 'confirmation',
                title: 'LBL_WARNING',
                messages: confirmationMsgTpl(confirmationMsgData),
                onConfirm: _.bind(this.updateAccountsModel, this, updatedData, setModelOnlyFlag)
            });
        }
    },

    /**
     * Updates the Accounts backbone model with new data
     * @param {Object} updatedData
     * @param {Boolean} setFlag -- true -- just set the updated parameters to the model
     *                    -- false -- save the updated parameters to the model
     */
    updateAccountsModel: function(updatedData, setFlag) {
        var changedAttributes = {};
        // always import the duns_num
        this.model.set('duns_num', this.duns_num);
        if (setFlag) {
            _.each(updatedData, function(updatedAttribute) {
                this.model.set(updatedAttribute.propName, updatedAttribute.propVal);
            }, this);
            app.alert.show('dnb-import-success', { level: 'success',
                title: app.lang.get('LBL_SUCCESS') + ':',
                messages: app.lang.get('LBL_DNB_OVERRIDE_SUCCESS'),
                autoClose: true});
        } else {
            _.each(updatedData, function(updatedAttribute) {
                changedAttributes[updatedAttribute.propName] = updatedAttribute.propVal;
            });
            this.model.save(changedAttributes, {success: function() {
                app.alert.show('dnb-import-success', { level: 'success',
                    title: app.lang.get('LBL_SUCCESS') + ':',
                    messages: app.lang.get('LBL_DNB_OVERRIDE_SUCCESS'),
                    autoClose: true});
            }});
            this.context.loadData();
        }
    },

    /**
     * Filters the data elements for the company information
     */
    baseFilterData: function() {
        this.filteredDD = {};
        _.each(this.compinfoDD, function(value, key) {
            var settingsFlag = this.settings.get(key);
            //if the settings flag is defined and is selected then
            //add that property to the filtered data dictionary
            if (!_.isUndefined(settingsFlag) && settingsFlag === true) {
                this.filteredDD[key] = value;
            } else if (_.isUndefined(settingsFlag)) {
                //if the settings flag is not defined
                //select it by default
                this.filteredDD[key] = value;
                this.settings.set(key, true);
            }
        }, this);
    },

    /**
     * Checks the Sugar data base for duplicate duns or contacts
     * @param {Object} dupeCheckParams
     * @param {Function} callBack
     * dupeCheckParams must have the following keys
     * 1.type Possible values are duns,contacts
     * 2.apiResponse
     * 3.module Possible values are findcompany, competitors, cleansematch, familytree, contacts, dunsPage, contactsPage
     */
    baseDuplicateCheck: function(dupeCheckParams, callBack) {
        var dupeCheckURL = app.api.buildURL('connector/dnb/dupecheck', '', {}, {});
        var self = this;
        app.api.call('create', dupeCheckURL, {'qdata': dupeCheckParams}, {
            success: function(data) {
                callBack.call(self, {'product': data});
            },
            error: _.bind(self.checkAndProcessError, self)
        });
    },

    /**
     * Build a list of accounts
     * @param {Object} balParams
     * @param {Function} callBack (function used to render api response)
     */
    baseAccountsBAL: function(balParams, callBack) {
        var balRslt = {'product': null, 'errmsg': null};
        var dnbBalURL = app.api.buildURL('connector/dnb/Accounts/bal', '', {}, {});
        var self = this;
        app.api.call('create', dnbBalURL, {'qdata': balParams}, {
            success: function(data) {
                var responseCode = self.getJsonNode(data, self.commonJSONPaths.srchRespCode),
                    responseMsg = self.getJsonNode(data, self.commonJSONPaths.srchRespMsg);
                if (responseCode && responseCode === self.responseCodes.success) {
                    balRslt.product = data;
                } else {
                    balRslt.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                }
                callBack.call(self, balRslt);
            },
            error: _.bind(self.checkAndProcessError, self)
        });
    },

    /**
     * Toggles the visibility of the import button in the dashlet
     * @param {String} btnName
     * @param {Boolean} isVisible
     */
    toggleImportBtn: function(btnName, isVisible) {
        if (this.layout.getComponent('dashlet-toolbar').getField(btnName)) {
            if (isVisible) {
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().show();
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().removeClass('hide');
            } else {
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().hide();
            }
        }
    },

    /**
     * Toggles enabled / disabled state of the button on the dashlet toolbar
     * @param {Boolean} isEnabled
     * @param {String} btnName
     */
    toggleDashletBtn: function(isEnabled, btnName) {
        if (this.layout.getComponent('dashlet-toolbar').getField(btnName)) {
            if (isEnabled) {
                this.layout.getComponent('dashlet-toolbar').getField(btnName).setDisabled(false);
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().removeClass('disabled');
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().removeClass('hide');
            } else {
                this.layout.getComponent('dashlet-toolbar').getField(btnName).setDisabled(true);
                this.layout.getComponent('dashlet-toolbar').getField(btnName).getFieldElement().addClass('disabled');
            }
        }
    },

    /**
     * Build a list of contacts
     * @param {Object} balParams
     * @param {Function} renderFunction
     */
    baseContactsBAL: function(balParams, renderFunction) {
        var self = this,
            balRslt = {'product': null, 'errmsg': null},
            dnbBalURL = app.api.buildURL('connector/dnb/Contacts/bal', '', {}, {});
        app.api.call('create', dnbBalURL, {'qdata': balParams}, {
            success: function(data) {
                var responseCode = self.getJsonNode(data, self.contactConst.responseCode),
                    responseMsg = self.getJsonNode(data, self.contactConst.responseMsg);
                if (responseCode && responseCode === self.responseCodes.success) {
                    balRslt.product = data;
                } else {
                    balRslt.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                }
                renderFunction.call(self, balRslt);
            },
            error: _.bind(self.checkAndProcessError, self)
        });
    },

    /**
     * Preprocessing contacts list
     * @param {Array} dnbApiResponse DNB API Response for Contacts
     * @param {Object} contactsListDD Contacts data dictionary
     * @return {Array} frmtCntctList formatted contacts
     */
    formatContactList: function(dnbApiResponse, contactsListDD) {
        var frmtCntctList = [];
        _.each(dnbApiResponse, function(contactObj) {
            //initialize empty formatted obj
            var frmCntctObj = {};
            //iterate through data dictionary and extract info
            _.each(contactsListDD, function(value, key) {
                var dataElement = this.getJsonNode(contactObj, value.json_path);
                if (dataElement) {
                    frmCntctObj[key] = dataElement;
                }
            },this);
            //only if the contact has a name and a principal id will we display it
            if (frmCntctObj.principalId && frmCntctObj.fullName) {
                if (frmCntctObj.emailInd || frmCntctObj.phoneInd) {
                    frmCntctObj.contactType = this.contactConst.premCntct;
                } else {
                    frmCntctObj.contactType = this.contactConst.stdCntct;
                }
                frmtCntctList.push(frmCntctObj);
            }
        },this);
        return frmtCntctList;
    },

    /**
     * Gets contact details for a duns and principal identification number combination
     * @param {Object} evt
     */
    baseGetContactDetails: function(evt) {
        if (this.disposed) {
            return;
        }
        var contact_id = evt.target.id;
        var duns_num = this.$(evt.target).data('duns');
        var contact_name = evt.target.text, contact_type;
        if (this.$(evt.target).hasClass(this.contactConst.premCntct)) {
            contact_type = this.contactConst.premCntct;
        } else if (this.$(evt.target).hasClass(this.contactConst.stdCntct)) {
            contact_type = this.contactConst.stdCntct;
        }
        if (this.name === 'dnb-bal-results') {
            this.template = app.template.get(this.name + '.dnb-bal-contact-details');
        } else if (this.name === 'dnb-contact-info') {
            this.template = app.template.get(this.name + '.dnb-contact-details');
        }
        this.cntctLoadMsg = {'contactName' : contact_name};
        this.render();
        this.$('div#dnb-contact-details-loading').show();
        this.$('div#dnb-contact-details').hide();
        //hiding the import buttons
        if (this.name === 'dnb-bal-results') {
            this.$('.importContacts').hide();
        } else if (this.name === 'dnb-contact-info') {
            this.toggleImportBtn('import_dnb_data', false);
        }
        var contactParams = {
            'duns_num' : duns_num,
            'contact_id' : contact_id,
            'contact_type' : contact_type
        };
        //check if cache has this data already
        var cacheKey = 'dnb:' + contactParams.contact_type + ':'
            + contactParams.duns_num + ':' + contactParams.contact_id;
        var cacheContent = app.cache.get(cacheKey);
        if (cacheContent) {
            this.currentContact = cacheContent.contactDetail;
            this.renderContactDetails(cacheContent);
        } else {
            var dnbContactDetailsURL = app.api.buildURL('connector/dnb/contacts', '', {},{}),
                resultData = {'contactDetail': null, 'errmsg' : null},
                self = this;
            //maintaining dashlet state
            this.currentContact = null;
            if (!_.isUndefined(this.dashletState)) {
                this.dashletState.view = 'detail';
                this.dashletState.content = cacheKey;
                this.dashletState.params = null;
            }
            app.api.call('create', dnbContactDetailsURL, {'qdata': contactParams},{
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        var contactDetail = self.getJsonNode(data, self.contactConst.contactsDetailPath);
                        if (contactDetail) {
                            var orgName = self.getJsonNode(data, self.contactConst.orgName);
                            if (orgName) {
                                contactDetail.orgName = orgName;
                            }
                            resultData.contactDetail = contactDetail;
                            self.currentContact = resultData.contactDetail;
                            app.cache.set(cacheKey, resultData);
                        } else {
                            resultData.errmsg = app.lang.get('LBL_DNB_NO_DATA');
                        }
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderContactDetails(resultData);
                },
                error: _.bind(this.checkAndProcessError, self)
            });
        }
    },

    /**
     * Renders the contact details
     * @param {Object} dnbApiResponse dnb api response for contactDetails
     */
    renderContactDetails: function(dnbApiResponse) {
        if (this.disposed) {
            return;
        }
        if (this.name === 'dnb-bal-results') {
            this.template = app.template.get(this.name + '.dnb-bal-contact-details');
        } else if (this.name === 'dnb-contact-info') {
            this.template = app.template.get(this.name + '.dnb-contact-details');
        }
        var frmtCntctDet, dnbCntctDet = {};
        if (dnbApiResponse.contactDetail) {
            frmtCntctDet = this.formatContactDetails(dnbApiResponse.contactDetail, this.contactsDetailDD);
            if (frmtCntctDet) {
                dnbCntctDet.product = frmtCntctDet;
                //passing the list of import_enabled_modules for bal contact details
                if (!_.isUndefined(this.import_enabled_modules)) {
                    dnbCntctDet.product.import_enabled_modules = this.import_enabled_modules;
                }
            } else {
                dnbCntctDet.errmsg = app.lang.get('LBL_DNB_NO_DATA');
            }
        } else if (dnbApiResponse.errmsg) {
            dnbCntctDet.errmsg = dnbApiResponse.errmsg;
        }
        this.dnbCntctDet = dnbCntctDet;
        this.render();
        //if there are no contact details hide the import button
        if (dnbCntctDet.errmsg) {
            if (this.name === 'dnb-bal-results') {
                this.$('.importContacts').hide();
            }
        } else if (dnbCntctDet.product) {
            if (this.name === 'dnb-bal-results') {
                this.$('.importContacts').show();
            } else if (this.name === 'dnb-contact-info') {
                if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
                    this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().removeClass('hide');
                    this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().show();
                }
            }
            this.currentContact = dnbCntctDet.product;
        }
        this.$('div#dnb-contact-details-loading').hide();
        this.$('div#dnb-contact-details').show();
    },

    /**
     * Preprocessing contact details
     * @param  {Object} contactDetail DNB API Response for contact details
     * @param  {Object} contactsDetailDD Contact Details Data Dictionary
     * @return {Object} frmtCntctDet Format Contact Details Array
     */
    formatContactDetails: function(contactDetail, contactsDetailDD) {
        var frmtCntctDet = {};
        frmtCntctDet.contact_profile = [];
        _.each(contactsDetailDD, function(value, key) {
            var dataElement = this.getJsonNode(contactDetail, value.json_path);
            if (dataElement) {
                if (key === 'title') {
                    var frmtJobTitles = this.formatJobTitles(dataElement, value.sub_object);
                    if (frmtJobTitles && frmtJobTitles.length > 0) {
                        //first job title is the current job title
                        frmtCntctDet[key] = frmtJobTitles[0].title;
                        frmtCntctDet.contact_profile.push({
                            'dataLabel': value.label,
                            'dataElement': frmtJobTitles[0].title
                        });
                        //the rest are used to display job history
                        if (frmtJobTitles.length > 1) {
                            frmtJobTitles.splice(0, 1);
                            frmtCntctDet[value.sub_object.data_type] = frmtJobTitles;
                        }
                    }
                } else if (key === 'comp_hist') {
                    var frmtCompHist = this.formatCompHist(dataElement, value.sub_object);
                    if (frmtCompHist && frmtCompHist.length > 0) {
                        frmtCntctDet[value.sub_object.data_type] = frmtCompHist;
                    }
                } else {
                    //this takes care of formatting general employee information
                    var maskedDataElement, dataObj = {};
                    if (key === 'email') {
                        maskedDataElement = this.emailMask(dataElement);
                    } else if (key === 'phone_work') {
                        maskedDataElement = this.phoneMask(dataElement);
                    }
                    dataObj.dataLabel = value.label;
                    if (!_.isUndefined(maskedDataElement)) {
                        dataObj.dataElement = maskedDataElement;
                    } else {
                        dataObj.dataElement = dataElement;
                    }
                    //this array is for making the hbs readable
                    frmtCntctDet.contact_profile.push(dataObj);
                    //this property is for importing the contact
                    frmtCntctDet[key] = dataElement;
                }
            }
        },this);
        return frmtCntctDet;
    },

    /**
     * Preprocessing job titles
     * @param {Array} jobTitles job titles
     * @param {Object} jobTitleDD job titles data dictionary
     * @return {Array} formatted job titles
     */
    formatJobTitles: function(jobTitles, jobTitleDD) {
        var jobTitleArray = [];
        _.each(jobTitles, function(jobObj) {
            var jobTitleObj = {
                title: this.getJsonNode(jobObj, jobTitleDD.title),
                start_date: this.getJsonNode(jobObj, jobTitleDD.start_date),
                end_date: this.getJsonNode(jobObj, jobTitleDD.end_date)
            };
            if (jobTitleObj.title) {
                jobTitleArray.push(jobTitleObj);
            }
        },this);
        return jobTitleArray;
    },

    /**
     * Preprocessing compensation history
     * @param {Array} compHist compensation history
     * @param {Object} compHistDD compensation history data dictionary
     * @return {Array} frmtCompHist formatted compensation history
     */
    formatCompHist: function(compHist, compHistDD) {
        var frmtCompHist = [];
        _.each(compHist, function(compHistObj) {
            var compDate = this.getJsonNode(compHistObj, compHistDD.comp_date),
                compDet = this.getJsonNode(compHistObj, compHistDD.comp_det),
                frmtCompHistObj = {};
            var frmtCompDet = [];
            _.each(compDet, function(compDetObj) {
                var frmtCompDetObj = {
                    'comp_type' : this.getJsonNode(compDetObj, compHistDD.comp_type),
                    'comp_amt' : this.getJsonNode(compDetObj, compHistDD.comp_amt),
                    'comp_curr' : this.getJsonNode(compDetObj, compHistDD.comp_curr)
                };
                if (frmtCompDetObj.comp_amt) {
                    frmtCompDetObj.comp_amt = this.formatSalesRevenue(frmtCompDetObj.comp_amt);
                    frmtCompDet.push(frmtCompDetObj);
                }
            },this);
            if (frmtCompDet.length > 0 && compDate) {
                frmtCompHistObj.comp_date = compDate;
                frmtCompHistObj.comp_det = frmtCompDet;
                frmtCompHist.push(frmtCompHistObj);
            }
        },this);
        return frmtCompHist;
    },

    /**
     * Masks the email address
     * @param  {String} email
     * @return {String} masked email
     */
    emailMask: function(email) {
        var match = email.match(/([A-Za-z]{2})(.*)(@)(.*)/);
        return match[1] + match[2].replace(/./g, 'x') + match[3] + match[4];
    },

    /**
     * Masks the email address
     * @param  {String} phone
     * @return {String} masked phone
     */
    phoneMask: function(phone) {
        var match = phone.match(/([0-9]{2})(.*)([0-9]{2})/);
        return match[1] + match[2].replace(/./g, 'x') + match[3];
    },

    /**
     * Imports the current contact information
     * @param {String} moduleName Possible values for module are Contact / LinkedContacts / Leads / Prospects
     * LinkedContacts is used to import a contact that is imported from a contacts dashlet that is linked
     * to a sugar account
     */
    baseImportContact: function(moduleName) {
        var model = this.getModuleModel(this.currentContact, moduleName);
        var self = this;
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, function(model) {
            if (!model) {
                return;
            }
            self.context.resetLoadFlag();
            self.context.set('skipFetch', false);
            self.context.loadData();
            _.each(app.controller.context.children, function(childContext) {
                if (childContext.get('module') === 'Contacts') {
                    childContext.reloadData({recursive: false});
                }
            });
        });
    },

    /**
     * Creates and returns a Module bean
     * @param {Object} modelBean
     * @param {String} moduleName possible values could be Contacts/LinkedContacts/Leads/Prospects
     * @return {Object} moduleModel
     */
    getModuleModel: function(modelBean, moduleName) {
        var module, moduleModel;
        if (moduleName === 'LinkedContacts') {
            module = 'Contacts';
        } else {
            module = moduleName;
        }
        var filteredModelBean = _.pick(modelBean, this.personTypeAttrList[module]);
        if (filteredModelBean.email) {
            var emailObj = {
                email_address: filteredModelBean.email,
                opt_out: false,
                primary_address: true,
                reply_to_address: false
            };
            filteredModelBean.email = [emailObj];
        }
        //adding properties specific to leads alone
        if (module === 'Leads') {
            filteredModelBean.lead_source = app.lang.get('LBL_DNB_OTHER');
            filteredModelBean.lead_source_description = app.lang.get('LBL_DNB_BAL');
        }
        //handling the scenario where we need to add a contact associated with an account
        if (moduleName === 'LinkedContacts') {
            filteredModelBean.account_id = this.model.get('id');
            filteredModelBean.account_name = this.model.get('name');
            moduleModel = app.data.createRelatedBean(this.model, null, 'contacts', filteredModelBean);
        } else {
            moduleModel = app.data.createBean(module, filteredModelBean);
        }
        return moduleModel;
    },

    /**
     * Gets the next set of records from the recordSet
     * @param {Array} recordSet
     * @param {Number} pageStart
     * @param {Number} pageEnd
     * @return {Array} recordSet
     */
    getNextPage: function(recordSet, pageStart, pageEnd) {
        return _.filter(recordSet, function(resultObj) {
            return resultObj.recordNum >= pageStart && resultObj.recordNum <= pageEnd;
        });
    },

    /**
     * TODO: refactor this to remove the logic
     * Render pagination control
     * @param {String} componentName (Optional)
     */
    renderPaginationControl: function() {
        //it more records exist in api display pagination controls
        if (this.recordCount > this.endRecord) {
            //display pagination controls
            this.$('#dnb-page-ctrl').toggleClass('hide', false);
            this.$('[data-action="show-more"]').removeClass('hide');
            this.$('.loading').hide();
        } else {
            //hide pagination controls
            this.$('#dnb-page-ctrl').toggleClass('hide', true);
        }
    },

    /**
     * Display pagination loading message
     */
    displayPaginationLoading: function() {
        this.$('[data-action="show-more"]').addClass('hide');
        this.$('.loading').show();
    },

    /**
     * Sets pagination offset and page numbers
     */
    setPaginationParams: function() {
        this.pageNo = this.pageNo + 1;
        this.endRecord = this.pageNo * this.pageSize;
        this.startRecord = (this.endRecord - this.pageSize) + 1;
    },

    /**
     * Gets the next set of records from the context
     * Else invoke the
     */
    paginateRecords: function() {
        return this.getNextPage(this.formattedRecordSet, this.startRecord, this.endRecord);
    },

    /**
     * Initialize pagination parameters
     * @param {Number} pageSize
     */
    initPaginationParams: function(pageSize) {
        //# of records to be displayed in the dashlet
        this.pageSize = !_.isUndefined(pageSize) ? pageSize : 10;
        //initial page no.
        this.pageNo = 1;
        //max # of records D&B API to return
        //default to 10 times page size
        this.apiPageSize = 2 * this.pageSize;
        this.apiPageOffset = 1;
        this.startRecord = 1;
        this.endRecord = this.pageSize;
        //sets the record no for the last record from the api
        //this will be used to determine if we can fetch the next set of records
        // from the context or do we need to invoke the api
        this.apiPageEndRecord = (this.apiPageOffset + this.apiPageSize) - 1;
        //setting the current set of formatted records to the context
        //this is to be used for:
        //1. concatenating the next page
        //2. dupe check for back to list
        this.currentPage = null;
        //this flag is used to determine whether pagination params must be reset
        //this would be set to false when we invoke the API pagination
        //this would help us preserve the pagination params across API calls
        this.resetPaginationFlag = true;
    },

    /**
     * Sets pagination params to existing params
     * @param {Object} apiParams
     * @return {Object}
     */
    setApiPaginationParams: function(apiParams) {
        apiParams.CandidatePerPageMaximumQuantity = this.apiPageSize;
        apiParams.CandidateDisplayStartSequenceNumber = this.apiPageOffset;
        return apiParams;
    },

    /**
     * Loads the D&B Dashlets with appropriate data
     * @param {String} modelAttribute
     * @param {String} contextAttribute
     * @param {Function} callBackFunction
     * @param {String} callBackParams
     * @param {String} errorTemplate
     */
    loadDNBData: function(modelAttribute, contextAttribute, callBackFunction, callBackParams, errorTemplate, fieldAclTemplate) {
        if (this.checkFieldExists(modelAttribute)) {
            var field,
            modelAttr = this[modelAttribute],
            contextAttr;
            //get the attribute set in the context
            if (!_.isNull(contextAttribute)) {
                contextAttr = app.controller.context.get(contextAttribute);
            }
            if (!_.isUndefined(modelAttr) && !_.isNull(modelAttr)) {
                field = modelAttr;
            } else if (!_.isUndefined(contextAttr)) {
                field = contextAttr;
            }
            if (!_.isUndefined(field) && !_.isNull(field)) {
                if(!_.isNull(callBackParams)) {
                    callBackFunction.call(this, field, callBackParams);
                } else {
                    callBackFunction.call(this, field);
                }
            } else {
                this.template = app.template.get(errorTemplate);
                if (!this.disposed) {
                    this.render();
                }
            }
        } else {
            this.template = app.template.get(fieldAclTemplate);
            if (!this.disposed) {
                this.render();
            }
        }
    },

    /**
     * Event handler for pagination controls
     * Renders next page from context if available
     * else invokes the D&B API to get the next page
     * @param {Function} paginationCallBack
     * @param {Object} apiParams Parameters for api call
     * @param {Function} callBack
     */
    invokePagination: function(paginationCallBack, apiParams, callBack) {
        this.displayPaginationLoading();
        this.setPaginationParams();
        //if the endRecord after pagination is greater than apiPageEndRecord
        //we have to invoke the api with the pagination controls
        if (this.endRecord > this.apiPageEndRecord && !_.isNull(paginationCallBack)) {
            this.apiPageEndRecord = (this.startRecord + this.apiPageSize) - 1;
            this.resetPaginationFlag = false;
            //setting the apiPageOffset
            this.apiPageOffset = this.startRecord;
            paginationCallBack.call(this, this.setApiPaginationParams(apiParams), callBack);
        } else {
            var pageData = {
                'product':  this.paginateRecords(),
                'count': this.recordCount
            };
            this.renderPage(pageData, true);
        }
    },

    /**
     * Renders the currentPage
     * @param {Object} pageData
     * @param {Boolean} append boolean to indicate if records need to be appended to exsiting list
     */
    renderPage: function(pageData, append) {
        if (_.isUndefined(append) || !append) {
            if (this.disposed) {
                return;
            }
            this.template = this.resultTemplate;
            this.listData = pageData;
            //pageData count is not defined when the page is being rendered after
            //dupe check
            //hence using the count from the context variable
            if (_.isUndefined(pageData.count)) {
                pageData.count = this.recordCount;
            }
            //if the api returns a success response then only set the count
            if (pageData.product && !_.isUndefined(this.resultCountTmpl)) {
                this.listData.count = this.resultCountTmpl + " (" + this.formatSalesRevenue(pageData.count) + ")";
            } else {
                delete this.listData['count'];
            }
            this.render();
        } else {
            this.currentPage = this.currentPage.concat(pageData.product);
            _.each(pageData.product, function(listObj) {
                //compile account row
                var rowHtml = this.rowTmpl(listObj);
                //append account row to exising list
                this.$(this.selectors.rsltList).append(rowHtml);
            }, this);
        }
        this.$(this.selectors.load).toggleClass('hide', true);
        this.$(this.selectors.rslt).toggleClass('hide', false);
        //render pagination controls only if the api returns a success response
        if (pageData.product) {
            this.renderPaginationControl();
        }
    },

    /**
     * Bulk Import D&B Objects
     * @param {Array} bulkArray
     * @param {String} module
     * @param {Function} callBack
     */
    invokeBulkImport: function(bulkArray, module, callBack) {
        //display loading message
        app.alert.show('bulkImport', {
            level: 'process',
            title: app.lang.getAppString('LBL_DNB_BI_LOADING'),
            autoClose: false
        });
        //hide previous
        var bulkImportURL = app.api.buildURL('connector/dnb/' + module + '/bulkimport', '', {},{}),
            self = this;
        app.api.call('create', bulkImportURL, {'bulkdata': bulkArray}, {
            success: function(data) {
                //dismiss loading symbol
                app.alert.dismiss('bulkImport');
                var newAccounts = data.importSuccess,
                    duplicates = data.duplicates,
                    title, level, message;
                var viewAccountsMsg = "<a href='#{{buildRoute module=module}}' data-route='#{{buildRoute module=module}}'>{{str 'LBL_DNB_VIEW_ACCT'}}</a>";
                var viewAcctsHTML = Handlebars.compile(viewAccountsMsg)({'module': self.module});

                if (newAccounts > 0 && duplicates === 0) {
                    level = 'success';
                    title = app.lang.get('LBL_SUCCESS');
                    message = app.lang.get('LBL_DNB_BI_YOU_ADD') + newAccounts + app.lang.get('LBL_DNB_BI_NEW_ACCT');
                } else if (newAccounts > 0 && duplicates > 0) {
                    level = 'warning',
                    title = app.lang.get('LBL_WARNING');
                    message = app.lang.get('LBL_DNB_BI_YOU_ADD') + newAccounts + app.lang.get('LBL_DNB_BI_NEW_ACCT');
                    message += duplicates + app.lang.get('LBL_DNB_BI_DUP_MSG');
                } else if (newAccounts === 0) {
                    level = 'error',
                    title = app.lang.get('LBL_ERROR');
                    message = app.lang.get('LBL_DNB_BI_ERR');
                }
                if (newAccounts !== 0) {
                    message += viewAcctsHTML;
                }
                app.alert.show('dnb-import', {
                    level: level,
                    title: title + ':',
                    messages: message,
                    autoClose: true,
                    autoCloseDelay: 10000
                });
                callBack.call(self);
            },
            error: function(xhr, status, error) {
                app.alert.dismiss('bulkImport');
                var errorMessage,
                    errorCode = xhr.code;
                if(!_.isUndefined(errorCode)) {
                    errorMessage = app.lang.get(this.commonErrorMap[errorCode]);
                }
                if(_.isUndefined(errorMessage)) {
                    errorMessage = this.commonErrorMap['ERROR_DNB_UNKNOWN'];
                }
                app.alert.show('dnb-import', {
                    level: 'error',
                    title: app.lang.get('LBL_ERROR'),
                    messages: errorMessage,
                    autoClose: true,
                    autoCloseDelay: 10000
                });
            }
        });
    },

    /**
     * Toggle the button between enabled and disabled states
     * @param {Boolean} isDisabled
     * @param {String} selector
     */
    toggleButton: function(isDisabled, selector) {
        this.$(selector).toggleClass('disabled', isDisabled);
        this.$(selector).prop('disabled', isDisabled);
    }
}) },
"massupdate-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateProgressView
 * @alias SUGAR.App.view.views.BaseMassupdateProgressView
 * @extends View.View
 */
({
	// Massupdate-progress View (base) 

    plugins: ['Editable'],

    events: {
        'click [name=btn-stop]': 'pauseUpdate'
    },

    /**
     * Total number of records.
     *
     * @property
     */
    totalRecord: 0,

    /**
     * Executed datetime in milliseconds.
     *
     * @property
     */
    _startTime: 0,

    /**
     * Speed of last executed job.
     *
     * @property
     */
    _velocity: 0,

    /**
     * HTML Elements that needs to update dynamically.
     *
     * @property
     */
    $holders: {},

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSUPDATE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSUPDATE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSUPDATE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSUPDATE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSUPDATE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSUPDATE_SUCCESS',
            TITLE: 'TPL_MASSUPDATE_TITLE'
        },
        'delete': {
            PROGRESS_STATUS: 'TPL_MASSDELETE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSDELETE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSDELETE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSDELETE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSDELETE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSDELETE_SUCCESS',
            TITLE: 'TPL_MASSDELETE_TITLE'
        }
    },

    /**
     * @inheritdoc
     * Check if current process job is completed.
     *
     * @return {boolean} If this process job is not completed, it returns true.
     */
    hasUnsavedChanges: function() {
        return (this.totalRecord > 0);
    },

    /**
     * Initialize the job collection set.
     *
     * @param {Backbone.Collection} collection Selected set of models.
     */
    initCollection: function(collection) {
        this.unbindData();
        this.collection = collection;
        this.hide();
        this.bindDataChange();
    },

    /**
     * Initialize the labels.
     */
    initLabels: function() {
        this.LABELSET = this._labelSet[this.collection.method || this.collection.defaultMethod];
    },

    /**
     * Initialize the dynamic DOM elements into the variable,
     * in order to avoid the multiple jQuery selector.
     */
    initHolders: function() {
        var self = this;
        self.$holders = {};
        this.$('[data-holder]').each(function(holder) {
            var $el = $(this);
            self.$holders[$el.data('holder')] = $el;
        });
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        this.offBefore('start');
        this.off('render', null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     * Bind the listeners for each massupdate status.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.collection.on('massupdate:always', this.updateProgress, this);
        this.collection.on('massupdate:start', this.showProgress, this);
        this.collection.on('massupdate:end', this.hideProgress, this);
        this.collection.on('massupdate:fail', this.checkError, this);
        this.collection.on('massupdate:resume', this.resumeProcess, this);
        this.collection.on('massupdate:pause', this.pauseProcess, this);
    },

    /**
     * Check current job occurs error or not.
     *
     * If api retry the attempt,
     * it displays api failure error message in the alert bar.
     */
    checkError: function() {
        if (this.collection.attempt === 0) {
            this.$holders.bar
                .addClass('progress-info')
                .removeClass('progress-danger');
            return;
        } else if (this.collection.attempt > this.collection.maxAllowAttempt) {
            return;
        }
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                num: this.collection.attempt,
                total: this.collection.maxAllowAttempt
            })
        });
    },

    /**
     * Estimate remaining time.
     *
     * @return {Number} Remaining seconds.
     */
    getEstimate: function() {
        if (!this.collection.chunks) {
            return 0;
        }
        var chunkSize = this.collection.chunks.length,
            remainSize = this.collection.length,
            duration = (new Date().getTime() - this._startTime) / 1000;
        this._startTime = new Date().getTime();
        this._velocity = chunkSize / duration; //amount per sec

        return parseInt(remainSize / this._velocity, 10);
    },

    /**
     * Convert numeric time into the relative time.
     * @param {Number} elapsed Numeric time.
     * @return {String} Converted string time.
     *   Returns empty unless condition is satisfied.
     */
    getRelativeTime: function(elapsed) {
        var msPerMinute = 60,
            msPerHour = msPerMinute * 60,
            msPerDay = msPerHour * 24,
            unitString = '',
            relateTime = 0;

        if (elapsed <= 0) {
            return '';
        }

        if (elapsed < msPerMinute) {
            relateTime = elapsed;
            unitString = app.lang.get('LBL_DURATION_SECONDS');
        } else if (elapsed < msPerHour) {
            relateTime = Math.round(elapsed / msPerMinute);
            unitString = app.lang.get('LBL_DURATION_MINUTES');
        } else if (elapsed < msPerDay) {
            relateTime = Math.round(elapsed / msPerHour);
            unitString = app.lang.get('LBL_DURATION_HOUR');
        } else {
            //too huge
            return '';
        }

        return app.lang.get(this.LABELSET['DURATION_FORMAT'], this.collection.baseModule, {
            time: relateTime,
            unit: unitString
        });
    },

    /**
     * Returns number of total elements for progress.
     *
     * @return {Number} Number of total elements.
     */
    getTotalRecords: function() {
        return this.collection.length;
    },

    /**
     * Calculate remaining records.
     *
     * @return {Number} Remaining size.
     */
    getRemainder: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.collection.models.length, this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate current progress size.
     * Include the completed queue size and current executing chunk size.
     *
     * @return {Number} Progress size.
     */
    getProgressSize: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.totalRecord, this.totalRecord - this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate completed size.
     *
     * @return {Number} Completed size.
     */
    getCompleteRecords: function() {
        return this.totalRecord - this.collection.length;
    },

    /**
     * Calculate number of failed updates.
     *
     * @return {Number} Number of failed updates.
     */
    getFailedRecords: function() {
        return this.collection.numFailures;
    },

    /**
     * Resume the mass job once user were requested to resume.
     * Update screen in proper way.
     */
    resumeUpdate: function() {
        this.collection.resumeFetch();
    },

    /**
     * Request pausing the mass job once user were requested to pause.
     * Update screen in proper way.
     */
    pauseUpdate: function() {
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(true);
        this.collection.pauseFetch();
    },

    /**
     * Update the progress view when the job is paused.
     */
    pauseProcess: function() {
        this.$holders.bar.removeClass('active');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'confirmation',
            messages: app.lang.get(this.LABELSET['WARNING_CLOSE'], this.module, {
                num: this.getRemainder()
            }),
            onConfirm: _.bind(this.hideProgress, this),
            onCancel: _.bind(this.resumeUpdate, this),
            autoClose: false
        });
    },

    /**
     * Update the progress view when the job is resumed.
     */
    resumeProcess: function() {
        this.$holders.bar.addClass('active');
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(false);
    },

    /**
     * Start displaying the progress view.
     */
    showProgress: function() {
        this.initLabels();
        this.totalRecord = this.getTotalRecords();
        this._startTime = new Date().getTime();

        //restore back previous button status.
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }

        var title = app.lang.get(this.LABELSET.TITLE, this.module, {
            module: this.modulePlural
        });
        this.$holders.title.text(title);

        this.updateProgress();
        this.show();
    },

    /**
     * Finish displaying the pregress view.
     * Reset current mass job.
     */
    hideProgress: function() {
        var size = this.getCompleteRecords(),
            discardSize = this.collection.discards.length,
            failed = this.getFailedRecords();
        if (discardSize > 0) {
            //permission warning
            var message = app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                num: this.totalRecord - discardSize
            });
            message += app.lang.get('TPL_MASSUPDATE_WARNING_PERMISSION', this.module, {
                remain: discardSize
            });
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: message,
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else if (this.totalRecord !== size || failed > 0) {
            //incomplete
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: app.lang.get(this.LABELSET['WARNING_INCOMPLETE'], this.module, {
                    num: this.getRemainder() + failed
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else {
            //successfully complete
            app.alert.show('massupdate_final_notice', {
                level: 'success',
                messages: app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                    num: size
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        }
        this.totalRecord = 0;
        this.collection.resetProgress();
        this.hide();
    },

    /**
     * Update current progress status.
     */
    updateProgress: function() {
        if (!this.collection || this.collection.length === 0) {
            return;
        }

        var estimate = this.getEstimate(),
            estimateMessage = this.getRelativeTime(estimate),
            size = this.getProgressSize(),
            percent = (size * 100 / this.totalRecord),
            message = app.lang.get(this.LABELSET['PROGRESS_STATUS'], this.module, {
                num: size,
                percent: Math.round(percent),
                total: this.totalRecord
            });
        if (!_.isEmpty(estimateMessage)) {
            this.$holders.estimate.text(estimateMessage);
        }
        this.checkError();
        this.$holders.message.text(message);
        this.$holders.progressbar.css({'width': percent + '%'});
    }
}) },
"tutorial": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TutorialView
 * @alias SUGAR.App.view.views.BaseTutorialView
 * @extends View.TutorialView
 */
({
	// Tutorial View (base) 

    /**
     * extendsFrom: This needs to be app.view.TutorialView since it's extending a Sidecar specific view class.  This is a
     * special case, as the normal method is for it to be a string.
     */
    extendsFrom: app.view.TutorialView,

    className: '', //override default class

    initialize: function(options) {
        app.events.trigger('app:help:hide');

        this.resizeCallback = _.debounce(_.bind(function(){
            this.highlightItem(this.index);
        }, this), 400);
        $(window).on('resize', this.resizeCallback);
        this.keyupCallback = _.bind(this.processKeyCode, this);
        $(document).on('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.initialize.call(this, options);
        app.events.on("cache:clean", function(callback) {
            callback(["tutorialPrefs"]);
        });
    },
    processKeyCode: function(e) {
        switch(e.which) {
            case 37: // left
                this.back(e);
                break;

            case 39: // right
            case 13: // Enter
                this.next(e);
                break;

            case 27: // exit
                this.hide(e);
                break;

            default: return; // exit this handler for other keys
        }
        e.preventDefault();
    },

    /**
     * removes the tour
     */
    remove: function() {
        $(window).off('resize', this.resizeCallback);
        $(document).off('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.remove.call(this);
        var prefs = app.cache.get('tutorialPrefs') || {};
        if (prefs.showTooltip) {
            this.showTooltip();
            this.removeTooltip(3000);
        }
    },

    /**
     * shows tooltip on tour button
     */
    showTooltip: function() {
        $('[data-action=tour]')
            .tooltip({
                container: 'body',
                trigger: 'manual'
            })
            .tooltip('show');
    },

    /**
     * removes tooltip from tour button
     * @param {int} delayTime milliseconds.
     */
    removeTooltip: function(delayTime) {
        if (!delayTime) {
            $('[data-action=tour]').tooltip('hide');
        } else {
            _.delay(function() { $('[data-action=tour]').tooltip('hide'); }, delayTime);
        }
    }
}) },
"sweetspot-config-theme": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigThemeView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigThemeView
 * @extends View.View
 */
({
	// Sweetspot-config-theme View (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = this._getMeta(options);
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Merges the base metadata with custom view metadata.
     *
     * @protected
     * @param {Object} options The options hash containing the custom
     *   metadata.
     * @return {Object} The metadata this view should use.
     */
    _getMeta: function(options) {
        return  _.extend({},
            app.metadata.getView(null, 'sweetspot-config-theme'),
            app.metadata.getView(this.module, 'sweetspot-config-theme'),
            options.meta
        );
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);
    },


    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this._initTheme();
    },

    /**
     * Initializer function that ensures the correct theme is checked when the
     * view is rendered.
     *
     * @protected
     */
    _initTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.model.set('theme', theme);
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     *
     * @return {undefined} Returns `undefined` if the default theme is selected.
     */
    generateConfig: function() {
        var theme = this._getSelectedTheme();

        // The default configuration should not be defined in user prefs.
        if (!theme) {
            return;
        }
        var data = this._formatForUserPrefs(theme);
        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {string} theme The configured theme name.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(theme) {
        return {theme: theme};
    },

    /**
     * Returns the currently selected theme from this view.
     *
     * @protected
     * @return {string|undefined} The currently selected theme. Returns
     *   `undefined` if the default theme is selected.
     */
    _getSelectedTheme: function() {
        var theme = this.model.get('theme');

        // The default configuration should be empty in user prefs.
        if (theme === 'default') {
            return;
        }

        return theme;
    },

    /**
     * Compare with the user preferences and return true if the checkbox
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.theme;
        var newConfig = this._getSelectedTheme();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"modal-confirm": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalConfirmView
 * @alias SUGAR.App.view.views.BaseModalConfirmView
 * @extends View.View
 */
({
	// Modal-confirm View (base) 

    events: {
        'click [name=close_button]' : 'close',
        'click [name=ok_button]' : 'ok'
    },
    initialize: function(options) {
        this.message = options.layout.confirmMessage;
        app.view.View.prototype.initialize.call(this, options);
    },
    close: function(evt) {
        this.layout.context.trigger("modal:close");
    },
    ok: function(evt) {
        this.layout.context.trigger("modal:callback");
    }
}) },
"audit-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditHeaderpaneView
 * @alias SUGAR.App.view.views.BaseAuditHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Audit-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        //shortcut keys
        app.shortcuts.register('AuditHeaderPanel:Close', ['esc','ctrl+alt+l'], function() {
            var $closeButton = this.$('a[name=close_button]');
            if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                $closeButton.click();
            }
        }, this, true);
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    }
}) },
"dupecheck-list-multiselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListMultiselectView
 * @alias SUGAR.App.view.views.BaseDupecheckListMultiselectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-multiselect View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-multiselect',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);
        this._super('initialize', [options]);
    }
}) },
"dnb-bal-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dnb-bal-header View (base) 

    events: {
        'click [name="reset_button"]': 'triggerClearParams'
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.title = this.meta.title;
    },

    /**
     * Triggers event to clear all parameters
     */
    triggerClearParams: function() {
        this.layout.trigger('dnbbal:param:clear');
    }
}) },
"help-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HelpDashletView
 * @alias SUGAR.App.view.views.BaseHelpDashletView
 * @extends View.View
 *
 * @deprecated Since 7.7. Will be removed in 7.9.
 */
({
	// Help-dashlet View (base) 

    plugins: ['Dashlet'],

    /**
     * Holds the Object returned by app.help.get()
     * <pre><code>
     * {
     *    title: '',
     *    body: '',
     *    more_help: ''
     * }
     * </code></pre>
     * @type {Object}
     */
    helpObject: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.logger.warn('View.Views.Base.HelpDashletView is deprecated since 7.7. Will be removed in 7.9.');

        this.getHelpObject();
    },

    /**
     * Method to fetch the help object from the app.help utility
     */
    getHelpObject: function() {
        var helpUrl = {
                more_info_url: this.createMoreHelpLink(),
                more_info_url_close: '</a>'
            },
            ctx = this.context && this.context.parent || this.context,
            layout = (this.meta.preview) ? 'preview' : ctx.get('layout');

        this.helpObject = app.help.get(ctx.get('module'), layout, helpUrl);

        // if title is empty for some reason, use the dashlet label as the fallback
        if (_.isEmpty(this.helpObject.title)) {
            this.helpObject.title = app.lang.get(this.meta.label);
        }
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        this.settings.set({
            label: this.helpObject.title
        });
    },

    /**
     * @inheritdoc
     */
    getLabel: function() {
        return this.helpObject.title;
    },

    /**
     * Collects server version, language, module, and route and returns an HTML link to be used
     * in the template
     *
     * @return {string} The HTML a-tag for the More Help link
     */
    createMoreHelpLink: function() {
        var serverInfo = app.metadata.getServerInfo(),
            lang = app.lang.getLanguage(),
            module = app.controller.context.get('module'),
            route = this.context.get('layout');

        if (route == 'records') {
            route = 'list';
        }

        var url = 'http://www.sugarcrm.com/crm/product_doc.php?edition=' + serverInfo.flavor
            + '&version=' + serverInfo.version + '&lang=' + lang + '&module=' + module + '&route=' + route;
        if (route == 'bwc') {
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                url += '&action=' + action[1];
            }
        }

        return '<a href="' + url + '" target="_blank">';
    },

    /**
     * @inheritdoc
     *
     * Overriding to pass this.helpObject as the template model to use,
     * and this.options in case templateOptions get passed down
     */
    _renderHtml: function() {
        this._super('_renderHtml', [this.helpObject, this.options]);
    }
}) },
"dashletconfiguration-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletconfigurationHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletconfigurationHeaderpaneView
 * @extends View.View
 */
({
	// Dashletconfiguration-headerpane View (base) 

    plugins: ['Editable', 'ErrorDecoration'],

    events: {
        "click a[name=cancel_button]": "close",
        "click a[name=save_button]":   "save"
    },

    /**
     * Store the translated i18n label.
     * @type {String} Translated dashlet's title label.
     * @private
     */
    _translatedLabel: null,

    /**
     * @inheritdoc
     * Binds the listener for the before `save` event.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.before('save', function(model) {
            return this.layout.triggerBefore('dashletconfig:save', model);
        }, this);

        //shortcut keys
        app.shortcuts.register('Dashlet:Config:Cancel', ['esc','ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=cancel_button]');
            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.click();
            }
        }, this, true);
        app.shortcuts.register('Dashlet:Config:Save', ['ctrl+s','ctrl+alt+a'], function() {
            var $saveButton = this.$('a[name=save_button]');
            if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                $saveButton.click();
            }
        }, this, true);
    },

    /**
     * @inheritdoc
     * Compare with the previous attributes and translated dashlet's label
     * in order to warn unsaved changes.
     *
     * @return {Boolean} true if the dashlet setting contains changes.
     */
    hasUnsavedChanges: function() {
        var previousAttributes = _.extend(this.model.previousAttributes(), {
            label: this._translatedLabel
        });
        return !_.isEmpty(this.model.changedAttributes(previousAttributes));
    },

    /**
     * Triggers a `save` event before `app.drawer.close()` is called, in case
     * any processing needs to be done on the model before it is saved.
     *
     * @return {Boolean} `false` if the `dashletconfig:save` event returns false.
     */
    save: function() {
        if (this.triggerBefore('save', this.model) === false) {
            return false;
        }

        var fields = {};
        _.each(this.meta.panels[0].fields, function(field) {
            fields[field.name] = field;
        });

        this.model.doValidate(fields, _.bind(function(isValid) {
            if (isValid) {
                app.drawer.close(this.model);
            }
        }, this));
    },

    close: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     *
     * Translate model label before render using model attributes.
     */
    _renderHtml: function() {
        var label;
        this.model = this.context.get('model');
        label = app.lang.get(
            this.model.get('label'),
            this.model.get('module') || this.module,
            this.model.attributes
        );
        this._translatedLabel = label;
        this.model.set('label', label, {silent: true});
        app.view.View.prototype._renderHtml.call(this);
    }
}) },
"footer-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FooterActionsView
 * @alias SUGAR.App.view.views.BaseFooterActionsView
 * @extends View.View
 */
({
	// Footer-actions View (base) 

    events: {
        'click [data-action=shortcuts]': 'shortcuts',
        'click [data-action=tour]': 'showTutorialClick',
        'click [data-action=feedback]': 'feedback',
        'click [data-action=support]': 'support',
        'click [data-action=help]': 'help'
    },
    tagName: 'span',
    layoutName: '',
    watchingForDashboard: false,

    /**
     * Array of layout names where the help button should be disabled
     */
    helpBtnDisabledLayouts: [
        'about',
        'first-login-wizard'
    ],

    handleViewChange: function(layout, params) {
        var module = params && params.module ? params.module : null;
        // should we disable the help button or not, this only happens when layout is 'bwc'
        this.layoutName = _.isObject(layout) ? layout.name : layout;
        this.disableHelpButton(true);
        if (app.tutorial.hasTutorial(this.layoutName, module)) {
            this.enableTourButton();
            if (params.module === 'Home' && params.layout === 'record' && params.action === 'detail') {
                // first time in or upgrade, show tour
                var serverInfo = app.metadata.getServerInfo(),
                    currentKeyValue = serverInfo.build + '-' + serverInfo.flavor + '-' + serverInfo.version,
                    lastStateKey = app.user.lastState.key('toggle-show-tutorial', this),
                    lastKeyValue = app.user.lastState.get(lastStateKey);
                if (currentKeyValue !== lastKeyValue) {
                    // first time in, or first time after upgrade
                    app.user.lastState.set(lastStateKey, currentKeyValue);
                    this.showTutorial({showTooltip: true});
                }
            }
        } else {
            this.disableTourButton();
        }
    },
    handleRouteChange: function(route, params) {
        this.routeParams = {'route': route, 'params': params};
    },
    enableTourButton: function() {
        this.$('[data-action=tour]').removeClass('disabled');
        this.events['click [data-action=tour]'] = 'showTutorialClick';
        this.undelegateEvents();
        this.delegateEvents();
    },
    disableTourButton: function() {
        this.$('[data-action=tour]').addClass('disabled');
        delete this.events['click [data-action=tour]'];
        this.undelegateEvents();
        this.delegateEvents();
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on('app:view:change', this.handleViewChange, this);
        var self = this;
        app.utils.doWhen(function() {
            return !_.isUndefined(app.router);
        }, function() {
            self.listenTo(app.router, 'route', self.handleRouteChange);
        });

        app.events.on('app:help', function() {
            this.help();
        }, this);

        app.events.on('app:help:shown', function() {
            this.toggleHelpButton(true);
            this.disableHelpButton(false);
        }, this);

        app.events.on('app:help:hidden', function() {
            this.toggleHelpButton(false);
            this.disableHelpButton(true);
        }, this);

        app.events.on('alert:cancel:clicked', function() {
            // re-check if help should be disabled or not and set accordingly
            this.disableHelpButton(this.shouldHelpBeDisabled());
        }, this);

        this._watchForDashboard();

        app.shortcuts.register(app.shortcuts.GLOBAL + 'Help', '?', this.shortcuts, this);

        app.user.lastState.preserve(app.user.lastState.key('toggle-show-tutorial', this));

        this.before('render', function() {
            if (this._feedbackView) {
                this._feedbackView.dispose();
            }
        }, this);
    },

    /**
     * Watch for when the dashboard container gets rendered and enable the help buttons
     *
     * @private
     */
    _watchForDashboard: function() {
        if (this.watchingForDashboard === false) {
            this.watchingForDashboard = true;
            app.utils.doWhen(function() {
                var layout = app.controller.layout;
                if (!_.isUndefined(layout)) {
                    if (layout.module == 'Home' || layout.name === 'bwc') {
                        // if the layout exists and it's the `Home` Module or `bw`, just enable the button as
                        // a url redirect is what is used for the help here.
                        return true;
                    } else {
                        var sidebar = layout.getComponent('sidebar');
                        if (sidebar) {
                            var dashboard = sidebar.getComponent('dashboard-pane');
                            if (dashboard) {
                                // return true if we have dashlets or if we are on the list
                                return (dashboard.$('.dashlets').length > 0 ||
                                dashboard.$('.container-fluid').length == 1);
                            }
                        }
                    }
                }
                return false;
            }, _.bind(function() {
                this.watchingForDashboard = false;
                this.disableHelpButton(false);
            }, this));
        }
    },

    /**
     * Checks any criteria to see if help button should be disabled
     * @return {boolean}
     */
    shouldHelpBeDisabled: function() {
        return (_.indexOf(this.helpBtnDisabledLayouts, this.layoutName) !== -1);
    },

    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.isShortcutsEnabled = (this.isAuthenticated && app.shortcuts.isEnabled());
        app.view.View.prototype._renderHtml.call(this);
    },

    /**
     * Toggles feedback popup on click (open or close).
     * TODO move this to a feedback field
     *
     * This currently sets and uses the internal `_feedbackIsOpen` flag to
     * create and dispose the {@link FeedbackView}.
     * FIXME this shouldn't work that way and should trigger an event that the
     * additionalComponent (the feedback layout) is listening to and the toggle
     * will simply trigger the event for the layout to show and hide.
     * This will improve performance (no more layout being disposed and created
     * on click).
     *
     * If the app isn't yet in sync (all metadata loaded to create the view)
     * the button doesn't do anything.
     *
     * @param {Event} evt the `click` event.
     */
    feedback: function(evt) {
        if (!app.isSynced) {
            return;
        }

        if (!this._feedbackView || this._feedbackView.disposed) {
            this._feedbackView = app.view.createView({
                module: 'Feedbacks',
                name: 'feedback',
                button: this.$('[data-action="feedback"]')
            });

            this.listenTo(this._feedbackView, 'show hide', function(view, active) {
                this.$('[data-action="feedback"]').toggleClass('active', active);
            });
        }
        this._feedbackView.toggle();
    },

    support: function() {
        window.open('http://support.sugarcrm.com', '_blank');
    },

    /**
     * Help Button Click Event Listener
     *
     * @param {Object} event        The Click Event
     */
    help: function(event) {
        if (this.layoutName === 'bwc' || this.layoutName === 'about') {
            this.bwcHelpClicked();
            return;
        }
        var button = this.$('[data-action="help"]');
        var buttonDisabled = button.hasClass('disabled');
        var buttonAppEvent = button.hasClass('active') ? 'app:help:hide' : 'app:help:show';

        if (!buttonDisabled) {
            // add the disabled so that way if it's clicked again, it won't triggered the events again,
            // this will get removed below
            button.addClass('disabled');
            // trigger the app event to show and hide the help dashboard
            app.events.trigger(buttonAppEvent);
        }
    },

    /**
     * Disable the help button
     *
     * @param {boolean} [disable=true]      Should we disable it or enable it, if not passed will default to true
     */
    disableHelpButton: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;

        var button = this.$('[data-action=help]');
        if (button) {
            button.toggleClass('disabled', disable);
        }

        if (disable) {
            this._watchForDashboard();
        }

        return disable;
    },

    /**
     * Utility Method to toggle the help button on and off.
     *
     * @param {Boolean} active      Set or remove the active state of the button
     * @param {Object} (button)     Button Object (optional), will be found if not passed in
     */
    toggleHelpButton: function(active, button) {
        if (_.isUndefined(button)) {
            button = this.$('[data-action=help]');
        }

        if (button) {
            button.toggleClass('active', active);
        }
    },

    /**
     * Open shortcut help.
     * @param event
     */
    shortcuts: function(event) {
        var activeDrawerLayout = app.drawer.getActive(),
            $shortcutButton = this.$('[data-action=shortcuts]');

        if (!activeDrawerLayout || activeDrawerLayout.type !== 'shortcuts') {
            $shortcutButton.addClass('active');
            app.drawer.open({
                layout: 'shortcuts'
            }, function() {
                $shortcutButton.removeClass('active');
            });
        } else {
            app.drawer.close();
        }
    },

    /**
     * click event for show tour icon
     * @param {Object} e click event.
     */
    showTutorialClick: function(e) {
        if (!app.tutorial.instance) {
            this.showTutorial();
            e.currentTarget.blur();
        }
    },

    /**
     * show tour overlay
     * @param {Object} prefs preferences to preserve.
     */
    showTutorial: function(prefs) {
        app.tutorial.resetPrefs(prefs);
        app.tutorial.show(app.controller.context.get('layout'), {module: app.controller.context.get('module')});
    },

    /**
     * Calls the old Help Docs if in BWC mode
     */
    bwcHelpClicked: function() {
        var serverInfo = app.metadata.getServerInfo(),
            lang = app.lang.getLanguage(),
            module = app.controller.context.get('module'),
            route = this.routeParams.route,
            url = 'http://www.sugarcrm.com/crm/product_doc.php?edition=' + serverInfo.flavor + '&version=' + serverInfo.version + '&lang=' + lang + '&module=' + module + '&route=' + route;
        if (route == 'bwc') {
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                url += '&action=' + action[1];
            }
        }
        app.logger.info("help URL: " + url);
        window.open(url);
    }
}) },
"filter-module-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the module dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownView
 * @extends View.View
 */
({
	// Filter-module-dropdown View (base) 

    //Override default Backbone tagName
    tagName: "span",
    className: "table-cell",

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get("filter-module-dropdown.selection-partial");
        this._select2formatResultTemplate = app.template.get("filter-module-dropdown.result-partial");

        this.listenTo(this.layout, "filter:change:module", this.handleChange);
        this.listenTo(this.layout, "filter:render:module", this._render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._renderDropdown();
    },

    /**
     * Render select2 dropdown
     * @private
     */
    _renderDropdown: function() {
        var self = this;

        this.filterList = this.getFilterList();

        // Hide the dropdown if filterList has not been specified.
        if (!this.filterList) {
            this.$el.hide();
            return;
        }

        this.filterNode = this.$(".related-filter");

        this.filterNode.select2({
            data: this.filterList,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-related-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            width: 'off'
        });

        // Disable the module filter dropdown.
        if (this.shouldDisableFilter()) {
            this.filterNode.select2("disable");
        }

        this.filterNode.off("change");
        this.filterNode.on("change", function(e) {
            /**
             * Called when the user selects a module in the dropdown
             * Triggers filter:change:module on filter layout
             * @param {Event} e
             */
            var linkModule = e.val;
            if (self.layout.layoutType === "record" && linkModule !== "all_modules") {
                linkModule = app.data.getRelatedModule(self.module, linkModule);
            }
            self.layout.trigger("filter:change:module", linkModule, e.val);
        });
    },

    /**
     * Get the list for filter module dropdown.
     * @return {Object}
     */
    getFilterList: function() {
        var filterList;

        if (this.layout.showingActivities) {
            filterList = this.getModuleListForActivities();
        } else if (this.layout.layoutType === "record") {
            filterList = this.getModuleListForSubpanels();
        }

        return filterList;
    },

    /**
     * Should the filter be disabled?
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return (this.layout.layoutType !== "record" || this.layout.showingActivities);
    },

    /**
     * Trigger events when a change happens
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (linkName === "all_modules") {
            this.layout.trigger("subpanel:change");
        } else if (linkName) {
            this.layout.trigger("subpanel:change", linkName);
        }

        // It is important to reset the `currentFilterId` in order to retrieve
        // the last filter from cache later.
        this.context.set('currentFilterId', null);

        if (this.filterNode) {
            this.filterNode.select2("val", linkName || linkModuleName);
        }
        if (!silent) {
            this.layout.layout.trigger("filter:change", linkModuleName, linkName);
            this.layout.trigger('filter:get', linkModuleName, linkName);
            //Clear the search input and apply filter
            this.layout.trigger('filter:clear:quicksearch');
        }
    },

    /**
     * For record layout,
     * Populate the module dropdown by reading the subpanel relationships
     */
    getModuleListForSubpanels: function() {
        var filters = [];
        filters.push({id: "all_modules", text: app.lang.get("LBL_MODULE_ALL")});

        var subpanels = this.pullSubpanelRelationships();
        subpanels = this._pruneHiddenModules(subpanels);
        if (subpanels) {
            _.each(subpanels, function(value, key) {
                var module = app.data.getRelatedModule(this.module, value);
                if (app.acl.hasAccess("list", module)) {
                    filters.push({id: value, text: app.lang.get(key, this.module)});
                }
            }, this);
        }
        return filters;
    },

    /**
     * For Activity Stream,
     * Populate the module dropdown with a single item
     */
    getModuleListForActivities: function() {
        var filters = [], label;
        if (this.module == "Activities") {
            label = app.lang.get("LBL_MODULE_ALL");
        } else {
            label = app.lang.getModuleName(this.module, {plural: true});
        }
        filters.push({id: 'Activities', text: label});
        return filters;
    },

    /**
     * Pull the list of related modules from the subpanel metadata
     * @return {Object}
     */
    pullSubpanelRelationships: function() {
        // Subpanels are retrieved from the global module and not the
        // subpanel module, therefore we use this.module instead of
        // this.currentModule.
        return app.utils.getSubpanelList(this.module);
    },

    /**
     * Prunes hidden modules from related dropdown list
     * @param {Object} subpanels List of candidate subpanels to display
     * @return {Object} pruned list of subpanels
     * @private
     */
    _pruneHiddenModules: function(subpanels){
        var hiddenSubpanels = _.map(app.metadata.getHiddenSubpanels(), function(subpanel) {
            return subpanel.toLowerCase();
        });
        var pruned = _.reduce(subpanels, function(obj, value, key) {
            var relatedModule = app.data.getRelatedModule(this.module, value);
            if (relatedModule && !_.contains(hiddenSubpanels, relatedModule.toLowerCase())) {
                obj[key] = value;
            }
            return obj;
        }, {}, this);
        return pruned;
    },

    /**
     * Get the dropdown labels for the module dropdown
     * @param {Object} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        var selection, label;
        if (el.val() === "all_modules") {
            label = (this.layout.layoutType === "record") ? app.lang.get("LBL_MODULE_ALL") : app.lang.getModuleName(this.module, {plural: true});
            selection = {id: "all_modules", text: label};
        } else if (_.findWhere(this.filterList, {id: el.val()})) {
            selection = _.findWhere(this.filterList, {id: el.val()});
        } else if(this.filterList && this.filterList.length > 0)  {
            selection = this.filterList[0];
        }
        callback(selection);
    },

    /**
     * Returns the label for the dropdown.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        var selectionLabel;

        if (this.layout.layoutType !== "record" || this.layout.showingActivities) {
            selectionLabel = app.lang.get("LBL_MODULE");
        } else {
            selectionLabel = app.lang.get("LBL_RELATED") + '<i class="fa fa-caret-down"></i>';
        }

        return selectionLabel;
    },

    /**
     * Update the text for the selected module and returns template
     *
     * @param {Object} item
     * @return {string}
     */
    formatSelection: function(item) {
        var safeString;

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        // Update the text for the selected module.
        this.$('.choice-related').html(safeString);

        return this._select2formatSelectionTemplate(this.getSelectionLabel());
    },

    /**
     * Returns template
     * @param {Object} option
     * @return {string}
     */
    formatResult: function(option) {
        // TODO: Determine whether active filters should be highlighted in bold in this menu.
        return this._select2formatResultTemplate(option.text);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        this._super('_dispose');
    }
}) },
"quicksearch-modulelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchModuleListView
 * @alias SUGAR.App.view.views.BaseQuicksearchModuleListView
 * @extends View.View
 */
({
	// Quicksearch-modulelist View (base) 

    className: 'table-cell quicksearch-modulelist-wrapper',
    plugins: ['Dropdown', 'EllipsisInline'],
    dropdownItemSelector: '[data-action=select-module], [data-action=select-all]',

    events: {
        'click [data-action=select-all]': 'selectAllModules',
        'click [data-action=select-module]': 'selectModule',
        'keydown [data-action=select-all]': 'allModulesKeydownHandler',
        'keydown [data-action=select-module]': 'moduleKeydownHandler',
        'click [data-toggle=dropdown]': 'moduleDropdownClick'
    },

    // List of modules that should not be included in the module list
    blacklistModules: ['Tags'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.hide();

        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * A collection of the available modules.
         *
         * @type {Backbone.Collection}
         */
        this.searchModuleFilter = new Backbone.Collection(null, {
            //adds models in alphabetical order of model's id's module name translation
            comparator: function(model) {
                return app.lang.getModuleName(model.id, {plural: true});
            }
        });

        /**
         * The lastState key for local storage.
         *
         * @type {String}
         */
        this.stateKey = app.user.lastState.buildKey('quicksearch', 'modulelist', this.name);

        /**
         * Template for the module icons in the search bar.
         *
         * @type {Handlebars.Template}
         * @private
         */
        this._moduleIconTemplate = app.template.getView(this.name + '.module-avatar');

        /**
         * Data structure for the display of the module icons.
         *
         * @type {Object}
         */
        this.moduleIcons = {};

        // When the app is ready, fetch the searchable modules and put them in
        // the module list dropdown. This cannot be in the initialize because
        // when initialize is called, the only module available is login.
        app.events.on('app:sync:complete', function() {
            this.populateModules();
            // If there is a module preference stored in local storage,
            // default selection to those modules.
            var previousModuleSelection = app.user.lastState.get(this.stateKey);
            if (_.isEmpty(previousModuleSelection)) {
                this.searchModuleFilter.allSelected = true;
            } else {
                _.each(previousModuleSelection, function(module) {
                    this.searchModuleFilter.get(module).set('selected', true);
                }, this);
            }
            this._setSelectedModules();
            // Prepare the module icons for display
            var moduleIconObj = this._buildModuleIconList();
            this.moduleIcons = {icon: moduleIconObj};
            this.render();
            this.layout.off('route:search', this.populateModuleSelectionFromContext);
            this.layout.on('route:search', this.populateModuleSelectionFromContext, this);

            // We need to call `populateModuleSelectionFromContext` here to
            // update the module icons if the user navigates directly to the
            // search page from outside Sugar. In this use case,
            // 'quicksearch-modulelist.js' is initialized and needs to update
            // the module icons to be in sync with the ones in the url.
            this.populateModuleSelectionFromContext();
        }, this);

        // On expansion of quicksearch, show the module dropdown & buttons.
        this.layout.on('quicksearch:expanded', this.show, this);

        // On collapse of quicksearch, hide the module dropdown & buttons.
        this.layout.on('quicksearch:collapse', this.hide, this);

        // Whenever anything happens within the quicksearch layout navigation,
        // close the module list dropdown.
        this.layout.on('navigate:next:component navigate:previous:component navigate:to:component', function() {
            this.$el.removeClass('open');
        }, this);
    },

    /**
     * Populate the module selection from the search context.
     */
    populateModuleSelectionFromContext: function() {
        // Reset all the selections
        var previousModuleSelection = this.context.get('module_list');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.$('[data-action=select-module]').removeClass('selected');

        // Handle the 'all selected' case
        if (_.isEmpty(previousModuleSelection)) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            // A specific set of modules have been selected.
        } else {
            this.searchModuleFilter.allSelected = false;
            this.$('[data-action=select-all]').removeClass('selected');
            _.each(previousModuleSelection, function(module) {
                var moduleFilter = this.searchModuleFilter.get(module);
                if (moduleFilter) {
                    moduleFilter.set('selected', true);
                    this.$('[data-action=select-module][data-module=' + module + ']').addClass('selected');
                }
            }, this);
        }
        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle module 'select/unselect' event.
     *
     * @param {Event} event
     */
    selectModule: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();
        var $li = $(event.currentTarget);
        var module = $li.data('module');
        var moduleModel = this.searchModuleFilter.get(module);

        // If all the modules were selected, we unselect all of them first.
        if (this.searchModuleFilter.allSelected) {
            this.$('[data-action=select-all]').removeClass('selected', false);
            this.searchModuleFilter.allSelected = false;
        }

        // Then we select the clicked module.
        var checkModule = !moduleModel.get('selected');
        moduleModel.set('selected', checkModule);
        $li.toggleClass('selected', checkModule);

        // Check to see if all the modules are now all selected or unselected.
        var selectedLength = this.searchModuleFilter.where({'selected': true}).length;

        // All modules are selected, set them all to unselected.
        if (selectedLength === this.searchModuleFilter.length) {
            this.searchModuleFilter.invoke('set', {selected: false});
            selectedLength = 0;
        }

        // If all modules are now unselected, update checkboxes and set the
        // `allSelected` property of the filter.
        if (selectedLength === 0) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            this.$('[data-action=select-module]').removeClass('selected');
        }

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle clicks on the "Search all" list item.
     * @param {event} event
     */
    selectAllModules: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();

        // Selects all modules.
        this.$('[data-action=select-all]').addClass('selected');
        this.$('[data-action=select-module]').removeClass('selected');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.searchModuleFilter.allSelected = true;

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handles the keydown events on the "All Modules" checkbox.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    allModulesKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectAllModules(event);
            event.preventDefault();
        }
    },

    /**
     * Handles the keydown events on the module list items.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    moduleKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectModule(event);
            event.preventDefault();
        }
    },

    /**
     * Trigger `quicksearch:results:close` when the module dropdown is clicked.
     */
    moduleDropdownClick: function() {
        this.layout.trigger('quicksearch:results:close');
    },

    /**
     * Updates the modules icons in the search bar, based on the currently
     * selected modules.
     *
     * @private
     */
    _updateModuleIcons: function() {
        // Update the module icons in the search bar.
        var $moduleIconContainer = this.$('[data-label=module-icons]');
        $moduleIconContainer.empty();
        var moduleIconObj = this._buildModuleIconList();

        $moduleIconContainer.append(this._moduleIconTemplate({icon: moduleIconObj}));
    },

    /**
     * Builds an array of objects for displaying the module icons.
     * @return {Array}
     * @private
     */
    _buildModuleIconList: function() {
        var moduleIconObj = [];
        // If all modules are selected, display "all" icon.
        if (this.collection.selectedModules.length === 0) {
            moduleIconObj.push({});
            // If 3 or fewer selected, display the module icons that are selected.
        } else if (this.collection.selectedModules.length <= 3) {
            _.each(this.collection.selectedModules, function(module) {
                moduleIconObj.push({module: module});
            }, this);
            // If there are more than 3 modules selected, display the
            // "Multiple Modules" icon
        } else {
            moduleIconObj.push({multiple: true});
        }
        return moduleIconObj;
    },

    /**
     * Populate `this.searchModuleFilter` with the searchable modules, using
     * acls and the metadata attribute `checkGlobalSearchEnabled`.
     */
    populateModules: function() {
        if (this.disposed) {
            return;
        }

        //Reset the collection of module filters so we don't add duplicate
        //elements to the original collection.
        this.searchModuleFilter.reset();
        var modules = app.metadata.getModules() || {};

        //filter the module names out based on global search enabled, has
        //access to acl, and is not a blacklisted module
        _.each(modules, function(meta, module) {
            if (meta.globalSearchEnabled &&
                app.acl.hasAccess.call(app.acl, 'view', module) &&
                !_.contains(this.blacklistModules, module)
            ) {
                var moduleModel = new Backbone.Model({id: module, selected: false});
                this.searchModuleFilter.add(moduleModel);
            }
        }, this);
    },

    /**
     * Store the selected modules on the collection and in local storage.
     *
     * @private
     */
    _setSelectedModules: function() {
        var selectedModules = [];
        if (!this.searchModuleFilter.allSelected) {
            this.searchModuleFilter.each(function(model) {
                if (model.get('selected')) {
                    selectedModules.push(model.id);
                }
            });
        }

        this.collection.selectedModules = selectedModules;
        app.user.lastState.set(this.stateKey, this.collection.selectedModules);
    }
}) },
"dupecheck-list-edit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListEditView
 * @alias SUGAR.App.view.views.BaseDupecheckListEditView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-edit View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-selectedit',

    addActions: function() {
        if (this.actionsAdded) return;
        this._super('addActions');

        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Prepend Select and Edit action
            firstRightColumn.fields.unshift({
                type: 'rowaction',
                label: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                css_class: 'btn btn-invisible btn-link ellipsis_inline',
                tooltip: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                event: 'list:dupecheck-list-select-edit:fire'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateView
 * @alias SUGAR.App.view.views.CreateView
 * @extends View.Views.Base.RecordView
 */
({
	// Create View (base) 

    extendsFrom: 'RecordView',
    editAllMode: false,

    enableDuplicateCheck: false,
    dupecheckList: null, //duplicate list layout

    saveButtonName: 'save_button',
    cancelButtonName: 'cancel_button',
    restoreButtonName: 'restore_button',

    /**
     * If this create view has subpanel models to save
     */
    hasSubpanelModels: false,

    /**
     * A collection of alert messages to be used in this view. The alert methods
     * should be invoked by Function.prototype.call(), passing in an instance of
     * a sidecar view. For example:
     *
     *     // ...
     *     this.alerts.showInvalidModel.call(this);
     *     // ...
     *
     * FIXME: SC-3451 will refactor this `alerts` structure.
     * @property {Object}
     */
    alerts: {
        showInvalidModel: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_RESOLVE_ERRORS'
            });
        },
        showServerError: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'server-error';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_GENERIC_SERVER_ERROR'
            });
        },
        showSuccessButDeniedAccess: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'warning',
                messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                autoClose: true,
                autoCloseDelay: 9000
            });
        }
    },

    /**
     * Initialize the view and prepare the model with default button metadata
     * for the current layout.
     */
    initialize: function (options) {
        this.plugins = _.union(this.plugins || [], [
            'FindDuplicates'
        ]);

        //add states for create view
        this.STATE = _.extend({}, this.STATE, {
            CREATE: 'create',
            SELECT: 'select',
            DUPLICATE: 'duplicate'
        });

        //inherit base create metadata for purpose of initialization
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);

        this._super("initialize", [options]);

        // FIXME: SC-3451 will refactor this `alerts` structure.
        this.alerts = _.extend({}, this.alerts, {
            showServerError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                this.cancel();
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
            },
            showSuccessButDeniedAccess: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'warning',
                    messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                    autoClose: true,
                    autoCloseDelay: 9000
                });
            }
        });

        this.model.off("change", null, this);

        //keep track of what post-save action was chosen in case user chooses to ignore dupes
        this.context.lastSaveAction = null;

        //listen for the select and edit button
        this.context.on('list:dupecheck-list-select-edit:fire', this.editExisting, this);

        //enable buttons if there is an error
        this.model.on('error:validation', this.enableButtons, this);

        //extend the record view definition
        this.meta = _.extend({}, app.metadata.getView(this.module, 'record'), this.meta);

        //enable or disable duplicate check?
        var moduleMetadata = app.metadata.getModule(this.module);
        this.enableDuplicateCheck = (moduleMetadata && moduleMetadata.dupCheckEnabled) || false;

        // If user has no list acl it doesn't make sense to enable dupecheck
        if (!app.acl.hasAccess('list', this.module)) {
            this.enableDuplicateCheck = false;
        }

        var fields = (moduleMetadata && moduleMetadata.fields) ? moduleMetadata.fields : {};

        this.model.relatedAttributes = this.model.relatedAttributes || {};

        var assignedUserField = _.find(fields, function(field) {
            return field.type === 'relate' &&
                (field.name === 'assigned_user_id' || field.id_name === 'assigned_user_id');
        });
        if (assignedUserField) {
            // set the default assigned user as current user, unless we are copying another record
            var isDuplicate = this.model.has('assigned_user_id') && this.model.has('assigned_user_name');
            if (!isDuplicate) {
                this.model.setDefault({
                    'assigned_user_id': app.user.id,
                    'assigned_user_name': app.user.get('full_name')
                });
            }
            this.model.relatedAttributes.assigned_user_id = app.user.id;
            this.model.relatedAttributes.assigned_user_name = app.user.get('full_name');
        }

        // need to reset the default attributes because the plugin may have
        // calculated default values.
        this.on('sugarlogic:initialize', function() {
            this.model.setDefault(this.model.attributes);
        }, this);
    },

    /**
     * Extends in order to set the {@link #action} to `create` while the fields
     * are rendering.
     *
     * This is a temporary fix that will be reviewed in 7.8. The action should
     * be `create` at all times but doing the proper fix may have bad impacts on
     * ACLs/non editable fields. Follow up in SC-4511.
     *
     * @inheritdoc
     */
    _renderFields: function() {
        var current = this.action;
        this.action = 'create';
        this._super('_renderFields');
        this.action = current;
    },

    /**
     * @inheritdoc
     */
    /**
     * Check unsaved changes.
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {Boolean} `true` if current model contains unsaved changes,
     *  `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var defaults,
            nonDefaultedAttributesChanged,
            defaultedAttributesChanged;

        if (this.resavingAfterMetadataSync) {
            return false;
        }

        defaults = this.model.getDefault() || {};
        nonDefaultedAttributesChanged = !_.isEqual(_.keys(defaults), _.keys(this.model.attributes));
        defaultedAttributesChanged = !_.isEmpty(this.model.changedAttributes(defaults));

        return (this.model.isNew() && (nonDefaultedAttributesChanged || defaultedAttributesChanged));
    },

    handleSync: function () {
        //override handleSync since there is no need to save the previous model state
    },

    /**
     * @inheritdoc
     *
     * Wires up the save buttons.
     */
    delegateButtonEvents: function() {
        this.context.on('button:' + this.saveButtonName + ':click', this.save, this);
        this.context.on('button:' + this.cancelButtonName + ':click', this.cancel, this);
        this.context.on('button:' + this.restoreButtonName + ':click', this.restoreModel, this);
    },

    _render: function () {
        this._super("_render");

        this.setButtonStates(this.STATE.CREATE);

        // Don't need to add dupecheck layout if dupecheck disabled
        if (this.enableDuplicateCheck) {
            this.renderDupeCheckList();
        }

        //SP-1502: Broadcast model changes so quickcreate field can keep track of unsaved changes
        app.events.trigger('create:model:changed', false);
        this.model.on('change', function() {
            app.events.trigger('create:model:changed', this.hasUnsavedChanges());
        }, this);
    },

    /**
     * Defaults to {@link #saveAndClose}.
     */
    save: function() {
        this.saveAndClose();
    },

    /**
     * Save and close drawer
     */
    saveAndClose: function () {
        this.initiateSave(_.bind(function () {
            if (this.closestComponent('drawer')) {
                app.drawer.close(this.context, this.model);
            } else {
                app.navigate(this.context, this.model);
            }
        }, this));
    },

    /**
     * Handle click on the cancel link
     */
    cancel: function () {
        //Clear unsaved changes on cancel.
        app.events.trigger('create:model:changed', false);
        this.$el.off();
        if (app.drawer.count()) {
            app.drawer.close(this.context);
            this._dismissAllAlerts();
        } else {
            app.router.navigate(this.module, {trigger: true});
        }
    },

    /**
     * Handle click on restore to original link
     */
    restoreModel: function () {
        this.model.clear();
        if (this._origAttributes) {
            this.model.set(this._origAttributes);
            this.model.isCopied = true;
        }

        // reset subpanels
        if (this.hasSubpanelModels) {
            // loop through subpanels and call resetCollection on create subpanels
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel')) {
                    this.context.trigger('subpanel:resetCollection:' + child.get('link'), true);
                }
            }, this);

            // reset the hasSubpanelModels flag
            this.hasSubpanelModels = false;
        }
        
        this.createMode = true;
        if (!this.disposed) {
            this.render();
        }
        this.setButtonStates(this.STATE.CREATE);
    },

    /**
     * Check for possible duplicates before creating a new record
     * @param callback
     */
    initiateSave: function (callback) {
        this.disableButtons();
        async.waterfall([
            _.bind(this.validateSubpanelModelsWaterfall, this),
            _.bind(this.validateModelWaterfall, this),
            _.bind(this.dupeCheckWaterfall, this),
            _.bind(this.createRecordWaterfall, this)
        ], _.bind(function (error) {
            this.enableButtons();
            if (error && error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else if (!error && !this.disposed) {
                this.context.lastSaveAction = null;
                callback();
            }
        }, this));
    },
    /**
     * Check to see if all fields are valid
     * @param callback
     */
    validateModelWaterfall: function(callback) {
        this.model.doValidate(this.getFields(this.module), function(isValid) {
            callback(!isValid);
        });
    },

    /**
     * Check to see if there are subpanel create models on this view
     * And trigger an event to tell the subpanel to validate itself
     *
     * @param callback
     * @return {Mixed}
     */
    validateSubpanelModelsWaterfall: function(callback) {
        this.hasSubpanelModels = false;
        _.each(this.context.children, function(child) {
            if (child.get('isCreateSubpanel')) {
                this.hasSubpanelModels = true;
                this.context.trigger('subpanel:validateCollection:' + child.get('link'), callback, true);
            }
        }, this);

        // If there are no subpanel models, callback false so the waterfall can continue
        if (!this.hasSubpanelModels) {
            return callback(false);
        }
    },

    /**
     * Check for possible duplicate records
     * @param callback
     */
    dupeCheckWaterfall: function (callback) {
        var success = _.bind(function (collection) {
                if (this.disposed) {
                    callback(true);
                }
                if (collection.models.length > 0) {
                    this.handleDuplicateFound(collection);
                    callback(true);
                } else {
                    this.resetDuplicateState();
                    this.disableButtons();
                    callback(false);
                }
            }, this),
            error = _.bind(function (e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    callback(true);
                }
            }, this);

        if (this.skipDupeCheck() || !this.enableDuplicateCheck) {
            callback(false);
        } else {
            this.checkForDuplicate(success, error);
        }
    },

    /**
     * Create new record
     * @param callback
     */
    createRecordWaterfall: function (callback) {
        var success = _.bind(function () {
                var acls = this.model.get('_acl');
                if (!_.isEmpty(acls) && acls.access === 'no' && acls.view === 'no') {
                    //This happens when the user creates a record he won't have access to.
                    //In this case the POST request returns a 200 code with empty response and acls set to no.
                    this.alerts.showSuccessButDeniedAccess.call(this);
                    callback(false);
                } else {
                    this._dismissAllAlerts();
                    app.alert.show('create-success', {
                        level: 'success',
                        messages: this.buildSuccessMessage(this.model),
                        autoClose: true,
                        autoCloseDelay: 10000,
                        onLinkClick: function() {
                            app.alert.dismiss('create-success');
                        }
                    });
                    callback(false);
                }
            }, this),
            error = _.bind(function (e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    if (e.status == 403) {
                        this.alerts.showNoAccessError.call(this);
                    } else {
                        this.alerts.showServerError.call(this);
                    }
                    callback(true);
                }
            }, this);

        this.saveModel(success, error);
    },

    /**
     * Check the server to see if there are possible duplicate records.
     * @param success
     * @param error
     */
    checkForDuplicate: function (success, error) {
        var options = {
            //Show alerts for this request
            showAlerts: true,
            success: success,
            error: error
        };

        this.context.trigger("dupecheck:fetch:fire", this.model, options);
    },

    /**
     * Duplicate found: display duplicates and change buttons
     */
    handleDuplicateFound: function () {
        this.setButtonStates(this.STATE.DUPLICATE);
        this.dupecheckList.show();
    },

    /**
     * Clear out all things related to duplicate checks
     */
    resetDuplicateState: function () {
        this.setButtonStates(this.STATE.CREATE);
        this.hideDuplicates();
    },

    /**
     * Called when current record is being saved to allow customization of options and params
     * during save
     *
     * Override to return set of custom options
     *
     * @param {Object} options The current set of options that is going to be used.  This is hand for extending
     */
    getCustomSaveOptions: function (options) {
        return {};
    },

    /**
     * Create a new record
     * @param success
     * @param error
     */
    saveModel: function (success, error) {
        var self = this,
            options;
        options = {
            success: success,
            error: error,
            viewed: true,
            relate: (self.model.link) ? true : null,
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': false,
                'error': false //error callback implements its own error handler
            },
            lastSaveAction: this.context.lastSaveAction
        };
        this.applyAfterCreateOptions(options);

        // Check if this has subpanel create models
        if (this.hasSubpanelModels) {
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel')) {
                    // create the child collection JSON structure to save
                    var childCollection = {
                        create: []
                    };

                    // loop through the models in the collection and push each model's JSON
                    // data to the 'create' array
                    _.each(child.get('collection').models, function(model) {
                        childCollection.create.push(model.toJSON())
                    }, this)

                    // set the child JSON collection data to the model
                    this.model.set(child.get('link'), childCollection);
                }
            }, this);
        }

        options = _.extend({}, options, self.getCustomSaveOptions(options));
        self.model.save(null, options);
    },

    /**
     * Apply after_create parameters to the URL to specify operations to execute after creating a record.
     * @param options
     */
    applyAfterCreateOptions: function(options) {
        var copiedFromModelId = this.context.get('copiedFromModelId');

        if (copiedFromModelId && this.model.isCopy()) {
            options.params = options.params || {};
            options.params.after_create = {
                copy_rel_from: copiedFromModelId
            };
        }
    },

    /**
     * Using the model returned from the API call, build the success message
     * @param model
     * @return {string}
     */
    buildSuccessMessage: function(model) {
        var modelAttributes,
            successLabel = 'LBL_RECORD_SAVED_SUCCESS',
            successMessageContext;

        //if we have model attributes, use them to build the message, otherwise use a generic message
        if (model && model.attributes) {
            modelAttributes = model.attributes;
        } else {
            modelAttributes = {};
            successLabel = 'LBL_RECORD_SAVED';
        }

        //use the model attributes combined with data from the view to build the success message context
        successMessageContext = _.extend({
            module: this.module,
            moduleSingularLower: this.moduleSingular.toLowerCase()
        }, modelAttributes);

        return app.lang.get(successLabel, this.module, successMessageContext);
    },

    /**
     * Check to see if we should skip duplicate check.
     *
     * Duplicate check should be skipped if we are displaying duplicates or user
     * has switched over to editing an existing duplicate record.
     *
     * @return {boolean}
     */
    skipDupeCheck: function () {
        var skipStates = [this.STATE.DUPLICATE, this.STATE.SELECT];
        return (_.contains(skipStates, this.getCurrentButtonState()));
    },

    /**
     * Clears out field values
     */
    clear: function () {
        this.model.clear();
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Make the specified record as the data to be edited, and merge the existing data.
     * @param model
     */
    editExisting: function (model) {
        var origAttributes = this.saveFormData();

        this.model.clear();
        this.model.set(this.extendModel(model, origAttributes));

        if (this.model.link) {
            this.model.link.isNew = false;
        }

        this.createMode = false;
        if (!this.disposed) {
            this.render();
        }
        this.toggleEdit(true);

        this.hideDuplicates();
        this.setButtonStates(this.STATE.SELECT);
    },

    /**
     * Merge the selected record with the data entered in the form
     * @param newModel
     * @param origAttributes
     * @return {Object}
     */
    extendModel: function (newModel, origAttributes) {
        var modelAttributes = _.clone(newModel.attributes);

        _.each(modelAttributes, function (value, key) {
            if (_.isUndefined(value) || _.isNull(value) ||
                ((_.isObject(value) || _.isArray(value) || _.isString(value)) && _.isEmpty(value))) {
                delete modelAttributes[key];
            }
        });

        return _.extend({}, origAttributes, modelAttributes);
    },

    /**
     * Save the data entered in the form
     * @return {Object}
     */
    saveFormData: function () {
        this._origAttributes = _.clone(this.model.attributes);
        return this._origAttributes;
    },

    /**
     * Sets the dupecheck list type
     *
     * @param {String} type view to load
     */
    setDupeCheckType: function(type) {
        this.context.set('dupelisttype', type);
    },

    /**
     * Render duplicate check list table
     */
    renderDupeCheckList: function () {
        this.setDupeCheckType('dupecheck-list-edit');
        this.context.set('collection', this.createDuplicateCollection(this.model));

        if (_.isNull(this.dupecheckList)) {
            this.dupecheckList = app.view.createLayout({
                context: this.context,
                name: 'create-dupecheck',
                module: this.module
            });
            this.dupecheckList.initComponents();
            this.addToLayoutComponents(this.dupecheckList);
        }

        this.$('.headerpane').after(this.dupecheckList.$el);
        this.dupecheckList.hide();
        this.dupecheckList.render();
    },

    /**
     * Add component to layout's component list so it gets cleaned up properly on dispose
     *
     * @param component
     */
    addToLayoutComponents: function (component) {
        this.layout._components.push(component);
    },

    /**
     * If initialized (depends on this.enableDuplicateCheck flag) hides the
     * duplicate list.
     */
    hideDuplicates: function () {
        if (this.dupecheckList) {
            this.dupecheckList.hide();
        }
    },

    /**
     * Disable buttons
     */
    disableButtons: function () {
        this.toggleButtons(false);
    },

    /**
     * Enable buttons
     */
    enableButtons: function () {
        this.toggleButtons(true);
    },

    registerShortcuts: function() {
        this._super('registerShortcuts');

        app.shortcuts.register('Create:Save', ['ctrl+s','ctrl+alt+a'], function() {
            var $saveButton = this.$('a[name=' + this.saveButtonName + ']');
            if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                $saveButton.get(0).click();
            }
        }, this, true);

        app.shortcuts.register('Create:Cancel', ['esc','ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=' + this.cancelButtonName + ']');
            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.get(0).click();
            }
        }, this, true);
    }
}) },
"quicksearch-taglist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagListView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagListView
 * @extends View.View
 */
({
	// Quicksearch-taglist View (base) 

    className: 'table-cell quicksearch-selected-tags',

    events: {
        'click .tag-remove': 'removeTagClicked',
        'click .tag-name': 'highlightTagClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.selectedTags = this.layout.selectedTags || [];

        this.activeIndex = null;

        // Listener for quicksearch tag additions
        this.layout.on('quicksearch:tag:add', this.addTag, this);

        this.layout.on('quicksearch:tags:remove', this.removeAllTags, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.selectedTags.length - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.tag-wrapper').removeClass('highlight');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', function() {
            this.layout.off('route:search', this.populateTagsFromContext);
            this.layout.on('route:search', this.populateTagsFromContext, this);
        }, this);

        this.context.on('tagsearch:fire:new', this.populateTagsFromContext, this);
    },

    /**
     * Populate the taglist with the tags specified in the context. Call a search if param is true
     */
    populateTagsFromContext: function() {
        var tagNames = this.context.get('tagParams');
        // If no tagNames, just move onto the regular search
        if (!tagNames || !tagNames.length) {
            this.selectedTags.splice(0, this.selectedTags.length);
            this.render();
            this.context.set('tags', []);
            this.context.trigger('search:fire:new');
            return;
        }
        var tags = app.data.createBeanCollection('Tags');
        var self = this;
        var tagNamesLowerCase = _.map(tagNames, function(tagName) {
            return tagName.toLowerCase();
        });

        tags.filterDef = {
            'filter': [{
                'name_lower': { '$in': tagNamesLowerCase }
            }]
        };

        tags.fetch({
            // Arbitrary large number, in case user wants to search by more than 20 tags.
            limit: 100,
            success: function(collection) {
                //Remove internal tag list and then re add the ones that should be there
                self.selectedTags.splice(0, self.selectedTags.length);
                _.each(collection.models, function(tag) {
                    self.selectedTags.push({id: tag.get('id'), name: tag.get('name')});
                });
                self.render();

                //Push completed tag objects to context
                self.context.set('tags', self.selectedTags);
                self.layout.trigger('quicksearch:button:toggle', false);

                self.context.trigger('search:fire:new');
            },
            error: function(e) {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Returns true if there are tags to focus. Otherwise, false.
     */
    isFocusable: function() {
        return this.selectedTags && this.selectedTags.length;
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        $(document).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        $(document).off('keydown.' + this.cid);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 37: // left arrow
                this.moveLeft();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 8:  // backspace
            case 46: // del
                this.handleBackspace();
                e.stopPropagation();
                e.preventDefault();
                break;
            default:
                this.layout.trigger('navigate:to:component', 'quicksearch-bar');
                break;
        }
    },

    /**
     * Handler for the backspace/delete keys. Removes tag if one is highlighted, then highlights a new tag
     * or re-focuses the search bar
     */
    handleBackspace: function() {
        this.removeTag(false);

        if (this.selectedTags.length) {
            // If there is a tag to the left of the removed tag, highlight it
            // If tagIndex is 0, highlight whatever is left at index 0.
            if (this.activeIndex > 0) {
                this.activeIndex--;
            }
            this._highlightActive();
        } else {
            // If no tags are left, automatically give focus back to whatever is to the right
            this.moveRight();
        }
    },

    /**
     * Adds a tag to the page
     * @param {Object} tag
     */
    addTag: function(tag) {
        if (tag && tag.name) {
            // If tag already exists do nothing
            if (!_.find(this.selectedTags, function(tagToCheck) {
                return tagToCheck.name === tag.name;
            })) {
                this.selectedTags.push(tag);
                this.render();
                this.layout.trigger('quicksearch:fire:search', true);
            }
        }
    },

    /**
     * Remove a specific tag
     * @param {jQuery || boolean} $tagParam - jQuery representation of tag pill. Optional
     * (if it doesn't exist, default to activeIndex)
     */
    removeTag: function($tagParam) {
        // Only continue if we have either a $tag param or an activeIndex
        if (!$tagParam && _.isNull(this.activeIndex)) {
            return;
        }

        var $tag = $tagParam || this.$('.tag-wrapper:eq(' + this.activeIndex + ')');

        // Remove the selected tag from the internal tag list
        var index = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
        this.selectedTags.splice(index, 1);

        // Remove the selected tag from the DOM
        $tag.remove();

        this.layout.trigger('quicksearch:fire:search', true);
    },

    /**
     * Click handler for tag removal element
     * @param {Event} e
     */
    removeTagClicked: function(e) {
        e.preventDefault();
        e.stopPropagation();
        var $tag = this.$(e.target).parent();
        this.removeTag($tag);
        this.$('.tag-wrapper').removeClass('highlight');

        // Go back to the quicksearch bar to prevent any shenanigans (only on click)
        this.layout.trigger('navigate:to:component', 'quicksearch-bar');
    },

    /**
     * Removes all tags from search bar (When searchbar's "X" is clicked)
     */
    removeAllTags: function() {
        // Remove all tags from the tags array (and the layout tag array since other views share that)
        this.selectedTags.splice(0, this.selectedTags.length);
        this.activeIndex = null;
        this.$('.tag-wrapper').remove();
    },


    /**
     * Click handler for tag highlighting
     * @param {Event} e
     */
    highlightTagClicked: function(e) {
        this.requestFocus();

        // Set highlight class
        this.$('.tag-wrapper').removeClass('highlight');
        var $tag = this.$(e.target).parent();
        $tag.addClass('highlight');

        // Set activeIndex
        this.activeIndex = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
    },

    /**
     * Highlights a specific tag element.
     */
    _highlightActive: function() {
        this.$('.tag-wrapper').removeClass('highlight');
        this.$('.tag-wrapper:eq(' + this.activeIndex + ')').addClass('highlight');
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Move to the next the active element.
     */
    moveRight: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.selectedTags.length - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveLeft: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.tag-wrapper').removeClass('highlight');
        this.disposeKeydownEvent();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"dashlet-cell-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletCellEmptyView
 * @alias SUGAR.App.view.views.BaseDashletCellEmptyView
 * @extends View.View
 */
({
	// Dashlet-cell-empty View (base) 

    events: {
        'click .dashlet.empty' : 'addClicked'
    },
    originalTemplate: null,
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        //use the dashboard model rather than the current page's
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
    },
    addClicked: function(evt) {
        var self = this;
        app.drawer.open({
            layout: 'dashletselect',
            context: this.layout.context
        }, function(model) {
            if(!model) return;
            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module"),
                        link: model.get("link")
                    }
                },
                type = conf.componentType;
            delete conf.config;
            delete conf.componentType;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.layout.addDashlet(dash);
        });
    },
    setMode: function(type) {
        if(type === 'edit') {
            this.template = this.originalTemplate;
        } else if(type === 'drag') {
            this.template = app.template.getView(this.name + '.drop') || this.originalTemplate;
        } else {
            this.template = app.template.getView(this.name + '.empty') || app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"filter-module-dropdown-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Adds ability switch modules with filter module dropdown.
 *
 * Part of {@link View.Layouts.Base.SelectionListModuleSwitchLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownSelectionListView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownSelectionListView
 * @extends View.Views.Base.FilterModuleDropdownView
 */
({
	// Filter-module-dropdown-selection-list View (base) 

    extendsFrom: 'FilterModuleDropdownView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.template = app.template.get('filter-module-dropdown');
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * @return {Object}
     */
    getFilterList: function() {
        var filterList = this.context.get('filterList');

        if (this.layout.showingActivities) {
            filterList = this._super('getFilterList');
        }

        return filterList;
    },

    /**
     * @inheritdoc
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return false;
    },

    /**
     * Set the value of the filter to be the current module.
     * @private
     */
    _renderDropdown: function() {
        this._super('_renderDropdown');
        if (this.filterNode) {
            this.filterNode.select2('val', this.module);
        }
    },

    /**
     * Trigger event to reload the layout when the module changes.
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (!silent) {
            this.context.trigger('selection-list:reload', linkModuleName);
        }
    },

    /**
     * Always returns the module with a downward-facing caret button for
     * selecting other modules.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        return app.lang.get('LBL_MODULE') + '<i class="fa fa-caret-down"></i>';
    }
}) },
"forecast-pareto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashlet that displays a chart.
 *
 * @class View.Views.Base.ForecastParetoView
 * @alias SUGAR.App.view.views.BaseForecastParetoView
 * @extends View.View
 */
({
	// Forecast-pareto View (base) 

    plugins: ['Dashlet', 'Tooltip'],

    className: 'forecasts-chart-wrapper',

    /**
     * Should we display the timeperiod Pivot options
     */
    displayTimeperiodPivot: true,

    /**
     * Track if they are a manager
     */
    isManager: false,

    /**
     * Track if the user is a top-level manager
     */
    isTopLevelManager: false,

    /**
     * When on a Record view this are fields we should listen to changes in
     */
    validChangedFields: ['amount', 'likely_case', 'best_case', 'worst_case', 'assigned_user_id',
        'date_closed', 'date_closed_timestamp', 'probability', 'commit_stage', 'sales_stage'],

    /**
     * Hold the initOptions if we have to call the Forecast/init end point cause we are not on Forecasts
     */
    initOptions: null,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Holds the Forecast Module Config
     */
    forecastConfig: undefined,

    /**
     * Are we using Opportunities with RevenueLineItems?
     */
    opportunitiesWithRevenueLineItems: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        // if the user is a manager, check if they're toplevel or not
        if (this.isManager) {
            this.isTopLevelManager = app.user.get('is_top_level_manager');
        }

        // if the parent exists, use it, otherwise use the main context
        this.initOptions = options;
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();

        var oppConfig = app.metadata.getModule('Opportunities', 'config');
        if (oppConfig && oppConfig['opps_view_by'] === 'RevenueLineItems') {
            this.opportunitiesWithRevenueLineItems = true;
        } else {
            this.opportunitiesWithRevenueLineItems = false;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.initOptions.meta.template = undefined;

            if (!options.meta.config) {
                // we only want to call this if forecast is setup and configured
                // and this is not the dashlet config screen
                app.api.call('GET', app.api.buildURL('Forecasts/init'), null, {
                    success: _.bind(this.forecastInitCallback, this),
                    complete: this.initOptions ? this.initOptions.complete : null
                });
            }

            this.displayTimeperiodPivot = (options.context.get('module') === 'Home');
        } else {
            // set the no access template
            this.initOptions.meta.template = 'forecast-pareto.no-access';
            var isAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(isAdmin);
        }

        this._super('initialize', [this.initOptions]);
    },

    /**
     * @inheritdoc
     */
    getLabel: function() {
        return app.lang.get(this.meta.label);
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is rendered from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }
        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.settings.module = 'Forecasts';
        }
        var fieldOptions = app.lang.getAppListStrings(this.dashletConfig.dataset.options),
            cfg = app.metadata.getModule('Forecasts', 'config');
        this.dashletConfig.dataset.options = {};

        if (cfg.show_worksheet_worst &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'worst_case')) {
            this.dashletConfig.dataset.options['worst'] = fieldOptions['worst'];
        }

        if (cfg.show_worksheet_likely) {
            this.dashletConfig.dataset.options['likely'] = fieldOptions['likely'];
        }

        if (cfg.show_worksheet_best &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'best_case')) {
            this.dashletConfig.dataset.options['best'] = fieldOptions['best'];
        }

        // Hide dataset drop-down if there is only one option.
        this.dashletConfig.show_dataset = true;
        if (_.size(this.dashletConfig.dataset.options) <= 1) {
            this.dashletConfig.show_dataset = false;
        }
    },

    /**
     * Callback function for Forecasts/init success
     */
    forecastInitCallback: function(initData) {
        if (this.disposed) {
            return;
        }
        var defaultOptions = {
            user_id: app.user.get('id'),
            // Default to 'user' view for reps, and 'group' view for managers.
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isManager && !this.isTopLevelManager),
            selectedTimePeriod: initData.defaultSelections.timeperiod_id.id,
            timeperiod_id: initData.defaultSelections.timeperiod_id.id,
            timeperiod_label: initData.defaultSelections.timeperiod_id.label,
            dataset: initData.defaultSelections.dataset,
            group_by: initData.defaultSelections.group_by,
            ranges: _.keys(app.lang.getAppListStrings(this.forecastConfig.buckets_dom))
        };

        var model = this._getNonForecastModel();

        if (model && !this.displayTimeperiodPivot && model.has('date_closed_timestamp') &&
            model.get('date_closed_timestamp') != 0) {
            // if we have a timestamp, use it, otherwise just default to the current time period
            defaultOptions.timeperiod_id = model.get('date_closed_timestamp');
        } else {
            this.layout.setTitle(this.getLabel() + ' ' + defaultOptions.timeperiod_label);
        }
        this.settings.set(defaultOptions);
    },

    /**
     * Overwrite loadData so the default behavior doesn't happen
     *
     * @override
     */
    loadData: function(options) {
        if (options && _.isFunction(options.complete)) {
            options.complete();
        }
    },

    _render: function() {
        this.settings.set('display_manager', this.isDisplayManager());
        this.spanSize = this.displayTimeperiodPivot && this.dashletConfig.show_dataset ? 'span4' : 'span6';
        this._super('_render');

        var chartField = this.getField('paretoChart');

        if (!_.isUndefined(chartField)) {
            chartField.renderChart();
            chartField.once('chart:pareto:rendered', function() {
                this.addRowToChart();
            }, this);
        }
    },

    /**
     * Called after _render
     */
    toggleRepOptionsVisibility: function() {
        var mgrToggleOffset;
        if (this.settings.get('display_manager') === true) {
            mgrToggleOffset = 6;
            this.$el.find('div.groupByOptions').addClass('hide');
        } else {
            mgrToggleOffset = 3;
            this.$el.find('div.groupByOptions').removeClass('hide');
        }

        if (this.displayTimeperiodPivot) {
            mgrToggleOffset = mgrToggleOffset - 3;
        }

        if (this.isManager) {
            var el = this.$el.find('#' + this.cid + '-mgr-toggle');
            if (el.length > 0) {
                var classes = el.attr('class').split(' ').filter(function(item) {
                    return item.indexOf('offset') === -1 ? item : '';
                });
                if (mgrToggleOffset != 0) {
                    classes.push('offset' + mgrToggleOffset);
                }
                el.attr('class', classes.join(' '));
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function(event) {
        this.settings.set({
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isDisplayManager() && !this.isTopLevelManager)
        });
    },

    /**
     * Calculates "display_manager" option according to visibility.
     *
     * @return {Boolean}
     */
    isDisplayManager: function() {
        return this.isManager ? (this.getVisibility() === 'group') : false;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // on the off chance that the init has not run yet.
        var meta = this.meta || this.initOptions.meta;
        if (meta.config) {
            return;
        }

        // if we don't have a context, this shouldn't run yet.
        if (_.isUndefined(this.context)) {
            return;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.on('render', function() {
                var chartField = this.getField('paretoChart'),
                    dashletToolbar = this.layout.getComponent('dashlet-toolbar');

                // if we have a dashlet-toolbar, then make it do the refresh icon
                // while the chart is loading from the server
                if (chartField && dashletToolbar) {
                    chartField.before('chart:pareto:render', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
                    }, dashletToolbar);
                    chartField.on('chart:pareto:rendered', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconRefresh).addClass(this.cssIconDefault);
                    }, dashletToolbar);
                }
            }, this);

            this.settings.on('change:title', function(model, title) {
                this.layout.setTitle(this.getLabel() + title);
            }, this);

            this.settings.on('change:display_manager', this.toggleRepOptionsVisibility, this);

            if (!this.displayTimeperiodPivot) {
                this.findModelToListen();
                this.listenModel.on('change', this.handleDataChange, this);
            } else {
                this.settings.on('change:selectedTimePeriod', function(context, timeperiod) {
                    this.settings.set({timeperiod_id: timeperiod});
                }, this);
            }
        }
    },

    findModelToListen: function() {
        this.listenModel = this._getNonForecastModel();
    },

    /**
     * Utility Method to find the proper model to use, if this.model.module is forecasts, go up to the parent context
     * and use the model that's attached to it otherwise return this.model
     *
     * @return {Backbone.Model|Data.Bean}
     * @private
     */
    _getNonForecastModel: function() {
        if (this.model.module == 'Forecasts') {
            return this.context.parent.get('model');
        }

        return this.model;
    },

    /**
     * Handler for when the model changes
     * @param {Object} [model]      The model that changed, if not provided, it will use this.model
     */
    handleDataChange: function(model) {
        model = model || this._getNonForecastModel();
        var changed = model.changed,
            changedField = _.keys(changed),
            validChangedFields = _.intersection(this.validChangedFields, _.keys(changed)),
            changedCurrencyFields = _.intersection(
                ['amount', 'best_case', 'likely_case', 'worst_case'],
                validChangedFields
            ),
            assigned_user = model.get('assigned_user_id');

        // lets make sure that the values actually changed on the currencies,
        // this is needed because the server will send back the values with out .00 on the end and the model has .00
        // so it looks like it changed, when in fact it didn't so don't worry about this change
        if (!_.isEmpty(changedCurrencyFields)) {
            _.each(changedCurrencyFields, function(field) {
                if (parseFloat(model.get(field)) == parseFloat(model.previous(field))) {
                    validChangedFields = _.without(validChangedFields, field);
                }
            });
        }

        // dump out if it's not a field we are watching
        if (_.isEmpty(validChangedFields)) {
            return;
        }

        if (this.settings.get('display_manager') === false && assigned_user == app.user.get('id')) {
            // we can update this chart
            // get what we are currently filtered by
            // find the item in the serverData
            var field = this.getField('paretoChart'),
                serverData = field.getServerData();

            if (!field.hasServerData()) {
                // if the field does not have server data, that means it's re-rendering the chart already,
                // just bail out
                return;
            }

            // if we only have one changed field and it's the date_closed, lets map it to a timestamp.
            // this happens on the Opp -> RLI Subpanel since we don't have SugarLogic Support in ListViews
            if (changedField.length == 1 && changedField[0] == 'date_closed') {
                // convert this into the timestamp
                changedField.push('date_closed_timestamp');
                changed.date_closed_timestamp = Math.round(+app.date.parse(changed.date_closed).getTime() / 1000);
                model.set('date_closed_timestamp', changed.date_closed_timestamp, {silent: true});
            }

            // before we do anything, lets make sure that if the date_changed, make sure it's still in this range,
            // if it's not force the chart to update to the new timeperiod that is valid for this row, then add this
            // row to the new timeperiod
            if (_.contains(changedField, 'date_closed_timestamp')) {
                if (!(model.get('date_closed_timestamp') >= _.first(serverData['x-axis']).start_timestamp &&
                    model.get('date_closed_timestamp') <= _.last(serverData['x-axis']).end_timestamp)) {

                    // lets check to see, if we have a collection as the listenModel, then just remove the row if there
                    // is more than one record in the collection
                    if (this.listenModel instanceof Backbone.Collection) {
                        if (this.listenModel.length > 1) {
                            this.removeRowFromChart(model);
                            return;
                        }
                    }
                    // we just have a model, so lets just update it
                    field.once('chart:pareto:rendered', function() {
                        this[0].addRowToChart(this[1]);
                    }, [this, model]);
                    this.settings.set('timeperiod_id', model.get('date_closed_timestamp'));
                    return;
                }
            }

            // Amount on Opportunity maps to likely in the data set
            if (_.contains(changedField, 'amount')) {
                changed.likely = this._convertCurrencyValue(changed.amount, model.get('base_rate'));
                delete changed.amount;
            }
            // Likely Case in RLI
            if (_.contains(changedField, 'likely_case')) {
                changed.likely = this._convertCurrencyValue(changed.likely_case, model.get('base_rate'));
                delete changed.likely_case;
            }

            if (_.contains(changedField, 'best_case')) {
                changed.best = this._convertCurrencyValue(changed.best_case, model.get('base_rate'));
                delete changed.best_case;
            }
            if (_.contains(changedField, 'worst_case')) {
                changed.worst = this._convertCurrencyValue(changed.worst_case, model.get('base_rate'));
                delete changed.worst_case;
            }

            if (_.contains(changedField, 'commit_stage')) {
                changed.forecast = changed.commit_stage;
                delete changed.commit_stage;
            }

            var record = _.find(serverData.data, function(record, i, list) {
                if (model.get('id') == record.record_id) {
                    list[i] = _.extend({}, record, changed);
                    return true;
                }
                return false;
            });

            // the row was not found, lets add it
            if (_.isEmpty(record)) {
                this.addRowToChart(model);
            } else {
                field.setServerData(serverData, _.contains(changedField, 'probability'));
            }
        } else if (_.contains(changedField, 'assigned_user_id')) {
            if (assigned_user === app.user.get('id')) {
                this.addRowToChart(model);
            } else {
                this.removeRowFromChart(model);
            }
        }
    },

    /**
     * Add the model to the pareto chart
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    addRowToChart: function(model) {
        model = model || this._getNonForecastModel();
        if (model.get('assigned_user_id') == app.user.get('id') && !this.settings.get('display_manager')) {
            var field = this.getField('paretoChart'),
                serverData = field.getServerData(),
            // make sure it doesn't exist in the serverdata
                found = _.find(serverData.data, function(record) {
                    return (record.record_id == model.get('id'));
                }),
                base_rate = model.get('base_rate'),
                likely_field = model.has('amount') ? model.get('amount') : model.get('likely_case');

            if (_.isEmpty(found)) {
                serverData.data.push({
                    best: this._convertCurrencyValue(model.get('best_case'), base_rate),
                    likely: this._convertCurrencyValue(likely_field, base_rate),
                    worst: this._convertCurrencyValue(model.get('worst_case'), base_rate),
                    record_id: model.get('id'),
                    date_closed_timestamp: model.get('date_closed_timestamp'),
                    probability: model.get('probability'),
                    sales_stage: model.get('sales_stage'),
                    forecast: model.get('commit_stage')
                });
                field.setServerData(serverData, true);
            }
        }
    },

    /**
     * Utility Method to convert to base rate
     * @param {Number} value
     * @param {Number} base_rate
     * @return {Number}
     * @protected
     */
    _convertCurrencyValue: function(value, base_rate) {
        return app.currency.convertWithRate(value, base_rate);
    },

    /**
     * Get the server data from the ParetoField and if the model exists in the data, remove it
     *
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    removeRowFromChart: function(model) {
        model = model || this._getNonForecastModel();
        var field = this.getField('paretoChart'),
            serverData = field.getServerData();

        _.find(serverData.data, function(record, i, list) {
            if (model.get('id') == record.record_id) {
                list.splice(i, 1);
                return true;
            }
            return false;
        });

        field.setServerData(serverData, true);
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        var ctx = this.context.parent;
        if (ctx) {
            ctx.off(null, null, this);
        }
        if (this.listenModel) this.listenModel.off(null, null, this);
        if (this.context) this.context.off(null, null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {BaseForecastParetoView} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    }
}) },
"tabbed-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Tabbed dashlet is an abstraction that allows new tabbed dashlets to be
 * easily created based on a metadata driven configurable set of tabs, where
 * each new tab is created under a tabs array, where a specific set of
 * properties can be defined.
 *
 * Supported properties:
 *
 * - {Boolean} active If specific tab should be active by default.
 * - {String} filter_applied_to Date field to be used on date switcher, defaults
 *   to date_entered.
 * - {Array} filters Array of filters to be applied.
 * - {String} label Tab label.
 * - {Array} labels Array of labels (singular/plural) to be applied when
 *   LBL_MODULE_NAME_SINGULAR and LBL_MODULE_NAME aren't available or there's a
 *   need to use custom labels depending on the number of records available.
 * - {String} link Relationship link to be used if we're on a record view
 *   context, leading to only associated records being shown.
 * - {String} module Module from which the records are retrieved.
 * - {String} order_by Sort records by field.
 * - {String} record_date Date field to be used to print record date, defaults
 *   to 'date_entered' if none supplied.
 * - {Array} row_actions Row actions to be applied to each record.
 *
 * Example:
 * <pre><code>
 * // ...
 * 'tabs' => array(
 *     array(
 *         'filter_applied_to' => 'date_entered',
 *         'filters' => array(
 *             'type' => array('$equals' => 'out'),
 *         ),
 *         'labels' => array(
 *             'singular' => 'LBL_DASHLET_EMAIL_OUTBOUND_SINGULAR',
 *             'plural' => 'LBL_DASHLET_EMAIL_OUTBOUND_PLURAL',
 *         ),
 *         'link' => 'emails',
 *         'module' => 'Emails',
 *     ),
 *     //...
 * ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.TabbedDashletView
 * @alias SUGAR.App.view.views.BaseTabbedDashletView
 * @extends View.View
 */
({
	// Tabbed-dashlet View (base) 

    plugins: ['Dashlet', 'RelativeTime', 'ToggleVisibility', 'Tooltip', 'Pagination'],

    events: {
        'click [data-action=show-more]': 'showMore',
        'click [data-action=tab-switcher]': 'tabSwitcher'
    },

    /**
     * Default settings used when none are provided via metadata.
     *
     * @template
     * @protected
     */
    _defaultSettings: {},

    /**
     * @inheritdoc
     *
     * Bind the separate context to avoid sharing context's handlers
     * between its extension dashlets.
     */
    initDashlet: function() {
        this._initSettings();
        if (this.meta.config) {
            return;
        }

        this.collection = app.data.createBeanCollection(this.module);
        this.context = this.context.getChildContext({
            forceNew: true,
            model: this.context.parent && this.context.parent.get('model'),
            collection: this.collection,
            //FIXME: name is temporary - special case for LinkedModel - SC-2550
            name: 'tabbed-dashlet',
            skipFetch: true
        });

        this.context.set('parentModule', this.module);

        this._initMaxHeightTarget();
        this._initEvents();
        this._initTabs();
        this._initTemplates();
    },

    /**
     * Initialize max height target element by overriding it's value and
     * setting it to a specific tab inner element.
     *
     * @return {View.Views.BaseTabbedDashletView} Instance of this view.
     * @template
     * @protected
     */
    _initMaxHeightTarget: function() {
        this.maxHeightTarget = this.meta.max_height_target || 'div.tab-content';

        return this;
    },

    /**
     * Initialize events.
     *
     * @return {View.Views.BaseTabbedDashletView} Instance of this view.
     * @template
     * @protected
     */
    _initEvents: function() {
        this.settings.on('change:filter', this.loadData, this);
        this.on('tabbed-dashlet:unlink-record:fire', this.unlinkRecord, this);
        this.context.on('tabbed-dashlet:refresh', this.refreshTabsForModule, this);
        this.context.on('change:collection', this.onCollectionChange, this);

        return this;
    },

    /**
     * Initialize tabs.
     *
     * @return {View.Views.BaseTabbedDashletView} Instance of this view.
     * @protected
     */
    _initTabs: function() {
        this.tabs = [];
        _.each(this.dashletConfig.tabs, function(tab, index) {
            if (tab.active) {
                this.settings.set('activeTab', index);
            }

            var collection = this._createCollection(tab);
            if (_.isNull(collection)) {
                return;
            }

            collection.on('add', this.bindCollectionAdd, this);
            collection.on('reset', this.bindCollectionReset, this);

            this.tabs[index] = tab;
            this.tabs[index].collection = collection;
            this.tabs[index].relate = _.isObject(collection.link);
            this.tabs[index].record_date = tab.record_date || 'date_entered';
            this.tabs[index].include_child_items = tab.include_child_items || false;
        }, this);

        return this;
    },

    /**
     * Initialize templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `custom/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     *
     * @return {View.Views.BaseTabbedDashletView} Instance of this view.
     * @template
     * @protected
     */
    _initTemplates: function() {
        this._tabsTpl = app.template.getView(this.name + '.tabs', this.module) ||
            app.template.getView(this.name + '.tabs') ||
            app.template.getView('tabbed-dashlet.tabs', this.module) ||
            app.template.getView('tabbed-dashlet.tabs');

        this._toolbarTpl = app.template.getView(this.name + '.toolbar', this.module) ||
            app.template.getView(this.name + '.toolbar') ||
            app.template.getView('tabbed-dashlet.toolbar', this.module) ||
            app.template.getView('tabbed-dashlet.toolbar');

        return this;
    },

    /**
     * Sets up settings, starting with defaults.

     * @return {View.Views.BaseTabbedDashletView} Instance of this view.
     * @protected
     */
    _initSettings: function() {
        var settings = _.extend({},
            this._defaultSettings,
            this.settings.attributes);

        this.settings.set(settings);

        return this;
    },

    /**
     * New model related properties are injected into each model.
     * Update the record date associating by tab's record date value.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var tab = this._getTab(model.collection);
        model.set('record_date', model.get(tab.record_date));
    },

    /**
     * Bind event trigger's for each updated models on collection reset.
     *
     * @param {BeanCollection} collection Activated tab's collection.
     */
    bindCollectionReset: function(collection) {
        _.each(collection.models, this.bindCollectionAdd, this);
    },

    /**
     * Bind event listener for the updating collection count on the tab.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, this.updateCollectionCount, this);
        }
        this.collection = this.context.get('collection');
        this.collection.on('add remove reset', _.debounce(this.updateCollectionCount, 100), this);
    },

    /**
     * Update the collection's count on the active tab.
     */
    updateCollectionCount: function() {
        var tabIndex = this.settings.get('activeTab'),
            count = this.collection.length;

        if (this.collection.next_offset >= 0) {
            count += '+';
        }
        this.$('[data-action=tab-switcher][data-index=' + tabIndex + ']')
            .children('[data-action=count]')
            .text(count);
    },

    /**
     * Retrieve records template.
     *
     * This will get the template from either the active tab associated module,
     * from the current module (since we might want to customize it per module)
     * or from core templates.
     *
     * Please define your template on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/records.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/records.hbs`
     *
     * @param {String} module Module name.
     * @return {Function} Template function.
     * @protected
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * Create collection based on tab properties and current context,
     * furthermore if supplied tab has a valid 'link' property a related
     * collection will be created instead.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection} A new instance of bean collection or null
     *   if we cannot access module metadata.
     * @protected
     */
    _createCollection: function(tab) {
        if (this.context.parent) {
            var module = this.context.parent.get('module');
        } else {
            var module = this.module;
        }

        var meta = app.metadata.getModule(module);
        if (_.isUndefined(meta)) {
            return null;
        }

        var options = {};
        if (meta.fields[tab.link] && meta.fields[tab.link].type === 'link') {
            options = {
                link: {
                    name: tab.link,
                    bean: this.model
                }
            };
        }

        var collection = app.data.createBeanCollection(tab.module, null, options);

        return collection;
    },

    /**
     * Retrieves collection options for a specific tab.
     *
     * @param {Integer} index Tab index.
     * @return {Object} Collection options.
     * @protected
     */
    _getCollectionOptions: function(index) {
        var tab = this.tabs[index],
            options = {
                limit: this.settings.get('limit'),
                offset: 0,
                params: {
                    order_by: tab.order_by || null,
                    include_child_items: tab.include_child_items || null
                },
                fields: tab.fields || null
            };

        if (tab.module != 'Meetings' && tab.module != 'Calls') {
            options.myItems = this.getVisibility() === 'user';
        }

        return options;
    },

    /**
     * Retrieves collection filters for a specific tab.
     *
     * @param {Integer} index Tab index.
     * @return {Array} Collection filters.
     * @protected
     */
    _getCollectionFilters: function(index) {
        var tab = this.tabs[index],
            filters = [];

        _.each(tab.filters, function(condition, field) {
            var filter = {};
            filter[field] = condition;

            filters.push(filter);
        });

        if ((tab.module === 'Meetings' || tab.module === 'Calls')
            && this.getVisibility() === 'user') {
            filters.push({
                "$or":[{"assigned_user_id":app.user.id},
                       {"users.id":app.user.id}]
            });
        }
        
        return filters;
    },

    /**
     * Retrieves tab based on supplied collection.
     *
     * @param {Object} collection Collection of the desired tab.
     * @return {Object} Tab.
     * @private
     */
    _getTab: function(collection) {
        return _.find(this.tabs, function(tab) {
            return tab.collection === collection;
        }, this);
    },

    /**
     * Override this method to provide custom filters.
     *
     * @param {Integer} index Tab index.
     * @return {Array} Custom filters.
     * @template
     * @protected
     */
    _getFilters: function(index) {
        return [];
    },

    /**
     * Fetch data for view tabs based on selected options and filters.
     *
     * @param {Object} options Options that are passed to collection/model's
     *   fetch method.
     */
    loadData: function(options) {

        if (this.disposed || this.meta.config) {
            return;
        }
        this.loadDataForTabs(this.tabs, options);

    },

    /**
     * Refresh tabs for the given module
     * @param module {String} name of module needing refresh
     */
    refreshTabsForModule: function(module){
        var toRefresh = [];
        _.each(this.tabs, function(tab){
            if (tab.module === module) {
               toRefresh.push(tab);
            }
        });
        this.loadDataForTabs(toRefresh, {});
    },

    /**
     * Load data for passed set of tabs
     * @param tabs {Array} Set of tabs to update
     * @param options {Object} load options
     */
    loadDataForTabs: function(tabs, options){
        options = options || {};
        var self = this;
        var loadDataRequests = [];
        _.each(tabs, function(tab, index) {
            loadDataRequests.push(function(callback){
                tab.collection.setOption(self._getCollectionOptions(index));

                tab.collection.filterDef = _.union(
                    self._getCollectionFilters(index),
                    self._getFilters(index)
                );
                tab.collection.fetch({
                    relate: tab.relate,
                    complete: function() {
                        tab.collection.dataFetched = true;
                        callback(null);
                    }
                });
            });
        }, this);
        if (!_.isEmpty(loadDataRequests)) {
            async.parallel(loadDataRequests, function(){
                if (self.disposed) {
                    return;
                }
                self.collection = self.tabs[self.settings.get('activeTab')].collection;
                self.context.set('collection', self.collection);

                self.render();

                if (_.isFunction(options.complete)) {
                    options.complete.call(self);
                }
            });
        }
    },

    /**
     * Convenience callback for updating this and related dashlets once a model has been removed
     * @return {Function} complete callback
     * @private
     */
    _getRemoveModelCompleteCallback: function() {
        return _.bind(function(model){
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger("tabbed-dashlet:refresh", model.module);
        }, this);
    },

    /**
     * Show more records for current collection.
     */
    showMore: function() {
        this.getNextPagination({
            showAlerts: true,
            limit: this.settings.get('limit')
        });
    },

    /**
     * Event handler for tab switcher.
     *
     * @param {Event} event Click event.
     */
    tabSwitcher: function(event) {
        var index = this.$(event.currentTarget).data('index');
        if (index === this.settings.get('activeTab')) {
            return;
        }

        this.settings.set('activeTab', index);
        this.collection = this.tabs[index].collection;
        this.context.set('collection', this.collection);
        this.render();
    },

    /**
     * Unlinks the selected record.
     *
     * Shows a confirmation alert and removes the model on confirm.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkRecord: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    showAlerts: true,
                    relate: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {String} record_date Date field to be used to print record
     *   date, defaults to date_entered, though it can be overridden on
     *   metadata.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        var recordsTpl = this._getRecordsTemplate(tab.module);

        this.toolbarHtml = this._toolbarTpl(this);
        this.tabsHtml = this._tabsTpl(this);
        this.recordsHtml = recordsTpl(this);

        this.row_actions = tab.row_actions;

        this._super('_renderHtml');
    },

    /**
     *  Handle Avatar display, in case image doesn't exist.
     *
     *  FIXME: render avatar should happen when rendering each row, after pagination.(SC-2605)
     *  @private
     */
    _renderAvatars: function() {
        this.$('img.avatar').load(function() {
            $(this).removeClass('hide');
        })
            .error(function() {
                $(this).parent().removeClass('avatar avatar-md').addClass('label label-module label-module-md label-Users');
                $(this).parent().find('span').removeClass('hide');
            });
        this.$('img.avatar').each(function() {
            var img = $(this);
            img.attr('src', img.data('src'));
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.tabs, function(tab) {
            tab.collection.off(null, null, this);
        });

        this._super('_dispose');
    }
}) },
"config-drawer-howto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigDrawerHowtoView
 * @alias SUGAR.App.view.views.BaseConfigDrawerHowtoView
 * @extends View.View
 */
({
	// Config-drawer-howto View (base) 

    howtoData: {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('config:howtoData:change', function(howtoData) {
            this.howtoData = howtoData;
            this._render();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // manually render this template with just the howtoData
        this.$el.html(this.template(this.howtoData))
    }
}) },
"access-denied": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AccessDeniedView
 * @alias SUGAR.App.view.views.BaseAccessDeniedView
 * @extends View.View
 */
({
	// Access-denied View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"logout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LogoutView
 * @alias SUGAR.App.view.views.BaseLogoutView
 * @extends View.View
 */
({
	// Logout View (base) 

    events: {
        "click [name=login_button]": "login",
        "click [name=login_form_button]": "login_form"
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.logoUrl = app.metadata.getLogoUrl();
        app.view.View.prototype._render.call(this);
        this.refreshAddtionalComponents();
        return this;
    },

    /**
     * Refresh additional components
     */
    refreshAddtionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * Process Login
     */
    login: function() {        
        if (app.config && 
            app.config.externalLogin === true &&
            app.config.externalLoginSameWindow === true &&
            !_.isEmpty(app.config.externalLoginUrl)
        ) {
            window.location.replace(app.config.externalLoginUrl);
        } else {
            app.router.login();
        }
    },

    /**
     * Show Login form
     */
    login_form: function() {
        app.config.externalLogin = false;
        app.controller.loadView({
            module: "Login",
            layout: "login",
            create: true
        });
    }
}) },
"dnb-premium-company-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbPremiumCompanyInfoView
 * @alias SUGAR.App.view.views.BaseDnbPremiumCompanyInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-premium-company-info View (base) 

    extendsFrom: 'DnbView',

    duns_num: null,

    //will contain the data elements selected by the user from the dashlet confid
    //filtered data dictionary
    filteredDD: null,

    events: {
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData'
    },

    initDashlet: function() {
        this._super('initDashlet');
        this.baseFilterData();
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.disposed) {
            return;
        }
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadCompanyInfo, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadCompanyInfo, this);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
        this.baseFilterData();
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated premium company information from DNB service
     */
    refreshClicked: function() {
        this.loadCompanyInfo(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadCompanyInfo: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getDNBPremCompanyDetails, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Gets Premium Company Information
     * @param duns_num duns_num
     */
    getDNBPremCompanyDetails: function(duns_num) {
        if (this.disposed) {
            return;
        }
        this.dnbFirmo = {};
        this.template = app.template.get('dnb.dnb-comp-info');
        this.dnbFirmo.loading_label = app.lang.get('LBL_DNB_PREMIUM_COMPANY_INFO_LOADING');
        this.render();
        this.$('div#dnb-compinfo-loading').show();
        this.$('div#dnb-compinfo-details').hide();
        this.baseCompanyInformation(duns_num, this.compInfoProdCD.prem, null, this.renderCompanyInformation);
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Form for creating a filter.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterRowsView
 * @alias SUGAR.App.view.views.BaseFilterRowsView
 * @extends View.View
 */
({
	// Filter-rows View (base) 

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow',
        'change [data-filter=field] input[type=hidden]': 'handleFieldSelected',
        'change [data-filter=operator] input[type=hidden]': 'handleOperatorSelected'
    },

    className: 'filter-definition-container',

    filterFields: [],

    lastFilterDef: [],

    /**
     * Map of fields types.
     *
     * Specifies correspondence between field types and field operator types.
     */
    fieldTypeMap: {
        'datetime' : 'date',
        'datetimecombo' : 'date'
    },

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        //Load partial
        this.formRowTemplate = app.template.get("filter-rows.filter-row-partial");

        this._super('initialize', [opts]);

        this.loadFilterOperators(this.module);

        /**
         * FIXME: we should consider moving it to metadata instead. (see TY-177).
         * Storage for operators that have no values associated with them
         *
         * @private
         * @property {Array}
         * */
        this._operatorsWithNoValues = ['$empty', '$not_empty'];

        this.listenTo(this.layout, "filterpanel:change:module", this.handleFilterChange);
        this.listenTo(this.layout, "filter:create:open", this.openForm);
        this.listenTo(this.layout, "filter:create:close", this.render);
        this.listenTo(this.context, "filter:create:save", this.saveFilter);
        this.listenTo(this.layout, "filter:create:delete", this.confirmDelete);
    },

    /**
     * Loads filterable fields and operators for supplied module.
     *
     * @param {string} module Selected module name.
     */
    handleFilterChange: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters')) || this.moduleName === module) {
            return;
        }

        /**
         * Name of the selected module which triggered the filter change.
         *
         * @property {string}
         */
        this.moduleName = module;

        this.loadFilterFields(module);
        this.loadFilterOperators(module);
    },

    /**
     * Loads the list of filter fields for supplied module.
     *
     * @param {string} module The module to load the filter fields for.
     */
    loadFilterFields: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters'))) {
            return;
        }

        this.fieldList = app.data.getBeanClass('Filters').prototype.getFilterableFields(module);
        this.filterFields = {};

        _.each(this.fieldList, function(value, key) {
            this.filterFields[key] = app.lang.get(value.vname, module);
        }, this);
    },

    /**
     * Loads the list of filter operators for supplied module.
     *
     * @param {string} [module] The module to load the filters for.
     */
    loadFilterOperators: function(module) {
        this.filterOperatorMap = app.metadata.getFilterOperators(module);
    },

    /**
     * Handler for filter:create:open event
     * @param {Bean} filterModel
     */
    openForm: _.debounce(function(filterModel) {
        // This debounce method should be in accordance with filterpanel `filter:create:open` event handler,
        // so components show up at the same time
        var template = filterModel.get('filter_template') || filterModel.get('filter_definition');
        if (_.isEmpty(template)) {
            this.render();
            this.addRow();
        } else {
            this.populateFilter();
        }
        // After populating the form, save the current edit state
        this.saveFilterEditState();

        //shortcut keys
        app.shortcuts.register('Filter:Add', '+', function() {
            this.$('[data-action=add]').last().click();
        },this);
        app.shortcuts.register('Filter:Remove', '-', function() {
            this.$('[data-action=remove]').last().click();
        },this);
    }, 100, true),

    /**
     * Save the filter.
     *
     * @param {String} [name] The name of the filter.
     */
    saveFilter: function(name) {
        var self = this,
            obj = {
                filter_definition: this.buildFilterDef(true),
                filter_template: this.buildFilterDef(),
                name: name || this.context.editingFilter.get('name'),
                module_name: this.moduleName
            },
            message = app.lang.get('TPL_FILTER_SAVE', this.moduleName, {name: name});

        this.context.editingFilter.save(obj, {
            success: function(model) {
                self.context.trigger('filter:add', model);
                self.layout.trigger('filter:toggle:savestate', false);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
    },


    /**
     * Popup alert to confirm delete action.
     */
    confirmDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_FILTER_CONFIRMATION', this.moduleName),
            onConfirm: _.bind(this.deleteFilter, this)
        });
    },

    /**
     * Delete the filter.
     */
    deleteFilter: function() {
        var self = this,
            name = this.context.editingFilter.get('name'),
            message = app.lang.get('TPL_DELETE_FILTER_SUCCESS', this.moduleName, {name: name});

        this.context.editingFilter.destroy({
            success: function(model) {
                self.layout.trigger('filter:remove', model);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
        this.layout.trigger('filter:create:close');
    },

    /**
     * Get filterable fields from the module metadata
     * @param {String} moduleName
     * @return {Object}
     */
    getFilterableFields: function(moduleName) {
        var moduleMeta = app.metadata.getModule(moduleName),
            fieldMeta = moduleMeta.fields,
            fields = {};
        if (moduleMeta.filters) {
            _.each(moduleMeta.filters, function(templateMeta) {
                if (templateMeta.meta && templateMeta.meta.fields) {
                    fields = _.extend(fields, templateMeta.meta.fields);
                }
            });
        }

        _.each(fields, function(fieldFilterDef, fieldName) {
            var fieldMetaData = app.utils.deepCopy(fieldMeta[fieldName]);
            if (_.isEmpty(fieldFilterDef)) {
                fields[fieldName] = fieldMetaData || {};
            } else {
                fields[fieldName] = _.extend({name: fieldName}, fieldMetaData, fieldFilterDef);
            }
            delete fields[fieldName]['readonly'];
        });

        return fields;
    },

    /**
     * Utility function that instantiates a field for this form.
     *
     * The field action is manually set to `detail` because we want to render
     * the `edit` template but the action remains `detail` (filtering).
     *
     * @param {Data.Bean} model A bean necessary to the field for storing the
     *   value(s).
     * @param {Object} def The field definition.
     * @return {View.Field} The field component.
     */
    createField: function(model, def) {
        var obj = {
            meta: {
                view: "edit"
            },
            def: def,
            model: model,
            context: app.controller.context,
            viewName: "edit",
            view: this
        };
        var field = app.view.createField(obj);
        field.action = 'detail';
        return field;
    },

    /**
     * Add a row to the next element of the event target that triggered it or
     * in the end of the list.
     *
     * @param {Event} [e] The event that triggered the row.
     * @return {Element} The new initialized appended row element.
     */
    addRow: function(e) {
        var $row;

        if (e) {
            // Triggered by clicking the plus sign. Add the row to that point.
            $row = this.$(e.currentTarget).closest('[data-filter=row]');
            $row.after(this.formRowTemplate());
            $row = $row.next();
            this.layout.trigger('filter:toggle:savestate', true);
        }
        return this.initRow($row);
    },

    /**
     * Initializes a row either with the retrieved field values or the
     * default field values.
     *
     * @param {jQuery} [$row] The related filter row.
     * @param {Object} [data] The values to set in the fields.
     * @return {jQuery} $row The initialized row element.
     */
    initRow: function($row, data) {
        $row = $row || $(this.formRowTemplate()).appendTo(this.$el);
        data = data || {};
        var model, field, $fieldValue, $fieldContainer;

        // Init the row with the data available.
        $row.data('name', data.name);
        $row.data('operator', data.operator);
        $row.data('value', data.value);

        // Create a blank model for the enum field, and set the field value if
        // we know it.
        model = app.data.createBean(this.moduleName);
        if (data.name) {
            model.set('filter_row_name', data.name);
        }
        field = this.createField(model, {
            name: 'filter_row_name',
            type: 'enum',
            options: this.filterFields
        });

        // Add the field to the dom.
        $fieldValue = $row.find('[data-filter=field]');
        $fieldContainer = $(field.getPlaceholder().string);
        $fieldContainer.appendTo($fieldValue);

        // Store the field in the data attributes.
        $row.data('nameField', field);

        this._renderField(field, $fieldContainer);

        if (data.name) {
            this.initOperatorField($row);
        }
        return $row;
    },


    /**
     * Remove a row
     * @param {Event} e
     */
    removeRow: function(e) {
        var $row = this.$(e.currentTarget).closest('[data-filter=row]'),
            fieldOpts = [
                {field: 'nameField', value: 'name'},
                {field: 'operatorField', value: 'operator'},
                {field: 'valueField', value: 'value'}
            ];

        this._disposeRowFields($row, fieldOpts);
        $row.remove();
        this.layout.trigger('filter:toggle:savestate', true);
        if (this.$('[data-filter=row]').length === 0) {
            this.addRow();
        }
    },

    /**
     * Validate all filter rows.
     *
     * @param {Array} rows A list of rows to validate.
     * @return {Boolean} `true` if all filter rows are valid, `false`
     *   otherwise.
     */
    validateRows: function(rows) {
        return _.every(rows, this.validateRow, this);
    },

    /**
     * Verify the value of the row is not empty.
     *
     * @param {Element} $row The row to validate.
     * @return {Boolean} `true` if valid, `false` otherwise.
     *
     * TODO we should receive the data only and be jQuery agnostic.
     */
    validateRow: function(row) {
        var $row = $(row),
            data = $row.data();

        if (_.contains(this._operatorsWithNoValues, data.operator)) {
            return true;
        }

        // for empty value in currency we dont want to validate
        if (!_.isUndefined(data.valueField) && !_.isArray(data.valueField) && data.valueField.type ==='currency'
            && (_.isEmpty(data.value) || (_.isObject(data.value) &&
            _.isEmpty(data.valueField.model.get(data.name))))) {
            return false;
        }

        //For date range and predefined filters there is no value
        if (data.isDateRange || data.isPredefinedFilter) {
            return true;
        } else if (data.isFlexRelate) {
            return data.value ?
                _.reduce(data.value, function(memo, val) {
                    return memo && !_.isEmpty(val);
                }, true) :
                false;
        }

        //Special case for between operators where 2 values are needed
        if (_.contains(['$between', '$dateBetween'], data.operator)) {

            if (!_.isArray(data.value) || data.value.length !== 2) {
                return false;
            }

            switch (data.operator) {
                case '$between':
                    // FIXME: the fields should set a true number (see SC-3138).
                    return !(_.isNaN(parseFloat(data.value[0])) || _.isNaN(parseFloat(data.value[1])));
                case '$dateBetween':
                    return !_.isEmpty(data.value[0]) && !_.isEmpty(data.value[1]);
                default:
                    return false;
            }
        }

        return _.isNumber(data.value) || !_.isEmpty(data.value);
    },

    /**
     * Rerender the view with selected filter
     */
    populateFilter: function() {
        var name = this.context.editingFilter.get('name'),
            filterOptions = this.context.get('filterOptions') || {},
            populate = this.context.editingFilter.get('is_template') && filterOptions.filter_populate,
            filterDef = this.context.editingFilter.get('filter_template') ||
                this.context.editingFilter.get('filter_definition');

        this.render();
        this.layout.trigger('filter:set:name', name);

        if (populate) {
            filterDef = app.data.getBeanClass('Filters').prototype.populateFilterDefinition(filterDef, populate);
        }
        _.each(filterDef, function(row) {
            this.populateRow(row);
        }, this);
        //Set lastFilterDef because the filter has already been applied and fireSearch is called in _disposeRowFields
        this.lastFilterDef = this.buildFilterDef(true);
        this.lastFilterTemplate = this.buildFilterDef();
    },

    /**
     * Populates row fields with the row filter definition.
     *
     * In case it is a template filter that gets populated by values passed in
     * the context/metadata, empty values will be replaced by populated
     * value(s).
     *
     * @param {Object} rowObj The filter definition of a row.
     */
    populateRow: function(rowObj) {
        var moduleMeta = app.metadata.getModule(this.layout.currentModule);
        var fieldMeta = moduleMeta.fields;

        _.each(rowObj, function(value, key) {
            var isPredefinedFilter = (this.fieldList[key] && this.fieldList[key].predefined_filter === true);

            if (key === '$or') {
                var keys = _.reduce(value, function(memo, obj) {
                    return memo.concat(_.keys(obj));
                }, []);

                key = _.find(_.keys(this.fieldList), function(key) {
                    if (_.has(this.fieldList[key], 'dbFields')) {
                        return _.isEqual(this.fieldList[key].dbFields.sort(), keys.sort());
                    }
                }, this);

                // Predicates are identical, so we just use the first.
                value = _.values(value[0])[0];
            } else if (key === '$and') {
                var values = _.reduce(value, function(memo, obj) {
                        return _.extend(memo, obj);
                    }, {});
                var def = _.find(this.fieldList, function(fieldDef) {
                        return _.has(values, fieldDef.id_name || fieldDef.name);
                    }, this);

                var operator = '$equals';
                key = def ? def.name : key;

                //  We want to get the operator from our values object only for currency fields
                if (def && !_.isString(values[def.name]) && def.type === 'currency') {
                    operator = _.keys(values[def.name])[0];
                    values[key] = values[key][operator];
                }
                value = {};
                value[operator] = values;
            } else if (!fieldMeta[key] && !isPredefinedFilter) {
                return;
            }

            if (!this.fieldList[key]) {
                //Make sure we use name for relate fields
                var relate = _.find(this.fieldList, function(field) { return field.id_name === key; });
                // field not found so don't create row for it.
                if (!relate) {
                    return;
                }
                key = relate.name;
                // for relate fields in version < 7.7 we used `$equals` and `$not_equals` operator so for version
                // compatibility & as per TY-159 needed to fix this since 7.7 & onwards we will be using `$in` &
                // `$not_in` operators for relate fields
                if (_.isString(value) || _.isNumber(value)) {
                    value = {$in: [value]};
                } else if (_.keys(value)[0] === '$not_equals') {
                    var val = _.values([value])[0];
                    value = {$not_in: val};
                }
            }

            if (_.isString(value) || _.isNumber(value)) {
                value = {$equals: value};
            }
            _.each(value, function(value, operator) {
                this.initRow(null, {name: key, operator: operator, value: value});
            }, this);
        }, this);
    },

    /**
     * Fired when a user selects a field to filter by
     * @param {Event} e
     */
    handleFieldSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {field: 'operatorField', value: 'operator'},
            {field: 'valueField', value: 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initOperatorField($row);
    },

    /**
     * Initializes the operator field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initOperatorField: function($row) {
        var $fieldWrapper = $row.find('[data-filter=operator]');
        var data = $row.data();
        var fieldName = data.nameField.model.get('filter_row_name');
        var previousOperator = data.operator;

        // Make sure the data attributes contain the right selected field.
        data['name'] = fieldName;

        if (!fieldName) {
            return;
        }

        // For relate fields
        data.id_name = this.fieldList[fieldName].id_name;
        // For flex-relate fields
        data.type_name = this.fieldList[fieldName].type_name;

        //Predefined filters don't need operators and value field
        if (this.fieldList[fieldName].predefined_filter === true) {
            data.isPredefinedFilter = true;
            this.fireSearch();
            return;
        }

        // Get operators for this filter type
        var fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type,
            payload = {},
            types = _.keys(this.filterOperatorMap[fieldType]);

        // For parent field with the operator '$equals', the operator field is
        // hidden and we need to display the value field directly. So here we
        // need to assign 'previousOperator' and 'data.operator variables' to let
        // the value field initialize.
        //FIXME: We shouldn't have a condition on the parent field. TY-352 will
        // fix it.
        if (fieldType === 'parent' && _.isEqual(types, ['$equals'])) {
            previousOperator = data.operator = types[0];
        }

        fieldType === 'parent' ?
            $fieldWrapper.addClass('hide').empty() :
            $fieldWrapper.removeClass('hide').empty();
        $row.find('[data-filter=value]').addClass('hide').empty();

        _.each(types, function(operand) {
            payload[operand] = app.lang.get(
                this.filterOperatorMap[fieldType][operand],
                [this.moduleName, 'Filters']
            );
        }, this);

        // Render the operator field
        var model = app.data.createBean(this.moduleName);

        if (previousOperator) {
            model.set('filter_row_operator', data.operator === '$dateRange' ? data.value : data.operator);
        }

        var field = this.createField(model, {
                name: 'filter_row_operator',
                type: 'enum',
                // minimumResultsForSearch set to 9999 to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/414
                searchBarThreshold: 9999,
                options: payload
            }),
            $field = $(field.getPlaceholder().string);

        $field.appendTo($fieldWrapper);
        data['operatorField'] = field;

        this._renderField(field, $field);

        var hide = fieldType === 'parent';
        this._hideOperator(hide, $row);

        // We want to go into 'initValueField' only if the field value is known.
        // We need to check 'previousOperator' instead of 'data.operator'
        // because even if the default operator has been set, the field would
        // have set 'data.operator' when it rendered anyway.
        if (previousOperator) {
            this.initValueField($row);
        }
    },

    /**
     * Shows or hides the operator field of the filter row specified.
     *
     * Automatically populates the operator field to have value `$equals` if it
     * is not in midst of populating the row.
     *
     * @param {boolean} hide Set to `true` to hide the operator field.
     * @param {jQuery} $row The filter row of interest.
     * @private
     */
    _hideOperator: function(hide, $row) {
        $row.find('[data-filter=value]')
            .toggleClass('span4', !hide)
            .toggleClass('span8', hide);
    },

    /**
     * Fired when a user selects an operator to filter by
     * @param {Event} e
     */
    handleOperatorSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {'field': 'valueField', 'value': 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initValueField($row);
    },

    /**
     * Initializes the value field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initValueField: function($row) {
        var data = $row.data();
        var operation = data.operatorField.model.get('filter_row_operator');

        // Make sure the data attributes contain the right operator selected.
        data.operator = operation;
        if (!operation) {
            return;
        }

        if (_.contains(this._operatorsWithNoValues, operation)) {
            this.fireSearch();
            return;
        }

        // Patching fields metadata
        var moduleName = this.moduleName,
            module = app.metadata.getModule(moduleName),
            fields = app.metadata._patchFields(moduleName, module, app.utils.deepCopy(this.fieldList));

        // More patch for some field types
        var fieldName = $row.find('[data-filter=field] input[type=hidden]').select2('val'),
            fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type,
            fieldDef = fields[fieldName];

        switch (fieldType) {
            case 'enum':
                fieldDef.isMultiSelect = true;
                // Set minimumResultsForSearch to a negative value to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/489#issuecomment-13535459
                fieldDef.searchBarThreshold = -1;
                break;
            case 'bool':
                fieldDef.type = 'enum';
                fieldDef.options = fieldDef.options || 'filter_checkbox_dom';
                break;
            case 'int':
                fieldDef.auto_increment = false;
                //For $in operator, we need to convert `['1','20','35']` to `1,20,35` to make it work in a varchar field
                if (operation === '$in') {
                    fieldDef.type = 'varchar';
                    fieldDef.len = 200;
                    if (_.isArray($row.data('value'))) {
                        $row.data('value', $row.data('value').join(','));
                    }
                }
                break;
            case 'teamset':
                fieldDef.type = 'relate';
                break;
            case 'datetimecombo':
            case 'date':
                fieldDef.type = 'date';
                //Flag to indicate the value needs to be formatted correctly
                data.isDate = true;
                if (operation.charAt(0) !== '$') {
                    //Flag to indicate we need to build the date filter definition based on the date operator
                    data.isDateRange = true;
                    this.fireSearch();
                    return;
                }
                break;
            case 'relate':
                fieldDef.auto_populate = true;
                fieldDef.isMultiSelect = true;
                break;
            case 'parent':
                data.isFlexRelate = true;
                break;
        }
        fieldDef.required = false;
        fieldDef.readonly = false;

        // Create new model with the value set
        var model = app.data.createBean(moduleName);

        var $fieldValue = $row.find('[data-filter=value]');
        $fieldValue.removeClass('hide').empty();

        //fire the change event as soon as the user start typing
        var _keyUpCallback = function(e) {
            if ($(e.currentTarget).is(".select2-input")) {
                return; //Skip select2. Select2 triggers other events.
            }
            this.value = $(e.currentTarget).val();
            // We use "silent" update because we don't need re-render the field.
            model.set(this.name, this.unformat($(e.currentTarget).val()), {silent: true});
            model.trigger('change');
        };

        //If the operation is $between we need to set two inputs.
        if (operation === '$between' || operation === '$dateBetween') {
            var minmax = [];
            var value = $row.data('value') || [];
            if (fieldType === 'currency' && $row.data('value')) {
                value = $row.data('value') || {};
                model.set(value);
                value = value[fieldName] || [];
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                model.id = 'not_new';
            }

            model.set(fieldName + '_min', value[0] || '');
            model.set(fieldName + '_max', value[1] || '');
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_min'})));
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_max'})));

            if(operation === '$dateBetween') {
                minmax[0].label = app.lang.get('LBL_FILTER_DATEBETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_DATEBETWEEN_TO');
            } else {
                minmax[0].label = app.lang.get('LBL_FILTER_BETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_BETWEEN_TO');
            }

            data['valueField'] = minmax;

            _.each(minmax, function(field) {
                var fieldContainer = $(field.getPlaceholder().string);
                $fieldValue.append(fieldContainer);
                this.listenTo(field, 'render', function() {
                    field.$('input, select, textarea').addClass('inherit-width');
                    field.$('.input-append').prepend('<span class="add-on">' + field.label + '</span>');
                    field.$('.input-append').addClass('input-prepend');
                    // .date makes .inherit-width on input have no effect so we need to remove it.
                    field.$('.input-append').removeClass('date');
                    field.$('input, textarea').on('keyup', _.debounce(_.bind(_keyUpCallback, field), 400));
                });
                this._renderField(field, fieldContainer);
            }, this);
        } else if (data.isFlexRelate) {
            _.each($row.data('value'), function(value, key) {
                model.set(key, value);
            }, this);

            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string),
                findRelatedName = app.data.createBeanCollection(model.get('parent_type'));
            data['valueField'] = field;
            $fieldValue.append(fieldContainer);

            if (model.get('parent_id')) {
                findRelatedName.fetch({
                    params: {filter: [{'id': model.get('parent_id')}]},
                    complete: _.bind(function() {
                        if (!this.disposed) {
                            if (findRelatedName.first()) {
                                model.set(fieldName,
                                    findRelatedName.first().get(field.getRelatedModuleField()),
                                    {silent: true});
                            }
                            if (!field.disposed) {
                                this._renderField(field, fieldContainer);
                            }
                        }
                    }, this)
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        } else {
            // value is either an empty object OR an object containing `currency_id` and currency amount
            if (fieldType === 'currency' && $row.data('value')) {
                // for stickiness & to retrieve correct saved values, we need to set the model with data.value object
                model.set($row.data('value'));
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                // Mark this one as not_new so that model isn't treated as new
                model.id = 'not_new';
            } else {
                model.set(fieldDef.id_name || fieldName, $row.data('value'));
            }
            // Render the value field
            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string);
            $fieldValue.append(fieldContainer);
            data['valueField'] = field;

            this.listenTo(field, 'render', function() {
                field.$('input, select, textarea').addClass('inherit-width');
                // .date makes .inherit-width on input have no effect so we need to remove it.
                field.$('.input-append').removeClass('date');
                field.$('input, textarea').on('keyup',_.debounce(_.bind(_keyUpCallback, field), 400));
            });
            if ((fieldDef.type === 'relate' || fieldDef.type === 'nestedset') &&
                !_.isEmpty($row.data('value'))
            ) {
                var self = this,
                    findRelatedName = app.data.createBeanCollection(fieldDef.module);
                findRelatedName.fetch({fields: [fieldDef.rname], params: {filter: [{'id': {'$in': $row.data('value')}}]},
                    complete: function() {
                        if (!self.disposed) {
                            if (findRelatedName.length > 0) {
                                model.set(fieldDef.id_name, findRelatedName.pluck('id'), { silent: true });
                                model.set(fieldName, findRelatedName.pluck(fieldDef.rname), { silent: true });
                            }
                            if (!field.disposed) {
                                self._renderField(field, fieldContainer);
                            }
                        }
                    }
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        }
        // When the value change a quicksearch should be fired to update the results
        this.listenTo(model, "change", function() {
            this._updateFilterData($row);
            this.fireSearch();
        });

        // Manually trigger the filter request if a value has been selected lately
        // This is the case for checkbox fields or enum fields that don't have empty values.
        var modelValue = model.get(fieldDef.id_name || fieldName);

        // To handle case: value is an object with 'currency_id' = 'xyz' and 'likely_case' = ''
        // For currency fields, when value becomes an object, trigger change
        if (!_.isEmpty(modelValue) && modelValue !== $row.data('value')) {
            model.trigger('change');
        }
    },

    /**
     * Update filter data for this row
     * @param $row Row to update
     * @private
     */
    _updateFilterData: function($row){
        var data = $row.data(),
            field = data['valueField'],
            name = data['name'],
            valueForFilter;

        //Make sure we use ID for relate fields
        if (this.fieldList[name] && this.fieldList[name].id_name) {
            name = this.fieldList[name].id_name;
        }

        //If we have multiple fields we have to build an array of values
        if (_.isArray(field)) {
            valueForFilter = [];
            _.each(field, function(field) {
                var value = !field.disposed && field.model.has(field.name) ? field.model.get(field.name) : '';
                value = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
                valueForFilter.push(value);
            });
        } else {
            var value = !field.disposed && field.model.has(name) ? field.model.get(name) : '';
            valueForFilter = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
        }
        $row.data("value", valueForFilter); // Update filter value once we've calculated final value
    },

    /**
     * Check each row, builds the filter definition and trigger the filtering
     */
    fireSearch: _.debounce(function() {
        var filterDef = this.buildFilterDef(true),
            filterTemplate = this.buildFilterDef(),
            defHasChanged = !_.isEqual(this.lastFilterDef, filterDef),
            templateHasChanged = !_.isEqual(this.lastFilterTemplate, filterTemplate);

        // Save the current edit state
        if (defHasChanged || templateHasChanged) {
            this.saveFilterEditState(filterDef, filterTemplate);
            this.lastFilterDef = filterDef;
            this.lastFilterTemplate = filterTemplate;
            this.layout.trigger('filter:toggle:savestate', true);
        }
        if (!defHasChanged) {
            return;
        }
        // Needed in order to prevent filtering a global context collection (see filter.js:applyFilter()).
        if (this.context.get('applyFilter') !== false) {
            this.layout.trigger('filter:apply', null, filterDef);
        }
    }, 400),

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} [filterDef] Filter Definition. Defaults to the
     *   {@link #builtFilderDef} with only valid rows.
     * @param {Object} [templateDef] Filter template definition. Defaults to
     *   the {@link #builtFilderDef} with all rows.
     */
    saveFilterEditState: function(filterDef, templateDef) {
        if (!this.context.editingFilter) {
            return;
        }
        this.context.editingFilter.set({
            'filter_definition': filterDef || this.buildFilterDef(true),
            'filter_template': templateDef || this.buildFilterDef()
        });
        var filter = this.context.editingFilter.toJSON();

        // Make sure the filter-actions view is rendered, otherwise it will override the name with an empty name.
        if (this.layout.getComponent('filter-actions') &&
            this.layout.getComponent('filter-actions').$('input').length === 1
        ) {
            filter.name = this.layout.getComponent('filter-actions').getFilterName();
        }
        this.layout.getComponent('filter').saveFilterEditState(filter);
    },

    /**
     * Build filter definition for all rows.
     *
     * @param {Boolean} onlyValidRows Set `true` to retrieve only filter
     *   definition of valid rows, `false` to retrieve the entire field
     *   template.
     * @return {Array} Filter definition.
     */
    buildFilterDef: function(onlyValidRows) {
        var $rows = this.$('[data-filter=row]'),
            filter = [];

        _.each($rows, function(row) {
            var rowFilter = this.buildRowFilterDef($(row), onlyValidRows);

            if (rowFilter) {
                filter.push(rowFilter);
            }
        }, this);

        return filter;
    },

    /**
     * Build filter definition for this row.
     *
     * @param {jQuery} $row The related row.
     * @param {Boolean} onlyIfValid Set `true` to validate the row and return
     *   `undefined` if not valid, or `false` to build the definition anyway.
     * @return {Object} Filter definition for this row.
     */
    buildRowFilterDef: function($row, onlyIfValid) {
        var data = $row.data();
        if (onlyIfValid && !this.validateRow($row)) {
            return;
        }
        var operator = data['operator'],
            value = data['value'] || '',
            name = data['id_name'] || data['name'],
            filter = {};

        if (_.isEmpty(name)) {
            return;
        }

        if (data.isPredefinedFilter || !this.fieldList) {
            filter[name] = '';
            return filter;
        } else {
            if (this.fieldList[name] && _.has(this.fieldList[name], 'dbFields')) {
                var subfilters = [];
                _.each(this.fieldList[name].dbFields, function(dbField) {
                    var filter = {};
                    filter[dbField] = {};
                    filter[dbField][operator] = value;
                    subfilters.push(filter);
                });
                filter['$or'] = subfilters;
            } else {
                if (data.isFlexRelate) {
                    var valueField = data['valueField'],
                        idFilter = {},
                        typeFilter = {};

                    idFilter[data.id_name] = valueField.model.get(data.id_name);
                    typeFilter[data.type_name] = valueField.model.get(data.type_name);
                    filter['$and'] = [idFilter, typeFilter];
                // Creating currency filter. For all but `$between` operators we use type property from data.valueField.
                // For `$between`, data.valueField is an array and therefore we check for type==='currency' from
                // either of the elements.
                } else if (data['valueField'] && (data['valueField'].type === 'currency' ||
                    (_.isArray(data.valueField) && data.valueField[0].type === 'currency'))
                    ) {
                    // initially value is an array which we later convert into an object for saving and retrieving
                    // purposes (stickiness structure constraints)
                    var amountValue;
                    if (_.isObject(value) && !_.isUndefined(value[name])) {
                        amountValue = value[name];
                    } else {
                        amountValue = value;
                    }

                    var amountFilter = {};
                    amountFilter[name] = {};
                    amountFilter[name][operator] = amountValue;

                    // for `$between`, we use first element to get dataField ('currency_id') since it is same
                    // for both elements and also because data.valueField is an array
                    var dataField;
                    if (_.isArray(data.valueField)) {
                        dataField = data.valueField[0];
                    } else {
                        dataField = data.valueField;
                    }

                    var currencyId;
                    currencyId = dataField.getCurrencyField().name;

                    var currencyFilter = {};
                    currencyFilter[currencyId] = dataField.model.get(currencyId);

                    filter['$and'] = [amountFilter, currencyFilter];
                } else if (operator === '$equals') {
                    filter[name] = value;
                } else if (data.isDateRange) {
                    //Once here the value is actually a key of date_range_selector_dom and we need to build a real
                    //filter definition on it.
                    filter[name] = {};
                    filter[name].$dateRange = operator;
                } else if (operator === '$in' || operator === '$not_in') {
                    // IN/NOT IN require an array
                    filter[name] = {};
                    //If value is not an array, we split the string by commas to make it an array of values
                    if (_.isArray(value)) {
                        filter[name][operator] = value;
                    } else if (!_.isEmpty(value)) {
                        filter[name][operator] = (value + '').split(',');
                    } else {
                        filter[name][operator] = [];
                    }
                } else {
                    filter[name] = {};
                    filter[name][operator] = value;
                }
            }

            return filter;
        }
    },

    /**
     * Reset filter values on filter form. Called after a click on `Reset` button
     */
    resetFilterValues: function() {
        var $rows = this.$('[data-filter=row]');
        _.each($rows, function(row) {
            var $row = $(row);
            var valueField = $row.data('valueField');

            if (!valueField || valueField.disposed) {
                return;
            }
            if (!_.isArray(valueField)) {
                valueField.model.clear();
                return;
            }
            _.each(valueField, function(field) {
                field.model.clear();
            });
        });
    },

    /**
     * Disposes fields stored in the data attributes of the row element.
     *
     *     @example of an `opts` object param:
     *      [
     *       {field: 'nameField', value: 'name'},
     *       {field: 'operatorField', value: 'operator'},
     *       {field: 'valueField', value: 'value'}
     *      ]
     *
     * @param  {jQuery} $row The row which fields are to be disposed.
     * @param  {Array} opts An array of objects containing the field object and
     *  value to the data attributes of the row.
     */
    _disposeRowFields: function($row, opts) {
        var data = $row.data(), model;

        if (_.isObject(data) && _.isArray(opts)) {
            _.each(opts, function(val) {
                if (data[val.field]) {
                    //For in between filter we have an array of fields so we need to cover all cases
                    var fields = _.isArray(data[val.field]) ? data[val.field] : [data[val.field]];
                    data[val.value] = '';
                    _.each(fields, function(field) {
                        model = field.model;
                        if (val.field === "valueField" && model) {
                            model.clear({silent: true});
                            this.stopListening(model);
                        }
                        field.dispose();
                        field = null;
                    }, this);
                    return;
                }
                if (data.isDateRange && val.value === 'value') {
                    data.value = '';
                }
            }, this);
        }
        //Reset flags
        data.isDate = false;
        data.isDateRange = false;
        data.isPredefinedFilter = false;
        data.isFlexRelate = false;
        $row.data(data);
        this.fireSearch();
    }
}) },
"history-summary-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryListBottomView
 * @alias SUGAR.App.view.views.BaseHistorySummaryListBottomView
 * @extends View.Views.Base.ListBottomView
 */
({
	// History-summary-list-bottom View (base) 

    extendsFrom: 'ListBottomView',

    /**
     * Assigns label for "More history..." since History isn't
     * a proper module and doesn't fetch lang strings
     * @override
     */
    setShowMoreLabel: function() {
        this.showMoreLabel = app.lang.get('LBL_MORE_HISTORY');
    }
}) },
"history-summary-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryPreviewView
 * @alias SUGAR.App.view.views.BaseHistorySummaryPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// History-summary-preview View (base) 

    extendsFrom: 'PreviewView',

    /**
     * @inheritdoc
     * @override
     *
     * Overridden to make custom calls by module to get activities
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        var self = this,
            newModel;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if(this.model && model && (this.model.get("id") == model.get("id") && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger("list:preview:decorate", false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));

            newModel = app.data.createBean(model.module);
            newModel.set('id', model.id);

            if (fetch) {
                newModel.fetch({
                    //Show alerts for this request
                    showAlerts: true,
                    success: function(model) {
                        self.renderPreview(model, collection);
                    },
                    //The view parameter is used at the server end to construct field list
                    view: viewName
                });
            } else {
                newModel.copy(model);
                this.renderPreview(newModel, collection);
            }
        }

        this.previewId = previewId;
    }
}) },
"filter-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the filter dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterFilterDropdownView
 * @alias SUGAR.App.view.views.BaseFilterFilterDropdownView
 * @extends View.View
 */
({
	// Filter-filter-dropdown View (base) 

    tagName: "span",
    className: "table-cell",

    events: {
        "click .choice-filter.choice-filter-clickable": "handleEditFilter",
        "click .choice-filter-close": "handleClearFilter"
    },

    /**
     * These labels are used in the filter dropdown
     *  - labelDropdownTitle        label used as the dropdown title. ie `Filter`
     *  - labelCreateNewFilter      label for create new filter action. ie `Create`
     *  - labelAllRecords           label used on record view when all related modules are selected. ie `All Records`
     *
     *  - labelAllRecordsFormatted  label used when all records are selected. ie `All <Module>s`
     *
     *                              It is set to null because already defined per module. However, some views are
     *                              allowed to override it because of the context. For instance, `dupecheck-list` view
     *                              wants to display `All duplicates` instead of `All <Module>s`
     */
    labelDropdownTitle:         'LBL_FILTER',
    labelCreateNewFilter:       'LBL_FILTER_CREATE_NEW',
    labelAllRecords:            'LBL_FILTER_ALL_RECORDS',
    labelAllRecordsFormatted:   null,


    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get("filter-filter-dropdown.selection-partial");
        this._select2formatResultTemplate = app.template.get("filter-filter-dropdown.result-partial");

        this.listenTo(this.layout, "filter:select:filter", this.handleSelect);
        this.listenTo(this.layout, "filter:change:module", this.handleModuleChange);
        this.listenTo(this.layout, "filter:render:filter", this._renderHtml);
    },

    /**
     * Truthy when filter dropdown is enabled.  Updated whenever the filter module changes.
     */
    filterDropdownEnabled: true,

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!this.layout.filters) {
            return;
        }
        this._super('_renderHtml');

        this.filterList = this.getFilterList();

        this._renderDropdown(this.filterList);
    },

    /**
     * Get the list of filters to fill the dropdown
     * @return {Array}
     */
    getFilterList: function() {
        var filters = [];
        if (this.layout.canCreateFilter()) {
            filters.push({id: "create", text: app.lang.get(this.labelCreateNewFilter)});
        }
        if (this.layout.filters.collection.get('all_records') && this.labelAllRecordsFormatted) {
            this.layout.filters.collection.get('all_records').set('name',  this.labelAllRecordsFormatted);
            this.layout.filters.collection.sort();
        }
        // This flag is used to determine when we have to add the border top (to separate categories)
        var firstNonEditable = false;
        this.layout.filters.collection.each(function(model) {
            var opts = {
                id: model.id,
                text: this.layout.filters.collection._getTranslatedFilterName(model)
            };
            if (model.get("editable") === false && !firstNonEditable) {
                opts.firstNonUserFilter = true;
                firstNonEditable = true;
            }
            filters.push(opts);
        }, this);

        return filters;
    },

    /**
     * Render select2 dropdown
     *
     * This function may be called even when this.render() is not because of
     * the "filter:render:filter" event listener.
     *
     * @private
     */
    _renderDropdown: function(data) {
        var self = this;
        this.filterNode = this.$(".search-filter");

        this.filterNode.select2({
            data: data,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            formatResultCssClass: _.bind(this.formatResultCssClass, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-filter-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            shouldFocusInput: function() {
                // We return false here so that we do not refocus on the field once
                // it has been blurred. If we return true, blur needs to happen
                // twice before it is really blurred.
                return false;
            },
            width: 'off'
        });

        // the shortcut keys need to be registered anytime this function is
        // called, not just on render
        app.shortcuts.register(
            'Filter:Create',
            ['f c', 'ctrl+alt+8'],
            function() {
                // trigger the change event to open the edit filter drawer
                this.filterNode.select2('val', 'create', true);
            },
            this
        );
        app.shortcuts.register('Filter:Edit', 'f e', function() {
            this.$('.choice-filter.choice-filter-clickable').click();
        }, this);
        app.shortcuts.register('Filter:Show', 'f m', function() {
            this.filterNode.select2('open');
        }, this);

        if (!this.filterDropdownEnabled) {
            this.filterNode.select2("disable");
        }

        this.filterNode.off("change");
        this.filterNode.on("change",
            /**
             * Called when the user selects a filter in the dropdown
             *
             * @triggers filter:change:filter on filter layout to indicate a new
             *   filter has been selected.
             *
             * @param {Event} e The `change` event.
             */
            function(e) {
                self.layout.trigger('filter:change:filter', e.val);
            }
        );
    },

    /**
     * This handler is useful for other components that trigger
     * `filter:select:filter` in order to select the dropdown value.
     *
     * @param {String} id The id of the filter to select in the dropdown.
     */
    handleSelect: function(id) {
        this.filterNode.select2('val', id, true);
    },

    /**
     * Get the dropdown labels for the filter
     * @param {Object} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        var data,
            model,
            val = el.val();

        if (val === 'create') {
            //It should show `Create`
            data = {id: "create", text: app.lang.get(this.labelCreateNewFilter)};

        } else {
            model = this.layout.filters.collection.get(val);

            //Fallback to `all_records` filter if not able to retrieve selected filter
            if (!model) {
                data = {id: "all_records", text: app.lang.get(this.labelAllRecords)};

            } else if (val === "all_records") {
                data = this.formatAllRecordsFilter(null, model);
            } else {
                data = {id: model.id, text: this.layout.filters.collection._getTranslatedFilterName(model)};
            }
        }

        callback(data);
    },

    /**
     * Update the text for the selected filter and returns template
     * @param {Object} item
     * @return {string}
     */
    formatSelection: function(item) {
        var ctx = {}, safeString;

        //Don't remove this line. We want to update the selected filter name but don't want to change to the filter
        //name displayed in the dropdown
        item = _.clone(item);

        this.toggleFilterCursor(this.isFilterEditable(item.id));

        if (item.id === 'all_records') {
            item = this.formatAllRecordsFilter(item);
        }

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        // Update the text for the selected filter.
        this.$('.choice-filter-label').html(safeString);

        if (item.id !== 'all_records') {
            this.$('.choice-filter-close').show();
        } else {
            this.$('.choice-filter-close').hide();
        }

        ctx.label = app.lang.get(this.labelDropdownTitle);
        ctx.enabled = this.filterDropdownEnabled;

        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Returns template
     * @param {Object} option
     * @return {string}
     */
    formatResult: function(option) {
        if (option.id === this.layout.getLastFilter(this.layout.layout.currentModule, this.layout.layoutType)) {
            option.icon = 'fa-check';
        } else if (option.id === 'create') {
            option.icon = 'fa-plus';
        } else {
            option.icon = undefined;
        }
        return this._select2formatResultTemplate(option);
    },

    /**
     * Adds a class to the `Create Filter` item (to add border bottom)
     * and a class to first user custom filter (to add border top)
     *
     * @param {Object} item
     * @return {string} css class to attach
     */
    formatResultCssClass: function(item) {
        if (item.id === 'create') { return 'select2-result-border-bottom'; }
        if (item.firstNonUserFilter) { return 'select2-result-border-top'; }
    },

    /**
     * Determine if a filter is editable
     *
     * @param {String} id
     * @return {boolean} `true` if filter is editable, `false` otherwise
     */
    isFilterEditable: function(id) {
        if (!this.layout.canCreateFilter() || !this.filterDropdownEnabled || this.layout.showingActivities) {
            return false;
        }
        if (id === "create" || id === 'all_records') {
            return true;
        } else {
            return !this.layout.filters.collection.get(id) || this.layout.filters.collection.get(id).get('editable') !== false;
        }
    },

    /**
     * Toggles cursor depending if the filter is editable or not.
     *
     * @param {boolean} active `true` for a pointer cursor, `false` for a not allowed cursor
     */
    toggleFilterCursor: function(editable) {
        if (editable) {
            this.$('.choice-filter').css("cursor", "pointer").addClass('choice-filter-clickable');
        } else {
            this.$('.choice-filter').css("cursor", "not-allowed").removeClass('choice-filter-clickable');
        }
    },

    /**
     * Formats label for `all_records` filter. When showing all subpanels, we expect `All records`
     *
     * @param {Object} item
     * @return {Object} item with formatted label
     */
    formatAllRecordsFilter: function (item, model) {
        item = item || {id: 'all_records'};

        //SP-1819: Seeing "All Leads" instead of "All Records" in sub panel
        //For the record view our Related means all subpanels (so should show `All Records`)
        var allRelatedModules = _.indexOf([this.module, 'all_modules'], this.layout.layout.currentModule) > -1;

        //If ability to create a filter
        if (this.isFilterEditable(item.id)) {
            item.text = app.lang.get(this.labelCreateNewFilter);
        } else if (this.layout.layoutType === 'record' && allRelatedModules) {
            item.text = app.lang.get(this.labelAllRecords);
            this.toggleFilterCursor(false);
        } else if (model) {
            item.text = this.layout.filters.collection._getTranslatedFilterName(model);
        }
        return item;
    },

    /**
     * Handler for when the user selects a filter in the filter bar.
     */
    handleEditFilter: function() {
        var filterId = this.filterNode.val(),
            filterModel;

        if (filterId === 'all_records') {
            // Figure out if we have an edit state. This would mean user was editing the filter so we want him to retrieve
            // the filter form in the state he left it.
            this.layout.trigger("filter:select:filter", 'create');
        } else {
            filterModel = this.layout.filters.collection.get(filterId);
        }

        if (filterModel && filterModel.get("editable") !== false) {
            this.layout.trigger("filter:create:open", filterModel);
        }
    },

    /**
     * Handler for when the user selects a module in the filter bar.
     */
    handleModuleChange: function(linkModuleName, linkName) {
        this.filterDropdownEnabled = (linkName !== "all_modules");
    },

    /**
     * When a click happens on the close icon, clear the last filter and trigger reinitialize
     * @param {Event} evt
     */
    handleClearFilter: function(evt) {
        //This event is fired within .choice-filter and another event is attached to .choice-filter
        //We want to stop propagation so it doesn't bubble up.
        evt.stopPropagation();
        this.layout.clearLastFilter(this.layout.layout.currentModule, this.layout.layoutType);
        var filterId;
        if (this.context.get('currentFilterId') === this.layout.filters.collection.defaultFilterFromMeta) {
            filterId = 'all_records';
        } else {
            filterId = this.layout.filters.collection.defaultFilterFromMeta;
        }
        this.layout.trigger('filter:select:filter', filterId);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        app.view.View.prototype._dispose.call(this);
    }
}) },
"convert-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConvertResultsView
 * @alias SUGAR.App.view.views.BaseConvertResultsView
 * @extends View.View
 */
({
	// Convert-results View (base) 

    associatedModels: null,

    events:{
        'click .preview-list-item':'previewRecord'
    },

    plugins: ['Tooltip'],

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("list:preview:decorate", this.decorateRow, this);
        this.associatedModels = app.data.createMixedBeanCollection();
    },

    bindDataChange: function() {
        this.model.on("change", this.populateResults, this);
    },

    /**
     * Build a collection of associated models and re-render the view.
     * Override this method for module specific functionality.
     */
    populateResults: function() {
        this.associatedModels.reset();
        app.view.View.prototype.render.call(this);
    },

    /**
     * Handle firing of the preview render request for selected row
     *
     * @param e
     */
    previewRecord: function(e) {
        var $el = this.$(e.currentTarget),
            data = $el.data(),
            model = app.data.createBean(data.module, {id:data.id});

        model.fetch({
            //Show alerts for this request
            showAlerts: true,
            success: _.bind(function(model) {
                model.module = data.module;
                app.events.trigger("preview:render", model, this.associatedModels);
            }, this)
        });
    },

    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function(model){
        this.$("tr.highlighted").removeClass("highlighted current above below");
        if(model){
            var rowName = model.module+"_"+ model.get("id");
            var curr = this.$("tr[name='"+rowName+"']");
            curr.addClass("current highlighted");
            curr.prev("tr").addClass("highlighted above");
            curr.next("tr").addClass("highlighted below");
        }
    }
}) },
"list-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListHeaderpaneView
 * @alias SUGAR.App.view.views.BaseListHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// List-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'list-headerpane'),
            app.metadata.getView(options.module, 'list-headerpane'),
            options.meta
        );

        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register('List:Headerpane:Create', 'a', function() {
            var $createButton = this.$('a[name=create_button]');
            if ($createButton.is(':visible') && !$createButton.hasClass('disabled')) {
                $createButton.get(0).click();
            }
        }, this);
    }
}) },
"dnb-lite-company-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbLiteCompanyInfoView
 * @alias SUGAR.App.view.views.BaseDnbLiteCompanyInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-lite-company-info View (base) 

    extendsFrom: 'DnbView',

    duns_num: null,

    //will contain the data elements selected by the user from the dashlet confid
    //filtered data dictionary
    filteredDD: null,

    events: {
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData'
    },

    initDashlet: function() {
        this._super('initDashlet');
        this.baseFilterData();
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.disposed) {
            return;
        }
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadCompanyInfo, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadCompanyInfo, this);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
        this.baseFilterData();
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated Company information lite from DNB service
     */
    refreshClicked: function() {
        this.loadCompanyInfo(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadCompanyInfo: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getDNBLiteCompanyDetails, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Gets Basic Company Information
     * @param duns_num duns_num
     */
    getDNBLiteCompanyDetails: function(duns_num) {
        if (this.disposed) {
            return;
        }
        this.dnbFirmo = {};
        this.template = app.template.get('dnb.dnb-comp-info');
        this.dnbFirmo.loading_label = app.lang.get('LBL_DNB_LITE_COMPANY_INFO_LOADING');
        this.render();
        this.$('div#dnb-compinfo-loading').show();
        this.$('div#dnb-compinfo-details').hide();
        this.baseCompanyInformation(duns_num, this.compInfoProdCD.lite, null, this.renderCompanyInformation);
    }
}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The SelectionListView provides an easy way to select a record from a list.
 * It's designed to be used in a drawer. The model attributes of the selected
 * record will be passed to the drawer callback.
 *
 * The SelectionListView has a generic implementation and can be overriden for
 * particular uses.
 *
 * It has to be opened passing the following data in the drawer's context:
 *
 * - `module` {String} The module the list is related to.
 * - `fields` {Array} The fields to be displayed.
 * - `filterOptions` {Object} the filter options for the list view.
 *
 *  Example of usage:
 *
 *     app.drawer.open({
	// Selection-list View (base) 

 *              layout: 'selection-list',
 *               context: {
 *                   module: this.getSearchModule(),
 *                   fields: this.getSearchFields(),
 *                   filterOptions: this.getFilterOptions(),
 *               }
 *           }, _.bind(this.setValue, this));
 *     },
 *
 * @class View.Views.Base.SelectionListView
 * @alias SUGAR.App.view.views.BaseSelectionListView
 * @extends View.Views.Base.FlexListView
 */
({
    extendsFrom: 'FlexListView',

    dataViewName: 'selection-list',

    initialize: function(options) {
        // Since list.js only fetches list view metadata, we need to build our
        // own metadata to send to the parent.
        var viewMeta = app.metadata.getView(options.module, options.name) ||
                       app.metadata.getView(options.module, this.dataViewName) || {};
        this.plugins = _.union(this.plugins, ['ListColumnEllipsis', 'ListRemoveLinks']);
        //setting skipFetch to true so that loadData will not run on initial load and the filter load the view.
        options.context.set('skipFetch', true);
        options.meta = _.extend(viewMeta, options.meta || {});
        this.setSelectionMeta(options);
        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click .search-and-select .single': 'triggerCheck'
        });
        this.initializeEvents();
    },

    /**
     * Sets metadata proper to selection-list.
     *
     * @param {Object} options
     *
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'single',
            label: 'LBL_LINK_SELECT',
            isSearchAndSelectAction: true
        };
    },

    /**
     * Checks the `[data-check=one]` element when the row is clicked.
     *
     * @param {Event} event The `click` event.
     */
    triggerCheck: function(event) {
        //Ignore inputs and links/icons, because those already have defined effects
        if (!($(event.target).is('a,i,input'))) {
            var checkbox = $(event.currentTarget).find('[data-check=one]');
            checkbox[0].click();
        }
    },

    /**
     * Sets up events.
     */
    initializeEvents: function() {
        this.context.on('change:selection_model selection-list:select', this._selectAndClose, this);
    },

    /**
     * Closes the drawer passing the selected model attributes to the callback.
     *
     * @param {object} context
     * @param {Data.Bean} selectedModel The selected record.
     *
     * @protected
     */
    _selectAndClose: function(context, selectedModel) {
        if (selectedModel) {
            this.context.unset('selection_model', {silent: true});
            app.drawer.close(this._getModelAttributes(selectedModel));
        }
    },

    /**
     * Returns attributes given a model with ACL check.
     *
     * @param {Data.bean} model
     * @return {object} attributes
     *
     * @private
     */
    _getModelAttributes: function(model) {
        var attributes = {
            id: model.id,
            value: model.get('name')
        };

        //only pass attributes if the user has view access
        _.each(model.attributes, function(value, field) {
            if (app.acl.hasAccessToModel('view', model, field)) {
                attributes[field] = attributes[field] || model.get(field);
            }
        }, this);

        return attributes;
    },

    /**
     * Adds Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super('addActions');
        if (this.meta.showPreview !== false) {
            this.rightColumns.push({
                type: 'preview-button',
                css_class: 'btn',
                tooltip: 'LBL_PREVIEW',
                event: 'list:preview:fire',
                icon: 'fa-eye'
            });
        } else {
            this.rightColumns.push({});
        }
    }
}) },
"dashlet-row-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletRowEmptyView
 * @alias SUGAR.App.view.views.BaseDashletRowEmptyView
 * @extends View.View
 */
({
	// Dashlet-row-empty View (base) 

    events: {
        'click .add-dashlet' : 'layoutClicked',
        'click .add-row.empty' : 'addClicked'
    },
    originalTemplate: null,
    columnOptions: [],
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
        this.columnOptions = [];

        var parentLayoutWidth = 12,
            parentLayout = this;
        while (parentLayout) {
            if (parentLayout.type === 'dashlet-row') {
                parentLayoutWidth = parentLayout.meta.width;
            }
            parentLayout = parentLayout.layout;
        }
        var allowColumnSize = _.max([
            1, //should be at least one
            Math.floor(parentLayoutWidth / this.model.minColumnSpanSize)
        ]);
        _.times(allowColumnSize, function(index) {
            var n = index + 1;
            this.columnOptions.push({
                index: n,
                label: (n > 1) ?
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMNS', this.module) :
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMN', this.module)
            });
        }, this);
    },
    addClicked: function(evt) {
        var self = this;
        this._addRowTimer = setTimeout(function() {
            self.addRow(1);
        }, 100);
    },
    layoutClicked: function(evt) {
        var columns = $(evt.currentTarget).data('value');
        var addRow = _.bind(this.addRow, this);
        _.delay(addRow, 0, columns);
    },
    addRow: function(columns) {
        this.layout.addRow(columns);
        if(this._addRowTimer) {
            clearTimeout(this._addRowTimer);
        }
    },
    setMode: function(model) {
        if(model === 'edit') {
            this.template = this.originalTemplate;
        } else {
            this.template = app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"masslink-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MasslinkProgressView
 * @alias SUGAR.App.view.views.BaseMasslinkProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Masslink-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSLINK_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSLINK_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSLINK_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSLINK_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSLINK_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSLINK_SUCCESS',
            TITLE: 'TPL_MASSLINK_TITLE'
        }
    }

}) },
"flex-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FlexListView
 * @alias SUGAR.App.view.views.BaseFlexListView
 * @extends View.Views.Base.ListView
 */
({
	// Flex-list View (base) 

    extendsFrom: 'ListView',
    className: 'flex-list-view',
    // Model being previewed (if any)
    _previewed: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['Tooltip']);
        this._super('initialize', [options]);

        //Store left column fields
        this.leftColumns = [];
        //Store right column fields
        this.rightColumns = [];
        this.addActions();

        this.template = app.template.getView('flex-list');
        this.events = _.clone(this.events);

        /**
         * The last state key that contains the full list of fields displayable
         * in list views of this module.
         *
         * @property {string}
         * @protected
         */
        this._allListViewsFieldListKey = app.user.lastState.buildKey('field-list', 'list-views', this.module);

        /**
         * The last state key that contains the visible state of the fields and
         * their position in the table for this specific view.
         *
         * @property {string}
         * @protected
         */
        this._thisListViewFieldListKey = app.user.lastState.key('visible-fields', this);

        if (this.meta.sticky_resizable_columns) {
            /**
             * The last state key that contains the user defined column widths
             * for this specific view.
             *
             * @property {string}
             * @protected
             */
            this._thisListViewFieldSizesKey = app.user.lastState.key('width-fields', this);
        }

        this._fields = this.parseFields();

        this.addPreviewEvents();

        //add debounce in initialize so that subclasses will not all use the same prototype function
        this.resize = _.bind(_.debounce(this.resize, 200), this);
        this.bindResize();

        var rightColumnsEvents = {};
        //add an event delegate for right action dropdown buttons onclick events
        if (this.rightColumns.length) {
            rightColumnsEvents = {
                'hidden.bs.dropdown .flex-list-view .actions': 'resetDropdownDelegate',
                'shown.bs.dropdown .flex-list-view .actions': 'delegateDropdown'
            };
        }

        this.events = _.extend(rightColumnsEvents, this.events, {
            'click [data-widths=reset]': 'resetColumnWidths',
            'click [data-columns-order=reset]': 'resetColumnOrder'
        });

        this.on('list:reorder:columns', this.reorderCatalog, this);
        this.on('list:toggle:column', this.saveCurrentState, this);
        this.on('list:save:laststate', this.saveCurrentState, this);
        this.on('list:column:resize:save', this.saveCurrentWidths, this);
        this.on('list:scrollLock', this.scrollLock, this);
    },

    // fn to turn off event listeners and reenable tooltips
    resetDropdownDelegate: function(e) {
        this.$el.removeClass('no-touch-scrolling');
        var $b = this.$(e.currentTarget).first();
        $b.parent().closest('.list').removeClass('open');
        $b.off('resetDropdownDelegate.right-actions');
    },

    delegateDropdown: function(e) {
        var $buttonGroup = this.$(e.currentTarget).first(), // the button group
            windowHeight = $(window).height() - 65; // height of window less padding

        // fn to detect menu colliding with window bottom
        var needsDropupClass = function($b) {
                var menuHeight = $b.height() + $b.children('ul').first().height();
                return (
                     windowHeight < $b.offset().top + menuHeight
                );
            };

        this.$el.addClass('no-touch-scrolling');
        // add open class to parent list to elevate absolute z-index for iOS
        $buttonGroup.parent().closest('.list').addClass('open');
        // detect window bottom collision
        $buttonGroup.toggleClass('dropup', needsDropupClass($buttonGroup));
        // listen for delegate reset
        $buttonGroup.on('resetDropdownDelegate.right-actions', this.resetDropdownDelegate);
        // add a listener to scrolling container
        $buttonGroup.parents('.main-pane')
            .on('scroll.right-actions', _.bind(_.debounce(function() {
                // detect window bottom collision on scroll
                $buttonGroup.toggleClass('dropup', needsDropupClass($buttonGroup));
            }, 30), this));
    },

    addPreviewEvents: function () {
        //When clicking on eye icon, we need to trigger preview:render with model&collection
        this.context.on("list:preview:fire", function (model) {
            app.events.trigger("preview:render", model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need to update the highlighted row
        app.events.on("list:preview:decorate", this.decorateRow, this);
        if (this.layout) {
            this.layout.on("list:sort:fire", function () {
                //When sorting the list view, we need to close the preview panel
                app.events.trigger("preview:close");
            }, this);
            this.layout.on("list:paginate:success", function () {
                //When fetching more records, we need to update the preview collection
                app.events.trigger("preview:collection:change", this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Parse fields to identify which fields are visible and which fields are
     * hidden.
     *
     * In practice, it creates a catalog that lists the fields that are
     * visible (user configuration if exists, otherwise default metadata
     * configuration) and all the fields (no matter their visible state) used to
     * populate the ellipsis dropdown.
     *
     * By default the catalog is sorted by the order defined in the metadata. If
     * user configuration is found, the catalog is sorted per user preference.
     *
     * @return {Object} The catalog object.
     */
    parseFields: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

        /**
         * The default order of the fields.
         *
         * @property {string[]}
         * @private
         */
        this._defaultFieldOrder = _.pluck(fields, 'name');
        var catalog = this._createCatalog(fields);

        /**
         * The custom order of the fields.
         *
         * See {@link #_getFieldsLastState}.
         *
         * @property {string[]}
         * @private
         */
        this._thisListViewFieldList = this._getFieldsLastState();

        if (this._thisListViewFieldList) {
            catalog = this._toggleFields(catalog, this._thisListViewFieldList, false);
            catalog = this.reorderCatalog(catalog, this._thisListViewFieldList.position, false);
        }
        return catalog;
    },

    /**
     * Retrieves the user configuration from the cache.
     *
     * The cached value changed in 7.2. In an entry is found in the local
     * storage and is at the wrong format, the value is converted to the new
     * format. If no entry found, or the entry has an unexpected format, it
     * throws an exception and return undefined.
     *
     * @return {Object/undefined} An object whom keys are field names, and
     * values are an object containing the position and the visible state,
     * or `undefined` in case of failure.
     *
     * @private
     */
    _getFieldsLastState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var data = app.user.lastState.get(this._thisListViewFieldListKey);
        if (_.isUndefined(data)) {
            return;
        }
        if (!_.isArray(data) || _.isEmpty(data)) {
            app.logger.error('The format of "' + this._thisListViewFieldListKey + '" is unexpected, skipping.');
            return;
        }
        if (_.isString(data[0])) {
            // Old format detected.
            return this._convertFromOldFormat(data);
        }
        return this._decodeCacheData(data);
    },

    /**
     * Create an object that contains 2 keys. Each key is associated to an array
     * that contains the field metadata.
     * List of keys:
     * - `visible` lists fields user wants to see,
     * - `all` lists all the fields, with a `selected` attribute that indicates
     * their visible state (used to populate the ellipsis dropdown).
     *
     * @param {Array} fields The list of field definition for this view.
     * @return {Object} The catalog object.
     * @private
     */
    _createCatalog: function(fields) {
        var catalog = {};
        catalog._byId = {};
        catalog.visible = [];
        catalog.all = [];

        _.each(fields, function(fieldMeta, i) {
            catalog._byId[fieldMeta.name] = this._patchField(fieldMeta, i);
        }, this);
        catalog.all = _.toArray(catalog._byId);
        catalog.visible = _.where(catalog.all, { selected: true });
        return catalog;
    },

    /**
     * Patch a field metadata for this list view.
     *
     * Note that {@link View.FlexListView requires the attributes `selected` and
     * `position`} in order to work properly.
     *
     * @param {Object} fieldMeta The field metadata.
     * @param {Number} index The index of the field in the field list.
     * @return {Object} The patched metadata.
     * @private
     */
    _patchField: function(fieldMeta, index) {
        var isVisible = (fieldMeta['default'] !== false);
        return _.extend({
            selected: isVisible,
            position: index + 1
        }, fieldMeta);
    },

    /**
     * Take the existing catalog and toggle field visibility based on the last
     * state found in the cache.
     *
     * If for some reason, the field is not found at all in the cached data, it
     * fallbacks to the default visible state of that field (defined in the
     * metadata).
     *
     * @param {Object} catalog The catalog of fields.
     * @param {Object} fields The decoded cached data that contains fields
     * wanted visible and fields wanted hidden.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} The catalog with visible state of fields based on user
     * preference.
     * @private
     */
    _toggleFields: function(catalog, fields, saveLastState) {
        if (_.isEmpty(fields) || (_.isEmpty(fields.visible) && _.isEmpty(fields.hidden))) {
            return catalog;
        }
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;
        _.each(fields.visible, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = true;
            }
        }, this);
        _.each(fields.hidden, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = false;
            }
        }, this);
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Sort the catalog of fields per the list of field names passed as
     * argument.
     *
     * @param {Object} catalog Field definitions listed in 2 categories:
     * `visible` / `all`.
     * @param {Array} order Array of field names used to sort the catalog.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} catalog The catalog of fields entirely sorted.
     */
    reorderCatalog: function(catalog, order, saveLastState) {
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;

        order = _.union(order, _.pluck(catalog.all, 'name'));

        _.each(order, function(fieldName, i) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.position = ++i;
            }
        });
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Takes the minimized value stored into the cache and decode it to make
     * it more readable and more manipulable.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And encoded data is:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     The decoded data will be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     `visible` contains the list of visible fields,
     *     `hidden` contains the list of hidden fields,
     *     `position` is the order of fields,
     *     indexes whom value is `0` are skipped (fields not displayable).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheData: function(encodedData) {
        var decodedData = {
            visible: [],
            hidden: [],
            position: []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(encodedData, function(fieldArray, i) {
            if (!_.isArray(fieldArray)) {
                return;
            }
            var name = fieldList[i];
            if (fieldArray[0]) {
                decodedData.visible.push(name);
            } else {
                decodedData.hidden.push(name);
            }
            decodedData.position[fieldArray[1]] = name;
        });
        decodedData.position = _.difference(decodedData.position, [undefined]);
        return decodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And decoded data is:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     The encoded data will be:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     `0` means the field is not displayable. (i.e: `A`, `D`, `G`),
     *     the first item is the visible state: `1` visible, `0` hidden,
     *     the second item of the array is the position of the field.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The minimized data.
     * @private
     */
    _encodeCacheData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(fieldList, function(fieldName) {
            var value = 0;
            if (_.contains(decodedData.position, fieldName)) {
                value = [
                    _.contains(decodedData.visible, fieldName) ? 1 : 0,
                    _.indexOf(decodedData.position, fieldName) + 1
                ];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     * For example, if the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the decoded data is:
     *
     *     {
     *         visible: ['B', 'C', 'E', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * The encoded data will be:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * `0` means the field has no user defined width. (i.e: `A`, `D`, `G`)
     * This is either because the column is hidden, or not displayable in this
     * list view.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The encoded data.
     * @private
     */
    _encodeCacheWidthData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        var visibleIndex = 0;
        _.each(fieldList, function(fieldName) {
            var value = 0;
            if (_.contains(decodedData.visible, fieldName)) {
                value = decodedData.widths[visibleIndex++];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the minimized value stored in the cache and decodes it to make it
     * more readable and easier to manipulate.
     *
     * If the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the encoded data is:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * The decoded data will be:
     *
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * - `visible` contains the list of visible fields,
     * - `widths` is the widths of fields, indexes whose value is `0` are
     * skipped (fields not being displayed).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheWidthData: function(encodedData) {
        var decodedData = {
            'visible': [],
            'widths': []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(_.pluck(this._fields.visible, 'name'), function(fieldName) {
            var index = _.indexOf(fieldList, fieldName);
            var width = encodedData[index] || 0;
            decodedData.visible.push(fieldName);
            decodedData.widths.push(width);
        });
        return decodedData;
    },

    /**
     * Append the list of fields defined in the metadata that are missing in the
     * field storage cache entry.
     *
     * We initially used `_.uniq` to guarantee the unicity of fields. It appears
     * that this `underscore` method is slow, unlike `Lo-Dash` one. Meanwhile a
     * potential migration to Lo-Dash, it is faster to build an object whom keys
     * are field names.
     *
     * @return {Array} The list of all the fields that are displayable in list
     * views of this module.
     * @private
     */
    _appendFieldsToAllListViewsFieldList: function() {
        this._allListViewsFieldList = app.user.lastState.get(this._allListViewsFieldListKey) || [];
        var obj = {};
        _.each(this._allListViewsFieldList, function(fieldName) {
            obj[fieldName] = fieldName;
        });

        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(fieldMeta, i) {
                obj[fieldMeta.name] = fieldMeta.name;
            }, this);
        }, this);
        this._allListViewsFieldList = _.keys(obj);
        app.user.lastState.set(this._allListViewsFieldListKey, this._allListViewsFieldList);
        return this._allListViewsFieldList;
    },

    /**
     * Converts the old localStorage data for fields visibility to the new
     * decoded format.
     *
     * {@link View.FlexListView#_encodeCacheData To see how the new format looks like.}
     *
     *     @example Only visible fields used to be stored. Example of data stored:
     *     <pre><code>
     *     [
     *         'B', 'C', 'F', 'H'
     *     ]
     *     </code></pre>
     *     If the list of fields defined in the metadata was:
     *     <pre><code>
     *     [
     *         'E', 'C', 'B', 'F', 'H'
     *     ]
     *     </code></pre>
     *     The decoded data would be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *
     * @return {Array} The data converted to the new decoded format.
     * @private
     */
    _convertFromOldFormat: function(visibleFieldList) {
        var thisViewFieldList = _.reduce(_.map(this.meta.panels, function(panel) {
            return _.pluck(panel.fields, 'name');
        }), function(memo, field) {
            return memo.concat(field);
        }, []);

        var decoded = {
            visible: [],
            hidden: [],
            position: []
        };
        _.each(thisViewFieldList, function(fieldName, i) {
            if (_.contains(visibleFieldList, fieldName)) {
                decoded.visible.push(fieldName);
            } else {
                decoded.hidden.push(fieldName);
            }
            decoded.position.push(fieldName);
        });
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        return decoded;
    },

    /**
     * Save to the cache the current order of fields, and their visible state.
     *
     *     @example Example of value stored in the cache:
     *     <pre><code>
     *     [
     *         ['A', 'B', 'D', 'C'],
     *         [0, 1, 0, 1]
     *     ]
     *     </code></pre>
     * Means the current order is `ABDC`, and only `B` and `C` are visible
     * fields.
     */
    saveCurrentState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var allFields = _.pluck(this._fields.all, 'name'),
            visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            hidden: _.difference(allFields, visibleFields),
            position: allFields
        };
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        this._thisListViewFieldList = this._getFieldsLastState();
    },

    /**
     * Add actions to left and right columns
     */
    addActions: function() {
        var meta = this.meta;
        if (_.isObject(meta.selection)) {
            this.isSearchAndSelectAction = meta.selection.isSearchAndSelectAction;
            switch (meta.selection.type) {
                case 'single':
                    this.addSingleSelectionAction();
                    break;
                case 'multi':
                    this.addMultiSelectionAction();
                    break;
                default:
                    break;
            }
        }
        if (meta && _.isObject(meta.rowactions)) {
            this.addRowActions();
        }
    },
    /**
     * Add single selection field to left column
     */
    addSingleSelectionAction: function () {
        var _generateMeta = function (name, label) {
            return {
                'type': 'selection',
                'name': name,
                'sortable': false,
                'label': label || ''
            };
        };
        var def = this.meta.selection;
        this.leftColumns.push(_generateMeta(def.name || this.module + '_select', def.label));
    },
    /**
     * Add multi selection field to left column
     */
    addMultiSelectionAction: function() {
        var _generateMeta = function(buttons, disableSelectAllAlert) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'actionmenu',
                        'buttons': buttons || [],
                        'disable_select_all_alert': !!disableSelectAllAlert
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var buttons = this.meta.selection.actions;
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;
        this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
    },
    /**
     * Add fieldset of rowactions to the right column
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || []
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },
    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function (model) {
        // If there are drawers, make sure we're updating only list views on active drawer.
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this._previewed = model;
            this.$("tr.highlighted").removeClass("highlighted current above below");
            if (model) {
                var rowName = model.module + "_" + model.id;
                var curr = this.$("tr[name='" + rowName + "']");
                curr.addClass("current highlighted");
                curr.prev("tr").addClass("highlighted above");
                curr.next("tr").addClass("highlighted below");
            }
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.colSpan = this._fields.visible.length || 0;
        if (this.leftColumns.length) {
            this.colSpan++;
        }
        if (this.rightColumns.length) {
            this.colSpan++;
        }
        if (this.colSpan < 2) {
            this.colSpan = null;
        }
        this._super('_renderHtml');

        if (this.leftColumns.length) {
            this.$el.addClass('left-actions');
        }
        if (this.rightColumns.length) {
            this.$el.addClass('right-actions');
        }

        var displayWidthSetting = this._thisListViewFieldSizes ||
            !_.isUndefined(app.user.lastState.get(this._thisListViewFieldSizesKey));
        var displayOrderSetting = false;
        if (this._thisListViewFieldList) {
            var customOrder = _.union(this._thisListViewFieldList.position, this._defaultFieldOrder);
            displayOrderSetting = !_.isEqual(customOrder, this._defaultFieldOrder);
        }
        this._toggleSettings('widths', displayWidthSetting);
        this._toggleSettings('order', displayOrderSetting);

        this.resize();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // FIXME SC-3484 Testing `this.closestComponent('sidebar')` is required
        // to make unit tests pass.
        if (this.closestComponent('sidebar') && !(app.drawer.count())) {
                this._setHelperScrollBar();
        }
    },

    /**
     * Sets up the helper scrollbar.
     *
     * It first sets the helper `scrollWidth` and `width`. Then it adds
     * listeners on the spy and helper scrollbars to make them follow each
     * other.
     * Then it adds a listener on the vertical scrolling to watch when the
     * bottom of the table is visible, and when it is, to hide the helper since
     * the scrollbar at the bottom of the table is visible.
     *
     * @private
     */
    _setHelperScrollBar: function() {
        /**
         * The 'helper' scrollbar is the horizontal scrollbar fixed to the
         * bottom of the screen.
         *
         * @property {jQuery}
         */
        this.$helper = this.$('[data-scroll-spy]');

        // if no helper was found, just go about our way and not produce any javascript errors
        if (this.$helper.length === 0) {
            return;
        }

        /**
         * The `spy` is the list container element.
         *
         * @property {jQuery}
         */
        this.$spy = this.$('.' + this.$helper.data('scrollSpy'));

        this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
        this._updateHelperWidth();
        this.listenTo(this.closestComponent('sidebar'), 'sidebar:toggle', _.bind(this._updateHelperWidth, this));

        this.$helper.on('scroll.' + this.cid, _.bind(function() {
            this.$spy.scrollLeft(this.$helper.scrollLeft());
        }, this));
        this.$spy.on('scroll.' + this.cid, _.bind(function() {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }, this));

        // `#content` is the scrolling element in responsive view.
        $('#content').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));

        // `.main-pane` is the scrolling element in desktop view.
        $('.main-pane').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));
    },

    /**
     * Toggles the helper scroll bar.
     *
     * If the spy's `width` is greater than its `scrollWidth` (the screen is
     * large enough) OR if the footer is higher than the table (the table is not
     * visible on the screen), we hide the helper scrollbar.
     * Also, we hide it if the bottom of the table is higher than the footer
     * (the natural scroll bar is present).
     *
     * @private
     */
    _toggleScrollHelper: function() {
        if (this.$spy.get(0).scrollWidth <= this.$spy.width() ||
            this.$('tbody').offset().top + this.$helper.height() > $('footer').offset().top
        ) {
            this.$helper.toggle(false);
            return;
        }

        this.$helper.toggle(!(this.$('.scrollbar-landmark').offset().top < $('footer').offset().top));
        if (this.$helper.css('display') !== 'none') {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }
    },

    /**
     * Updates the helper scrollbar width depending on whether dashboard is
     * open or not.
     *
     * @private
     */
    _updateHelperWidth: function() {
        if (this.$helper.length === 0) {
            return;
        }
        this.$helper.toggleClass('dash-collapsed', !$('.side.sidebar-content').is(':visible'));
    },

    /**
     * Saves the current field widths in {@link #_thisListViewFieldSizes}.
     *
     * If the stickiness is enabled, it also saves the widths into the cache,
     * so that the next time the view is loaded, the user retrieves his
     * preferred widths.
     *
     * Example of a value stored in the cache:
     *
     *     [125, 0, 52, 115, 0, 0, 51]
     *
     * Represents the current widths of fields `ABCDEF`, but no width has been
     * defined for fields `B`, `E` and `F` (because they were hidden or not
     * displayable).
     *
     * @param {Array} columns The widths of the current visible fields.
     */
    saveCurrentWidths: function(columns) {
        // Needed in order to fix the scroll helper whenever the widths change.
        this.resize();
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            widths: columns
        };
        var encoded = this._encodeCacheWidthData(decoded);
        this._toggleSettings('widths', true);

        /**
         * The list of user defined column widths for this specific view.
         *
         * @property {Array}
         * @protected
         */
        this._thisListViewFieldSizes = encoded;

        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.set(this._thisListViewFieldSizesKey, encoded);
        }
    },

    /**
     * Resets the column widths to the default settings.
     *
     * If the stickiness is enabled, it also removes the entry from the cache.
     */
    resetColumnWidths: function() {
        this._thisListViewFieldSizes = null;
        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.remove(this._thisListViewFieldSizesKey);
        }
        if (!this.disposed) {
            this.render();
            this._toggleSettings('widths', false);
        }
    },

    /**
     * Resets the column order to the default settings.
     */
    resetColumnOrder: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));
        this._fields = this._createCatalog(fields);
        this.saveCurrentState();
        if (this.disposed) {
            return;
        }
        this.render();
    },

    /**
     * Shows, or hides, the reset setting option from the settings dropdown.
     *
     * @param {string} category The setting to show or hide.
     * @param {boolean} show `true` to show it, `false` to hide it.
     * @private
     */
    _toggleSettings: function(category, show) {
        this.$('li[data-settings-li=' + category + ']').toggle(show);
    },

    /**
     * Gets the list of widths for each visible field in the list view.
     *
     * If the stickiness is enabled, it will look for the entry in the cache.
     *
     * @return {Array} The list of widths if found, `undefined` otherwise.
     */
    getCacheWidths: function() {
        var encodedData = this._thisListViewFieldSizes ||
            app.user.lastState.get(this._thisListViewFieldSizesKey);
        if (!encodedData) {
            return;
        }
        return this._decodeCacheWidthData(encodedData).widths;
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        $('#content, .main-pane').off('scroll.' + this.cid);
        $(this).parents('.main-pane').off('scroll.right-actions');
        this.$('.flex-list-view .actions').trigger('resetDropdownDelegate.right-actions');
        $(window).off('resize.flexlist-' + this.cid);

        if (this.$helper) {
            this.$helper.off('scroll.' + this.cid);
        }
        if (this.$spy) {
            this.$spy.off('scroll.' + this.cid);
        }

        this._super('unbind');
    },

    bindResize: function() {
        $(window).on("resize.flexlist-" + this.cid, _.bind(this.resize, this));
    },

    /**
     * Temporarily overwrites the css from the .scroll-width class so that
     * row field dropdown menues aren't clipped by overflow-x property.
     */
    scrollLock: function(lock) {
        var $content = this.$('.flex-list-view-content');
        if (lock) {
            $content.css({'overflow-y': 'visible', 'overflow-x': 'hidden'});
        } else {
            $content.removeAttr('style');
        }
    },

    /**
     * Updates the class of this flex list as scrollable or not, and
     * adjusts/toggles the scroll helper.
     */
    resize: function() {
        if (this.disposed) {
            return;
        }
        var $content = this.$('.flex-list-view-content');
        if (!$content.length) {
            return;
        }
        var toggle = $content.get(0).scrollWidth > $content.width() + 1;
        this.$el.toggleClass('scroll-width', toggle);

        if (this.$helper && this.$helper.length > 0) {
            this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
            this._toggleScrollHelper();
        }
    }
}) },
"dupecheck-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckHeaderView
 * @alias SUGAR.App.view.views.BaseDupecheckHeaderView
 * @extends View.View
 */
({
	// Dupecheck-header View (base) 


    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('dupecheck:collection:reset', this.updateCount, this);
     },

    updateCount: function() {
        var translatedString = app.lang.get(
            'LBL_DUPLICATES_FOUND',
            this.module,
            {'duplicateCount': this.collection.length}
        );
        this.$('span.duplicate_count').text(translatedString);
    }
}) },
"baseeditmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BaseeditmodalView
 * @alias SUGAR.App.view.views.BaseBaseeditmodalView
 * @extends View.View
 */
({
	// Baseeditmodal View (base) 

    events: {
        'click [name=save_button]': 'saveButton',
        'click [name=cancel_button]': 'cancelButton'
    },
    // Delegate events
    saveButton: function() {
        var createModel = this.context.get('createModel');

        this.$('[name=save_button]').attr('data-loading-text', app.lang.get('LBL_LOADING'));
        this.$('[name=save_button]').button('loading');

        // Disable the buttons during save.
        this.disableButtons(true);
        this.processModel(createModel);

        // saves the related bean
        createModel.save(null, {
            relate: true,
            fieldsToValidate: this.getFields(this.module),
            success: _.bind(function() {
                this.saveComplete();
            }, this),
            error: _.bind(function() {
                this.disableButtons(false);
            }, this)

        });
    },
    /**
     * Preprocess the model before saving. This function is here so that children may override it as necessary.
     * @param {object} model
     */
    processModel: function(model) {

    },
    cancelButton: function() {
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        this.$('.modal').modal('hide').find('form').get(0).reset();
        if (this.context.has('createModel')) {
            this.context.get('createModel').clear();
        }
    },
    saveComplete: function() {
        //reset the form
        this.$('.modal').modal('hide').find('form').get(0).reset();
        //reset the `Save` button
        this.disableButtons(false);
        //add the new model to the collection
        this.collection.fetch({relate: true});
    },

    /**
     * Enables or disables the buttons from the metadata. Disables them by
     * default.
     *
     * @param {boolean} [disable=true] Whether to enable or disable the buttons.
     *   Defaults to `true`.
     */
    disableButtons: function(disable) {
        var state = _.isUndefined(disable) ? true : disable;

        _.each(this.meta.buttons, function(button) {
            var btn = this.getField(button.name);
            btn.setDisabled(state);
        }, this);
    }
}) },
"casessummary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CasessummaryView
 * @alias SUGAR.App.view.views.BaseCasessummaryView
 * @extends View.View
 */
({
	// Casessummary View (base) 

    events: {
        'shown.bs.tab a[data-toggle="tab"]': 'resize',
    },

    plugins: ['Dashlet', 'Chart', 'EllipsisInline'],
    className: 'cases-summary-wrapper',

    tabData: null,
    tabClass: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.chart = nv.models.pieChart()
                .x(function(d) {
                    return d.key;
                })
                .y(function(d) {
                    return d.value;
                })
                .margin({top: 0, right: 0, bottom: 0, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .direction(app.lang.direction)
                .colorData('data')
                .tooltipContent(function(key, x, y, e, graph) {
                    return '<p><b>' + key + ' ' + parseInt(y, 10) + '</b></p>';
                })
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA')
                });

    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);
        d3.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Build content with favorite fields for content tabs
     */
    addFavs: function() {
        var self = this;
        //loop over metricsCollection
        _.each(this.tabData, function(tabGroup) {
            if (tabGroup.models && tabGroup.models.length > 0) {
                _.each(tabGroup.models, function(model) {
                    var field = app.view.createField({
                            def: {type: 'favorite'},
                            model: model,
                            meta: {view: 'detail'},
                            viewName: 'detail',
                            view: self
                        });
                    field.setElement(self.$('.favTarget.[data-model-id="' + model.id + '"]'));
                    field.render();
                });
            }
        });
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        this.total = data.models.length;

        var countClosedCases = data.where({status: 'Closed'})
                .concat(data.where({status: 'Rejected'}))
                .concat(data.where({status: 'Duplicate'})).length,
            countOpenCases = this.total - countClosedCases;

        this.chartCollection = {
            data: [],
            properties: {
                title: app.lang.get('LBL_CASE_SUMMARY_CHART'),
                value: 3,
                label: this.total
            }
        };
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_CLOSE_CASES'),
            classes: 'nv-fill-green',
            value: countClosedCases
        });
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_OPEN_CASES'),
            classes: 'nv-fill-red',
            value: countOpenCases
        });

        if (!_.isEmpty(data.models)) {
            this.processCases(data);
        }
    },

    /**
     * Build tab related data and set tab class name based on number of tabs
     * @param {data} object The chart related data.
     */
    processCases: function(data) {
        this.tabData = [];

        var status2css = {
                'Rejected': 'label-success',
                'Closed': 'label-success',
                'Duplicate': 'label-success'
            },
            stati = _.uniq(data.pluck('status')),
            statusOptions = app.metadata.getModule('Cases', 'fields').status.options || 'case_status_dom';

        _.each(stati, function(status, index) {
            if (!status2css[status]) {
                this.tabData.push({
                    index: index,
                    status: status,
                    statusLabel: app.lang.getAppListStrings(statusOptions)[status],
                    models: data.where({'status': status}),
                    cssClass: status2css[status] ? status2css[status] : 'label-important'
                });
            }
        }, this);

        this.tabClass = ['one', 'two', 'three', 'four', 'five'][this.tabData.length] || 'four';
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            oppID,
            accountBean,
            relatedCollection;
        if (this.meta.config) {
            return;
        }
        oppID = this.model.get('account_id');
        if (oppID) {
            accountBean = app.data.createBean('Accounts', {id: oppID});
        }
        relatedCollection = app.data.createRelatedCollection(accountBean || this.model, 'cases');
        relatedCollection.fetch({
            relate: true,
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on processCases completion
                    self.render();
                    self.addFavs();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null,
            limit: -1
        });
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Attachment dashlet displays Notes and Attachments records that is related to the LHS record.
 * The following items are configurable.
 *
 * - {Integer} limit Limit imposed to the number of records pulled.
 * - {Integer} auto_refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.AttachmentsView
 * @alias SUGAR.App.view.views.BaseAttachmentsView
 * @extends View.View
 */
({
	// Attachments View (base) 

    plugins: ['LinkedModel', 'Dashlet', 'Pagination'],
    events: {
        'click [data-event=create_button]': 'createRelatedNote',
        'click [data-event=select_button]': 'openSelectDrawer'
    },

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        timer: 0
    },

    /**
     * @inheritdoc
     *
     * @param {String} viewName view name.
     */
    initDashlet: function(viewName) {
        this._initOptions();
        if (!this.meta.config && this.context.get('collection')) {
            this.context.set('skipFetch', false);
            this.context.set('limit', this.limit);
        }
        if (!this.meta.config && !this.meta.preview) {
            this.context.on('attachment:view:fire', this.previewRecord, this);
            this.on('attachment:unlinkrow:fire', this.unlinkClicked, this);
            if (this.timer > 0) {
                //disabled previous interval
                this._disableAutoRefresh();
                this._enableAutoRefresh(this.timer);
            }
        }
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {Backbone.View} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        this.tbodyTag = 'ul[data-action="pagination-body"]';
        var options = _.extend(this._defaultOptions, this.settings.attributes || {});
        this.timer = parseInt(options['auto_refresh'], 10) * 60 * 1000;
        this.limit = options.limit;
        return this;
    },

    /**
     * Disable activated refresh interval
     * @protected
     */
    _disableAutoRefresh: function() {
        if (this.timerId) {
            clearInterval(this.timerId);
            this.timerId = null;
        }
        return this;
    },

    /**
     * Activate auto refresh data fetch.
     *
     * @param {Integer} msec Interval time in milli seconds(msec > 0).
     * @protected
     */
    _enableAutoRefresh: function(msec) {
        if (msec <= 0) {
            app.logger.error('Invalid interval timer: ' + msec);
            return this;
        }

        if (!_.isEmpty(this.timerId)) {
            app.logger.error('Trying to enable an already enabled auto-refresh dashlet.');
            return this;
        }

        this.timerId = setInterval(_.bind(function() {
            this.context.resetLoadFlag();
            this.layout.loadData();
        }, this), msec);
        return this;
    },

    /**
     * Apply svg icon plugin.
     */
    applySvgIcon: function() {
        var self = this,
            svgIconTemplate = app.template.get('attachments.svg-icon', this.module) ||
                app.template.get('attachments.svg-icon');
        this.$('[data-mime]').each(function() {
            var mimeType = $(this).data('mime'),
                filetype = self.dashletConfig.supportedImageExtensions[mimeType] || self._getFileType(mimeType);
            $(this).attr('data-filetype', filetype).html(svgIconTemplate());
        });
    },

    /**
     * Convert file mime type to file format
     *
     * @param {String} mimeType file mime type.
     * @return {String} file type.
     * @private
     */
    _getFileType: function(mimeType) {
        var filetype = mimeType.substr(mimeType.lastIndexOf('/') + 1).toUpperCase();
        return filetype ? filetype : this.dashletConfig.defaultType.toUpperCase();
    },

    /**
     * @inheritdoc
     *
     * Once collection is reset, the view should be refreshed.
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('reset', this.render, this);
        }
        this.on('render', this.applySvgIcon, this);
        this.on('linked-model:create', this._reloadData, this);
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this.context.set('skipFetch', false);
        this.context.reloadData();
    },

    /**
     * Choose the attachment from the existing module list
     */
    openSelectDrawer: function() {
        var parentModel = this.context.get('parentModel'),
            linkModule = this.context.get('module'),
            link = this.context.get('link'),
            self = this;

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: linkModule
            }
        }, function(model) {
            if (!model) {
                return;
            }
            var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
                options = {
                    //Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function(model) {
                        self.context.resetLoadFlag();
                        self.context.set('skipFetch', false);
                        self.context.loadData();
                    },
                    error: function(error) {
                        app.alert.show('server-error', {
                            level: 'error',
                            messages: 'ERR_GENERIC_SERVER_ERROR'
                        });
                    }
                };
            relatedModel.save(null, options);
        });
    },

    /**
     * Create new attachment record
     */
    createRelatedNote: function() {
        var link =  this.context.get('link'),
            parentModel = this.context.get('parentModel');
        this.createRelatedRecord(app.data.getRelatedModule(parentModel.module, link), link);
    },

    /**
     * Unlinks (removes) the selected model from the list view's collection.
     *
     * We trigger reset after removing the model in order to update html as well.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkClicked: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    //Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function() {
                        if (self.disposed) {
                            return;
                        }
                        self.collection.remove(model);
                        self.render();
                    }
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Dispose the interval timer as well.
     */
    _dispose: function() {
        this._disableAutoRefresh();
        app.view.View.prototype._dispose.call(this);
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top View (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanel-header',

    /**
     * @inheritdoc
     */
    attributes: {
        'data-sortable-subpanel': 'true'
    },

    /**
     * @inheritdoc
     */
    events: {
        'click': 'togglePanel',
        'click a[name=create_button]:not(".disabled")': 'createRelatedClicked'
    },

    plugins: ['LinkedModel', 'Tooltip'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'panel-top'),
            app.metadata.getView(options.module, 'panel-top'),
            options.meta
        );

        this._super('initialize', [options]);

        // This is in place to get the lang strings from the right module. See
        // if there is a better way to do this later.
        this.parentModule = this.context.parent.get('module');

        // FIXME: Revisit with SC-4775.
        this.on('linked-model:create', function() {
            this.context.set('skipFetch', false);
            this.context.reloadData();
        }, this);
    },

    /**
     * Event handler for the create button.
     *
     * @param {Event} event The click event.
     */
    createRelatedClicked: function(event) {
        this.createRelatedRecord(this.module);
    },

    /**
    * Event handler that toggles the subpanel layout when the SubpanelHeader is
    * clicked.
    *
    * Triggers the `panel:toggle` event to toggle the subpanel.
    *
    * @param {Event} The `click` event.
    */
    togglePanel: function(evt) {
        if (_.isNull(this.$el)) {
            return;
        }

        var $target = this.$(evt.target),
            isLink = $target.closest('a, button').length;

        if (isLink) {
            return;
        }

        this.context.set('collapsed', !this.context.get('collapsed'));
    }
}) },
"forecastdetails": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastdetailsView
 * @alias SUGAR.App.view.views.BaseForecastdetailsView
 * @extends View.View
 */
({
	// Forecastdetails View (base) 

    plugins: ['Dashlet', 'EllipsisInline'],

    /**
     * Manager totals for likely_adjusted
     */
    likelyTotal: 0,

    /**
     * Manager totals for best_adjusted
     */
    bestTotal: 0,

    /**
     * Manager totals for worst_adjusted
     */
    worstTotal: 0,

    /**
     * If we need to get the rollup or direct forecast data
     */
    shouldRollup: false,

    /**
     * Necessary for Forecast module as the selectedUser can change and be different from currently-loggged-in user
     */
    selectedUser: {},

    /**
     * Has Forecast module been set up
     */
    isForecastSetup: false,

    /**
     * Is the user a Forecast admin
     */
    isForecastAdmin: false,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * Holds the subDetails template so the timeperiod field doesn't re-fetch every re-render
     */
    subDetailsTpl: {},

    /**
     * Holds the detailsMsg template
     */
    detailsMsgTpl: {},

    /**
     * Holds the dom values for best/likely/worst show/hide dropdown
     */
    detailsDataSet: {},

    /**
     * Config metadata from Forecasts module
     */
    forecastConfig: {},

    /**
     * If timeperiod dropdown should be shown (not in Forecasts)
     */
    showTimeperiod: true,

    /**
     * Holds if the forecasts config has proper closed won/lost keys
     */
    forecastsConfigOK: false,

    /**
     * Contains the latest saved data from the server
     */
    serverData: {},

    /**
     * The parent module for the dashlet
     */
    currentModule: '',

    /**
     * The span class number to use span12, span4, etc
     */
    spanCSS: '',

    /**
     * Flag for if we've run getInitData yet or not
     */
    initDataLoaded: false,

    /**
     * events on the view for which to watch
     */
    events : {
        'click #forecastsProgressDisplayOptions div.datasetOptions label.radio' : 'changeDisplayOptions'
    },

    /**
     * Holds previous totals for math
     */
    oldTotals: {},

    /**
     * Holds a collection of quota Objects by the quota's record ID
     */
    quotaCollection: undefined,

    /**
     * What to show when we don't have access to the data
     */
    noDataAccessTemplate: undefined,

    /**
     * Holds likely/best/worst field access boolean values
     * ex: { likely: true, best: false, worst: false }
     */
    fieldDataAccess: {},

    /**
     * Managers that are not top-level managers should also
     * show the target quota (exact quota assigned by their mgr)
     */
    showTargetQuota: false,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentModule = app.controller.context.get("module");

        // check to make sure that forecast is configured
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();
        this.isForecastAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
        this.isManager = app.user.get('is_manager');

        if(!this.isForecastSetup) {
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(this.isForecastAdmin);
        }

        if(this.isForecastSetup && this.forecastsConfigOK) {
            this.serverData = new Backbone.Model();

            // Check field access
            var aclModule = this.forecastConfig.forecast_by,
                likelyFieldName = (aclModule == 'RevenueLineItems') ? 'likely_case' : 'amount';
            this.fieldDataAccess = {
                likely: app.acl.hasAccess('read', aclModule, app.user.get('id'), likelyFieldName),
                best: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'best_case'),
                worst: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'worst_case')
            };
            var hasAccess = (this.fieldDataAccess.likely && this.fieldDataAccess.best && this.fieldDataAccess.worst);
            // if any field has no access, get the noaccess field template
            if(hasAccess === false) {
                this.noDataAccessTemplate = app.template.getField('base', 'noaccess')(this);
            }

            // set up the model data
            this.resetModel();

            // since we need the timeperiods from 'Forecasts' set the models module to 'Forecasts'
            this.context.get('model').module = 'Forecasts';

            // use the object version of user not a Model
            this.selectedUser = app.user.toJSON();

            if (this.currentModule != 'Home') {
                // On Forecasts, this is based on whether user is viewing manager or rep worksheet
                this.shouldRollup = this.isManagerView();
            } else {
                // On Home, the dashlet should default to manager data for managers, and rep for non-manager
                this.shouldRollup = this.selectedUser.is_manager;
            }

            // once selectedUser & shouldRollup is set, check if user is a sub-manager
            this.checkShowTargetQuota();

            // set up the subtemplate
            this.subDetailsTpl = app.template.getView('forecastdetails.sub-details');
            this.detailsMsgTpl = app.template.getView('forecastdetails.details-msg');

            this.detailsDataSet = this.setUpShowDetailsDataSet(this.forecastConfig);

            this.checkSpanCSS();
        }
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        this.settings.module = 'Forecasts';
    },

    /**
     * Checks config show_worksheet_ settings for likely/best/worst and sets the spanCSS
     */
    checkSpanCSS: function() {
        var ct = 0;
        _.each([this.forecastConfig.show_worksheet_likely,
            this.forecastConfig.show_worksheet_best,
            this.forecastConfig.show_worksheet_worst], function(val)
        {
            if(val) {
                ct++;
            }
        });

        switch(ct) {
            case 3:
                this.spanCSS = '4';
                break;
            case 2:
                this.spanCSS = '6';
                break;
            case 1:
                this.spanCSS = '12';
                break;
            case 0:
                this.spanCSS = '';
                break;
        }

        this.model.set({spanCSS: this.spanCSS}, {silent: true});
    },

    /**
     * Returns an object of key: value pairs to be used in the select dropdowns to choose Likely/Best/Worst data to show/hide
     *
     * @param cfg Metadata config object for forecasts
     * @return {Object}
     */
    setUpShowDetailsDataSet: function(cfg) {
        var ds = app.metadata.getStrings('app_list_strings')['forecasts_options_dataset'] || [];

        var returnDs = {};
        _.each(ds, function(value, key) {
            if(cfg['show_worksheet_' + key] == 1) {
                returnDs[key] = value
            }
        }, this);
        return returnDs;
    },

    /**
     * Resets the model to default data
     */
    resetModel: function() {
        var model = {
            opportunities : 0,
            closed_amount : undefined,
            quota_amount : undefined,
            target_quota_amount: undefined,
            deficit_amount: undefined,
            worst_details: undefined,
            likely_details: undefined,
            best_details: undefined,
            show_details_likely: this.forecastConfig.show_worksheet_likely,
            show_details_best: this.forecastConfig.show_worksheet_best,
            show_details_worst: this.forecastConfig.show_worksheet_worst,
            spanCSS: this.spanCSS,
            quota_amount_str: undefined,
            target_quota_amount_str: undefined,
            closed_amount_str: undefined,
            deficit_class: undefined,
            deficit_amount_str: undefined,
            isForecastSetup: this.isForecastSetup,
            isForecastAdmin: this.isForecastAdmin
        };
        if(this.context.get('model')) {
            this.context.get('model').set(model)
        } else {
            this.model.set(model);
        }
    },

    /**
     * Builds dashlet url
     *
     * @return {Mixed} url to call
     */
    getProjectedURL: function() {
        var method = this.shouldRollup ? 'progressManager' : 'progressRep',
            url = 'Forecasts/' + this.model.get('selectedTimePeriod') + '/' + method + '/' + this.selectedUser.id,
            params = {};

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.shouldRollup) {
            params = {
                target_quota: (this.showTargetQuota) ? 1 : 0
            };
        }

        return app.api.buildURL(url, 'create', null, params);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.meta.config) {
            return;
        }

        var ctx = this.model;
        if (this.currentModule == 'Forecasts') {
            ctx = this.context.parent || this.context;
            this.showTimeperiod = false;
        } else if (this.currentModule == 'Home') {
            // listen to the TimePeriod field's model changes to set the dashlet
            this.settings.on('change:selectedTimePeriod', function(model) {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
                // reload dashlet data when the selectedTimePeriod changes
                this.loadData({});
            }, this);
        }

        ctx.on('change:selectedTimePeriod', function(model) {
            if(this.currentModule == 'Forecasts') {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
            }
            // reload dashlet data when the selectedTimePeriod changes
            this.loadData({});
        }, this);

        // Home module doesn't have a changing selectedUser
        if(this.currentModule == 'Forecasts') {

            this.quotaCollection = app.utils.getSubpanelCollection(ctx, 'ForecastManagerWorksheets');

            this.quotaCollection.on('reset', this.processQuotaCollection, this);

            this.quotaCollection.on('change:quota', function(data) {
                var oldQuota = (this.getOldTotalFromCollectionById(data.get('user_id'))) ? this.getOldTotalFromCollectionById(data.get('user_id')).quota : 0,
                    newQuota = data.get('quota'),
                    diff = app.math.sub(data.get('quota'), oldQuota),
                    newQuotaTotal = app.math.add(this.serverData.get('quota_amount'), diff);
                // set the new "oldTotals" value
                this.setOldTotalFromCollectionById(data.get('user_id'), {quota: newQuota});
                // calculate and update the Quota on the frontend
                this.calculateData({quota_amount: newQuotaTotal});
            }, this);

            this.processQuotaCollection();

            ctx.on('change:selectedUser', function(model) {
                this.updateDetailsForSelectedUser(model.get('selectedUser'));
                // reload dashlet data when the selectedUser changes
                this.loadData({});
            }, this);

            ctx.on('forecasts:worksheet:totals', function(data) {
                this.calculateData(this.mapAllTheThings(data, true), true);
            }, this);

            // Using LHS Model to store the initial values of the LHS model so we don't have
            // to ping the server every dashlet load for the true original DB values of the LHS model
            if(!_.has(ctx.attributes, 'lhsData')) {
                ctx.set({
                    lhsData: {
                        quotas: this.oldTotals
                    }
                });
            }
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        var ctx;
        if (this.currentModule) {
            if(this.currentModule == 'Forecasts') {
                ctx = this.context.parent || this.context;
                if(this.quotaCollection) {
                    this.quotaCollection.off(null, null, this);
                }
            } else {
                ctx = this.model;
            }

            if(ctx) {
                ctx.off(null, null, this);
            }

            if (this.currentModule == 'Home') {
                this.settings.off(null, null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Overrides loadData to load from a custom URL
     *
     * @override
     */
    loadData: function(options) {
        // if in dashlet config, or if Forecasts is not configured properly,
        // do not load data
        if(this.meta.config || !this.forecastsConfigOK || !this.isForecastSetup) {
            return;
        }

        if(!this.initDataLoaded) {
            this.getInitData(options);
        }

        if(!_.isEmpty(this.model.get('selectedTimePeriod'))) {
            var url = this.getProjectedURL(),
                cb = {
                    context: this,
                    success: _.bind(function(options, data) {
                        if(options && options.beforeParseData) {
                            data = options.beforeParseData(data);
                            data.parsedData = true;
                        }

                        this.handleNewDataFromServer(data)
                    }, this, options),
                    complete: options ? options.complete : null
                };

            app.api.call('read', url, null, null, cb);
        }
    },

    /**
     * Extensible function for getting initial data
     *
     * @param options
     */
    getInitData: function(options) {
        // get the current timeperiod
        app.api.call('GET', app.api.buildURL('TimePeriods/current'), null, {
            success: _.bind(function(currentTP) {
                // Make sure the model is here when we get back and this isn't mid-pageload or anything
                if(this.model) {
                    this.initDataLoaded = true;
                    this.model.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.settings.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.loadData();
                }
            }, this),
            error: _.bind(function() {
                // Needed to catch the 404 in case there isnt a current timeperiod
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Processes this.quotaCollection.models to determine which models IDs should be
     * saved into the closedWonIds array
     */
    processQuotaCollection: function() {
        var model = this.context.get('model') || this.model,
            newQuota = 0,
            oldQuota = model.get('quota_amount'),
            quota = 0;
        this.oldTotals.models = new Backbone.Model();
        _.each(this.quotaCollection.models, function(model) {
            quota = model.get('quota');
            newQuota = app.math.add(newQuota, quota);
            // save all the initial likely values
            this.setOldTotalFromCollectionById(model.get('user_id'), {
                quota: quota
            });
        }, this);

        if(oldQuota !== newQuota) {
            this.calculateData({quota_amount: newQuota});
        }
    },

    /**
     * Gets an object from the oldTotals Model
     *
     * @param id the model ID for the Object
     * @return {Object}
     */
    getOldTotalFromCollectionById: function(id) {
        return this.oldTotals.models.get(id);
    },

    /**
     * Sets a totals Object on the oldTotals Model by id
     *
     * @param id model id
     * @param totals object to set
     * @return {Mixed}
     */
    setOldTotalFromCollectionById: function(id, totals) {
        this.oldTotals.models.set(id, totals);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.renderSubDetails();
    },

    /**
     * Used to re-render only the projected data inside the dashlet so render doesnt
     * get called and dispose the select2 timeperiod field, which would then go
     * re-fetch its data at least once every render
     */
    renderSubDetails: function() {
        if(this.$el && this.subDetailsTpl) {
            var subEl = this.$el.find('.forecast-details'),
                model = this.context.get('model') || this.model;
            // Check if closed or quota is undefined (during opps/rli loading when those numbers aren't available yet)
            if(!_.isUndefined(model.get('closed_amount')) && !_.isUndefined(model.get('quota_amount'))) {
                subEl.html(this.subDetailsTpl(model.toJSON()));
                this.renderCSSChanges(model);
            } else {
                subEl.html('');
            }
        }
    },

    /**
     * Adds the CSS to elements classes post-render
     *
     * @param {Backbone.Model} [model]          The Model to use
     */
    renderCSSChanges: function(model) {
        model = model || this.context.get('model') || this.model;
        var isDeficit = model.get('is_deficit');

        // using getClassBasedOnAmount and sending 0 or 1 to resolve which class to use so the class names
        // are only in one place
        if(isDeficit) {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(0, 1, 'color'));
        } else {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(1, 0, 'color'));
        }

        this.checkPropertySetCSS('worst', model);
        this.checkPropertySetCSS('likely', model);
        this.checkPropertySetCSS('best', model);
    },

    /**
     * Checks a property on the config and sets the background color of an element
     * @param {String} prop 'likely', 'best', or 'worst'
     * @param {Backbone.Model} [model]      The model to use
     */
    checkPropertySetCSS: function(prop, model) {
        model = model || this.context.get('model') || this.model;
        // if we're showing the field
        // And this is the mgr view or it's the rep view and the user has access to the field
        if(this.forecastConfig['show_worksheet_' + prop]
            && (this.shouldRollup || (!this.shouldRollup && this.fieldDataAccess[prop]))) {
            var css = this.getClassBasedOnAmount(app.math.add(this.serverData.get(prop), this.serverData.get('closed_amount')), model.get('quota_amount'), 'background-color');
            this.$el.find('#forecast_details_' + prop + '_feedback').addClass(css);
        }
    },

    /**
     * Any variable mapping happens here
     *
     * @param data an Object
     */
    mapAllTheThings: function(data, fromModel) {
        if(this.shouldRollup) {
            // Manager View
            data.likely = data.likely_adjusted || data.likely_case;
            data.best = data.best_adjusted || data.best_case;
            data.worst = data.worst_adjusted || data.worst_case;
        } else {
            // Rep View
            if(fromModel) {
                data.likely = data.likely_case;
            } else {
                data.likely = data.amount;
            }

            data.best = data.best_case;
            data.worst = data.worst_case;
            data.closed_amount = data.won_amount;

            // can happen if data comes fromModel and won_amount isnt there
            if(_.isUndefined(data.closed_amount)) {
                // unset closed_amount so it doesnt impact totals
                delete data.closed_amount;
            }
        }

        if (fromModel) {
            data.worst = app.math.sub(data.worst, (data.closed_amount || 0));
            data.likely = app.math.sub(data.likely, (data.closed_amount || 0));
            data.best = app.math.sub(data.best, (data.closed_amount || 0));
        }

        return data;
    },

    /**
     * Success callback function for loadData to call
     *
     * @param data
     */
    handleNewDataFromServer: function(data) {
        // since the user might add this dashlet after they have changed the quota models, but before they saved it
        // we have to check and make sure that we're accounting for any changes in the dashlet totals that come
        // from the server
        if(this.currentModule == 'Forecasts' && this.context && this.shouldRollup) {
            var lhsData = this.context.get('lhsData');
            if(!lhsData && _.has(this.context, 'parent') && !_.isNull(this.context.parent)) {
                lhsData = this.context.parent.get('lhsData');
            }

            if(lhsData && !_.isEmpty(lhsData.quotas.models.attributes)) {
                var lhsTotal = 0;
                _.each(lhsData.quotas.models.attributes, function(val, key) {
                    lhsTotal = app.math.add(lhsTotal, val.quota);
                }, this);
                if(lhsTotal != parseFloat(data.quota_amount)) {
                    data.quota_amount = app.math.sub(data.quota_amount, app.math.sub(data.quota_amount, lhsTotal));
                }
            }
        }
        this.calculateData(this.mapAllTheThings(data, false));
    },

    /**
     * Handles parsing data objects into model
     *
     * @param data
     * @param fromModel if this request is from the model or the server
     */
    calculateData: function(data, fromModel) {
        fromModel = fromModel || false;
        // update serverData with changes from data
        this.serverData.set(data);

        // update data with any values serverData had but data doesn't
        // we create a new variable here, since we don't want to update the data param back on the worksheet table
        // and maybe break something
        var d = _.extend({}, data, this.serverData.toJSON());

        this.likelyTotal = d.likely;
        this.bestTotal = d.best;
        this.worstTotal = d.worst;

        d.quota_amount_str = app.currency.formatAmountLocale(d.quota_amount);
        d.closed_amount_str = app.currency.formatAmountLocale(d.closed_amount);

        if(this.showTargetQuota) {
            d.target_quota_amount_str = app.currency.formatAmountLocale(d.target_quota_amount);
        } else {
            this.serverData.unset('target_quota_amount_str');
        }
        d.showTargetQuota = this.showTargetQuota;

        // handle deficit
        d.deficit_amount = Math.abs(app.math.sub(d.quota_amount, d.closed_amount));
        d.deficit_amount_str = app.currency.formatAmountLocale(d.deficit_amount);
        d.is_deficit = (parseFloat(d.quota_amount) > parseFloat(d.closed_amount));

        var deficitLabelKey = (d.is_deficit) ? 'LBL_FORECAST_DETAILS_DEFICIT' : 'LBL_FORECAST_DETAILS_SURPLUS';
        d.deficit_label = app.lang.get(deficitLabelKey, 'Forecasts');

        // convert detailsForCase params to html template
        d.worst_details = this.detailsMsgTpl(this.getDetailsForCase('worst', this.worstTotal, d.quota_amount, d.closed_amount, fromModel));
        d.likely_details = this.detailsMsgTpl(this.getDetailsForCase('likely', this.likelyTotal, d.quota_amount, d.closed_amount, fromModel));
        d.best_details = this.detailsMsgTpl(this.getDetailsForCase('best', this.bestTotal, d.quota_amount, d.closed_amount, fromModel));

        if(this.shouldRollup && !_.isEmpty(this.selectedUser.reports_to_id)) {
            d.quota_label = app.lang.get('LBL_QUOTA_ADJUSTED', 'Forecasts');
        } else {
            d.quota_label = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        if(this.context || this.model) {
            var model = this.context.get('model') || this.model;
            if(model) {
                model.set(d);
                this.renderSubDetails();
            }
        }
    },

    /**
     * Determine if one value is bigger than another then build the language string to be used
     *
     * @param caseStr case string "likely", "best", or "worst"
     * @param caseValue the value of the case
     * @param stageValue the value of the quota or closed amount
     * @param closedAmt the value of closed_amount from the model
     * @param fromServer if this is coming from the model or the server
     * @return {Object} params for details-msg template
     */
    getDetailsForCase: function (caseStr, caseValue, stageValue, closedAmt, fromModel) {
        var params = {},
            // get Number versions of values for comparison
            caseValueN = app.math.add(caseValue, closedAmt),
            stageValueN = parseFloat(stageValue),
            openPipeline = 0,
            calcValue = 0;

        params.label = app.lang.get('LBL_' + caseStr.toUpperCase(), 'Forecasts');
        params.spanCSS = this.spanCSS;
        params.case = caseStr;
        params.shortOrExceed = '&nbsp;';
        params.openPipeline = '&nbsp;';
        params.feedbackLn1 = '';
        params.feedbackLn2 = '';

        var hasAccess = true;
        // if this is the rep view and the user doesnt have access to this field set to false
        if(!this.shouldRollup && !this.fieldDataAccess[caseStr]) {
            hasAccess = false;
        }
        // Check field access, in 2 of 3 cases below this works, otherwise it gets overwritten
        // in caseValueN == 0 && stageValueN == 0
        if(hasAccess)
        {
            if (caseValue) {
                params.amount = app.currency.formatAmountLocale(caseValue);
                params.labelAmount = params.label + ': ' + params.amount.toString();
            }

            if (caseValueN == 0 && stageValueN == 0) {
                // if we have no data
                params.amount = app.lang.get('LBL_FORECAST_DETAILS_NO_DATA', "Forecasts");
            } else if (caseValueN != 0 && stageValueN != 0 && caseValueN == stageValueN) {
                // if the values are equal but we have data
                params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_MEETING_QUOTA', "Forecasts");
            } else {
                /**
                 *  The bottom rectangles are supposed to tell the user if there is sufficient open pipeline in the current quarter to cover the deficit or not.
                 *  If there is surplus (meaning there is no deficit), the open pipeline will actually take the user above quota and that is always represented with green color.
                 */
                //if we are exceeding, we need to subtract to get the amount we exceed by
                if (caseValueN > stageValueN) {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_EXCEED', "Forecasts");
                    calcValue = app.math.sub(caseValueN, stageValueN);
                } else {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_SHORT', "Forecasts");
                    calcValue = app.math.sub(stageValueN, caseValueN);
                }

                params.percent = this.getPercent(calcValue, stageValueN);
                params.openPipeline = '(' + app.currency.formatAmountLocale(calcValue) + ')';

            }

            params.feedbackLn1 = params.shortOrExceed;

            if (params.percent) {
                params.feedbackLn1 += ' ' + params.percent;
            }

            params.feedbackLn2 = params.openPipeline;
        } else {
            params.amount = this.noDataAccessTemplate;
            params.labelAmount = params.label + ': ' + app.lang.get('LBL_NO_FIELD_ACCESS');
        }

        return params;
    },

    /**
     * Return the difference of two values and make sure it's a positive value
     *
     * used as a shortcut function for determine best/likely to closed/quota
     * @param caseValue
     * @param stageValue
     * @return {Number}
     */
    getAbsDifference: function (caseValue, stageValue) {
        return app.currency.formatAmountLocale(Math.abs(stageValue - caseValue));
    },

    /**
     * Gets a css class based on the amount relative to stageValue
     *
     * @param {Number} caseValue the value to check
     * @param {Number} stageValue the value to check against
     * @param {String} type the property to get
     * @return {string}
     */
    getClassBasedOnAmount: function (caseValue, stageValue, type) {
        var cssClass = '';
        // convert values to Numbers for comparison
        caseValue = parseFloat(caseValue);
        stageValue = parseFloat(stageValue);
        if(type == 'color') {
            if(caseValue == stageValue) {
                //
            } else if(caseValue > stageValue) {
                cssClass = 'font-green';
            } else {
                cssClass = 'font-red'
            }
        } else if(type == 'background-color') {
            if(caseValue == stageValue) {
                cssClass = 'grayLight';
            } else if(caseValue > stageValue) {
                cssClass = 'green';
            } else {
                cssClass = 'red';
            }
        }

        return cssClass;
    },

    /**
     * Returns a percent string based on the best/likely/worst case number vs. quota/closed amount
     *
     * @param caseValue likely/best/worst case value
     * @param stageValue the closed/quota amount from the model
     * @return {String}
     */
    getPercent: function (caseValue, stageValue) {
        var percent = 0,
            calcValue = caseValue;
        if (stageValue > 0 && caseValue > 0) {


            // divide the numbers and multiply times 100
            percent = (calcValue / stageValue) * 100;

            if (percent > 1) {
                // round to a whole number
                percent = Math.round(percent);
            } else {
                // Round the less-than-one percent to two decimal places
                // eg. percent=0.1234 -- percent*100 = 12.34, Math.round makes that 12
                // then percent/100 makes that back to 0.12
                percent = Math.round(percent*100)/100;
            }
        }
        return Math.abs(percent) + '%';
    },

    /**
     * Checks the selectedUser to see if they are a sub-manager
     */
    checkShowTargetQuota: function() {
        if(this.shouldRollup && this.selectedUser.is_manager && !this.selectedUser.is_top_level_manager) {
            this.showTargetQuota = true;
        } else {
            this.showTargetQuota = false;
        }
    },

    /**
     * checks the selectedUser to make sure it's a manager and if we should show the manager view
     * @return {Boolean}
     */
    isManagerView: function () {
        var isMgrView = false;
        if (this.currentModule == 'Forecasts') {
            // Forecasts has a more dynamic state, so make sure we check which worksheet is showing now
            if (this.context && this.context.parent && this.context.parent.has('model')) {
                isMgrView = this.context.parent.get('model').get('forecastType') == 'Rollup';
            }
        } else if(this.selectedUser.is_manager == true
            && (this.selectedUser.showOpps == undefined || this.selectedUser.showOpps === false))
        {
            isMgrView = true;
        }

        return isMgrView;
    },

    /**
     * Set the new time period
     *
     * @param {String} timePeriod id in string form
     */
    updateDetailsForSelectedTimePeriod: function (timePeriod) {
        // setting the model will trigger loadData()
        this.model.set({selectedTimePeriod: timePeriod});
    },

    /**
     * Set the new selected user
     *
     * @param {Object} selectedUser
     */
    updateDetailsForSelectedUser: function (selectedUser) {
        // don't directly set model selectedUser so we can handle selectedUser param in case it comes in as
        // just an id or something from somewhere else, so we can set it the right way for this dashlet
        this.selectedUser.last_name = selectedUser.last_name;
        this.selectedUser.first_name = selectedUser.first_name;
        this.selectedUser.full_name = selectedUser.full_name;
        this.selectedUser.id = selectedUser.id;
        this.selectedUser.is_manager = selectedUser.is_manager;
        this.selectedUser.reportees = selectedUser.reportees;
        this.selectedUser.showOpps = selectedUser.showOpps;
        this.selectedUser.user_name = selectedUser.user_name;
        this.selectedUser.reports_to_id = selectedUser.reports_to_id;
        this.selectedUser.reports_to_name = selectedUser.reports_to_name;
        this.selectedUser.is_top_level_manager = selectedUser.is_top_level_manager;

        this.shouldRollup = this.isManagerView();

        // update showTargetQuota on every user change
        this.checkShowTargetQuota();

        // setting the model will trigger loadData()
        this.model.set({selectedUser: selectedUser});
    },

    /**
     * Event handler to update which dataset is used.
     *
     * @param {jQuery.Event} evt click event
     */
    changeDisplayOptions : function(evt) {
        evt.preventDefault();
        this.handleOptionChange(evt);
    },

    /**
     * Handle the click event for the options menu
     *
     * @param {jQuery.Event} evt click event
     */
    handleOptionChange: function(evt) {
        var $el = $(evt.currentTarget),
            changedSegment = $el.attr('data-set');

        //check what needs to be done to the target
        if($el.hasClass('checked')) {
            //item was checked, uncheck it
            $el.removeClass('checked');
            $('div .projected_' + changedSegment).hide();
        } else {
            //item was unchecked and needs checked now
            $el.addClass('checked');
            $('div .projected_' + changedSegment).show();
        }
    }
}) },
"history-summary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryView
 * @alias SUGAR.App.view.views.BaseHistorySummaryView
 * @extends View.Views.Base.FlexListView
 */
({
	// History-summary View (base) 

    extendsFrom: 'FlexListView',

    /**
     * Array of module names to fetch history
     */
    activityModules: [],

    /**
     * An array of default activity modules to fetch
     */
    allActivityModules: [
        'Calls',
        'Emails',
        'Meetings',
        'Notes',
        'Tasks'
    ],

    /**
     * Module name of the record we're coming from
     */
    baseModule: '',

    /**
     * Record ID of the record we're coming from
     */
    baseRecord: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['ReorderableColumns', 'ResizableColumns', 'ListColumnEllipsis']);

        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }

        this.setActivityModulesToFetch();

        var HistoryCollection = app.BeanCollection.extend({
            module: 'history',
            activityModules: this.activityModules,
            buildURL: _.bind(function(params) {
                params = params || {};

                var url = app.api.serverUrl + '/'
                    + this.baseModule + '/'
                    + this.baseRecord + '/'
                    + 'link/history';

                params.module_list = this.activityModules.join(',');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            }, this),
            sync: function(method, model, options) {
                options = app.data.parseOptionsForSync(method, model, options);
                if (options.params.fields) {
                    delete options.params.fields;
                }
                var url = this.buildURL(options.params),
                    callbacks = app.data.getSyncCallbacks(method, model, options);

                app.api.call(method, url, options.attributes, callbacks);
            }
        });

        options.collection = new HistoryCollection();

        this._super('initialize', [options]);

        //override the flex-list template
        this.template = app.template.getView(this.meta.template);

        this.context.set({
            collection: this.collection
        });

        $('html').addClass('print-drawer');
    },

    /**
     * @override
     *
     * This view doesn't use the regular {@link Utils.Utils#isSortable} to check
     * whether the field is sortable.
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !lastOrderedFieldMeta.isSortable) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field: '',
                direction: 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * Sets the activityModules array which the collection sends to the endpoint
     * Override this function in child views to set a custom list of modules to fetch
     */
    setActivityModulesToFetch: function() {
        this.activityModules = this.allActivityModules;
    },

    /**
     * @inheritdoc
     * @override
     *
     * Overridden to use the collection's fetch, not the context
     */
    loadData: function(options) {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch(options);
    },

    /***
     * @inheritdoc
     *
     * Sets the field properly depending on the field name
     */
    _renderField: function(field) {
        var fieldName = field.name,
            fieldModule = field.model.get('_module'),
            fieldType = field.def.type || 'default';

        // check the fieldName and set the proper values
        if (fieldName === 'name') {
            // set the model's module to be the field's model's module
            // for the name link to be the proper ID
            field.model.module = fieldModule;
        } else if (fieldName === 'module') {
            field.model.set({
                module: field.model.get('moduleNameSingular')
            });
        } else if (fieldName === 'related_contact') {
            var contact,
                contactId;
            field.model.module = 'Contacts';
            switch (fieldModule) {
                case 'Emails':
                    // Emails does not have a related Contact/ID
                    contact = '';
                    contactId = '';
                    break;

                case 'Notes':
                case 'Calls':
                case 'Meetings':
                case 'Tasks':
                    contact = field.model.get('contact_name');
                    contactId = field.model.get('contact_id');
                    break;
            }
            field.model.set({
                related_contact: contact,
                related_contact_id: contactId
            });
        } else if (fieldName === 'status' && fieldModule === 'Emails') {
            // if this is the Status field and an Emails row,
            // translate the email status
            var fieldStatus = field.model.get('status'),
                emailStatusDom = app.lang.getAppListStrings('dom_email_status');

            // If this field is rendering again (like after "More history..." has been clicked)
            // it's 'status' will have already been run through the dom object
            if(!_.contains(emailStatusDom, fieldStatus)) {
                // if it hasn't already been translated, do it, do it now!
                fieldStatus = emailStatusDom[fieldStatus]
            }
            field.model.set({
                status: fieldStatus
            });
        }

        this._super('_renderField', [field]);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._sanitizeModels();
    },

    /**
     * Sets `model.module` to be in accordance with
     * model's `_module` attribute for each model.
     *
     * @private
     */
    _sanitizeModels: function() {
        this.collection.map(function(model) {
            model.module = model.get('_module');
        });
    },

    /**
     * @inheritdoc
     * @override
     *
     * Overriding to fetch using the collection, not the context
     */
    _setOrderBy: function(options) {
        if (this.orderByLastStateKey) {
            app.user.lastState.set(this.orderByLastStateKey, this.orderBy);
        }

        options.orderBy = this.orderBy;

        this.collection.dataFetched = false;
        this.collection.skipFetch = false;
        this.loadData(options);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $('html').removeClass('print-drawer');
        this._super('_dispose');
    }
}) },
"selection-list-context": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * This view displays the selected records at the top of a selection list. It
 * also allows to unselect them.
 *
 * @class View.Views.Base.SelectionListContextView
 * @alias SUGAR.App.view.views.BaseSelectionListContextView
 * @extends View.View
 */

({
	// Selection-list-context View (base) 

    className: 'selection-context',
    events: {
        'click [data-close-pill]': 'handleClosePillEvent',
        'click .reset_button': 'removeAllPills'
    },

    plugins: ['EllipsisInline'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.pills = [];
        /**
         * The maximum number of pills that can be displayed.
         *
         * @property {number}
         */
        this.maxPillsDisplayed = 50;
        this._super('initialize', [options]);
     },

    /**
     * Adds a pill in the template.
     *
     * @param {Data.Bean|Object|Array} models The model, set of model attributes
     * or array of those corresponding to the pills to add.
     */
    addPill: function(models) {
        var modelName;
        var pillsAttrs = [];
        var pillsIds = _.pluck(this.pills, 'id');
        models = _.isArray(models) ? models : [models];

        _.each(models, function(model) {
            //FIXME : SC-4196 will remove this.
            modelName = model.name || model.full_name || model.document_name ||
                model.get('name') || model.get('full_name') || model.get('document_name');
            if (modelName && !_.contains(pillsIds, model.id)) {
                pillsAttrs.push({id: model.id, name: modelName});
            }
        });

        this.pills.push.apply(this.pills, pillsAttrs);

        this._debounceRender();
    },

    /**
     * Removes a pill from the template.
     *
     * @param {Data.Bean|Object|Array} models The model or array of models
     * corresponding to the pills to remove. It can also be an object or array
     * of objects containing the 'id' of the pills to remove.
     *
     */
    removePill: function(models) {
        models = _.isArray(models) ? models : [models];
        var ids = _.pluck(models, 'id');
        this.pills = _.reject(this.pills, function(pill) {
            return _.contains(ids, pill.id);
        });
        this._debounceRender();
    },

    /**
     * Removes all the pills and sends an event to clear the mass collection.
     *
     * @param {Event} The click event.
     */
    removeAllPills: function(event) {
        if (event) {
            if (this.$(event.target).hasClass('disabled')) {
                return;
            }
        }
        this.pills = [];
        this.render();
        this.context.trigger('mass_collection:clear');
    },

    /**
     * Resets the pills to match the mass collection. Useful to update pills
     * on mass collection reset.
     *
     * @param {Data.BeanCollection} collection The collection that has been reset.
     */
    resetPills: function(collection) {
        if (!collection.length) {
            this.pills = [];
        }
        this.render();
    },

    /**
     * Click handler for the `close` button on a pill.
     *
     * @param {Event} event The click event.
     */
    handleClosePillEvent: function(event) {
        var id = this.$(event.target).closest('.select2-search-choice').data('id').toString();
        this.closePill(id);
    },

    /**
     * Removes the pill and triggers an event to remove it the model from the
     * mass collection.
     *
     * @param {string} modelId The id of the model to remove.
     */
    closePill: function(modelId) {
        this.removePill({id: modelId});
        var model = this.massCollection.get(modelId);
        this.context.trigger('mass_collection:remove', model);
    },

    /**
     * Debounced version of render.
     *
     * @private
     */
    _debounceRender: _.debounce(function() {
        this.render();
    }, 50),

    /**
     * @inheritdoc
     */
    _render: function() {
        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        if (this.pills.length > this.maxPillsDisplayed) {
            this.displayedPills = this.pills.slice(0, this.maxPillsDisplayed);
            this.tooManySelectedRecords = true;
            this.msgMaxPillsDisplayed = app.lang.get('TPL_MAX_PILLS_DISPLAYED', this.module, {
                maxPillsDisplayed: this.maxPillsDisplayed
            });
        } else {
            this.tooManySelectedRecords = false;
            this.displayedPills = this.pills;
        }

        var recordsLeft = this.massCollection.length - this.displayedPills.length;
        if (recordsLeft) {
            this.moreRecords = true;
            var label = this.displayedPills.length ? 'TPL_MORE_RECORDS' : 'TPL_RECORDS_SELECTED';
            this.msgMoreRecords = app.lang.get(label, this.module, {
                recordsLeft: recordsLeft
            });
        } else {
            this.moreRecords = false;
        }

        this._super('_render');
        this.stopListening(this.massCollection);

        this.listenTo(this.massCollection, 'add', this.addPill);
        this.listenTo(this.massCollection, 'remove', this.removePill);
        this.listenTo(this.massCollection, 'reset', this.resetPills);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('sync', function(collection, fetchedRecords) {
            if (!_.isArray(fetchedRecords)) {
                return;
            }
            var recordsToAdd = _.filter(fetchedRecords, function(attrs) {
                return this.massCollection.get(attrs.id);
            }, this);
            if (!recordsToAdd.length) {
                return;
            }
            this.addPill(recordsToAdd);
        }, this);
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"multi-selection-list-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * @class View.Views.Base.MultiSelectionListLinkView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListLinkView
 * @extends View.Views.Base.MultiSelectionListView
 */
({
	// Multi-selection-list-link View (base) 

    extendsFrom: 'MultiSelectionListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.meta.selection = _.extend({}, options.meta.selection, {isLinkAction: true});
    },

    /**
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection-list:link:multi', this._selectMultipleAndClose, this);
        this.context.on('selection-list:select', this._refreshList, this);
    },

    /**
     * After a model is selected, refresh the list view and add the model to
     * selections.
     *
     * @private
     */
    _refreshList: function() {
        this.context.reloadData({
            recursive: false,
            error: function(error) {
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            }
        });
    },

    /**
     * Selects multiple models to link and fire the mass link event.
     *
     * @private
     */
    _selectMultipleAndClose: function() {
        var selections = this.context.get('mass_collection');
        if (selections && selections.length > 0) {
            this.layout.once('list:masslink:complete', this._closeDrawer, this);
            this.layout.trigger('list:masslink:fire');
        }
    },

    /**
     * Closes the drawer and then refreshes record page with new links.
     *
     * @private
     */
    _closeDrawer: function(model, data, response) {
        app.drawer.close();

        var context = this.context.get('recContext');
        var view = this.context.get('recView');

        if (context.has('parentModel')) {
            var parentModel = context.get('parentModel');
            var syncedAttributes = parentModel.getSynced();
            var updatedAttributes = _.reduce(data.record, function(memo, val, key) {
                    if (!_.isEqual(syncedAttributes[key], val)) {
                        memo[key] = val;
                    }
                    return memo;
                }, {});
            parentModel.set(updatedAttributes);
            //Once parent model is reset, reset internal synced attributes as well
            parentModel.setSyncedAttributes(data.record);
        }

        context.set('skipFetch', false);
        context.reloadData();
    }
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.ListView
 * @alias SUGAR.App.view.views.BaseListView
 * @extends View.View
 */
({
	// List View (base) 

    className: 'list-view',

    plugins: ['Pagination'],

    events: {
        'click [class*="orderBy"]':'setOrderBy'
    },

    defaultLayoutEvents: {
        "list:search:fire": "fireSearch",
        "list:filter:toggled": "filterToggled",
        "list:alert:show": "showAlert",
        "list:alert:hide": "hideAlert",
        "list:sort:fire": "sort"
    },

    /**
     * View name that corresponds to the list of fields API should retrieve.
     * @property {string}
     */
    dataViewName: 'list',

    defaultContextEvents: {},

    // Model being previewed (if any)
    _previewed: null,
    //Store left column fields
    _leftActions: [],
    //Store right column fields
    _rowActions: [],
    //Store default and available(+visible) field names
    _fields: {},

    initialize: function(options) {
        //Grab the list of fields to display from the main list view (assuming initialize is being called from a subclass)
        var listViewMeta = app.metadata.getView(options.module, 'list') || {};
        //Extend from an empty object to prevent polution of the base metadata
        options.meta = _.extend({}, listViewMeta, options.meta || {});
        options.meta.type = options.meta.type || 'list';
        options.meta.action = 'list';
        options = this.parseFieldMetadata(options);

        app.view.View.prototype.initialize.call(this, options);

        //Set the context to load the field list from the record metadata.
        this.context.set('dataView', this.dataViewName);

        this.attachEvents();
        this.orderByLastStateKey = app.user.lastState.key('order-by', this);
        this.orderBy = this._initOrderBy();
        if(this.collection) {
            this.collection.orderBy = this.orderBy;
        }
        // Dashboard layout injects shared context with limit: 5.
        // Otherwise, we don't set so fetches will use max query in config.
        this.limit = this.context.has('limit') ? this.context.get('limit') : null;
        this.metaFields = this.meta.panels ? _.first(this.meta.panels).fields : [];

        this.registerShortcuts();
    },

    /**
     * Initializes the {@link #orderBy} property.
     *
     * Retrieves the last state from the local storage and verifies the field
     * is still sortable.
     *
     * @return {Object}
     * @return {string} return.field The field name to sort by.
     * @return {string} return.direction The direction to sort by (either `asc`
     *   or `desc`).
     * @protected
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !app.utils.isSortable(this.module, lastOrderedFieldMeta)) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field : '',
                direction : 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * @override
     * @private
     */
    _render: function () {
        app.view.View.prototype._render.call(this);
        //If user has no `list` access, render `noaccess.hbs` template
        if (!app.acl.hasAccessToModel(this.action, this.model)) {
            this._noAccessTemplate = this._noAccessTemplate || app.template.get("list.noaccess");
            this.$el.html(this._noAccessTemplate());
        }
    },

    /**
     * Parses the field's metadata to make sure that the following attributes
     * respect specific standards:
     *
     *  - `align`: accepted values are `left`, `center` and `right`.
     *  - `width`: the value can be a default width (e.g. `small` or `large`) or
     *  a number in pixels. Percentage widths are ignored.
     *
     * The method will add (or append to) two properties to each field's
     * metadata:
     *
     * - `classes`: css classes that should be set on the column header.
     * - `styles`: inline style that should be set on the column header.
     *
     * To render properly, make sure that the template sets them on the
     * column headers.
     *
     * @param {Object} options The `options` object passed in
     *   {@link #initialize}.
     * @param {Object} options.meta The metadata that we want to parse.
     * @return {Object} The `options` object with the metadata parsed and
     *   patched.
     */
    parseFieldMetadata: function(options) {
        // standardize the align and width param in the defs if they exist
        _.each(options.meta.panels, function(panel, panelIdx) {
            _.each(panel.fields, function(field, fieldIdx) {
                var fieldFromMeta = options.meta.panels[panelIdx].fields[fieldIdx];
                // FIXME align should be handled by the field directly - SC-3588
                if (!_.isUndefined(field.align)) {
                    if (_.contains(['left', 'center', 'right'], field.align)) {
                        fieldFromMeta.align = 't' + field.align;
                    } else {
                        delete fieldFromMeta.align;
                    }
                }

                // The width field in Studio is defined as a percentage which is
                // deprecated for Sugar7 modules. Check to see if module list
                // view metadata has been defined as percentage and if so,
                // ignore.
                if (!_.isUndefined(field.width)) {
                    // check to see if it's a percentage
                    // match beginning, decimal of 0 to 3 places, percent sign, end
                    var percent = field.width.toString().match(/^(\d{0,3})\%$/);
                    // ignore if defined as percent
                    if (!percent && !_.isEmpty(field.width+'')) {
                        var width = parseInt(field.width, 10);
                        if (!_.isNaN(width) && _.isNumber(width)) {
                            var styles = 'max-width:' + width + 'px;min-width:' + width + 'px';
                            fieldFromMeta.styles = styles;
                            fieldFromMeta.expectedWidth = width;
                        } else {
                            fieldFromMeta.widthClass = 'cell-' + field.width;
                            fieldFromMeta.expectedWidth = field.width;
                        }
                    }
                }
            }, this);
        }, this);

        return options;
    },

    /**
     * Takes the defaultListEventMap and listEventMap and binds the events. This is to allow views that
     * extend ListView to specify their own events.
     */
    attachEvents: function() {
        this.layoutEventsMap = _.extend(this.defaultLayoutEvents, this.layoutEvents); // If undefined nothing will be added.
        this.contextEventsMap = _.extend(this.defaultContextEvents, this.contextEvents);

        if (this.layout) {
            _.each(this.layoutEventsMap, function(callback, event) {
                this.layout.on(event, this[callback], this);
            }, this);
        }

        if (this.context) {
            _.each(this.contextEventsMap, function(callback, event) {
                this.context.on(event, this[callback], this);
            }, this);
        }
    },

    sort: function() {
        //When sorting the list view, we need to close the preview panel
        app.events.trigger("preview:close");
    },

    showAlert: function(message) {
        this.$("[data-target=alert]").html(message);
        this.$("[data-target=alert-container]").removeClass("hide");
    },

    hideAlert: function() {
        this.$("[data-target=alert-container]").addClass("hide");
        this.$("[data-target=alert]").empty();
    },
    filterToggled:function (isOpened) {
        this.filterOpened = isOpened;
    },
    fireSearch:function (term) {
        term = term || "";
        var options = {
            limit: this.limit || null,
            query: term
        };
        this.context.get("collection").resetPagination();
        this.context.resetLoadFlag(false);
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },

    /**
     * Sets order by on collection and view.
     *
     * The event is canceled if an element being dragged is found.
     *
     * @param {Event} event jQuery event object.
     */
    setOrderBy: function(event) {
        if ($(event.currentTarget).find('ui-draggable-dragging').length) {
            return;
        }
        var collection, options, eventTarget, orderBy;
        var self = this;

        collection = self.collection;
        eventTarget = self.$(event.currentTarget);

        // first check if alternate orderby is set for column
        orderBy = eventTarget.data('orderby');
        // if no alternate orderby, use the field name
        if (!orderBy) {
            orderBy = eventTarget.data('fieldname');
        }
        // if same field just flip
        if (orderBy === self.orderBy.field) {
            self.orderBy.direction = self.orderBy.direction === 'desc' ? 'asc' : 'desc';
        } else {
            self.orderBy.field = orderBy;
            self.orderBy.direction = 'desc';
        }

        collection.orderBy = self.orderBy;

        collection.resetPagination();

        options = self.getSortOptions(collection);

        if(this.triggerBefore('list:orderby', options)) {
            self._setOrderBy(options);
        }
    },

    /**
     * Run the order by on the collection
     *
     * @param {Object} options
     * @private
     */
    _setOrderBy: function(options) {
        if(this.orderByLastStateKey) {
            app.user.lastState.set(this.orderByLastStateKey, this.orderBy);
        }
        // refetch the collection
        this.context.resetLoadFlag(false);
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },
    /**
     * Gets options for fetch call for list sorting
     * @param collection
     * @return {Object}
     */
    getSortOptions: function(collection) {
        var self = this, options = {};
        // Treat as a "sorted search" if the filter is toggled open
        options = self.filterOpened ? self.getSearchOptions() : {};

        //Show alerts for this request
        options.showAlerts = true;

        // If injected context with a limit (dashboard) then fetch only that
        // amount. Also, add true will make it append to already loaded records.
        options.limit = self.limit || null;
        options.success = function (collection, response, options) {
            self.layout.trigger("list:sort:fire", collection, self);
        };

        // if we have a bunch of models already fetch at least that many
        if (collection.offset) {
            options.limit = collection.offset;
            options.offset = 0;
        }

        return options;
    },
    getSearchOptions:function () {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params:{},
            fields:collection.fields ? collection.fields : this.collection
        };
        if (term) {
            options.params.q = term;
        }
        if (this.context.get('link')) {
            options.relate = true;
        }
        return options;
    },
    bindDataChange:function () {
        if (this.collection) {
            this.collection.on("reset", this.render, this);
        }
    },

    _dispose: function() {
        this._fields = null;
        app.view.View.prototype._dispose.call(this);
    },

    /**
     * Select next or previous row.
     * @param {Boolean} down
     */
    selectRow: function(down) {
        var $rows = this.$('.dataTable tbody tr'),
            $selected,
            $next;

        if ($rows.hasClass('selected')) {
            $selected = $rows.filter('.selected');
            $next = down ? $selected.next() : $selected.prev();
            if($next.length > 0) {
                $selected.removeClass('selected');
                $next.addClass('selected');
                this.makeRowVisible($next);
            }
        } else {
            $rows.first().addClass('selected');
            this.makeRowVisible();
        }
    },

    /**
     * Scroll list view such that the selected row is visible.
     * @param {jQuery} $selected
     */
    makeRowVisible: function($selected) {
        var $mainpane = this.$el.closest('.main-pane'),
            mainpaneHeight,
            selectedHeight,
            selectedTopPosition,
            selectedOffsetParent;

        if (_.isUndefined($selected)) {
            $mainpane.scrollTop(0);
            return;
        }

        mainpaneHeight = $mainpane.height();
        selectedHeight = $selected.height();
        selectedOffsetParent = $selected.offsetParent();
        selectedTopPosition = $selected.position().top + selectedOffsetParent.position().top;

        if ((selectedTopPosition + selectedHeight) > mainpaneHeight) {
            $mainpane.scrollTop($mainpane.scrollTop() + mainpaneHeight/2);
        }

        if (selectedTopPosition < 0) {
            $mainpane.scrollTop($mainpane.scrollTop() - mainpaneHeight/2);
        }
    },

    /**
     * Scroll list view either right or left.
     * @param {Boolean} right
     */
    scrollHorizontally: function(right) {
        var $scrollableDiv = this.$('.flex-list-view-content'),
            scrollEnabled = this.$el.hasClass('scroll-width'),
            nextScrollPosition,
            increment = 60;

        if (scrollEnabled) {
            if (right) {
                nextScrollPosition = $scrollableDiv.scrollLeft() + increment;
            } else {
                nextScrollPosition = $scrollableDiv.scrollLeft() - increment;
            }

            $scrollableDiv.scrollLeft(nextScrollPosition);
        }
    },

    /**
     * Register shortcut keys.
     */
    registerShortcuts: function() {
        app.shortcuts.register('List:Select:Down', 'j', function() {
            this.selectRow(true);
        }, this);

        app.shortcuts.register('List:Select:Up', 'k', function() {
            this.selectRow(false);
        }, this);

        app.shortcuts.register('List:Scroll:Left', 'h', function() {
            this.scrollHorizontally(false);
        }, this);

        app.shortcuts.register('List:Scroll:Right', 'l', function() {
            this.scrollHorizontally(true);
        }, this);

        app.shortcuts.register('List:Select:Open', 'o', function() {
            if (this.$('.selected [data-type=name] a:visible').length > 0) {
                this.$('.selected [data-type=name] a:visible').get(0).click();
            } else if (this.$('.selected [data-type=fullname] a:visible').length > 0) {
                this.$('.selected [data-type=fullname] a:visible').get(0).click();
            }
        }, this);
    }
}) },
"link-moduleselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LinkModuleselectView
 * @alias SUGAR.App.view.views.BaseLinkModuleselectView
 * @extends View.View
 */
({
	// Link-moduleselect View (base) 

    linkModules: [],
    events: {
        'click label[for=relationship]': 'setFocus'
    },
    initialize: function (options) {
        app.view.View.prototype.initialize.call(this, options);
        this.linkModules = this.context.get("linkModules");
    },
    setFocus: function (e) {
        this.$("#relationship").select2("open");
    },
    _renderHtml: function (ctx, options) {
        var self = this;
        app.view.View.prototype._renderHtml.call(this, ctx, options);
        this.$(".select2").select2({
            width: '100%',
            allowClear: true,
            placeholder: app.lang.get("LBL_SEARCH_SELECT")
        }).on("change", function (e) {
            if (_.isEmpty(e.val)) {
                self.context.trigger("link:module:select", null);
            } else {
                var meta = self.linkModules[e.val];
                self.context.trigger("link:module:select", {link: meta.link, module: meta.module});
            }
        });
    },
    _dispose: function() {
        this.$(".select2").select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"modal-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalHeaderView
 * @alias SUGAR.App.view.views.BaseModalHeaderView
 * @extends View.View
 */
({
	// Modal-header View (base) 

    events: {
        'click .close' : 'close'
    },
    close: function() {
        this.layout.hide();
    },
    setTitle: function(title) {
        this.title = title;
    },
    setButton: function(buttons) {
        this.buttons = buttons;
    }
}) },
"massaddtolist-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistProgressiew
 * @alias SUGAR.App.view.views.BaseMassaddtolistProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Massaddtolist-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSADDTOLIST_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSADDTOLIST_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSADDTOLIST_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSADDTOLIST_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSADDTOLIST_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSADDTOLIST_SUCCESS',
            TITLE: 'TPL_MASSADDTOLIST_TITLE'
        }
    }

}) },
"subpanel-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used within Subpanel layouts.
 *
 * @class View.Views.Base.SubpanelListView
 * @alias SUGAR.App.view.views.BaseSubpanelListView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Subpanel-list View (base) 

    extendsFrom: 'RecordlistView',
    fallbackFieldTemplate: 'list',
    plugins: ['ErrorDecoration', 'Editable', 'SugarLogic', 'Pagination',
        'ResizableColumns', 'MassCollection'],

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:unlinkrow:fire": "warnUnlink"
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        // `dataViewName` corresponds to the list of fields the API should retrieve.
        this.dataViewName = options.name || 'subpanel-list';

        this._super("initialize", [options]);

        // Setup max limit on collection's fetch options for this subpanel's context
        var limit = this.context.get('limit') || app.config.maxSubpanelResult;

        if (limit) {
            this.context.set('limit', limit);
            //supanel-list extends indirectly ListView, and `limit` determines # records displayed
            this.limit = limit;
        }

        //Override the recordlist row template
        this.rowTemplate = app.template.getView('recordlist.row');

        //event register for preventing actions
        //when user escapes the page without confirming deletion
        app.routing.before("route", this.beforeRouteUnlink, this);
        $(window).on("beforeunload.unlink" + this.cid, _.bind(this.warnUnlinkOnRefresh, this));
    },

    /**
     * When parent recordlist's initialize is invoked (above), this will get called
     * and populate our the list's meta with the proper view subpanel metadata.
     * @return {Object} The view metadata for this module's subpanel.
     */
    _initializeMetadata: function() {
        return  _.extend({},
            app.metadata.getView(null, 'subpanel-list', true),
            app.metadata.getView(this.options.module, 'record-list', true),
            app.metadata.getView(this.options.module, 'subpanel-list', true)
        );
    },

    /**
     * Unlink (removes) the selected model from the list view's collection
     */
    unlinkModel: function() {
        var self = this,
            model = this._modelToUnlink;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getUnlinkMessages(self._modelToUnlink).success
                }
            },
            relate: true,
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToUnlink = null;
                self.collection.remove(model, { silent: redirect });

                if (redirect) {
                    self.unbindBeforeRouteUnlink();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                // We trigger reset after removing the model so that
                // panel-top will re-render and update the count.
                self.collection.trigger('reset');
                self.render();
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteUnlink: function () {
        if (this._modelToUnlink) {
            this.warnUnlink(this._modelToUnlink);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when unlinking a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getUnlinkMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_UNLINK_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Popup dialog message to confirm unlink action
     *
     * @param {Backbone.Model} model the bean to unlink
     */
    warnUnlink: function(model) {
        var self = this;
        this._modelToUnlink = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('unlink_confirmation', {
            level: 'confirmation',
            messages: self.getUnlinkMessages(model).confirmation,
            onConfirm: _.bind(self.unlinkModel, self),
            onCancel: function() {
                self._modelToUnlink = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm unlink action
     *
     * @return {String} the message to be displayed in the browser alert
     */
    warnUnlinkOnRefresh: function() {
        if (this._modelToUnlink) {
            return this.getUnlinkMessages(this._modelToUnlink).confirmation;
        }
    },

    /**
     * Detach the event handlers for warning unlink
     */
    unbindBeforeRouteUnlink: function() {
        app.routing.offBefore("route", this.beforeRouteUnlink, this);
        $(window).off("beforeunload.unlink" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        this.unbindBeforeRouteUnlink();
        this._super('_dispose');
    }
}) },
"filtered-search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredSearchView
 * @alias SUGAR.App.view.views.BaseFilteredSearchView
 * @extends View.View
 */
({
	// Filtered-search View (base) 

    events: {
        'keyup [data-searchfield]': 'searchFired'
    },

    /**
     * @inheritdoc
     *
     * Update searchable fields.
     */
    bindDataChange: function() {
        this.context.on('filteredlist:filter:set', this.setFilter, this);
    },

    /**
     * Update quick search placeholder to display searchable fields.
     * @param {Array} filter List of field name.
     */
    setFilter: function(filter) {
        var label = app.lang.get('LBL_SEARCH_BY') + ' ' + filter.join(', ') + '...';
        this.$('[data-searchfield]').attr('placeholder', label);
    },

    /**
     * Updated current typed search term.
     */
    searchFired: _.debounce(function(evt) {
        var value = $(evt.currentTarget).val();
        this.context.trigger('filteredlist:search:fired', value);
    }, 100)
}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditView
 * @alias SUGAR.App.view.views.BaseAuditView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Audit View (base) 

    extendsFrom: 'FilteredListView',

    fallbackFieldTemplate: 'list-header',

    /**
     * @inheritdoc
     * Assign base module and record id.
     * Override the new Audit collection
     * in order to fetch correct audit end-point.
     */
    initialize: function(options) {
        // in order to render the 'list' template on each field
        this.action = 'list';
        // populating metadata for audit module
        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }
        this._super('initialize', [options]);

       if (!this.collection) {
           this._initCollection();
       }
    },

    /**
     * Override the collection set up by new audit REST end-point.
     * @private
     */
    _initCollection: function() {
        var AuditCollection = app.BeanCollection.extend({
            module: 'audit',
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,
            buildURL: function(params) {
                params = params || {};

                var parts = [],
                    url;
                parts.push(app.api.serverUrl);
                parts.push(this.baseModule);
                parts.push(this.baseRecordId);
                parts.push(this.module);
                url = parts.join('/');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            },
            sync: function(method, model, options) {
                var url = this.buildURL(options.params),
                    callbacks = app.data.getSyncCallbacks(method, model, options);
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new AuditCollection();
    },

    /**
     * @inheritdoc
     * Instead of fetching context, it fetches the collection directly.
     */
    loadData: function() {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     *
     * Patch audit models `before` and `after` fields with information of
     * original field available within parent model, in order to render
     * properly.
     */
    _renderData: function() {
        var parentModule = this.context.parent.get('module');
        var fields = app.metadata.getModule(parentModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var before = _.findWhere(model.fields, {name: 'before'});
            _.extend(before, fields[model.get('field_name')], {name: 'before'});

            var after = _.findWhere(model.fields, {name: 'after'});
            _.extend(after, fields[model.get('field_name')], {name: 'after'});

            // FIXME: Temporary fix due to time constraints, proper fix will be addressed in TY-359
            // We can check just `before` since `before` and `after` refer to same field
            if (_.contains(['multienum', 'enum'], before['type']) && before['function']) {
                before['type'] = 'base';
                after['type'] = 'base';
            }

            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in
            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.module),
                model.fields
            );
        }, this);

        this._super('_renderData');
    }
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BwcView
 * @alias SUGAR.App.view.views.BaseBwcView
 * @extends View.View
 */
({
	// Bwc View (base) 

    className: 'bwc-frame',
    // Precompiled regex (note-regex literal causes errors but RegExp doesn't)
    moduleRegex: new RegExp('module=([^&]*)'),
    idRegex: new RegExp('record=([^&]*)'),
    actionRegex: new RegExp('action=([^&]*)'),

    plugins: ['Editable', 'LinkedModel'],

    /**
     * Enabled actions for warning unsaved changes.
     */
    warnEnabledBwcActions: [
        'editview', 'config'
    ],

    /**
     * The URL to a BWC view to be used in the iFrame element (template).
     *
     * See {@link #_renderHtml} on how this is created and then kept in sync
     * with the iFrame.
     *
     * @property {string}
     */
    url: '',

    /**
     * Sets the current URL of this view to point to a bwc link.
     *
     * See {@link #_setCurrentUrl} on how this is kept in sync with the current
     * view url and window hash.
     *
     * @property {string}
     * @private
     */
    _currentUrl: '',

    initialize: function(options) {
        // If (for some reason) we're trying to directly access old Home/Dashboards, for redirect to sidecar #Home
        var url = options.context.get('url');
        if (url && (url.search(/module=Home.*action=index/) > -1 || url.search(/action=index.*module=Home/) > -1)) {
            app.router.navigate('#Home', {trigger: true});
            return;
        }

        app.events.on("api:refreshtoken:success", this._refreshSession, this);

        this._super('initialize', [options]);
        this.bwcModel = app.data.createBean('bwc');

        // because loadView disposes the old layout when the bwc iFrame is no
        // longer in the DOM, it causes a memory leak unless we unbind it
        // before the new layout is loaded.
        app.before('app:view:load', this.unbindDom, this);
    },

    /**
     * @inheritdoc
     *
     * Inspect changes on current HTML input elements with initial values.
     */
    hasUnsavedChanges: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        //if bwcModel is empty, then it should return false (since it's not in enabled actions)
        // or we couldnt find a edit view to compare or the view doesn't want to be compared
        if (_.isEmpty(this.bwcModel.attributes) || _.isUndefined(bwcWindow.EditView) || $(bwcWindow.EditView).data('disablebwchaschanged')) {
            return false;
        }
        // some forms may still be doing async loading after document ready
        // do not compare if the loading is not done yet
        if (!_.isUndefined(bwcWindow.asyncLoading) && bwcWindow.asyncLoading) {
            return false;
        }
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        return !_.isEmpty(this.bwcModel.changedAttributes(newAttributes));
    },

    /**
     * Retrieves form's input values in object format
     *
     * @param {HTMLElement} theForm form element.
     * @return {Object} key-value paired object.
     */
    serializeObject: function(theForm) {
        var formArray = $(theForm).serializeArray();
        return _.reduce(formArray, function(acc, field) {
            acc[field.name] = field.value;
            return acc;
        }, {});
    },

    /**
     * @inheritdoc
     *
     * Override {@link View.View#_render} method to
     * extend ACL check for Administration module in BWC mode.
     * Allow access to Administration if user has admin access to any
     * module only, if not - show error message and navigate to home.
     */
    _render: function() {
        if (this.module === 'Administration' &&
            !app.acl.hasAccessToAny('admin') &&
            !app.acl.hasAccessToAny('developer')
        ) {
            app.logger.info(
                'Current user does not have access to this module view. name: ' +
                    this.name + ' module:' + this.module
            );
            app.error.handleRenderError(this, 'view_render_denied');
            app.router.navigate('#Home', {trigger: true});
            return;
        }
        app.view.View.prototype._render.call(this);
        return this;
    },

    /**
     * Render the iFrame and listen for content changes on it.
     *
     * Every time there is an update on the iFrame, we:
     * - clear any '.bwc.sugarcrm' event (namespace for any bind in this view);
     * - update the controller context to mach our bwc module (if exists);
     * - update our url to match the current iFrame location in bwc way;
     * - rewrite links for sidecar modules;
     * - rewrite links that go for new windows;
     * - memorize the form input elements in order to warn unsaved changes;
     * - update the context model to mach our current bwc module (if exists);
     *
     * @private
     */
    _renderHtml: function() {
        var self = this;

        this.url = app.utils.addIframeMark(this.context.get('url') || 'index.php?module=' + this.module + '&action=index');
        app.view.View.prototype._renderHtml.call(this);

        this.$('iframe').load(function() {
            //In order to update current location once bwc link is clicked.
            self.url = 'index.php' + this.contentWindow.location.search;
            self._setCurrentUrl();

            if (this.contentWindow.$ === undefined) {
                // no jQuery available, graceful fallback
                return;
            }

            $(this.contentWindow).one('beforeunload', _.bind(self.unbindDom, self));

            self._setModule(this.contentWindow);
            self._setBwcModel(this.contentWindow);
            self._setModel(this.contentWindow);
            self._rewriteLinksForSidecar(this.contentWindow);
            self._rewriteNewWindowLinks(this.contentWindow);
            self._cloneBodyClasses(this.contentWindow);

            $('html', this.contentWindow.document).on('click.bwc.sugarcrm', function() {
                app.bwc.trigger('clicked');
            });
        });
    },

    /**
     * Clone classes, added by Modernizr, "top frame" into "bwc frame";
     * necessary for various overrides on iPhone and Android.
     */
    _cloneBodyClasses: function(contentWindow) {
        contentWindow.$('html').addClass($('html').prop('class'));
    },
    /**
     * Update the controller context to mach our bwc module.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModule: function(contentWindow) {
        var module = this.moduleRegex.exec(contentWindow.location.search);
        module = (_.isArray(module)) ? module[1] : null;

        if (!module) {
            // try and strip module off the page if its not set on location
            if (contentWindow.$ && contentWindow.$('input[name="module"]') && contentWindow.$('input[name="module"]').val()) {
                module = contentWindow.$('input[name="module"]').val();
            } else {
                return;
            }

        }
        // on BWC import we want to try and take the import module as the module
        if (module === 'Import') {
            var importModule = /import_module=([^&]*)/.exec(contentWindow.location.search);
            if (!_.isNull(importModule) && !_.isEmpty(importModule[1])) {
                module = importModule[1];
            } else if (contentWindow.$ &&
                contentWindow.$('input[name="import_module"]') &&
                contentWindow.$('input[name="import_module"]').val()) {

                // try and strip import module off the page if its not set on location
                module = contentWindow.$('input[name="import_module"]').val();
            }
        }
        // update bwc context
        var app = window.parent.SUGAR.App;
        app.controller.context.set('module', module);
        app.events.trigger('app:view:change', this.layout, {module: module});
    },

    /**
     * Memorize the form input elements if current page contains edit form.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setBwcModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        //once edit page is entered, the page is navigated without action query string.
        //Therefore, if current page contains 'EditView' form, bind the action as 'editview'.
        if (contentWindow.EditView) {
            action = 'editview';
        }

        var attributes = {};
        if (_.contains(this.warnEnabledBwcActions, action)) {
            attributes = this.serializeObject(contentWindow.EditView);
        }
        this.resetBwcModel(attributes);
    },

    /**
     * Populates the context model with API data.
     * `this.model` is a link for `this.context.model`.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        if (action !== 'detailview') {
            return;
        }

        var id = this.idRegex.exec(this._currentUrl);
        if (!_.isArray(id)) {
            return;
        }

        this.model.set('id', id[1]);
        this.model.module = this.context.get('module');
        this.model.fetch();
    },

    /**
     * @inheritdoc
     *
     * Opens the appropriate sidecar create layout in a drawer.
     *
     * @param {String} module Module name.
     * @param {String} link Link name.
     */
    openCreateDrawer: function(module, link) {
        var parentModel = this.context.get('model'),
            model = this.createLinkModel(parentModel, link),
            self = this;
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            // Reload the BWC to update subpanels.
            self.$('iframe').get(0).contentWindow.location.reload(true);
        });
    },

    /**
     * Opens the Archive Email drawer, passing in the parent model to relate to
     * Reloads the BWC page if email created so it appears in the subpanel
     */
    openArchiveEmailDrawer: function() {
        var self = this,
            parentModel = this.context.get('model');

        app.drawer.open({
            layout: 'archive-email',
            context: {
                create: true,
                module: 'Emails',
                prepopulate: {
                    related: parentModel
                }
            }
        }, function(model) {
            if (model) {
                // Reload the BWC to update subpanels.
                self.$('iframe').get(0).contentWindow.location.reload(true);
            }
        });
    },

    /**
     * Update current window location based on the {@link #url} property.
     *
     * Confirms that the sidecar hash is always matching the url in the iFrame
     * prefixed by`#bwc/` hash (for proper routing handling).
     *
     * @private
     */
    _setCurrentUrl: function() {
        this._currentUrl = app.utils.rmIframeMark('#bwc/' + this.url);
        window.parent.location.hash = this._currentUrl;
    },

    /**
     * Revert model attributes with the current form elements.
     */
    revertBwcModel: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        this.resetBwcModel(newAttributes);
    },

    /**
     * Reset model attributes with the initial attributes.
     *
     * @param {Object} key-value pair attributes.
     */
    resetBwcModel: function(attr) {
        this.bwcModel.clear({
            silent: true
        }).set(attr);
    },

    /**
     * Gets the sidecar url based on a given bwc hyperlink.
     * @param {String} href the bwc hyperlink.
     * @return {String} the new sidecar hyperlink (empty string if unable to convert).
     */
    convertToSidecarUrl: function(href) {
        var module = this.moduleRegex.exec(href),
            id = this.idRegex.exec(href),
            action = this.actionRegex.exec(href);

        module = (_.isArray(module)) ? module[1] : null;
        if (!module) {
            return '';
        }
        //Route links for BWC modules through bwc/ route
        if (app.metadata.getModule(module).isBwcEnabled) {
            //Remove any './' nonsense in existing hrefs
            href = href.replace(/^.*\//, '');
            return "bwc/" + href;
        }
        id = (_.isArray(id)) ? id[1] : null;
        action = (_.isArray(action)) ? action[1] : '';
        // fallback to sidecar detail view
        if (action.toLowerCase() === 'detailview') {
            action = '';
        }

        if (!id && action.toLowerCase() === 'editview') {
            action = 'create';
        }
        return app.router.buildRoute(module, id, action);
    },

    /**
     * Rewrites old link element to the new sidecar router.
     *
     * This adds an event to all the links that are converted and don't open in
     * a new tab/window. Therefore it is imperative that you take memory leaks
     * precautions. See {@link #unbindDom} for more information.
     *
     * The reason why we don't use an `onclick="..."` attribute, is simply due
     * to requirements of tracking the event and stop propagation, which would
     * be extremely difficult to support cross browser.
     *
     * @param {HTMLElement} The link `<a>` to rewrite into a sidecar url.
     */
    convertToSidecarLink: function(elem) {
        elem = $(elem);
        //Relative URL works better on all browsers than trying to include origin
        var baseUrl = app.config.siteUrl || window.location.pathname;
        var href = elem.attr('href');
        var module = this.moduleRegex.exec(href);
        var dataSidecarRewrite = elem.attr('data-sidecar-rewrite');
        var action = this.actionRegex.exec(href);

        if (
            !_.isArray(module) ||
            _.isEmpty(module[1]) ||
            _.isUndefined(app.metadata.getModule(module[1])) ||
            module[1] === "Administration" || // Leave Administration module links alone for 7.0
            href.indexOf("javascript:") === 0 || //Leave javascript alone (this is mostly BWC links)
            dataSidecarRewrite === 'false' ||
            (_.isArray(action) && action[1] === 'sugarpdf') //Leave PDF downloads for bwc modules
        ) {
            return;
        }
        var sidecarUrl = this.convertToSidecarUrl(href);
        elem.attr('href', baseUrl + '#' + sidecarUrl);
        elem.data('sidecarProcessed', true);

        if (elem.attr('target') === '_blank') {
            return;
        }

        app.logger.debug('Bind event in BWC view');

        elem.on('click.bwc.sugarcrm', function(e) {
            if (e.button !== 0 || e.ctrlKey || e.metaKey) {
                return;
            }
            e.stopPropagation();
            parent.SUGAR.App.router.navigate(sidecarUrl, {trigger: true});
            return false;
        });
        app.accessibility.run(elem, 'click');
    },

    /**
     * Allow BWC modules to rewrite their links when using their own ajax
     * calls.
     *
     * *ATTENTION:* This method might cause memory leaks if not used properly.
     * Make sure that {@link #unbindDom} is being used and cleaning up any
     * events that this view is creating (use {@link Utils.Logger.levels}
     * `debug` level to track all the events being created and check if the
     * ones being cleared by {@link #unbindDom} match.
     */
    rewriteLinks: function() {
        app.logger.warn('Possible memory leak on BWC code');
        var frame = this.$('iframe').get(0).contentWindow;
        this._rewriteLinksForSidecar(frame);
        this._rewriteNewWindowLinks(frame);
    },

    /**
     * Rewrite old links on the frame given to the new sidecar router.
     *
     * This will match all hrefs that contain "module=" on it and if the module
     * isn't blacked listed, then rewrite into sidecar url.
     * Since iFrame needs full URL to sidecar urls (to provide copy paste urls,
     * open in new tab/window, etc.) this will check what is the base url to
     * apply to that path.
     *
     * See `include/modules.php` for the list (`$bwcModules`) of modules not
     * sidecar ready.
     *
     * This method is private because it binds data and might cause memory
     * leaks. Please use this with caution and with {@link #unbindDom}.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteLinksForSidecar: function(frame) {
        var self = this;

        frame.$('a[href*="module="]').each(function(i, elem) {
            self.convertToSidecarLink(elem);
        });
    },

    /**
     * Rewrite new window links (`target=_blank`) on the frame given to the new
     * sidecar with bwc url.
     *
     * This will match all `"target=_blank"` links that aren't already pointing
     * to sidecar already and make them sidecar bwc compatible. This will
     * assume that all links to sidecar modules are already rewritten.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteNewWindowLinks: function(frame) {
        var ieOrigin,
            baseUrl,
            $links = frame.$('a[target="_blank"]').not('[href^="http"]').not('[href*="entryPoint=download"]');

        // for IE 10 & below, which does not have window.location.origin
        if (!window.location.origin) {
            ieOrigin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
        }
        baseUrl = app.config.siteUrl || (window.location.origin || ieOrigin) + window.location.pathname;

        $links.each(function(i, elem) {
            var $elem = $(elem);
            if ($elem.data('sidecarProcessed')) {
                return;
            }
            $elem.attr('href', baseUrl + '#bwc/' + $elem.attr('href'));
        });
    },

    /**
     * Unbinds all events that were hooked in this view with the `bwc.sugarcrm`
     * namespace into links (`<a>` anchor tags).
     *
     * Only unbinds if the content window has jQuery and the `iframe` is
     * loaded.
     * To avoid memory leaks, please always confirm that this function is
     * called when any event is added to the `iframe` from this view or
     * sidecar.
     *
     * Example:
     *
     *     // write some `methodWithBind` that binds click events in bwc
     *     // elements in this bwc view.
     *     // call that method from within the bwc view like:
     *     parent.SUGAR.App.view.views.BaseBwcView.prototype.methodWithBind();
     *     // memory leak will happen if `methodWithBind` doesn't use the
     *     // `.bwc.sugarcrm` namespace.
     *
     * If the BWC view is replacing it's current html with a new one, it should
     * also call this method before replacing the contents, so that it won't
     * cause memory leak.
     */
    unbindDom: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        if (!bwcWindow || bwcWindow.$ === undefined) {
            return;
        }

        this.confirmMemLeak(bwcWindow.document);

        $('a', bwcWindow.document).off('.bwc.sugarcrm');
        $('html', bwcWindow.document).off('.bwc.sugarcrm');
    },

    confirmMemLeak: function(target) {
        app.logger.debug(function() {
            var registered = _.reduce($('a', target), function(memo, el) {
                var events = $._data(el, 'events');
                return memo + _.where(_.flatten(events), {namespace: 'bwc.sugarcrm'}).length;
            }, 0);

            return 'Clear ' + registered + ' event(s) in `bwc.sugarcrm`.';
        });
    },

    /**
     * Before routing event handling on BWC views.
     *
     * This will track all url changes during the BWC redirect process. It
     * calls {@link #unbindDom} on all route changes, unless the new url
     * requested is the same as the previous one with only the `bwcFrame=1`
     * difference in the URL.
     * When the latter happens, it just means that we are cleaning up the link,
     * but there is no actual reload of the iFrame, so we can't remove the
     * events.
     *
     * The {@link #_setCurrentUrl} method is setting the {@link #_currentUrl}
     * as the one set in the parent window as hash. This means that there is no
     * real reload of the view, just hash update to keep it in sync.
     *
     * The custom route `route: "bwc/*url"` is ignoring the reload of the view
     * based on the same logic used here.
     *
     * @deprecated since 7.7, will be removed in 7.8.
     *
     * @param {Object} route Route object being passed from
     *   {@link Core.Routing#beforeRoute}.
     */
    beforeRoute: function(route) {

        app.log.warn('`app.bwc.beforeRoute()` is deprecated since 7.7. This method will be removed in 7.8.');

        var bwcUrl = route && route.args && route.args[0];

        if (bwcUrl && this._currentUrl.replace('#bwc/', '') === bwcUrl) {
            // update hash link only
            return;
        }

        this.unbindDom();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off("api:refreshtoken:success", this._refreshSession, this);

        this.unbindDom();
        app.offBefore(null, null, this);
        if (this.bwcModel) {
            this.bwcModel.off();
            this.bwcModel = null;
        }
        this._super('_dispose');
    },

    /**
     * Refreshes session on server side
     */
    _refreshSession: function() {
        app.bwc.login();
    }
}) },
"planned-activities": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @inheritdoc
 *
 * Planned Activities dashlet takes advantage of the tabbed dashlet abstraction
 * by using its metadata driven capabilities to configure its tabs in order to
 * display planned activities of specific modules.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Planned Activities
 * dashlet also supports other properties:
 *
 * - {Array} invitation_actions field def for the invitation actions buttonset
 *           triggers showing invitation actions buttons and corresponding collection
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.PlannedActivitiesView
 * @alias SUGAR.App.view.views.BasePlannedActivitiesView
 * @extends View.Views.Base.HistoryView
 */
({
	// Planned-activities View (base) 

    extendsFrom: 'HistoryView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {String} _defaultSettings.date Date against which retrieved
     *   records will be filtered, supported values are 'today' and 'future',
     *   defaults to 'today'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        date: 'today',
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Store current date state in settings.
     */
    initDashlet: function() {
        this._super('initDashlet');
        if (!this.meta.last_state) {
            this.meta.last_state = {
                id: this.dashModel.get('id') + ':' + this.name,
                defaults: {}
            };
        }
        if (this.meta.config) {
            this.layout.before('dashletconfig:save', function() {
                this._saveSetting('date', this.settings.get('date'));
            }, this);
        } else {
            this.settings.on('change:date', function(model, value) {
                this._saveSetting('date', value);
            }, this);
        }

        this.settings.set('date', this.getDate());
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * @inheritdoc
     *
     * Once new records are received, prevent rendering new rows until we fetch
     * the invitation collection by calling {@link #updateInvitation}.
     */
    _initEvents: function() {
        this.events = _.extend(this.events, {
            'click [data-action=date-switcher]': 'dateSwitcher'
        });

        this._super('_initEvents');
        this.on('planned-activities:close-record:fire', this.heldActivity, this);
        this.on('linked-model:create', this.loadData, this);

        this.before('render:rows', function(data) {
            this.updateInvitation(this.collection, data);
            return false;
        }, this);

        return this;
    },

    /**
     * Update the invitation collection.
     *
     * @param {BeanCollection} collection Active tab's collection.
     * @param {Array} data Added recordset's data.
     */
    updateInvitation: function(collection, data) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (!data.length || !tab.invitations) {
            return;
        }
        this._fetchInvitationActions(tab, _.pluck(data, 'id'));
    },

    /**
     * Completes the selected activity.
     *
     * Shows a confirmation alert and sets the activity as `Held` on confirm.
     * Also updates the collection and re-renders the dashlet to remove it from
     * the view.
     *
     * @param {Data.Bean} model Call/Meeting model to be marked as `Held`.
     */
    heldActivity: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('close_activity_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PLANNED_ACTIVITIES_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Held'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {string} params.module Module name.
     * @param {string} params.link Relationship link.
     */
    createRecord: function(event, params) {
        // FIXME: At the moment there are modules marked as bwc enabled though
        // they have sidecar support already, so they're treated as exceptions
        // and drawers are used instead.
        var self = this,
            bwcExceptions = ['Emails'],
            meta = app.metadata.getModule(params.module) || {};

        if (meta.isBwcEnabled && !_.contains(bwcExceptions, params.module)) {
            this._createBwcRecord(params.module, params.link);
            return;
        }

        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * Create new record.
     *
     * If we're on Homepage an orphan record is created, otherwise, the link
     * parameter is used and the new record is associated with the record
     * currently being viewed.
     *
     * @param {string} module Module name.
     * @param {string} link Relationship link.
     * @protected
     */
    _createBwcRecord: function(module, link) {
        if (this.module !== 'Home') {
            app.bwc.createRelatedRecord(module, this.model, link);
            return;
        }

        var params = {
            return_module: this.module,
            return_id: this.model.id
        };

        var route = app.bwc.buildRoute(module, null, 'EditView', params);

        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * @protected
     */
    _initTabs: function() {
        this._super('_initTabs');

        _.each(this.tabs, function(tab) {
            if (!tab.invitation_actions) {
                return;
            }
            tab.invitations = this._createInvitationsCollection(tab);
        }, this);

        return this;
    },

    /**
     * Create invites collection to set the accept status on the given link.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection} A new instance of bean collection.
     * @protected
     */
    _createInvitationsCollection: function(tab) {
        return app.data.createBeanCollection(tab.module, null, {
            link: {
                name: tab.module.toLowerCase(),
                bean: app.data.createBean('Users', {
                    id: app.user.get('id')
                })
            }
        });
    },

    /**
     * @inheritdoc
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('history.records', this.module) ||
                app.template.getView('history.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * @inheritdoc
     */
    _getFilters: function(index) {

        var today = app.date().format('YYYY-MM-DD'),
            tab = this.tabs[index],
            filter = {},
            filters = [],
            defaultFilters = {
                today: {$lte: today},
                future: {$gt: today}
            };

        filter[tab.filter_applied_to] = defaultFilters[this.getDate()];

        filters.push(filter);

        return filters;
    },

    /**
     * @inheritdoc
     */
    tabSwitcher: function(event) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.invitations) {
            tab.invitations.dataFetched = false;
        }

        this._super('tabSwitcher', [event]);
    },

    /**
     * Event handler for date switcher.
     *
     * @param {Event} event Click event.
     */
    dateSwitcher: function(event) {
        var date = this.$(event.currentTarget).val();
        if (date === this.getDate()) {
            return;
        }

        this.settings.set('date', date);
        this.loadData();
    },

    /**
     * Saves a setting to local storage.
     *
     * @param {string} setting The setting name.
     * @param {string} value The value to save.
     * @private
     */
    _saveSetting: function(setting, value) {
        var key = app.user.lastState.key(setting, this);
        app.user.lastState.set(key, value);
    },

    /**
     * Get current date state.
     * Returns default value if can't find in last state or settings.
     *
     * @return {string} Date state.
     */
    getDate: function() {
        var date = app.user.lastState.get(
            app.user.lastState.key('date', this),
            this
        );
        return date || this.settings.get('date') || this._defaultSettings.date;
    },

    /**
     * @inheritdoc
     *
     * On load of new data, make sure we reload invitations related data, if
     * it is defined for the current tab.
     */
    loadDataForTabs: function(tabs, options) {
        _.each(tabs, function(tab) {
            if (tab.invitations) {
                tab.invitations.dataFetched = false;
            }
        }, this);

        this._super('loadDataForTabs', [tabs, options]);
    },

    /**
     * Fetch the invitation actions collection for
     * showing the invitation actions buttons
     * @param {Object} tab Tab properties.
     * @param {Array|*} addedIds New added record ids.
     * @private
     */
    _fetchInvitationActions: function(tab, addedIds) {
        this.invitationActions = tab.invitation_actions;
        tab.invitations.filterDef = {
            'id': {'$in': addedIds || this.collection.pluck('id')}
        };

        tab.invitations.fetch({
            relate: true,
            success: _.bind(function(collection) {
                if (this.disposed) {
                    return;
                }

                _.each(collection.models, function(invitation) {
                    var model = this.collection.get(invitation.get('id'));
                    model.set('invitation', invitation);
                }, this);

                if (!_.isEmpty(addedIds)) {
                    _.each(addedIds, function(id) {
                        var model = this.collection.get(id);
                        this._renderRow(model);
                        this._renderAvatars();
                    }, this);
                    return;
                }
                this.render();
                this._renderAvatars();
            }, this),
            complete: function() {
                tab.invitations.dataFetched = true;
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {Bean} invitation The invitation bean that relates the data with the
     *   Users' invitation statuses. This is the model supplied to the
     *   `invitation-actions` field.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        if (!this.collection.length || !tab.invitations ||
            tab.invitations.dataFetched) {
            this._super('_renderHtml');
            return;
        }

        this._fetchInvitationActions(tab);
    }
}) },
"sweetspot-config-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigHeaderpaneView
 * @extends View.View
 */
({
	// Sweetspot-config-headerpane View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Binds events that this view uses.
     */
    _bindEvents: function() {
        this.context.on('sweetspot:config:enableButtons', this.toggleButtons, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.createShortcutSession();
        this.registerShortcuts();
    },

    /**
     * Toggles the buttons in this view between enabled/disabled states.
     *
     * FIXME: This method should be updated to use `this.buttons` instead of
     * looping over all the fields. Update this when SC-3909 is merged.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.fields, function(field) {
            if (field instanceof app.view.fields.BaseButtonField) {
                field.setDisabled(state);
            }
        });
    },

    /**
     * Create new shortcut session.
     */
    createShortcutSession: function() {
        app.shortcuts.createSession([
            'SweetSpot:Config:Save',
            'SweetSpot:Config:Cancel'
        ], this);
    },

    /**
     * Register keyboard shortcuts for various headerpane buttons.
     */
    registerShortcuts: function() {
        app.shortcuts.register('SweetSpot:Config:Save', ['ctrl+s','ctrl+alt+a'], function() {
            var $saveButton = this.$('a[name=save_button]');
            if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                $saveButton.click();
            }
        }, this, true);

        app.shortcuts.register('SweetSpot:Config:Cancel', ['esc','ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=cancel_button]');
            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.get(0).click();
            }
        }, this, true);
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates.
 *
 * @class View.Views.Base.MergeDuplicatesView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesView
 * @extends View.Views.Base.ListView
 */
({
	// Merge-duplicates View (base) 

    plugins: ['Editable', 'ErrorDecoration', 'Tooltip', 'EllipsisInline', 'MergeDuplicates'],
    extendsFrom: 'ListView',
    events: {
        'click [data-mode=preview]' : 'togglePreview',
        'click [data-action=copy]' : 'triggerCopy',
        'click [data-action=delete]' : 'triggerDelete'
    },

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} merge_relate_fetch_concurrency Determining how many worker
     *   functions should be run in parallel for fetch.
     * - {Number} merge_relate_fetch_timeout Timeout for fetch related records
     *   call (milliseconds).
     * - {Number} merge_relate_fetch_limit Max number of records to fetch
     *   for related collection at a time.
     * - {Number} merge_relate_update_concurrency Determining how many worker
     *   functions should be run in parallel for update beans.
     * - {Number} merge_relate_update_timeout Timeout for update
     *   beans (milliseconds).
     * - {Number} merge_relate_max_attempt Max number of attemps for
     *   merge related.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *      'merge_relate_fetch_concurrency' => 2,
     *      'merge_relate_fetch_timeout' => 90000,
     *      'merge_relate_fetch_limit' => 20,
     *      'merge_relate_update_concurrency' => 4,
     *      'merge_relate_update_timeout' => 90000,
     *      'merge_relate_max_attempt' => 3,
     *      //...
     * ),
     * // ...
     * </code></pre>
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        merge_relate_fetch_concurrency: 2,
        merge_relate_fetch_timeout: 90000,
        merge_relate_fetch_limit: 20,
        merge_relate_update_concurrency: 4,
        merge_relate_update_timeout: 90000,
        merge_relate_max_attempt: 3
    },

    /**
     * List of fields to generate the metadata on the fly.
     *
     * @property {Array} mergeFields
     */
    mergeFields: [],

    /**
     * @property {Object} rowFields
     */
    rowFields: {},

    /**
     * @property {Data.Bean} primaryRecord
     */
    primaryRecord: {},

    /**
     * @property {Boolean} [toggled=false]
     */
    toggled: false,

    /**
     * @property {Boolean} [isPreviewOpen=false]
     */
    isPreviewOpen: false,

    /**
     * Array of field defs keys that contain fields to populate.
     *
     * For some types of field we should populate additional fields
     * that can be determined from fields defs. E.g.
     * 1. if field type is 'relate' and 'parent'
     *     - def.id_name contains field name for id of related
     * 2. if field type is 'parent'
     *     - def.type_name contains field name for type of related
     *
     * @property {Array} relatedFieldsMap
     */
    relatedFieldsMap: ['id_name', 'type_name'],

    /**
     * Field names won't be mergeable.
     *
     * @property {Array} fieldNameBlacklist
     */
    fieldNameBlacklist: [
        'date_entered', 'date_modified', 'modified_user_id', 'created_by', 'deleted'
    ],

    /**
     * Field types won't be mergeable.
     *
     * @property {Array} fieldTypesBlacklist
     *
     * TODO: remove types that have properly implementation for merge interface
     */
    fieldTypesBlacklist: ['team_list', 'link', 'id', 'password'],

    /**
     * Links names won't be mergeable.
     * Those links will be not used in merge related records.
     *
     * @property {Array} relatesBlacklist
     */
    relatesBlacklist: [
        'assigned_user_link', 'modified_user_link', 'created_by_link',
        'teams', 'team_link', 'team_count_link',
        'archived_emails', 'email_addresses', 'email_addresses_primary',
        'forecastworksheets',
        'currencies'
    ],

    /**
     * Links names for certain module won't be mergeable.
     * Those links will be not used in merge related records for certain module.
     *
     * @property {Object} relatesBlacklistForModule
     */
    relatesBlacklistForModule: {
        Accounts: ['revenuelineitems'],
        Opportunities: ['accounts'],
        Leads: ['meetings_parent', 'calls_parent'],
        Prospects: ['tasks'],
        Bugs: ['project'],
        RevenueLineItems: ['campaign_revenuelineitems']
    },

    /**
     * @property {Object} mergeStat Contains stat after merging.
     */
    mergeStat: null,

    /**
     * Object used as context for merge duplicates view.
     *
     * {Backbone.Model} mergeProgressModel
     */
    mergeProgressModel: null,

    /**
     * @property {Backbone.Model} mergeRelatedCollection Contains related records to merge.
     */
    mergeRelatedCollection: null,

    /**
     * Attribute combos allowed to merge.
     *
     * @property {Array} validArrayAttributes
     */
    validArrayAttributes: [
        { type: 'datetimecombo', source: 'db' },
        { type: 'datetime', source: 'db' },
        { type: 'varchar', source: 'db' },
        { type: 'enum', source: 'db' },
        { type: 'multienum', source: 'db' },
        { type: 'text', source: 'db' },
        { type: 'date', source: 'db' },
        { type: 'time', source: 'db' },
        { type: 'currency', source: 'db', calculated: false },
        { type: 'int', source: 'db' },
        { type: 'long', source: 'db' },
        { type: 'double', source: 'db' },
        { type: 'float', source: 'db' },
        { type: 'short', source: 'db' },
        { dbType: 'varchar', source: 'db' },
        { dbType: 'double', source: 'db' },
        { type: 'relate' },
        { type: 'parent' },
        { type: 'image' },
        { type: 'teamset' },
        { type: 'email' },
        { type: 'tag' }
    ],

    /**
     * Types of fields that can be processed
     * in {@link View.Views.BaseMergeDuplicatesView#flattenFieldsets}.
     * @property {Array} flattenFieldTypes
     */
    flattenFieldTypes: ['fieldset', 'fullname'],

    /**
     * Variable to store generated values for some types of fields (e.g. teamset).
     * @property {Object} generatedValues
     */
    generatedValues: null,

    /**
     * @inheritdoc
     *
     * Initialize merge collection as collection of selected records and
     * initialise fields that can be used in merge.
     */
    initialize: function(options) {

        this._super('initialize', [options]);
        this._initSettings();
        this._initializeMergeFields();
        this._initializeMergeCollection(this._prepareRecords());

        this.action = 'list';
        this._delegateEvents();
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        this.layout.on('mergeduplicates:save:fire', this.triggerSave, this);

        app.events.on('preview:open', _.bind(this.onPreviewToggle, this, true), this);
        app.events.on('preview:close', _.bind(this.onPreviewToggle, this, false), this);
        this.on('render', this._showAlertIfIdentical, this);
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMergeDuplicatesView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = app.config.mergeDuplicates && {
            merge_relate_fetch_concurrency: app.config.mergeDuplicates.mergeRelateFetchConcurrency,
            merge_relate_fetch_timeout: app.config.mergeDuplicates.mergeRelateFetchTimeout,
            merge_relate_fetch_limit: app.config.mergeDuplicates.mergeRelateFetchLimit,
            merge_relate_update_concurrency: app.config.mergeDuplicates.mergeRelateUpdateConcurrency,
            merge_relate_update_timeout: app.config.mergeDuplicates.mergeRelateUpdateTimeout,
            merge_relate_max_attempt: app.config.mergeDuplicates.mergeRelateMaxAttempt
        };

        this._settings = _.extend(
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Standardize primary record from list of records.
     *
     * Put primary at the beginning of records.
     * This is useful primarily to know which record will be the primary
     * in the collection to be pulled later. We do not use the input models.
     *
     * @return {Array} records.
     * @private
     */
    _prepareRecords: function() {
        var records = this._validateModelsForMerge(this.context.get('selectedDuplicates'));

        this.setPrimaryRecord(this._findPrimary(records));
        return records;
    },

    /**
     * Find primary model from models chosen for merge.
     *
     * If primary model has no access to edit it finds first model that can
     * be edited and sets it as primary.
     *
     * @param {Data.Bean[]} models Set of models to merge.
     * @return {Data.Bean} Primary model
     * @protected
     */
    _findPrimary: function(models) {
        var primary = this.context.has('primaryRecord') &&
            _.findWhere(models, {id: this.context.get('primaryRecord').id});

        return primary || _.find(models, function(model) {
            return app.acl.hasAccessToModel('edit', model);
        });
    },

    /**
     * Initialize fields for merge.
     *
     * Creates filtered set of model's fields that can be merged.
     * @private
     */
    _initializeMergeFields: function() {
        var meta = app.metadata.getView(this.module, 'record'),
            fieldDefs = app.metadata.getModule(this.module).fields;

        this.mergeFields = _.chain(meta.panels)
            .map(function(panel) {
                return this.flattenFieldsets(panel.fields);
            }, this)
            .flatten()
            .filter(function(field) {
                return field.name && this.validMergeField(fieldDefs[field.name]);
            }, this)
            .value();
    },

    /**
     * Initialize collection for merge.
     *
     * Enforce the order of the ids so that primaryRecord always appears first
     * and only retrieve the records specified.
     * @param {Array} records
     * @private
     */
    _initializeMergeCollection: function(records) {
        var ids = (_.pluck(records, 'id'));

        if (this.collection) {
            this.collection.filterDef = [];
            this.collection.filterDef.push({ 'id': { '$in' : ids}});
            this.collection.comparator = function(model) {
                return _.indexOf(ids, model.get('id'));
            };
        }
    },

    /**
     * Handler for save merged records event.
     *
     * Shows confirmation message and calls
     * {@link View.Views.BaseMergeDuplicatesView#_savePrimary} on confirm.
     */
    triggerSave: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            alternativeModelNames = [];

        _.each(alternativeModels, function(model) {
            alternativeModelNames.push(app.utils.getRecordName(model));
        }, this);

        this.clearValidationErrors(this.getFieldNames());

        app.alert.show('merge_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_CONFIRM') + ' ' +
                // FIXME needs to be removed on SC-4494.
                Handlebars.Utils.escapeExpression(alternativeModelNames.join(', ')) + '. ' +
                app.lang.get('LBL_MERGE_DUPLICATES_PROCEED'),
            onConfirm: _.bind(this._savePrimary, this)
        });
    },

    /**
     * Saves primary record and triggers `mergeduplicates:primary:saved` event on success.
     * Before saving triggers also `duplicate:unformat:field` event.
     *
     * @private
     */
    _savePrimary: function() {
        var self = this,
            fields = this.getFieldNames().filter(function(field) {
            return app.acl.hasAccessToModel('edit', this.primaryRecord, field);
        }, this);

        this.primaryRecord.trigger('duplicate:unformat:field');

        this.primaryRecord.save({}, {
            fieldsToValidate: fields,
            success: function() {
                // Trigger format fields again, because they can come different
                // from the server (e.g: only teams checked will be in the
                // response, and we still want to display unchecked teams on the
                // view)
                self.primaryRecord.trigger('duplicate:format:field');
                self.primaryRecord.trigger('mergeduplicates:primary:saved');
            },
            error: function(error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.primaryRecord, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                self.resetRadioSelection(model.id);
                            } else {
                                self._savePrimary();
                            }
                        }
                    });
                }
            },
            lastModified: this.primaryRecord.get('date_modified'),
            showAlerts: true,
            viewed: true
        });
    },

    /**
     * Removes merged models and triggers `mergeduplicates:primary:merged` on success.
     *
     * We need to wait until all models are removed from server
     * to properly reload records view. Runs destroy methods in parallel
     * and triggers event after all requests have finished.
     *
     * @private
     */
    _removeMerged: function() {
        var self = this,
            models = _.without(this.collection.models, this.primaryRecord);

        async.forEach(models, function(model, callback) {
            self.collection.remove(model);
            model.destroy({success: function() {
                callback.call();
            }});
        }, function() {
            self.primaryRecord.trigger('mergeduplicates:primary:merged');
            self.hideMainPreviewPanel();
        });
    },

    /**
     * Hide the preview panel, from the main drawer
     */
    hideMainPreviewPanel: function() {
        //Get main drawer
        var $main_drawer = app.$contentEl.children().first();
        if (!_.isUndefined($main_drawer) && $main_drawer.hasClass('drawer inactive')) {
            var layout = $main_drawer.find('.sidebar-content');
            layout.find('.side-pane').addClass('active');
            layout.find('.dashboard-pane').show();
            layout.find('.preview-pane').removeClass('active');
        }
    },
    /**
     * @inheritdoc
     *
     * Override fetching fields names. Use fields that are allowed to merge only.
     *
     * Add additional fields for cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related
     *
     * @return {Array} array of field names.
     */
    getFieldNames: function() {
        var fields = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            _.each(this.relatedFieldsMap, function(relatedField) {
                if (!_.isUndefined(def[relatedField]) && !_.isUndefined((fieldDefs[def[relatedField]].name))) {
                    fields.push(fieldDefs[def[relatedField]].name);
                }
            });
            var related_fields = mergeField.related_fields || def.related_fields || undefined;
            if (!_.isUndefined(related_fields) && _.isArray(related_fields)) {
                _.each(related_fields, function(rField) {
                    fields.push(rField);
                });
            }
            fields.push(def.name);
        }, this);
        return _.unique(fields);
    },

    /**
     * Create metadata for panels.
     *
     * Team sets will have a special metadata setup to match the height in all
     * records shown (match height).
     *
     * The fields are sorted by difference of values, showing first the ones
     * that are different among all records and then the ones that are equal.
     *
     * @param {Array} fields The list of fields for the module.
     * @return {Object} The metadata for the view template.
     * @private
     */
    _generateMetadata: function(fields) {
        this.generatedValues = {
            teamsets: []
        };

        _.each(fields, function(field) {
            if (field.type === 'teamset') {

                var teams = {};
                this.collection.each(function(model) {
                    _.each(model.get(field.name), function(team) {
                        teams[team.id] = team;
                    });
                });

                this.generatedValues.teamsets[field.name] = _.values(teams);
                field.maxHeight = _.size(teams);
                field.noRadioBox = true;
            }
        }, this);

        var models = this.collection.without(this.primaryRecord);
        fields = _.sortBy(fields, function(field) {
            return _.every(models, function(model) {
                return _.isEqual(this.primaryRecord.get(field.name), model.get(field.name));
            }, this);
        }, this);

        return {
            type: 'list',
            panels: [
                {
                    fields: fields
                }
            ]
        };
    },

    /**
     * Checks if all values are the same among all models.
     *
     * Compares the field value from primary model with values from other
     * models and returns `false` if it finds 1 field that isn't equal across
     * all models.
     *
     * @param {Data.Bean} primary The model chosen as primary.
     * @param {Data.Bean[]} models The array of models to compare with.
     * @return {Boolean} Is field value the same among all models.
     *
     * @private
     */
    _isSimilar: function(primary, models) {
        return _.every(models, function(model) {
            var modelFields = this.rowFields[model.id],
                primaryFields = this.rowFields[primary.id];

            return _.every(modelFields, function(field, index) {
                return field.equals(primaryFields[index]);
            }, this);
        }, this);
    },

    /**
     * Utility method for determining if a field is mergeable from its def.
     *
     * @param {Object} fieldDef Defs of validated field.
     * @return {Boolean} Is this field a valid field to merge?
     */
    validMergeField: function(fieldDef) {

        if (!fieldDef ||
            fieldDef.auto_increment === true ||
            !this._validMergeFieldName(fieldDef) ||
            !this._validMergeFieldType(fieldDef) ||
            this._isDuplicateMergeDisabled(fieldDef)
        ) {
            return false;
        }

        if (this._isDuplicateMergeEnabled(fieldDef)) {
            return true;
        }

        return this._validMergeFieldAttributes(fieldDef);
    },

    /**
     * Validate field to merge by name.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldName: function(defs) {
        return !_.contains(this.fieldNameBlacklist, defs.name);
    },

    /**
     * Validate field to merge by type.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldType: function(defs) {
        return !_.contains(this.fieldTypesBlacklist, defs.type);
    },

    /**
     * Checks if duplicate_merge is disabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeDisabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'disabled' ||
                defs.duplicate_merge === false)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Checks if duplicate_merge is enabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeEnabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'enabled' ||
                defs.duplicate_merge === true)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Validate field to merge by attributes.
     *
     * Uses `this.validArrayAttributes` hash to validate attributes.
     * Also checks if field is calculated and if it is returns `false`.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldAttributes: function(defs) {
        // normalize fields that might not be there
        defs.dbType = defs.dbType || defs.type;
        defs.source = defs.source || 'db';
        defs.calculated = defs.calculated || false;

        if (defs.calculated !== false) {
            return false;
        }

        // compare to values in the list of acceptable attributes
        return _.some(this.validArrayAttributes, function(o) {
            return _.chain(o)
                .keys()
                .every(function(key) {
                    return o[key] === defs[key];
                })
                .value();
        });
    },

    /**
     * Utility method for taking a fieldlist with possible nested fields,
     * and returning a flat array of fields.
     *
     * @param {Array} defs Unprocessed list of fields from metadata.
     * @return {Array} Fields flat list of fields.
     */
    flattenFieldsets: function(defs) {
        var fieldsetFilter = function(field) {
                return (field.type &&
                    _.isArray(field.fields) &&
                    _.contains(this.flattenFieldTypes, field.type));
            },
            fields = _.reject(defs, fieldsetFilter, this),
            fieldsets = _.filter(defs, fieldsetFilter, this),
            sort = _.chain(defs).pluck('name').value() || [],
            sortTemp = [];

        while (fieldsets.length) {
            //collect fields' names from fieldset
            var fieldsNames = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .pluck('name')
                .value();
            sortTemp = [];
            // create new sort sequence
            _.each(sort, function(value) {
                if (value === _.first(fieldsets).name) {
                    sortTemp = sortTemp.concat(fieldsNames);
                } else {
                    sortTemp = sortTemp.concat(value);
                }
            }, this);
            sort = sortTemp;
            // fieldsets need to be broken into component fields
            fieldsets = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .value();

            // now collect the raw fields from the press
            fields = fields.concat(_.reject(fieldsets, fieldsetFilter));

            // do we have any more fieldsets to squash?
            fieldsets = _.filter(fieldsets, fieldsetFilter);
        }
        // sorting fields acording to sequence
        fields = _.sortBy(fields, function(value, index) {
            var result = index,
                name = value;
            if (!_.isUndefined(value.name)) {
                name = value.name;
                _.each(sort, function(valueSort, indexSort) {
                    if (valueSort == name) {
                        result = indexSort;
                    }
                });
            }
            return result;
        });
        return fields;
    },

    /**
     * Event listeners for `preview:open` and `preview:close` events
     *
     * @param {boolean} open Flag indicating the desired state of the preview
     */
    onPreviewToggle: function(open) {
        this.isPreviewOpen = open;
        this.$('[data-mode=preview]').toggleClass('on', open);
    },

    /**
     * Toggles a Preview for the primary record.
     *
     * @param {Event} evt Mouse click event.
     */
    togglePreview: function(evt) {
        if (this.isPreviewOpen) {
            app.events.trigger('preview:close');
        } else {
            this.updatePreviewRecord(this.primaryRecord);
        }
    },

    /**
     * Creates the preview panel for the model in question.
     *
     * @param {Data.Bean} model Model to preview.
     */
    updatePreviewRecord: function(model) {
        var module = model.module || model.get('module');
        var previewCollection = app.data.createBeanCollection(module, [model]);
        app.events.trigger('preview:render', model, previewCollection, false);
    },

    /**
     * Updates the view's title.
     *
     * @param {String} title
     */
    updatePrimaryTitle: function(title) {
        this.$('[data-container=primary-title]').text(title);
    },

    /**
     * @inheritdoc
     *
     * Add additional fields for specific types like 'parent' and 'relate'.
     * Setup primary model editable.
     * Setup drag-n-drop functionality.
     */
    _renderHtml: function() {
        this.meta = this._generateMetadata(this.mergeFields);

        this._super("_renderHtml");

        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
        this.setPrimaryEditable(this.primaryRecord.id);
        this.setDraggable();
    },

    /**
     * Shows confirmation message if records are identical.
     * @protected
     */
    _showAlertIfIdentical: function() {
        if (!this.collection.length) {
            return;
        }

        var self = this,
            alternatives = this.collection.without(this.primaryRecord);

        if (this._isSimilar(this.primaryRecord, alternatives)) {
            app.alert.show('merge_confirmation_identical', {
                level: 'confirmation',
                messages: app.lang.get('TPL_MERGE_DUPLICATES_IDENTICAL', this.module),
                onConfirm: function() {
                    self.layout.trigger('mergeduplicates:save:fire');
                }
            });
        }
    },

    /**
     * Set ups label of primary record as draggable using jQuery UI Sortable plugin.
     */
    setDraggable: function() {
        var self = this,
        mergeContainer = this.$('[data-container=merge-container]');
        mergeContainer.find('[data-container=primary-label]').sortable({
            connectWith: self.$('[data-container=primary-label]'),
            appendTo: mergeContainer,
            axis: 'x',
            disableSelection: true,
            cursor: 'move',
            placeholder: 'primary-lbl-placeholder-span',
            start: function(event, ui) {
                self.$('[data-container=primary-label]').addClass('primary-lbl-placeholder');
            },
            stop: _.bind(self._onStopSorting, self)
        });

        mergeContainer.find('[data-container=primary-label].disabled').sortable(
            'option', 'disabled', true
        );
    },

    /**
     * Handler for jQuery UI Sortable plugin event triggered when sorting has stopped.
     *
     * Set ups choosed record as primary and make it editable.
     * If old primary record is changed shows confirmation message to confirm action.
     *
     * @param {Event} event
     * @param {Object} ui
     */
    _onStopSorting: function(event, ui) {
        var self = this,
            droppedTo = ui.item.parents('[data-record-id]');

        self.$('[data-container=primary-label]').removeClass('primary-lbl-placeholder');
        // short circuit if we didn't land on anything
        if (droppedTo.length === 0) {
            self.$('[data-container=primary-label]').sortable('cancel');
            return;
        }

        if (self.primaryRecord && self.primaryRecord.id !== droppedTo.data('record-id')) {
            var changedAttributes = self.primaryRecord.changedAttributes(
                self.primaryRecord.getSynced()
            );
            if (!_.isEmpty(changedAttributes)) {
                app.alert.show('change_primary_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_MERGE_UNSAVED_CHANGES'),
                    onConfirm: function() {
                        self.primaryRecord.revertAttributes();
                        self.setPrimaryEditable(droppedTo.data('record-id'));
                    },
                    onCancel: function() {
                        self.$('[data-record-id=' + self.primaryRecord.get('id') + '] ' +
                            '[data-container=primary-label]').sortable('cancel');
                    }
                });
                return;
            }
            self.setPrimaryEditable(droppedTo.data('record-id'));
        }
    },

    /**
     * Enable/disable radio buttons according to ACL access to fields for all models.
     */
    checkCopyRadioButtons: function() {
        if (!this.primaryRecord) {
            return;
        }
        _.each(this.mergeFields, function(field) {
            var model = this.primaryRecord,
                element = this.$('[data-field-name=' + field.name + '][data-record-id=' + model.id + ']'),
                others = this.$('[data-field-name=' + field.name + '][data-record-id!=' + model.id + ']'),
                editAccess = app.acl.hasAccessToModel('edit', model, field.name);

            element.prop('disabled', !editAccess || field.readonly);

            if (!editAccess || field.readonly) {
                others.prop('disabled', true);
                return;
            }

            _.each(others, function(domElement) {
                var el = $(domElement),
                    readAccess = app.acl.hasAccessToModel(
                        'read',
                        this.collection.get(el.data('record-id')),
                        field.name
                    );
                el.prop('disabled', !readAccess);
            }, this);
        }, this);
    },

    /**
     * Prepare primary record for edit mode.
     *
     * Toggle primary record in edit mode, setup panel title and
     * update preview panel if it is opened. Make sure we get the model in
     * the collection, with all fields in it. If id parameter is provided
     * switch primary record to new model before and revert old primary record
     * to standard record. If new model is same as primary no action is taken.
     * Triggers `duplicate:format:field` before toggle fields.
     *
     * @param {String} [id] The record representing the new primary model.
     */
    setPrimaryEditable: function(id) {

        var oldPrimaryRecord = this.primaryRecord,
            newPrimaryRecord = this.collection.get(id || null);

        if (!_.isUndefined(newPrimaryRecord) && newPrimaryRecord !== oldPrimaryRecord) {
            this.setPrimaryRecord(newPrimaryRecord);
        }

        if (!this.primaryRecord) {
            return;
        }

        if (oldPrimaryRecord && oldPrimaryRecord !== this.primaryRecord) {
            this.toggleFields(this.rowFields[oldPrimaryRecord.id], false);
        }

        this.primaryRecord.trigger('duplicate:format:field');

        this.toggleFields(this.rowFields[this.primaryRecord.id], true);
        this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        if (this.isPreviewOpen) {
            this.updatePreviewRecord(this.primaryRecord);
        }
        this.$('.primary-edit-mode').removeClass('primary-edit-mode');
        this.$('[data-record-id=' + this.primaryRecord.id + ']').addClass('primary-edit-mode');
        this.resetRadioSelection(this.primaryRecord.id);
        this.checkCopyRadioButtons();
        this._disableRemovePrimary();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Checks can primary record be removed or not and if not hides remove control.
     *
     * Primary record cannot be removed is there is not other model with edit access.
     *
     * @protected
     */
    _disableRemovePrimary: function() {
        var disableRemovePrimary = !_.some(this.collection.models, function(model) {
            return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
        }, this);

        this.$('[data-record-id=' + this.primaryRecord.get('id') + ']')
            .find('[data-action=delete]')
            .css('visibility', (disableRemovePrimary ? 'hidden' : 'visible'));
    },

    resetRadioSelection: function(modelId) {
        this.$('[data-record-id=' + modelId + '] input[type=radio]').attr('checked', true);
    },

    /**
     * Set a given model as primary.
     *
     * If the given module is already the primary record no action will be taken.
     * This will toggle off all the events of the old primary record and
     * setup the events for the new model. It will also setup primary record
     * 'change' event handler to updates title of panel,
     * 'mergeduplicates:primary:saved' to remove others models and
     * 'mergeduplicates:primary:merged' event handler to close drawer.
     *
     * @param {Data.Bean} model Primary model.
     */
    setPrimaryRecord: function(model) {
        if (this.primaryRecord === model) {
            return;
        }

        if (this.primaryRecord instanceof Backbone.Model) {
            this.primaryRecord.off(null, null, this);
        }

        this.primaryRecord = model;

        this.primaryRecord.on('change', function(model) {
            this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:saved', function() {
            this._mergeRelatedRecords();
        }, this);

        this.primaryRecord.on('mergeduplicates:related:merged', function() {
            this._onRelatedMerged();
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:merged', function() {
            app.alert.dismiss('mergeduplicates_merging');
            this._showSuccessMessage();
            app.drawer.close(true, this.primaryRecord);
        }, this);
    },

    /**
     * Event handler for radio box controls.
     *
     * Before copy value from model or restore value
     * triggers `before duplicate:field` event.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerCopy: function(evt) {
        var currentTarget = this.$(evt.currentTarget),
            recordId = currentTarget.data('record-id'),
            fieldName = currentTarget.data('field-name'),
            fieldDefs = app.metadata.getModule(this.module).fields,
            model;

        if (_.isUndefined(this.primaryRecord) ||
            _.isUndefined(this.primaryRecord.id) ||
            _.isUndefined(recordId) ||
            _.isUndefined(fieldName) ||
            _.isUndefined(fieldDefs[fieldName])
        ) {
            return;
        }

        model = this.collection.get(recordId);
        if (_.isUndefined(model)) {
            return;
        }

        if (!app.acl.hasAccessToModel('edit', this.primaryRecord, fieldName) ||
            !app.acl.hasAccessToModel('read', model, fieldName)) {
            return;
        }

        var data = currentTarget.data();
        // Unlike data(), attr() doesn't perform type conversions if possible.
        // This is good because recordItemId can sometimes be numeric but must be type of string always.
        data.recordItemId = currentTarget.attr('data-record-item-id');
        data = _.extend({}, data, {
            checked: currentTarget.prop('type') === 'checkbox' ?
                currentTarget.prop('checked') : true
        });
        if (this.triggerBefore('duplicate:field', {model: model, data: data}) === false) {
            return;
        }

        if (model === this.primaryRecord) {
            this.revert(fieldName);
        } else {
            this.copy(fieldName, model);
        }
    },

    /**
     * Copy value from selected field to primary record.
     *
     * Setups new value current field and additional fields.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to copy.
     * @param {Data.Bean} model Model to copy from.
     */
    copy: function(fieldName, model) {
        this._setRelatedFields(fieldName, model);
        this.primaryRecord.set(fieldName, model.get(fieldName));

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            model !== this.primaryRecord ? model : null,
            model !== this.primaryRecord ? model.get(fieldName) : null
        );
    },

    /**
     * Revert value of field to latest sync state.
     *
     * Revert original values.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to revert.
     */
    revert: function(fieldName) {
        var syncedAttributes = this.primaryRecord.getSynced();

        this._setRelatedFields(fieldName, this.primaryRecord, true);
        this.primaryRecord.set(
            fieldName,
            !_.isUndefined(syncedAttributes[fieldName]) ?
                syncedAttributes[fieldName] :
                this.primaryRecord.get(fieldName)
        );

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            this.primaryRecord,
            this.primaryRecord.get(fieldName)
        );
    },

    /**
     * Event handler for model delete button.
     *
     * Shows alert message to confirm model removing.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerDelete: function(evt) {
        var recordId = this.$(evt.currentTarget).closest('[data-record-id]').data('recordId'),
            model = this.collection.get(recordId),
            self = this;
        if (this.collection.length <= 2 || !recordId || !model) {
            return;
        }

        if (model === this.primaryRecord) {
            var allow = _.some(this.collection.models, function(model) {
                return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
            }, this);
            if (!allow) {
                return;
            }
        }
        app.alert.show('record-delete-confirm', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_REMOVE', this.module),
            onConfirm: function() {
                self.deleteFromMerge(model);
                self.$('[data-container="merge-container"]').attr('class', function(){
                    return $(this).attr('class').replace(
                        /\b(num\-cols\-)(\d+)\b/g,
                        '$1' + self.collection.length
                    );
                });
            }
        });
    },

    /**
     * Delete model from collection to merge.
     *
     * If removed model is primary find first model in
     * collection an setup it as primary.
     *
     * @param {Data.Bean} model Model to remove.
     */
    deleteFromMerge: function(model) {

        this.collection.remove(model, {silent: true});

        var selModelEl = '[data-container=merge-record][data-record-id=' + model.get('id') + ']';

        if (model === this.primaryRecord) {
            var primary = this._findPrimary(this.collection.models),
                selNewPrimaryEl = '[data-container=merge-record][data-record-id=' + primary.get('id') + ']',
                primaryEl = this.$(selNewPrimaryEl).find('[data-container=primary-label]'),
                primaryLabel = this.$(selModelEl).find('[data-container=primary-label-span]');

            primaryEl.append(primaryLabel);
            this.setPrimaryEditable(primary.get('id'));

        }

        this.$(selModelEl).remove();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Copy additional fields to primary model.
     *
     * Cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related.
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related.
     *
     * @param {String} fieldName Name of main field to copy.
     * @param {Data.Bean} model Model from which values should be coped.
     * @param {Boolean} synced Use last synced attributes of model for copy or not.
     * @protected
     */
    _setRelatedFields: function(fieldName, model, synced) {
        synced = synced || false;

        var fieldDefs = app.metadata.getModule(this.module).fields;
            defs = fieldDefs[fieldName],
            syncedAttributes = synced ? model.getSynced() : {},
            fields = _.union(defs.populate_list, defs.related_fields);

        _.each(this.relatedFieldsMap, function(field) {
            if (!_.isUndefined(defs[field]) && !_.isUndefined(fieldDefs[defs[field]].name)) {
                fields.push(fieldDefs[defs[field]].name);
            };
        });

        // FIXME: populate_list is only available on related fields plus
        // related_fields is only available on fieldsets, so this logic should
        // be implemented on field side thus calling a method like
        // this.fields[fieldName].revertTo(model); here SC-3467
        _.each(fields, function(relatedField) {
            if (_.isUndefined(fieldDefs[relatedField])) {
                return;
            }

            this.primaryRecord.set(
                relatedField,
                !_.isUndefined(syncedAttributes[relatedField]) ?
                    syncedAttributes[relatedField] :
                    model.get(relatedField)
            );
        }, this);
    },

    /**
     * Returns defs of bean fields that are valid link for merge related records.
     *
     * @return {Object[]} Defs of fields.
     * @protected
     */
    _getRelatedLinks: function() {
        var fieldDefs = app.metadata.getModule(this.module).fields,
            excludedLinks = this._getExcludedRelatedLinks();

        return _.filter(fieldDefs, function(field) {
            return !_.isUndefined(field.type) && field.type === 'link' &&
                !_.contains(excludedLinks, field.name) &&
                this._isValidRelateLink(field) &&
                this._isValidRelateLinkType(field);
        }, this);
    },

    /**
     * Returns names of links that has been processed using `relate` fields on UI.
     *
     * @return {String[]} Names of links.
     * @protected
     */
    _getExcludedRelatedLinks: function() {
        var excludedLinks = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            if (def.type === 'relate' && !_.isUndefined(def.link)) {
                excludedLinks.push(def.link);
            }
        }, this);

        return excludedLinks;
    },

    /**
     * Check is certain link valid for merge related records.
     *
     * Returns false in cases:
     * 1. link name isn't defined
     * 2. link module doesn't exist in our metadata
     * 3. link is in global black list
     * 4. link is in black list for current module
     * 5. merge is disabled in link defs
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related.
     *
     * @protected
     */
    _isValidRelateLink: function(link) {
        if (!link || !link.name) {
            return false;
        }

        var module = app.data.getRelatedModule(this.module, link.name);
        if (_.isEmpty(app.metadata.getModule(module))) {
            return false;
        }

        if (_.contains(this.relatesBlacklist, link.name)) {
            return false;
        }

        if (!_.isUndefined(this.relatesBlacklistForModule[this.module]) &&
            _.contains(this.relatesBlacklistForModule[this.module], link.name)
        ) {
            return false;
        }

        if (!_.isUndefined(link.duplicate_merge) &&
            (link.duplicate_merge === 'disabled' ||
                link.duplicate_merge === 'false' ||
                link.duplicate_merge === false)
        ) {
            return false;
        }

        return true;
    },

    /**
     * Check is certain link valid for merge related records by link type.
     *
     * Returns false for cases:
     * 1. type of link is `one`
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related by link type.
     * @protected
     */
    _isValidRelateLinkType: function(link) {
        if (!_.isUndefined(link.link_type) && link.link_type === 'one') {
            return false;
        }
        return true;
    },

    /**
     * Merge related records using queue.
     * Triggers `mergeduplicates:related:merged` event on finish.
     * @protected
     */
    _mergeRelatedRecords: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            relatedLinks = _.pluck(this._getRelatedLinks(), 'name'),
            progressView,
            queue,
            tasks = [];

        this.mergeStat = {
            records: this.collection.models.length,
            total: 0, total_errors: 0, total_fetch_errors: 0
        };

        this.mergeProgressModel = new Backbone.Model({
            isStopped: false
        });

        this.mergeRelatedCollection = this.getMergeRelatedCollection();

        if (!alternativeModels || !alternativeModels.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        if (!relatedLinks || !_.isArray(relatedLinks) || !relatedLinks.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        progressView = this._getProgressView();
        progressView.reset();
        progressView.setTotalRecords(alternativeModels.length * relatedLinks.length);

        this.mergeProgressModel.trigger('massupdate:start');

        _.each(relatedLinks, function(link) {
            _.each(alternativeModels, function(model) {
                tasks.push({
                    collection: self._createRelatedCollection(model, link)
                });
            });
        });
        queue = async.queue(function(task, callback) {
            if (self.mergeProgressModel.get('isStopped')) {
                callback.call();
                return;
            }
            self._mergeRelatedCollection(task.collection, callback);
        }, this._settings.merge_relate_fetch_concurrency);
        queue.drain = function() {
            var finishMerge = function() {
                self.mergeProgressModel.trigger('massupdate:end');
                if (!self.mergeProgressModel.get('isStopped')) {
                    self.primaryRecord.trigger('mergeduplicates:related:merged');
                }
            };
            // Wait until all related records be merged or finish merge.
            self.mergeRelatedCollection.queue.running() ?
                self.mergeRelatedCollection.queue.drain = finishMerge :
                finishMerge();
        };
        queue.push(tasks, function(err) {});
    },

    /**
     * Creates collection against the parent model to merge related records.
     *
     * @return {Backbone.Collection} Merge collection.
     */
    getMergeRelatedCollection: function() {
        var constructor = Backbone.Collection.extend({
            method: 'create',
            queue: null,
            view: null,

            /**
             * @property {String} id Primary record's ID.
             */
            id: this.primaryRecord.id,

            /**
             * @property {String} module Primary record's module name.
             */
            module: this.primaryRecord.module,

            /**
             * @property {Number} attempt Current trial attempt number.
             */
            attempt: 0,

            /**
             * @inheritdoc
             *
             * Sync added set of records and clear collection.
             */
            initialize: function(models, options) {
                this.view = options.view;
                this.queue = async.queue(
                    _.bind(function(task, callback) {
                        this.sync('update', this, {
                            chunk: task,
                            queueSuccess: callback
                        });
                    }, this),
                    this.view._settings.merge_relate_update_concurrency
                );
                this.on('add', function(model, options) {
                    this.queue.push(
                        {
                            link_name: model.link.name,
                            ids: _.pluck(this.models, 'id')
                        },
                        function(err) {}
                    );
                    this.reset();
                }, this);
            },

            /**
             * @inheritdoc
             *
             * Overrides default behaviour to use related API and send related
             * records into chunks.
             */
            sync: function(method, model, options) {
                var apiMethod = options.method || this.method,
                    url = app.api.buildURL(this.module, method, {link: true, id: this.id}, options.params),
                    callbacks = {
                        success: function(data, response) {
                            model.view.mergeStat.total = model.view.mergeStat.total + options.chunk.ids.length;
                            options.queueSuccess();
                            if (_.isFunction(options.success)) {
                                options.success(model, data, response);
                            }
                        },
                        error: function(xhr, status, error) {
                            model.attempt = model.attempt + 1;
                            model.view.mergeProgressModel.trigger('massupdate:item:attempt', model);
                            if (model.attempt <= (model.view._settings.merge_relate_max_attempt)) {
                                app.api.call(apiMethod, url, options.chunk, callbacks);
                            } else {
                                model.attempt = 0;
                                model.view.mergeStat.total_errors = model.view.mergeStat.total_errors + 1;
                                model.view.mergeProgressModel.trigger('massupdate:item:fail', model);
                            }
                        },
                        complete: function(xhr, status) {
                            if (_.isFunction(options.complete)) {
                                options.complete(xhr, status);
                            }
                        }
                    };
                app.api.call(apiMethod, url, options.chunk, callbacks);
            }
        }),
        collection = new constructor([], {view: this});
        return collection;
    },

    /**
     * Called when merge related records process is finished.
     *
     * @protected
     */
    _onRelatedMerged: function() {
        var self = this;

        if (this.mergeStat.total_fetch_errors > 0 ||
            this.mergeStat.total_errors > 0
        ) {
            app.alert.show('final_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_MERGE_DUPLICATES_FAIL_PROCESS', this.module),
                onConfirm: function() {
                    self._onMergeRelatedCompleted();
                },
                onCancel: function() {
                    self.mergeProgressModel.trigger('massupdate:end');
                },
                autoClose: false
            });
            return;
        }

        this._onMergeRelatedCompleted();
    },

    /**
     * Starts removing models and shows process message.
     * @protected
     */
    _onMergeRelatedCompleted: function() {
        app.alert.show('mergeduplicates_merging', {
            level: 'process',
            title: app.lang.get('LBL_SAVING', this.module)
        });
        this._removeMerged();
    },

    /**
     * Creates related collection.
     * Setup additional parameters for merge process.
     *
     * @param {Data.Bean} model Model to create related collection.
     * @param {String} link Relationship link name.
     * @return {Data.BeanCollection} Created collection.
     * @protected
     */
    _createRelatedCollection: function(model, link) {
        var relatedCollection = app.data.createRelatedCollection(model, link);

        return _.extend(relatedCollection, {
            attempt: 0,
            maxAllowAttempt: this._settings.merge_relate_max_attempt,
            objectName: app.data.getRelatedModule(this.primaryRecord.module, link)
        });
    },

    /**
     * Recursively merge related collection.
     *
     * Recursively fetch data from link collection and creates (links) beans
     * to primary record.
     *
     * @param {Data.BeanCollection} collection Collection to merge.
     * @param {Function} callback Function called on end.
     * @param {Number} offset Offset to fetch data.
     * @protected
     */
    _mergeRelatedCollection: function(collection, callback, offset) {

        if (this.mergeProgressModel.get('isStopped')) {
            callback.call();
            return;
        }

        offset = offset || 0;

        var self = this,
            onCollectionMerged = function() {
                self.mergeProgressModel.trigger('massupdate:item:processed');
                callback.call();
            };

        collection.fetch({
            relate: true,
            limit: this._settings.merge_relate_fetch_limit,
            offset: offset,
            fields: ['id'],
            apiOptions: {
                timeout: this._settings.merge_relate_fetch_timeout,
                skipMetadataHash: true
            },
            success: function(data, response, options) {
                if (!data || !data.models || !data.models.length) {
                    onCollectionMerged.call();
                    return;
                }

                self.mergeRelatedCollection.add(data.models);

                if (!_.isUndefined(data.next_offset) && data.next_offset !== -1) {
                    self._mergeRelatedCollection(collection, callback, data.next_offset);
                } else {
                    onCollectionMerged.call();
                }
            },
            error: function() {
                collection.attempt = collection.attempt + 1;
                self.mergeProgressModel.trigger('massupdate:item:attempt', collection);
                if (collection.attempt <= collection.maxAllowAttempt) {
                    self._mergeRelatedCollection(collection, callback, offset);
                } else {
                    self.mergeStat.total_fetch_errors = self.mergeStat.total_fetch_errors + 1;
                    self.mergeProgressModel.trigger('massupdate:item:fail', collection);
                    onCollectionMerged.call();
                }
            }
        });
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MergeDuplicatesProgress view component.
     * @protected
     */
    _getProgressView: function() {
        var progressView = this.layout.getComponent('merge-duplicates-progress');
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                name: 'merge-duplicates-progress',
                layout: this.layout,
                model: this.mergeProgressModel
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Displays alert message with last merge related records stat.
     *
     * @protected
     */
    _showSuccessMessage: function() {
        app.alert.show('mergerelated_final_notice', {
            level: 'success',
            messages: app.lang.get('TPL_MERGE_DUPLICATES_STAT', this.module, {
                stat: this.mergeStat
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * @inheritdoc
     *
     * Override 'reset' event for collection to setup first model ar primary.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.collection.on('reset', function(coll) {
            if (coll.length) {
                _.each(coll.models, function(model) {
                    model.readonly = !app.acl.hasAccessToModel('edit', model);
                }, this);
                this.setPrimaryRecord(this._findPrimary(coll.models));
            }
            if (this.disposed) {
                return;
            }
            this.render();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Off all events on primary model.
     */
    _dispose: function() {
        if (!_.isEmpty(this.primaryRecord)) {
            this.primaryRecord.off(null, null, this);
        }
        this._super('_dispose');
    }
}) },
"dnb-standard-company-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbStandardCompanyInfoView
 * @alias SUGAR.App.view.views.BaseDnbStandardCompanyInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-standard-company-info View (base) 

    extendsFrom: 'DnbView',

    duns_num: null,

    //will contain the data elements selected by the user from the dashlet confid
    //filtered data dictionary
    filteredDD: null,

    events: {
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData'
    },

    initDashlet: function() {
        this._super('initDashlet');
        this.baseFilterData();
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.disposed) {
            return;
        }
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadCompanyInfo, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadCompanyInfo, this);
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated standard company information from DNB service
     */
    refreshClicked: function() {
        this.loadCompanyInfo(false);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
        this.baseFilterData();
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadCompanyInfo: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getDNBStdCompanyDetails, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Gets Standard Company Information
     * @param duns_num duns_num
     */
    getDNBStdCompanyDetails: function(duns_num) {
        if (this.disposed) {
            return;
        }
        this.dnbFirmo = {};
        this.template = app.template.get('dnb.dnb-comp-info');
        this.dnbFirmo.loading_label = app.lang.get('LBL_DNB_STD_COMPANY_INFO_LOADING');
        this.render();
        this.$('div#dnb-compinfo-loading').show();
        this.$('div#dnb-compinfo-details').hide();
        this.baseCompanyInformation(duns_num, this.compInfoProdCD.std, null, this.renderCompanyInformation);
    }
}) },
"quicksearch-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuicksearchButtonView
 * @alias SUGAR.App.view.fields.BaseQuicksearchButtonView
 * @extends View.View
 */
({
	// Quicksearch-button View (base) 

    className: 'quicksearch-button-wrapper',

    events: {
        'click [data-action=search_icon]' : 'searchIconClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        // Listener for `quicksearch:close`.
        this.layout.on('quicksearch:close', function() {
            if (!this.context.get('search')) {
                this.toggleSearchIcon(true);
            }
        }, this);

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = false;

        /**
         * Used for indicating the state of the button icon.
         *
         * @property {boolean}
         * - `true` means magnifying glass.
         * - `false` means X icon.
         */
        this.searchButtonIcon = true;

        this.layout.on('quicksearch:button:toggle', this.toggleSearchIcon, this);
    },


    /**
     * Toggles the search icon between the magnifying glass and x.
     *
     * @param {boolean} searchButtonIcon Indicates the state of the search button icon
     * - `true` means magnifying glass.
     * - `false` means X icon.
     */
    toggleSearchIcon: function(searchButtonIcon) {
        if (this.searchButtonIcon === searchButtonIcon) {
            return;
        }
        var iconEl = this.$('[data-action=search_icon] .fa').first();
        this.searchButtonIcon = searchButtonIcon;
        if (searchButtonIcon) {
            iconEl.removeClass('fa-times');
            iconEl.addClass('fa-search');
        } else {
            iconEl.removeClass('fa-search');
            iconEl.addClass('fa-times');
        }
    },

    /**
     * Handler for clicks on the search icon (or x, depending on state).
     */
    searchIconClickHandler: function() {
        if (this.searchButtonIcon) {
            if (this.layout.isResponsiveMode) {
                this.layout.trigger('quicksearch:expand');
            } else {
                this.layout.trigger('quicksearch:bar:search');
            }
        } else {
            this.layout.trigger('quicksearch:bar:clear');
            this.layout.trigger('quicksearch:close');
        }
    }
}) },
"preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewHeaderView
 * @alias SUGAR.App.view.views.BasePreviewHeaderView
 * @extends View.View
 */
({
	// Preview-header View (base) 

    className: 'preview-headerbar',

    events: {
        'click [data-direction]': 'triggerPagination',
        'click .preview-headerbar .closeSubdetail': 'triggerClose'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        this.checkACL(this.model);

        this._delegateEvents();
    },

    /**
     * Set up event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        if (this.layout) {
            this.layout.on('preview:pagination:update', this.render, this);
        }

        if (this.layout.previewEdit) {
            _.extend(this.events, {'click [data-action=edit]': 'triggerEdit'});
            this.layout.on('preview:edit:complete', this.toggleSaveAndCancel, this);
        }
    },

    triggerPagination: function(e) {
        var direction = this.$(e.currentTarget).data();
        this.layout.trigger('preview:pagination:fire', direction);
    },

    triggerClose: function() {
        app.events.trigger('list:preview:decorate', null, this);
        app.events.trigger('preview:close');
    },

    /**
     * Call preview view to turn on editing
     */
    triggerEdit: function() {
        this.toggleSaveAndCancel(true);
        this.layout.trigger('preview:edit');
    },

    /**
     * Toggle save, cancel, left, right and x buttons
     *
     * @param {boolean} edit `true` to show save and cancel and hide
     * left, right and X icons
     */
    toggleSaveAndCancel: function(edit) {
        if (edit) {
            this.getField('save_button').show();
            this.getField('cancel_button').show();
            this.$('[data-direction], [data-action=close]').hide();
        } else {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
            this.$('[data-direction], [data-action=close]').show();
        }
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to hide preview save/cancel buttons initially
     * @private
     */
    _renderFields: function() {
        this._super('_renderFields');

        if (this.layout.previewEdit) {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
        }
    },

    /**
     *  @inheritdoc
     *
     *  @override Overiding render
     */
    _render: function() {
        this.layout.on('previewheader:ACLCheck', this.checkACL, this)
        this._super('_render');
    },

    /**
     * Check if the user has permission to edit the current record
     *
     * @param model Model for preview
     */
    checkACL: function(model) {
        if (app.config.previewEdit && this.layout.meta.editable === true &&
            app.acl.hasAccessToModel('edit', model)) {
            this.layout.previewEdit = true;
        } else {
            this.layout.previewEdit = false;
        }
    }
}) },
"orgchart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.OrgchartView
 * @alias SUGAR.App.view.views.BaseOrgchartView
 * @extends View.View
 */
({
	// Orgchart View (base) 

    events: {
        'click .zoom-control': 'zoomChart',
        'click .toggle-control': 'toggleChart'
    },
    plugins: ['Dashlet', 'Tooltip', 'Chart'],

    // user configurable
    nodetemplate: null,
    reporteesEndpoint: '',
    zoomExtents: null,
    nodeSize: null,

    // private
    jsTree: null,
    slider: null,
    sliderZoomIn: null,
    sliderZoomOut: null,
    container: null,

    /**
     * Initialize the View
     *
     * @constructor
     * @param {Object} options
     */
    initialize: function(options) {
        var self = this;
        this._super('initialize', [options]);

        //TODO: change api to accept id as param or attrib as object to produce
        this.reporteesEndpoint = app.api.buildURL('Forecasts', 'orgtree/' + app.user.get('id'), null, {'level': 2});
        this.zoomExtents = {'min': 0.25, 'max': 1.75};
        this.nodeSize = {'width': 124, 'height': 56};

        this.chart = nv.models.tree()
                .duration(300)
                .nodeSize(this.nodeSize)
                .nodeRenderer(self.nodeRenderer)
                .zoomExtents(self.zoomExtents)
                .zoomCallback(function(scale) {
                    self.moveSlider(scale);
                })
                .horizontal(false)
                .getId(function(d) {
                    return d.metadata.id;
                })
                .nodeClick(function() {
                    var route = d3.select(this).select('.nv-org-name').attr('data-url');
                    app.router.navigate(route, {trigger: true});
                })
                .nodeCallback(function(d) {
                    d.selectAll('text').text(function() {
                        var text = d3.select(this).text();
                        return nv.utils.stringEllipsify(text, self.container, 96);
                    });
                    d.selectAll('image')
                        .on('error', function(d) {
                            d3.select(this).attr('xlink:href', 'include/images/user.svg');
                        });
                    d.select('.nv-org-name')
                        .on('mouseover', function(d) {
                            d3.select(this).classed('hover', true);
                        })
                        .on('mouseout', function(d, i) {
                            d3.select(this).classed('hover', false);
                        });
                });
    },

    /**
     * Returns a url to a user record
     * @param {String} id the User record id.
     * @protected
     */
    _buildUserUrl: function(id) {
        return '#' + app.bwc.buildRoute('Employees', id);
    },

    /**
     * Appends the node content to the tree
     * This should be extended by each implementation
     * @param {String} content tree content container.
     * @param {Object} d tree node metadata.
     * @param {Int} w tree node width.
     * @param {Int} h tree node height.
     */
    nodeRenderer: function(content, d, w, h) {
        if (!d.metadata.img || d.metadata.img === '') {
            d.metadata.img = 'include/images/user.svg';
        }
        var node = content.append('g').attr('class', 'nv-org-node');
        node.append('rect').attr('class', 'nv-org-bkgd')
            .attr('x', 0)
            .attr('y', 0)
            .attr('rx', 2)
            .attr('ry', 2)
            .attr('width', w)
            .attr('height', h);
        node.append('image').attr('class', 'nv-org-avatar')
            .attr('xlink:href', d.metadata.img)
            .attr('width', '32px')
            .attr('height', '32px')
            .attr('transform', 'translate(3, 3)');
        node.append('text').attr('class', 'nv-org-name')
            .attr('data-url', d.url)
            .attr('transform', 'translate(38, 11)')
            .text(d.metadata.full_name);
        node.append('text').attr('class', 'nv-org-title')
            .attr('data-url', d.url)
            .attr('transform', 'translate(38, 21)')
            .text(d.metadata.title);
        return node;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        var self = this;
        if (!this.isChartReady()) {
            return;
        }

        if (!this.slider) {
            // chart controls
            this.slider = this.$('.btn-slider .noUiSlider');
            this.sliderZoomIn = this.$('.btn-slider i[data-control="zoom-in"]');
            this.sliderZoomOut = this.$('.btn-slider i[data-control="zoom-out"]');

            //zoom slider
            this.slider.noUiSlider('init', {
                start: 100,
                knobs: 1,
                scale: [this.zoomExtents.min * 100, this.zoomExtents.max * 100],
                connect: false,
                step: 25,
                change: function(moveType) {
                    var values, scale;
                    if (!self.chart_loaded) {
                        return;
                    }

                    if (moveType === 'slide') {
                        values = self.slider.noUiSlider('value');
                        scale = self.chart.zoomLevel(values[0] / 100);
                    } else {
                        scale = self.chart.zoomScale();
                    }
                    self.sliderZoomIn.toggleClass('disabled', (scale === self.zoomExtents.max));
                    self.sliderZoomOut.toggleClass('disabled', (scale === self.zoomExtents.min));
                }
            });
        }
        this.moveSlider();

        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }

        //jsTree control for selecting root node
        this.jsTree = this.$('div[data-control="org-jstree"]').jstree({
            // generating tree from json data
            'json_data': {
                'data': this.chartCollection
            },
            // plugins used for this tree
            'plugins': ['json_data', 'ui', 'types'],
            'core': {
                'animation': 0
            },
            'ui': {
                // when the tree re-renders, initially select the root node
                'initially_select': ['jstree_node_' + app.user.get('user_name')]
            }
        }).on('loaded.jstree', function(e) {
                // do stuff when tree is loaded
                self.$('div[data-control="org-jstree"]').addClass('jstree-sugar');
                self.$('div[data-control="org-jstree"] > ul').addClass('list');
                self.$('div[data-control="org-jstree"] > ul > li > a').addClass('jstree-clicked');
        }).on('click.jstree', function(e) {
                e.stopPropagation();
                e.preventDefault();
        }).on('select_node.jstree', function(event, data) {
                var jsData = data.inst.get_json();

                self.chart.filter(jQuery.data(data.rslt.obj[0], 'id'));
                self.forceRepaint();
                self.moveSlider();

                self.$('div[data-control="org-jstree-dropdown"] .jstree-label').text(data.inst.get_text());
                data.inst.toggle_node(data.rslt.obj);
        });
        app.accessibility.run(this.jsTree, 'click');

        this.container = d3.select('svg#' + this.cid);

        d3.select('svg#' + this.cid)
            .datum(this.chartCollection[0])
            .transition().duration(500)
            .call(this.chart);

        this.chart.reset();

        this.forceRepaint();

        this.$('.nv-expcoll').on('click', function(e) {
            self.forceRepaint();
            self.moveSlider();
        });

        this.chart_loaded = _.isFunction(this.chart.resize);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Forces repaint of images using opacity animation to fix
     * issue with rendering foreignObject in SVG
     */
    forceRepaint: function() {
        this.$('.rep-avatar').on('load', function() {
            $(this).removeClass('loaded').addClass('loaded');
        });

        this.$('img').error(function() {
            $(this).attr('src', 'include/images/user.svg');
        });
    },

    /**
     * Move the slider position
     * Use whenever the tree changes size
     */
    moveSlider: function(scale) {
        var s = scale || 1;
        if (this.slider) {
            this.slider.noUiSlider('move', {to: s * 100});
        }
    },

    /**
     * Override the hasChartData method in Chart plugin because
     * this view does not have a total value.
     */
    hasChartData: function() {
        return !_.isEmpty(this.chartCollection);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * orgchart nvd3 model uses resize instead of update.
     */
    chartResize: function() {
        this.moveSlider();
        this.chart.resize();
    },

    /**
     * Recursively step through the tree and for each node representing a tree node, run the data attribute through
     * the _postProcessTree function.  This function supports n-levels of the tree hierarchy.
     *
     * @param data The data structure returned from the REST API Forecasts/reportees endpoint
     * @return The modified data structure after all the parent and children nodes have been stepped through
     * @private
     */
    _postProcessTree: function(data) {
        var root = [],
            self = this;

        if (_.isArray(data) && data.length == 2) {
            root.push(data[0]);
            root[0].children.push(data[1]);
        } else {
            root.push(data);
        }

        //protect against admin and other valid Employees
        if (_.isEmpty(root[0].metadata.id)) {
            return null;
        }

        _.each(root, function(entry) {
            var adopt = [];

            //Scan for the nodes with the data attribute.  These are the nodes we are interested in
            if (!entry.data) {
                return;
            }

            entry.metadata.url = self._buildUserUrl(entry.metadata.id);

            if (!entry.metadata.picture || entry.metadata.picture === '') {
                entry.metadata.img = 'include/images/user.svg';
            } else {
                entry.metadata.img = app.api.buildFileURL({
                    module: 'Employees',
                    id: entry.metadata.id,
                    field: 'picture'
                });
            }

            if (!entry.children) {
                return;
            }

            //For each children found (if any) then call _postProcessTree again.
            _.each(entry.children, function(childEntry) {
                var newChild;
                if (entry.metadata.id !== childEntry.metadata.id) {
                    newChild = self._postProcessTree(childEntry);
                    if (!_.isEmpty(newChild)) {
                        adopt.push(newChild[0]);
                    }
                }
            }, this);

            entry.children = adopt;

        }, this);

        return root;
    },

    /**
     * Slider control for zooming chart viewport.
     * @param {e} event The event object that is triggered.
     */
    zoomChart: function(e) {
        var button, step, scale;
        if (!this.chart_loaded) {
            return;
        }

        button = $(e.target).data('control');
        step = 0.25 * (button === 'zoom-in' ? 1 : -1);
        scale = this.chart.zoomStep(step);

        this.moveSlider(scale);
    },

    /**
     * Handle all chart manipulation toggles.
     * @param {e} event The event object that is triggered.
     */
    toggleChart: function(e) {
        var button;
        if (!this.chart_loaded) {
            return;
        }

        //if icon clicked get parent button
        button = $(e.currentTarget).hasClass('btn') ? $(e.currentTarget) : $(e.currentTarget).parent('.btn');

        switch (button.data('control')) {
            case 'orientation':
                this.chart.orientation();
                button.find('i').toggleClass('fa-arrow-right fa-arrow-down');
                break;

            case 'show-all-nodes':
                this.chart.showall();
                this.forceRepaint();
                break;

            case 'zoom-to-fit':
                this.chart.resize();
                break;

            default:
        }

        this.moveSlider();
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this;

        app.api.call('get', this.reporteesEndpoint, null, {
            success: function(data) {
                self.chartCollection = self._postProcessTree(data);
                if (!self.disposed) {
                    self.renderChart();
                }
            },
            complete: options ? options.complete : null
        });
    },

    /**
     * overriding _dispose to make sure custom added event listeners are removed
     * @private
     */
    _dispose: function() {
        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }
        if (this.slider) {
            this.slider.off('move');
        }
        this._super('_dispose');
    }
}) },
"resolve-conflicts-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsListView
 * @alias SUGAR.App.view.views.BaseResolveConflictsListView
 * @extends View.Views.Base.FlexListView
 */
({
	// Resolve-conflicts-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListRemoveLinks'],

    initialize: function (options) {
        // set as single select list
        options.meta = options.meta || {};
        options.meta.selection = {type: 'single', label: 'LBL_LINK_SELECT'};

        this._super('initialize', [options]);

        // do not fetch on initial load
        this.context._fetchCalled = true;

        this._buildList();
    },

    /**
     * Do not build default list columns.
     */
    parseFields: function () {},

    /**
     * Populate the list with data from the client and the server.
     * @private
     */
    _buildList: function() {
        var dataInDb = this.context.get('dataInDb'),
            modelToSave = this.context.get('modelToSave'),
            modelInDb, copyOfModelToSave, originalId;

        if (!_.isEmpty(dataInDb) && !_.isEmpty(modelToSave)) {
            modelInDb = app.data.createBean(modelToSave.module, dataInDb);
            copyOfModelToSave = app.data.createBean(modelToSave.module);
            originalId = modelToSave.get('id');

            //cannot use bean.copy() because we need date_modified
            copyOfModelToSave.set(app.utils.deepCopy(modelToSave.attributes));

            this._buildFieldDefinitions(copyOfModelToSave, modelInDb);

            // set IDs to be different so that backbone collection can recognize that they're not the same
            copyOfModelToSave.id = originalId + '-client';
            modelInDb.id = originalId + '-database';

            // indicate which model is from the client and the server
            copyOfModelToSave.set('_dataOrigin', 'client');
            modelInDb.set('_dataOrigin', 'database');

            // set the person who modified the data
            copyOfModelToSave.set('_modified_by', app.lang.get('LBL_YOU'));
            modelInDb.set('_modified_by', modelInDb.get('modified_by_name'));

            this._populateMissingDataFromDatabase(copyOfModelToSave, modelInDb);
            this.collection.add([copyOfModelToSave, modelInDb]);
        }
    },

    /**
     * Build columns to be displayed to the user.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _buildFieldDefinitions: function(modelToSave, modelInDb) {
        var fieldsThatDiffer,
            fieldDefinition,
            modifiedByColumnDef = {
                name: '_modified_by',
                type: 'base',
                label: 'LBL_MODIFIED',
                sortable: false
            };

        // determine which fields have different values
        fieldsThatDiffer = app.utils.compareBeans(modelToSave, modelInDb);

        // remove modified_by_name if exists
        fieldsThatDiffer = _.filter(fieldsThatDiffer, function(name) {
            return name !== 'modified_by_name';
        });

        // get field view definitions
        fieldDefinition = this._getFieldViewDefinition(fieldsThatDiffer);

        // insert modified by column
        fieldDefinition = _.union([modifiedByColumnDef], fieldDefinition);

        this._fields = this._createCatalog(fieldDefinition);
    },

    /**
     * @inheritdoc
     */
    _patchField: function(fieldMeta, i) {
        var isVisible = (fieldMeta.name !== 'date_modified');
        return _.extend({
            sortable: false,
            selected: isVisible,
            position: ++i
        }, fieldMeta, {
            sortable: false
        });
    },

    /**
     * Get field view definition from the record view, given field names.
     * @param fieldNames
     * @return {Array}
     * @private
     */
    _getFieldViewDefinition: function(fieldNames) {
        var fieldDefs = [],
            moduleViewDefs = app.metadata.getView(this.module, 'record'),
            addFieldDefinition = function(definition) {
                if (definition.name && (_.indexOf(fieldNames, definition.name) !== -1)) {
                    fieldDefs.push(app.utils.deepCopy(definition));
                }
            };

        _.each(moduleViewDefs.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (field.fields && _.isArray(field.fields)) {
                    // iterate through fieldsets to get the field view definition
                    _.each(field.fields, function(field) {
                        addFieldDefinition(field);
                    });
                } else {
                    addFieldDefinition(field);
                }
            });
        });

        return fieldDefs;
    },

    /**
     * Populate missing values on the client's bean from the database data.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _populateMissingDataFromDatabase: function(modelToSave, modelInDb) {
        _.each(modelInDb.attributes, function(value, attribute) {
            if (!modelToSave.has(attribute) || !app.utils.hasDefaultValueChanged(attribute, modelToSave)) {
                modelToSave.set(attribute, value);
            }
        })
    },

    /**
     * Trigger preview event when the preview is clicked. Preview needs to render without activity
     * stream and pagination.
     */
    addPreviewEvents: function () {
        this._super("addPreviewEvents");

        this.context.off('list:preview:fire', null, this);
        this.context.on('list:preview:fire', function (model) {
            app.events.trigger('preview:render', model, this.collection, false, model.id, false);
            app.events.trigger('preview:pagination:hide');
        }, this);
    },

    /**
     * Add Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super("addActions");

        this.rightColumns.push({
            type: 'rowaction',
            css_class: 'btn',
            tooltip: 'LBL_PREVIEW',
            event: 'list:preview:fire',
            icon: 'fa-eye'
        });
    }
}) },
"filter-quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for doing a quick search.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterQuicksearchView
 * @alias SUGAR.App.view.views.BaseFilterQuicksearchView
 * @extends View.View
 */
({
	// Filter-quicksearch View (base) 

    events: {
        'keyup': 'throttledSearch',
        'paste': 'throttledSearch'
    },

    plugins: ['QuickSearchFilter'],

    className: 'table-cell full-width',

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);
        this.listenTo(this.layout, 'filter:clear:quicksearch', this.clearInput);
        this.listenTo(this.layout, 'filter:change:module', this.updatePlaceholder);

        //shortcut keys
        app.shortcuts.register('Filter:Search', ['f i','ctrl+alt+9'], function() {
            if (this.$el.is(':visible')) {
                this.$el.focus();
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Changes `this.$el` to point to the `<input>` element.
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.setElement(this.$('input'));
    },

    /**
     * For customers with large datasets, allow customization to disable
     * the automatic filtering in the omnibar.
     *
     * @inheritdoc
     */
    delegateEvents: function(events) {
        if (app.config.disableOmnibarTypeahead) {
            // Remove the keyup and paste events from this.events.
            // This is before the call to this._super('delegateEvents'),
            // so they have not been registered.
            delete this.events.keyup;
            delete this.events.paste;

            // On enter key press, apply the quicksearch.
            this.events.keydown = _.bind(function(evt) {
                // Enter key code is 13
                if (evt.keyCode === 13) {
                    this.applyQuickSearch();
                }
            }, this);
        }
        this._super('delegateEvents', [events]);
    },

    /**
     * Fires the quick search.
     * @param {Event} [event] A keyup event.
     */
    throttledSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 400),

    /**
     * Retrieves the labels for the fields that are searchable in the
     * quicksearch.
     *
     * @param {string} moduleName The module name the fields belong to.
     * @param {string[]} fields The list of searchable fields.
     * @return {string[]} The list of labels.
     */
    getFieldLabels: function(moduleName, fields) {
        var moduleMeta = app.metadata.getModule(moduleName);
        var labels = [];

        _.each(_.flatten(fields), function(fieldName) {
            var fieldMeta = moduleMeta.fields[fieldName];
            if (fieldMeta) {
                labels.push(app.lang.get(fieldMeta.vname, moduleName).toLowerCase());
            }
        });

        return labels;
    },

    /**
     * Update quick search placeholder to Search by Field1, Field2, Field3 when the module changes
     * @param string linkModuleName
     * @param string linkModule
     */
    updatePlaceholder: function(linkModuleName, linkModule) {
        var label;
        this.toggleInput();
        if (!this.$el.hasClass('hide') && linkModule !== 'all_modules') {
            var filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
                fields = filtersBeanPrototype.getModuleQuickSearchMeta(linkModuleName).fieldNames,
                fieldLabels = this.getFieldLabels(linkModuleName, fields);
            label = app.lang.get('LBL_SEARCH_BY') + ' ' + fieldLabels.join(', ') + '...';
        } else {
            label = app.lang.get('LBL_BASIC_QUICK_SEARCH');
        }
        var input = this.$el.attr('placeholder', label);
        //Call placeholder() because IE9 does not support placeholders.
        if (_.isFunction(input.placeholder)) {
            input.placeholder();
        }
    },

    /**
     * Hide input if on Activities
     */
    toggleInput: function() {
        this.$el.toggleClass('hide', !!this.layout.showingActivities);
    },

    /**
     * Clear input
     */
    clearInput: function() {
        this.toggleInput();
        var input = this.$el.val('');
        //Call placeholder() because IE9 does not support placeholders.
        if (_.isFunction(input.placeholder)) {
            input.placeholder();
        }
        this.applyQuickSearch(true);
    },

    /**
     * Invokes the `filter:apply` event with the current value on the
     * quicksearch field.
     *
     * @param {boolean} [force] `true` to always trigger the `filter:apply`
     *   event, `false` otherwise. Defaults to `false`.
     */
    applyQuickSearch: function(force) {
        force = !_.isUndefined(force) ? force : false;
        var newSearch = this.$el.val();
        if (force || this.currentSearch !== newSearch) {
            this.currentSearch = newSearch;
            this.layout.trigger('filter:apply', newSearch);
        }
    }
}) },
"dnb-meter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dnb-meter View (base) 

    extendsFrom: 'DnbView',
    plugins: ['Chart', 'Dashlet'],

    meterConst: {
        'responseCode' : 'GetMeterResponse.TransactionResult.ResultID',
        'responseMsg' : 'GetMeterResponse.TransactionResult.ResultText',
        'meterInfoPath' : 'GetMeterResponse.GetMeterResponseDetail.GetMeterResult'
    },

    meterDD: {
        'productCode': {
            'json_path': 'DNBProductID',
            'productMapping': {
                'DCP_PREM': 'LBL_DNB_METER_ACCT',
                'DCP_STD': 'LBL_DNB_METER_ACCT',
                'DCP_BAS': 'LBL_DNB_METER_ACCT',
                'LNK_FF': 'LBL_DNB_METER_FF',
                'CNTCT_PLUS': 'LBL_DNB_METER_PREM_CNTCT',
                'CNTCT': 'LBL_DNB_METER_STD_CNTCT'
            }
        },
        'maxLimit': {
            'json_path': 'MeterDetail.UsageLimit',
            'label': 'LBL_DNB_METER_REMAINING'
        },
        'usage': {
            'json_path': 'MeterDetail.UsageCount',
            'label': 'LBL_DNB_METER_USED'
        },
        'contractStart': {
            'json_path': 'MeterDetail.StartTimestamp',
            'label': 'LBL_DNB_CONT_START'
        },
        'contractEnd': {
            'json_path': 'MeterDetail.EndTimestamp',
            'label': 'LBL_DNB_CONT_END'
        }
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        this.dnbChartIds = _.keys(this.meterDD.productCode.productMapping);
        this.chart = this.createChart();
    },

    /**
     * Return pie chart model
     */
    createChart: function () {
        return nv.models.pieChart()
            .x(function(d) { return d.key })
            .margin({top: 5, right: 5, bottom: 5, left: 5})
            .startAngle(function(d) { return (d.startAngle - Math.PI) / 2 })
            .endAngle(function(d) { return (d.endAngle - Math.PI) / 2 })
            .showLabels(false)
            .donut(true)
            .donutRatio(0.70)
            .donutLabelsOutside(true)
            .showTitle(false)
            .tooltips(true)
            .showLegend(false)
            .direction(app.lang.direction)
            .tooltipContent(function(key, x, y, e, graph) {
                return '<p><b>' + key + ': ' + y.replace('.00','') + '</b></p>';
            });
    },

    /**
     * Refresh dashlet once Refresh link clicked from geat button
     * To show updated data from D&B Competitors service
     */
    refreshClicked: function() {
        this.chartCollection = null;
        this.contractInfo = null;
        this.loadData();
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }
        //remove unwanted chart ids
        _.each(_.difference(this.dnbChartIds, _.keys(this.chartCollection)), function(chartId) {
            this.$('div#dnb' + chartId).remove();
        }, this);
        //render chart
        _.each(this.chartCollection, function(chartDetails, chartId) {
            this.$('div#dnb' + chartId).removeClass('hide');
            var chartSelector = 'svg#' + chartId;
            var dnbChart = this.createChart();
            dnbChart.hole(chartDetails.chartData.data[0].value);
            dnbChart.holeFormat(function(wrap, data) {
                var wrapEnter = wrap.selectAll('text').data([null]).enter().append('g')
                    .attr('transform', 'translate(0,-1)');
                wrapEnter.append('text')
                    .text(chartDetails.chartData.data[0].value)
                    .attr('dy', '-.2em')
                    .attr('class', 'nv-pie-hole-value');
                wrapEnter.append('text')
                    .text(chartDetails.chartLabel)
                    .attr('text-anchor', 'middle')
                    .attr('class', 'nv-pie-hole-label')
                    .attr('dy', '.8em')
                    .style('fill', '#333')
                    .style('font-size', '11px');
            });
            d3.select(this.el).select(chartSelector)
                .datum(chartDetails.chartData)
                .transition().duration(500)
                .call(dnbChart);
        }, this);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this;
        if (this.meta.config) {
            return;
        }
        if (!this.disposed) {
            this.render();
        }
        var dnbMeterURL = app.api.buildURL('connector/dnb/meter/', '', {},{}),
            resultData = {'product': null, 'errmsg' : null};
        app.api.call('read', dnbMeterURL, null, {
            success: function(data) {
                var responseCode = self.getJsonNode(data, self.meterConst.responseCode),
                    responseMsg = self.getJsonNode(data, self.meterConst.responseMsg);
                if (responseCode && responseCode === self.responseCodes.success) {
                    resultData.product = data;
                } else {
                    resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                }
                self.renderMeterInfo.call(self, resultData);
            },
            error: _.bind(self.checkAndProcessError, self)
        });
    },

    /**
     * Render D&B Meter response to charts
     * @param {Object} dnbMeterResponse
     */
    renderMeterInfo: function(dnbMeterResponse) {
        if (dnbMeterResponse.product) {
            var meterDetail = this.getJsonNode(dnbMeterResponse.product, this.meterConst.meterInfoPath);
            this.chartCollection = this.formatMeterInfo(meterDetail, this.meterDD);

            if (!this.disposed) {
                this.render();
            }
        } else if(dnbMeterResponse.errmsg) {
            this.renderError(dnbMeterResponse.errmsg);
        }
    },

    /**
     * Format the D&B Meter Response
     * @param {Object} dnbMeterResponse
     * @param {Object} dnbMeterDD data dictionary
     * @return {Object}
     */
    formatMeterInfo: function(dnbMeterResponse, dnbMeterDD) {
        var formattedMeterResponse = {};
        _.each(dnbMeterResponse, function(meterDetailObj){
            var productCode = this.getJsonNode(meterDetailObj, dnbMeterDD.productCode.json_path);
            if (!_.isUndefined(productCode)) {
                var meterDetails = {};
                meterDetails.data = [];
                var meterUsage = parseInt(this.getJsonNode(meterDetailObj, dnbMeterDD.usage.json_path), 10),
                    meterLimit = parseInt(this.getJsonNode(meterDetailObj, dnbMeterDD.maxLimit.json_path), 10);
                meterDetails.data.push({
                    'key':   app.lang.get(dnbMeterDD.usage.label),
                    'value': meterUsage,
                    'color': this.usageToColorMapping(meterUsage, meterLimit)
                });
                meterDetails.data.push({
                    'key':   app.lang.get(dnbMeterDD.maxLimit.label),
                    'value': meterLimit - meterUsage,
                    'color': 'grey'
                });
                formattedMeterResponse[productCode] = {
                    'chartData':  meterDetails,
                    'chartLabel': app.lang.get(dnbMeterDD.productCode.productMapping[productCode])
                };
            }
            //get contract start and end dates
            if (_.isUndefined(this.contractInfo) || _.isNull(this.contractInfo)) {
                var contractEndDate = this.getJsonNode(meterDetailObj, dnbMeterDD.contractEnd.json_path);
                if(!_.isUndefined(contractEndDate)) {
                    contractEndDate = app.date(contractEndDate.substr(0,10)).format(app.date.convertFormat(app.user.getPreference('datepref')));
                    this.contractInfo = {
                        'cntLabel': app.lang.get(dnbMeterDD.contractEnd.label),
                        'cntInfo': contractEndDate
                    };
                }
            }
        }, this);
        return formattedMeterResponse;
    },

    /**
     * Returns color for the donut chart based on meterUsage percentage
     * @param {Number} meterUsage
     * @param {Number} meterLimit
     * @return {string}
     */
    usageToColorMapping: function(meterUsage, meterLimit) {
        var meterUsagePercentage = meterUsage / meterLimit;
        if (meterUsagePercentage < 0.5) {
            return 'green'
        } else if (meterUsagePercentage > 0.5 && meterUsagePercentage < 0.75) {
            return 'orange'
        } else {
            return 'red';
        }
    },

    /**
     * function for determining if chart has data.
     * Can be overridden in views by defining hasChartData method.
     */
    hasChartData: function() {
        return !(_.isUndefined(this.chartCollection) || _.isNull(this.chartCollection));
    },

    /**
     * Renders an error from the D&B API
     * @param {String} msg The error message from the api
     */
    renderError: function(msg) {
        this.dnbError = {errMsg:  msg};
        this.template = app.template.get('dnb.dnb-error');
        this.renderErrorMessage();
    }
}) },
"dupecheck-list-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListSelectView
 * @alias SUGAR.App.view.views.BaseDupecheckListSelectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-select View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-singleselect'
}) },
"vcard-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportView
 * @alias SUGAR.App.view.views.BaseVcardImportView
 * @extends View.View
 */
({
	// Vcard-import View (base) 

    /**
     * @inheritdoc
     * Imports a vcf file and creates a record based on person type
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('vcard:import:finish', this.importVCard, this);
        this.on('render', this._setFileField, this);
    },

    /**
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _setFileField: function() {
        var field = this.getField('vcard_import');
        field.setMode('edit');
    },

    /**
     * Event to trigger the uploading of the vcf and record creation
     */
    importVCard: function() {
        var vcardFieldName = 'vcard_import',
            $vcardFile = this.$('[name=vcard_import]');

        if (_.isEmpty($vcardFile.val())) {
            app.alert.show('error_validation_vcard', {
                level: 'error',
                messages: 'LBL_EMPTY_VCARD'
            });
        } else {
            var ajaxParams = {
                    temp: false,
                    deleteIfFails: false
                },
                fields = {},
                field = this.getField(vcardFieldName);

            fields[vcardFieldName] = field.def;

            this.context.trigger('vcard:import-finish-button:toggle', false);
            app.alert.show('vcard_importing', {
                level: 'process',
                title: app.lang.get('LBL_SAVING', this.module)
            });
            this.model.uploadFile(vcardFieldName, $vcardFile, {
                success: _.bind(this._doValidateFileSuccess, this),
                error: _.bind(this._doValidateFileError, this)
            }, ajaxParams);
        }
    },

    /**
     * Success callback for the {@link #importVCard} function.
     *
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(data) {
        var route = app.router.buildRoute(this.module, data.vcard_import);
        app.router.navigate(route, {trigger: true});
        app.alert.dismiss('vcard_importing');
        app.alert.show('vcard-import-saved', {
            level: 'success',
            messages: app.lang.get('LBL_IMPORT_VCARD_SUCCESS', this.module),
            autoClose: true
        });
    },

    /**
     * Error callback for the {@link #importVCard} function.
     *
     * @param {Object} error Error object returned from the API.
     */
    _doValidateFileError: function(error) {
        this.context.trigger('vcard:import-finish-button:toggle', true);
        app.alert.dismiss('vcard_importing');
        app.alert.show('error_validation_vcard', {
            level: 'error',
            messages: app.lang.get('TPL_IMPORT_VCARD_FAILURE', this.module, {module: this.module})
        });
    }
}) },
"headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HeaderpaneView
 * @alias SUGAR.App.view.views.BaseHeaderpaneView
 * @extends View.View
 */
({
	// Headerpane View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.meta = _.extend({}, app.metadata.getView(null, 'headerpane'), this.meta);

        /**
         * The label used for the title. This is the raw label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         * @private
         */
        this._title = this.meta.title;

        this.context.on('headerpane:title', function(title) {
            this._title = title;
            if (!this.disposed) this.render();
        }, this);

        //shortcut keys
        app.shortcuts.register('Headerpane:Cancel', ['esc', 'ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=cancel_button]'),
                $closeButton = this.$('a[name=close]');

            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.click();
            } else if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                $closeButton.click();
            }
        }, this, true);
        app.shortcuts.register('Headerpane:Save', ['ctrl+s', 'ctrl+alt+a'], function() {
            var $saveButton = this.$('a[name=save_button]');
            if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                $saveButton.click();
            }
        }, this, true);
        $(window).on('resize.headerpane.' + this.cid, _.bind(this.adjustHeaderpane, this));
        this.layout.on('headerpane:adjust_fields', this.adjustTitle, this);
    },

    /**
     * Adjusts the title's ellipsis max-width to match the ancestor title cell.
     */
    adjustTitle: function() {
        var $titleCell = this.$el.find('[data-name=title]');
        if ($titleCell) {
            var $ellipsisDiv = $titleCell.find('.ellipsis_inline');
            var width = $titleCell.css('max-width');
            $ellipsisDiv.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        /**
         * The title being rendered in the headerpane. This is the formatted
         * label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #_formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         */
        this.title = !_.isUndefined(this._title) ? this._formatTitle(this._title) : this.title;
        this.meta.fields = _.map(this.meta.fields, function(field) {
            if (field.name === 'title') {
                field['formatted_value'] = this.title || this._formatTitle(field['default_value']);
            }
            return field;
        }, this);
        this._super('_renderHtml');
    },

    /**
     * Formats the title before being rendered.
     *
     * @param {string} title The unformatted title.
     * @return {string} The formatted title.
     * @protected
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module);
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis.
     */
    adjustHeaderpane: function() {
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell,
            ellipsisCellWidth,
            $recordCells;

        if (this.disposed) {
            return;
        }

        $recordCells = this.$('.headerpane h1').children('.record-cell, .btn-toolbar');

        if (($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }
        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return 0;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url', 'dashboardtitle', 'label'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');

        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            width -= ellipsifiedCell.getCellPadding();
            ellipsifiedCell.setMaxWidth(width);
        } else {
            $ellipsisCell.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderFields: function() {
        this._super('_renderFields');
        this.adjustHeaderpane();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.headerpane.' + this.cid);
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"search-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * List view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchListView
 * @alias SUGAR.App.view.views.BaseSearchListView
 * @extends View.View
 */
({
	// Search-list View (base) 

    plugins: ['Pagination'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};
        this.addPreviewEvents();
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            this.parseModels(this.collection.models);
            if (this._previewed) {
                app.events.trigger('preview:close');
            }
            this.render();
        }, this);
    },

    /**
     * Parses models to generate primary fields and secondary fields based on
     * the metadata and data sent by the globalsearch API. This is used to
     * render them properly in the template.
     *
     * @param {Data.Bean[]} models The models to parse.
     */
    parseModels: function(models) {
        var gsUtils = app.utils.GlobalSearch;
        _.each(models, function(model) {
            var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module);
            this._fieldsMeta[model.module] = moduleMeta;

            model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
            model.secondaryFields = gsUtils.highlightFields(model, moduleMeta.secondaryFields, true);

            this._rejectEmptyFields(model, model.primaryFields);
            this._rejectEmptyFields(model, model.secondaryFields);

            model.primaryFields = this._sortHighlights(model.primaryFields);
            model.secondaryFields = this._sortHighlights(model.secondaryFields);

            model.rowactions = moduleMeta.rowactions;
        }, this);
    },

    /**
     * Converts a hash of field names and their definitions into an array of
     * field definitions sorted such as:
     *
     *  - avatar field(s) is(are) first (in theory there should be only one),
     *  - highlighted fields are second,
     *  - non highlighted fields are third.
     *
     * @param {Object} fieldsObject The object to transform.
     * @return {Array} fieldsArray The sorted array of objects.
     * @private
     */
    _sortHighlights: function(fieldsObject) {
        var fieldsArray = _.values(fieldsObject);
        fieldsArray = _.sortBy(fieldsArray, function(field) {
            if (field.type === 'avatar') {
                return 0;
            }
            return field.highlighted ? 1 : 2;
        });
        return fieldsArray;
    },

    /**
     * Removes fields that have an empty value.
     *
     * @param {Data.Bean} model The model.
     * @param {Object} viewDefs The viewDefs of the fields.
     * @private
     */
    _rejectEmptyFields: function(model, viewDefs) {
        _.each(viewDefs, function(field) {
            if (field.type === 'avatar' || field.highlighted) {
                return;
            }
            var fieldValue = model.get(field.name);
            // _.isEmpty() returns true for any number, so checking for _.isNumber() as well
            if (_.isEmpty(fieldValue) && !_.isNumber(fieldValue)) {
                delete viewDefs[field.name];
            }
        });
    },

    /**
     * Adds event listeners related to preview.
     */
    addPreviewEvents: function() {
        this.context.on('list:preview:fire', function(model) {
            app.events.trigger('preview:render', model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need
        //to update the highlighted row.
        app.events.on('list:preview:decorate', this.decorateRow, this);
        if (this.layout) {
            this.layout.on('list:paginate:success', function() {
                //When fetching more records, we need to update the preview
                //collection.
                app.events.trigger('preview:collection:change', this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Decorates the row in the list that is being shown in Preview.
     *
     * @param {Data.Bean} model The model corresponding to the row to be
     *   decorated. Pass a falsy value to clear decoration.
     */
    decorateRow: function(model) {
        this._previewed = model;
        this.$('li.highlighted').removeClass('highlighted current');
        if (model) {
            var curr = this.$('[data-id="' + model.id + '"]');
            curr.addClass('current highlighted');
        }
    },

    /**
     * Add the tags and facets options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        var selectedFacets = this.context.get('selectedFacets');
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        var options = null;
        if (selectedFacets || tagFilters) {
            options = {
                apiOptions: {
                    data: {},
                    fetchWithPost: true,
                    useNewApi: true
                }
            };
        }
        if (selectedFacets) {
            options.apiOptions.data.agg_filters = selectedFacets;
        }
        if (tagFilters) {
            options.apiOptions.data.tag_filters = tagFilters;
        }

        return options;
    }
}) },
"dnb-company-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbCompanyInfoView
 * @alias SUGAR.App.view.views.BaseCompanyInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-company-info View (base) 

    extendsFrom: 'DnbView',
    statesList: '',
    countryList: '',
    duns_num: null,
    selectedCountry: 'Country',
    companyList: null,
    //data dictionary from cleanse match
    cleanseMatchDD: null,
    compInfoConst: {
        'responseCode' : 'GetCleanseMatchResponse.TransactionResult.ResultID',
        'responseMsg' : 'GetCleanseMatchResponse.TransactionResult.ResultText',
        'cmCandidates' : 'GetCleanseMatchResponse.GetCleanseMatchResponseDetail.MatchResponseDetail.MatchCandidate',
        'cmMaxCount' : 100
    },
    events: {
        'click a.dnb-company-name': 'dunsClickHandler',
        'click .importDNBData': 'importDNBData',
        'click .dnb_checkbox': 'importCheckBox',
        'change #countryList': 'changeState',
        'change #stateList': 'validateMatchParams',
        'click .backToList' : 'backToCompanyList',
        'click [data-action="backToImportEnrich"]': 'backToImportEnrich',
        'click [data-action="dnb-lookup"]': 'dnbSearch',
        'click [data-action="dnb-match"]': 'invokeCMRequest',
        'click [data-action="show-more"]': 'invokePagination'
    },
    selectors: {
        'load': 'div#dnb-company-list-loading',
        'rslt': 'div#dnb-company-list',
        'rsltList': 'ul#dnb-results-list'
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function() {
        this._super('initDashlet');
        var pagesz = this.settings.get('pagesz');
        if (_.isUndefined(pagesz)){
            pagesz = 10;
        } else {
            this.pagesz = parseInt(pagesz, 10);
        }
        this.settings.set('pagesz', pagesz);
        this.initPaginationParams(this.pagesz);
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadImportEnrich, this);
        app.events.register('dnbcompinfo:duns_selected', this);
        app.events.register('dnbcompinfo:industry_code', this);
        this.statesList = app.lang.getAppListKeys('dnb_states_iso');
        this.countryList = app.lang.getAppListKeys('dnb_countries_iso');
        //initializing the data dictionary for cleanse match
        this.cleanseMatchDD = this.searchDD;
        this.cleanseMatchDD.confidenceCode = { 'json_path' : 'MatchQualityInformation.ConfidenceCodeValue' };
        this.rowTmpl = app.template.get('dnb.dnb-account-row');
    },

    /**
     * Refresh dashlet
     */
    refreshClicked: function() {
        this.initPaginationParams(this.pagesz);
        this.loadImportEnrich(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadImportEnrich: function(isCollapsed) {
        if (this.disposed) {
            return;
        }

        //if the dashlet is not collapsed load data from D&B
        if (!isCollapsed) {
            var errTmpl = this.name + '.dnb-no-duns';
            this.loadDNBData('duns_num', null, this.getCompInfo, null, errTmpl, 'dnb.dnb-no-duns-field');
                    this.renderDropDowns();
        } else {
            this.toggleImportBtn(false, 'dnb_import');
        }
    },

    /**
     * render country and stste drop downs
     */
    renderDropDowns: function() {
        this.$('#countryList').select2({
            placeholder: app.lang.get('LBL_DNB_SLCT_CTRY'),
            data: this.populateCountry(),
            containerCss: {'width': '80%'}
        });
        this.$('#stateList').select2({
            placeholder: app.lang.get('LBL_DNB_SLCT_STATE'),
            data: this.populateState(this.selectedCountry),
            containerCss: {'width': '80%'}
        });
    },

    /**
     * Redirects from the search results or cleanse match results
     * Back to the import and enrich screen
     */
    backToImportEnrich: function() {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name + '.dnb-no-duns');
        this.render();
        this.renderDropDowns();
    },

    /**
     * Gets the company information duns_num
     * @param {String} duns_num
     */
    getCompInfo: function(duns_num) {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name + '.dnb-company-details');
        this.render();
        this.$('div#dnb-company-detail-loading').show();
        this.$('div#dnb-company-details').hide();
        this.baseCompanyInformation(duns_num, this.compInfoProdCD.std, null, this.renderCompanyDetails);
    },

    /**
     * Performs refresh check when the dashlet is loaded
     * @param {Array} options
     */
    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
    },

    /**
     * Renders the company list when the back button is clicked
     */
    backToCompanyList: function() {
        if (this.disposed) {
            return;
        }
        var dupeCheckParams = {
            'type': 'duns',
            'apiResponse': this.currentPage,
            'module': 'dunsPage'
        };
        if (!_.isUndefined(this.currentPage[0].confidenceCode)) {
            this.template = app.template.get(this.name + '.dnb-cm-results');
        } else {
            this.template = app.template.get(this.name + '.dnb-company-list');
        }
        this.resultTemplate = this.template
        this.render();
        this.$(this.selectors.load).toggleClass('hide', false);
        this.$(this.selectors.rslt).toggleClass('hide', true);
        var targetFields = ['dnb_import', 'data_valid_ind'];
        _.each(targetFields, function(fieldName) {
            if (!_.isUndefined(this.layout.getComponent('dashlet-toolbar').getField(fieldName))) {
                this.layout.getComponent('dashlet-toolbar').getField(fieldName).getFieldElement().hide();
            }
        }, this);
        this.baseDuplicateCheck(dupeCheckParams, this.renderPage);
    },

    /**
     * Render search and cleanse match results
     * @param {Array} dnbApiResponse list of companies from dnb search / match api
     */
    renderCompanyList: function(dnbApiResponse) {
        var dnbCompanyList = {},
            appendRecords = false;
        if (this.resetPaginationFlag) {
            this.initPaginationParams(this.pagesz);
        }
        if (dnbApiResponse.product) {
            var apiCompanyList;
            if (dnbApiResponse.product.GetCleanseMatchResponse) {
                this.resultTemplate = app.template.get(this.name + '.dnb-cm-results');
                apiCompanyList = this.getJsonNode(dnbApiResponse.product, this.compInfoConst.cmCandidates);
                this.formattedRecordSet = this.formatSrchRslt(apiCompanyList, this.cleanseMatchDD);
                this.formattedRecordSet = this.formatConfidenceCodes(this.formattedRecordSet);
                this.recordCount = this.getJsonNode(dnbApiResponse.product, this.commonJSONPaths.cmCount);
                this.paginationCallback = null;
            } else {
                this.resultTemplate = app.template.get(this.name + '.dnb-company-list');
                apiCompanyList = this.getJsonNode(dnbApiResponse.product, this.commonJSONPaths.srchRslt);
                this.formattedRecordSet = this.formatSrchRslt(apiCompanyList, this.searchDD);
                this.recordCount = this.getJsonNode(dnbApiResponse.product, this.commonJSONPaths.srchCount);
                this.paginationCallback = this.baseAccountsBAL;
            }
            var nextPage = this.paginateRecords();
            //currentPage is set to null by initPaginationParams
            if (_.isNull(this.currentPage)) {
                this.currentPage = nextPage;
                dnbCompanyList.product = this.currentPage;
            } else {
                //this loop gets executed when api is called again to obtain more records
                dnbCompanyList.product = nextPage;
                appendRecords = true;
            }
        } else if (dnbApiResponse.errmsg) {
            dnbCompanyList.errmsg = dnbApiResponse.errmsg;
        }
        this.renderPage(dnbCompanyList, appendRecords);
    },

    /**
     * Overriding the renderPage in base dashlet
     * @param {Object} pageData
     * @param {Boolean} append boolean to indicate if records need to be appended to exsiting list
     */
    renderPage: function(pageData, appendRecords) {
        this._super('renderPage', [pageData, appendRecords]);
        //if the pagination controls are not displayed then
        //display the back to import enrich link for cleanse match and for keyword search
        if (this.recordCount <= this.endRecord) {
            this.$('#dnb-page-ctrl').toggleClass('hide', false);
            this.$('[data-action="show-more"]').addClass('hide');
            this.$('.loading').hide();
        }
        this.toggleImportBtn(false, 'dnb_import');
    },

    /**
     * Invokes D&B Search API based on the company name
     */
    dnbSearch: function() {
        this.currentPage = null;
        this.initPaginationParams(this.pagesz);
        if (this.disposed) {
            return;
        }
        var companyName = this.model.get('name');
        if (companyName) {
            this.template = app.template.get(this.name + '.dnb-company-list');
            this.render();
            this.$(this.selectors.load).toggleClass('hide', false);
            this.$(this.selectors.rslt).toggleClass('hide', true);
            this.companyList = null;
            var balParams = {
                'KeywordText': companyName
            };
            //setting balParams to context because we want to retain the api parameters
            //without the pagination related parameters
            this.balParams = balParams;
            this.baseAccountsBAL(this.setApiPaginationParams(balParams), this.renderCompanyList);
        }
    },

    /**
     * Event handler for handling clicks on D&B Search Results
     * @param {Object} evt
     */
    dunsClickHandler: function(evt) {
        if (this.disposed) {
            return;
        }
        var duns_num = evt.target.id;
        if (duns_num) {
            this.template = app.template.get(this.name + '.dnb-company-details');
            this.render();
            this.$('div#dnb-company-detail-loading').show();
            this.$('div#dnb-company-details').hide();
            this.trigger('dnbcompinfo:duns_selected', duns_num);
            this.baseCompanyInformation(duns_num, this.compInfoProdCD.lite, null, this.renderCompanyDetails);
        }
    },

    /**
     * Renders the dnb company details with chechboxes
     * @param {Object} companyDetails -- dnb api response for company details
     */
    renderCompanyDetails: function(companyDetails) {
        if (this.disposed) {
            return;
        }
        this.dnbProduct = {};
        if (companyDetails.product) {
            var duns_num = this.getJsonNode(companyDetails.product, this.appendSVCPaths.duns);
            if (!_.isUndefined(duns_num)) {
                this.duns_num = duns_num;
                app.controller.context.set('dnb_temp_duns_num', this.duns_num);
                this.dnbProduct.product = this.formatCompanyInfo(companyDetails.product, this.accountsDD);
                this.dnbProduct.product = this.getDataIndicators(this.accountsDD, this.dnbProduct.product);
                var industryCodeArray = this.getJsonNode(companyDetails.product, this.appendSVCPaths.industry);
                if (!_.isUndefined(industryCodeArray)) {
                    //extracting the primary hoovers industry code and passing it on
                    //to the industry info dashlet
                    //25838 indicates hoovers industry code
                    //if the DisplaySequence == 1
                    //it indicates that the industry code is the primary hoovers industry code
                    var industryObj = this.getPrimaryIndustry(industryCodeArray, 25838);
                    var hooversIndustryCode = this.getJsonNode(industryObj, 'IndustryCode.$'),
                        hooversTypeCode = industryObj['@DNBCodeValue'];
                    if (!_.isUndefined(hooversIndustryCode) && !_.isUndefined(hooversTypeCode)) {
                        app.controller.context.set('dnb_temp_hoovers_ind_code', hooversIndustryCode + '-' + hooversTypeCode);
                    }
                }
                //check if there are any new data
                var newDataElementsArray = _.filter(this.dnbProduct.product, function(dataElement) {
                    return dataElement.dataInd === 'new' || dataElement.dataInd === 'upd';
                });
                //if there are no new data elements then display
                // message that the company information is up to date
                if (newDataElementsArray.length === 0) {
                    this.dnbProduct.product = null;
                    this.dnbProduct.errmsg = app.lang.get('LBL_DNB_UPTODATE_MSG');
                } else {
                    this.toggleImportBtn('dnb_import', true);
                }
            }
        } else if (companyDetails.errmsg) {
            this.dnbProduct.errmsg = companyDetails.errmsg;
        }
        this.template = app.template.get(this.name + '.dnb-company-details');
        if (!this.model.get('duns_num')) {
            this.dnbProduct.isNotLinked = true;
        }
        this.render();
        this.$('div#dnb-company-detail-loading').hide();
        this.$('div#dnb-company-details').show();
        this.importCheckBox();
    },

    /**
     * Populates the stare and compare screen with duplicate / upload indicators
     * @param   {Object} accountsDD accounts data dictionary
     * @param   {Object} frmtCompInfo formatted company info
     * @return  {Object} formatted company info with data indicators
     */
    getDataIndicators: function(accountsDD, frmtCompInfo) {
        var accountsModel = this.model;
        _.each(frmtCompInfo, function(dataObj) {
            var sugarColumnName = dataObj.dataName;
            var dnbDataElement = dataObj.dataElement,
                sugarDataElement = accountsModel.get(sugarColumnName);
            if (dnbDataElement && sugarDataElement) {
                dnbDataElement = $.trim(dnbDataElement);
                sugarDataElement = $.trim(sugarDataElement);
                if (sugarDataElement == dnbDataElement) {
                    dataObj.dataInd = 'dup';
                } else if (sugarDataElement != dnbDataElement) {
                    dataObj.dataInd = 'upd';
                }
            } else if (dnbDataElement) {
                dataObj.dataInd = 'new';
            }
        },this);
        return frmtCompInfo;
    },

    /**
     * Populates the stare and compare screen with duplicate / upload indicators
     */
    importCheckBox: function() {
        var dnbCheckBoxes = $('.dnb_checkbox:checked');
        if (dnbCheckBoxes.length > 0) {
            this.toggleDashletBtn(true, 'dnb_import');
        } else {
            this.toggleDashletBtn(false, 'dnb_import');
        }
    },

    /**
     * Populate the countries drop down
     * @return {Array}
     */
    populateCountry: function() {
        var countryOptionsArray = [];
        _.each(this.countryList, function(element, index) {
            countryOptionsArray.push({
                id: index,
                text: element
            });
        });
        return countryOptionsArray;
    },

    /**
     * Populate the states drop down based on the country selected
     * @param  {String} selectedCountry country iso-code
     * @return {Array}
     */
    populateState: function(selectedCountry) {
        // Initialize the array of states that will populate the dropdown
        var stateOptionsArray = [];

        // Get the full states array from the app list strings
        var statesArray = app.lang.getAppListStrings('dnb_states_iso');

        // Grab the selected country code, since the states array is based on
        // country code
        var selectedCountryCode = this.countryList[selectedCountry];

        // Now build the states array properly, from the right states
        var state_arr = statesArray[selectedCountryCode];
        if (selectedCountry !== 'Country' && !_.isUndefined(state_arr)) {
            _.each(state_arr, function(element, index) {
                stateOptionsArray.push({
                    id: state_arr[index].code,
                    text: state_arr[index].name
                });
            });
        }
        return stateOptionsArray;
    },

    /**
     * Changes the states drop down based on the country selection
     */
    changeState: function() {
        this.selectedCountry = this.$('#countryList').val();
        //disable match button
        this.$('#dnb-match-btn').addClass('disabled');
        this.$('#countryList').select2('val', this.selectedCountry);
        this.$('#stateList').select2({
            placeholder: app.lang.get('LBL_DNB_SLCT_STATE'),
            data: this.populateState(this.selectedCountry),
            containerCss: {'width': '80%'}
        });
    },

    /**
     * validate if all the parameters for cleanse and match are available
     enable the match btn
     */
    validateMatchParams: function() {
        var accountName = this.model.get('name');
        if (!_.isUndefined(accountName) && this.$('#countryList').val() !== 'Country' && this.$('#statesList').val() !== 'State') {
            this.$('#dnb-match-btn').removeClass('disabled');
        }
    },

    /**
     * Invoke CleanseMatch
     * It is a D&B API the cleanse the company name addresses and provides a response
     * with possible matches
     * @param {Object} evt
     */
    invokeCMRequest: function(evt) {
        this.currentPage = null;
        this.initPaginationParams(this.pagesz);
        if (this.disposed) {
            return;
        }
        if (!$(evt.target).hasClass('disabled')) {
            var self = this,
                townName = this.model.get('billing_address_city'),
                zipCode = this.model.get('billing_address_postalcode');
            var cmRequestParams = {
                'IncludeCleansedAndStandardizedInformationIndicator' : 'true', //mandatory
                'CountryISOAlpha2Code' : this.$('#countryList').val(), //country code mandatory
                'cleansematch' : 'true',//mandatory
                'SubjectName' : this.model.get('name'), //company name mandatory
                'TerritoryName' : this.$('#stateList').val() //optional
            };
            if (townName) {
                cmRequestParams.PrimaryTownName = townName;
            }
            if (zipCode) {
                cmRequestParams.FullPostalCode = zipCode;
            }
            //setting the maximum # of results to be returned by cleanse match call
            cmRequestParams.CandidateMaximumQuantity = this.compInfoConst.cmMaxCount;
            self.template = app.template.get(self.name + '.dnb-cm-results');
            self.render();
            self.$(self.selectors.load).toggleClass('hide', false);
            self.$(self.selectors.rslt).toggleClass('hide', true);
            var dnbCMRequestURL = app.api.buildURL('connector/dnb/cmRequest', '', {},{});
            var cmResults = {'product': null, 'errmsg': null};
            app.api.call('create', dnbCMRequestURL, {'qdata': cmRequestParams}, {
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.compInfoConst.responseCode),
                        responseMsg = self.getJsonNode(data, self.compInfoConst.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        cmResults.companies = self.getJsonNode(data, self.compInfoConst.cmCandidates);
                        cmResults.product = data;
                    } else {
                        cmResults.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderCompanyList(cmResults);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     * Format confidence codes
     * @param  {Array} dnbCompanyList
     * @return {Array} dnbCompanyList formatted
     */
    formatConfidenceCodes: function(dnbCompanyList) {
        _.each(dnbCompanyList, function(compObj) {
            var confidenceCode = compObj.confidenceCode,
                matchMeta = {};
            if (confidenceCode >= 8) {
                matchMeta.confClass = 'label-success';
                matchMeta.confText = app.lang.get('LBL_DNB_HIGH_CONF');
            } else if (confidenceCode === 7 || confidenceCode === 6) {
                matchMeta.confClass = 'label-warning';
                matchMeta.confText = app.lang.get('LBL_DNB_MED_CONF');
            } else if (confidenceCode < 6) {
                matchMeta.confClass = 'label-important';
                matchMeta.confText = app.lang.get('LBL_DNB_LOW_CONF');
            }
            compObj.matchMeta = matchMeta;
        },this);
        return dnbCompanyList;
    },

    /**
     * Event handler for pagination controls
     */
    invokePagination: function() {
        if (!_.isUndefined(this.currentPage[0].confidenceCode)) {
            //invoking client side pagination alone for cleanse match
            this._super('invokePagination', [null, null, this.renderCompanyList]);
        } else {
            //invoking client and server side pagination for account search
            this._super('invokePagination', [this.baseAccountsBAL, this.balParams, this.renderCompanyList]);
        }

    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordView
 * @alias SUGAR.App.view.views.BaseRecordView
 * @extends View.View
 */
({
	// Record View (base) 

    inlineEditMode: false,

    createMode: false,

    plugins: [
        'SugarLogic',
        'ErrorDecoration',
        'GridBuilder',
        'Editable',
        'Audit',
        'FindDuplicates',
        'ToggleMoreLess',
        'Tooltip'
    ],

    enableHeaderButtons: true,

    enableHeaderPane: true,

    events: {
        'click .record-edit-link-wrapper': 'handleEdit',
        'click a[name=cancel_button]': '_deprecatedCancelClicked',
        'click [data-action=scroll]': 'paginateRecord',
        'click .record-panel-header': 'togglePanel',
        'click #recordTab > .tab > a:not(.dropdown-toggle)': 'setActiveTab',
        'click .tab .dropdown-menu a': 'triggerNavTab'
    },

    /**
     * Button fields defined in view definition.
     */
    buttons: null,

    /**
     * Button states.
     */
    STATE: {
        EDIT: 'edit',
        VIEW: 'view'
    },

    // current button states
    currentState: null,

    // fields that should not be editable
    noEditFields: null,

    // width of the layout that contains this view
    _containerWidth: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        _.bindAll(this);
        /**
         * @inheritdoc
         * @property {Object} meta
         * @property {boolean} meta.hashSync Set to `true` to update URL
         *   consistently with the view state (`edit` or `detail`)
         */
        options.meta = _.extend({}, app.metadata.getView(null, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        app.view.View.prototype.initialize.call(this, options);
        this.buttons = {};

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };
        this.createMode = this.context.get('create') ? true : false;

        // Even in createMode we want it to start in detail so that we, later, respect
        // this.editableFields (the list after pruning out readonly fields, etc.)
        this.action = 'detail';

        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        //Set the context to load the field list from the record metadata.
        this.context.set('dataView', 'record');
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        // displays error msg when required field is missing
        this.model.on('error:validation', this.alerts.showInvalidModel, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.model.on('acl:change', this.handleAclChange, this);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        this.delegateButtonEvents();

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);

        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);

        $(window).on('resize.' + this.cid, this.overflowTabs);

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
        });

        this.on('render', this.registerShortcuts, this);
    },

    /**
     * Handler for when the ACLs change on the model. Toggles the `hide` class
     * on the pencil wrapper for each of the fields on this view that had ACL
     * changes.
     *
     * @param {Object} diff The diff object of fields and whether or not they
     *   had ACL changes.
     */
    handleAclChange: function(diff) {
        var fields = _.keys(diff);

        this._setNoEditFields();
        this.setEditableFields();

        var noEditFieldsMap = _.object(this.noEditFields, _.values(this.noEditFields));
        var $pencils = this.$('[data-wrapper=edit]');

        _.each($pencils, function(pencilEl) {
            var $pencilEl = $(pencilEl);
            var field = $pencilEl.data('name');

            if (!diff[field]) {
                return;
            }

            var hidePencil = !_.isUndefined(noEditFieldsMap[field]);
            $pencilEl.toggleClass('hide', hidePencil);
        }, this);
    },

    /**
     * Compare with last fetched data and return true if model contains changes.
     *
     * Check changes for fields that are editable only.
     *
     * {@link app.plugins.view.editable}
     *
     * @return {Boolean} `true` if current model contains unsaved changes, otherwise `false`.
     */
    hasUnsavedChanges: function() {
        var changedAttributes,
            editableFieldNames = [],
            unsavedFields,
            self = this,
            setAsEditable = function(fieldName) {
                if (fieldName && _.indexOf(self.noEditFields, fieldName) === -1) {
                    editableFieldNames.push(fieldName);
                }
            };

        if (this.resavingAfterMetadataSync)
            return false;

        changedAttributes = this.model.changedAttributes(this.model.getSynced());

        if (_.isEmpty(changedAttributes)) {
            return false;
        }

        // get names of all editable fields on the page including fields in a fieldset
        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (!field.readonly) {
                    setAsEditable(field.name);
                    if (field.fields && _.isArray(field.fields)) {
                        _.each(field.fields, function(field) {
                            setAsEditable(field.name);
                        });
                    }
                }
            });
        });

        // check whether the changed attributes are among the editable fields
        unsavedFields = _.intersection(_.keys(changedAttributes), editableFieldNames);

        return !_.isEmpty(unsavedFields);
    },

    /**
     * Called when current record is being duplicated to allow customization of
     * fields that will be copied into new record.
     *
     * Override to setup the fields on this bean prior to being displayed in
     * Create dialog.
     *
     * @param {Object} prefill Bean that will be used for new record.
     * @template
     */
    setupDuplicateFields: function(prefill) {
    },

    setLabel: function(context, value) {
        this.$('.record-label[data-name="' + value.field + '"]').text(value.label);
    },

    /**
     * Called each time a validation pass is completed on the model.
     *
     * Enables the action button and calls {@link #handleSave} if the model is
     * valid.
     *
     * @param {boolean} isValid TRUE if model is valid.
     */
    validationComplete: function(isValid) {
        this.toggleButtons(true);
        if (isValid) {
            this.handleSave();
        }
    },

    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);
        this.context.on('button:save_button:click', this.saveClicked, this);
        this.context.on('button:delete_button:click', this.deleteClicked, this);
        this.context.on('button:duplicate_button:click', this.duplicateClicked, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
    },

    _render: function() {
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        if (this.meta && this.meta.panels) {
            this._initTabsAndPanels();
        }

        app.view.View.prototype._render.call(this);

        if (this.context.get('record_label')) {
            this.setLabel(this.context, this.context.get('record_label'));
        }

        // Field labels in headerpane should be hidden on view but displayed in edit and create
        _.each(this.fields, function(field) {
            // some fields like 'favorite' is readonly by default, so we need to remove edit-link-wrapper
            if (field.def.readonly && field.name && -1 == _.indexOf(this.noEditFields, field.name)) {
                this.$('.record-edit-link-wrapper[data-name=' + field.name + ']').remove();
            }
        }, this);

        this.initButtons();
        this.setEditableFields();

        if (this.context.get('action') === 'edit') {
            this.setButtonStates(this.STATE.EDIT);
            this.toggleEdit(true);
        } else {
            this.setButtonStates(this.STATE.VIEW);
            if (this.createMode) {
                // RecordView starts with action as detail; once this.editableFields has been set (e.g.
                // readonly's pruned out), we can call toggleEdit - so only fields that should be are editable
                this.toggleEdit(true);
            }
        }

        // initialize tab view only if the component is attached to DOM,
        // otherwise it's initialized partially and cannot be properly
        // re-initialized after the component is attached to DOM
        if ($.contains(document.documentElement, this.$el[0])) {
            this.handleActiveTab();
            this.overflowTabs();
        }
    },

    /**
     * Handles initiation of Tabs and Panels view upon render
     * @private
     */
    _initTabsAndPanels: function() {
        this.meta.firstPanelIsTab = this.checkFirstPanel();
        this.meta.lastPanelIndex = this.meta.panels.length - 1;

        _.each(this.meta.panels, function(panel, i) {
            if (panel.header) {
                this.meta.firstNonHeaderPanelIndex = (i + 1);
            }
        }, this);

        // Tell the view to use Tabs and Panels view if either there exists a tab or if the number of panels isn't
        // equivalent to the amount expected for Business Card view (2 panels + possibly 1 if header exists)
        var headerExists = 0;
        if (_.first(this.meta.panels).header) {
            headerExists = 1;
        }

        this.meta.useTabsAndPanels = false;

        //Check if there are any newTabs
        for (i = headerExists; i < this.meta.panels.length; i++) {
            if (this.meta.panels[i].newTab) {
                this.meta.useTabsAndPanels = true;
            }
        }

        //Check for panel number
        if (this.meta.panels.length > (2 + headerExists)) {
            this.meta.useTabsAndPanels = true;
        }

        // set states
        _.each(this.meta.panels, function(panel){
            var panelKey = app.user.lastState.key(panel.name+':tabState', this);
            var panelState = app.user.lastState.get(panelKey);
            panel.panelState = panelState || panel.panelDefault;
        }, this);
    },
    /**
     * handles setting active tab
     */
    handleActiveTab: function() {
        var activeTabHref = this.getActiveTab(),
            activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]');

        // Always show first tab if we're on the create view
        if (this.createMode) {
            this.$('#recordTab a:first').tab('show');
            return;
        }

        if (activeTabHref && activeTab) {
            activeTab.tab('show');
        } else if (this.meta.useTabsAndPanels && this.checkFirstPanel()) {
            // If tabs and no last state set, show first tab on render
            this.$('#recordTab a:first').tab('show');
        }
    },
    /**
     * Gets the active tab in the user last state
     * @return {String} The active tab id in the user's last state.
     */
    getActiveTab: function() {
        var activeTabHref = app.user.lastState.get(app.user.lastState.key('activeTab', this));

        // Set to first tab by default
        if (!activeTabHref) {
            activeTabHref = this.$('#recordTab > .tab:first-child > a').attr('href') || '';
            app.user.lastState.set(
                app.user.lastState.key('activeTab', this),
                activeTabHref.substring(0, activeTabHref.indexOf(this.cid))
            );
        }
        else {
            activeTabHref += this.cid;
        }
        return activeTabHref;
    },
    /**
     * sets active tab in user last state
     * @param {Event} event
     */
    setActiveTab: function(event) {
        if (this.createMode) {
            return;
        }
        var tabTarget = this.$(event.currentTarget).attr('href'),
            tabKey = app.user.lastState.key('activeTab', this),
            cidIndex = tabTarget.indexOf(this.cid);

        tabTarget = tabTarget.substring(0, cidIndex);
        app.user.lastState.set(tabKey, tabTarget);
    },
    /**
     * saves panel state in user last state
     * @param {String} panelID
     * @param {String} state
     */
    savePanelState: function(panelID, state) {
        if (this.createMode) {
            return;
        }
        var panelKey = app.user.lastState.key(panelID+':tabState', this);
        app.user.lastState.set(panelKey, state);
    },

    /**
     * Parses through an array of panels metadata and sets some of them
     * as no edit fields.
     *
     * FIXME: SC-3940, remove this call to _setNoEditFields when we merge
     * master_platform into master, as this was fixed by SC-3908.
     *
     * @param {Array} [panels] The panels to parse. This default to
     *   `this.meta.panels`.
     * @private
     */
    _setNoEditFields: function(panels) {
        panels = panels || this.meta.panels;

        delete this.noEditFields;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            _.each(panel.fields, function(field, index) {
                var keys = _.keys(field);
                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.type === 'fieldset') {
                    if (field.readonly || _.every(field.fields, function(f) {
                        return !app.acl.hasAccessToModel('edit', this.model, f.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);
        }, this);
    },

    /**
     * sets editable fields
     */
    setEditableFields: function() {
        delete this.editableFields;
        this.editableFields = [];

        var previousField, firstField;
        _.each(this.fields, function(field) {

            var readonlyField = field.def.readonly ||
                _.indexOf(this.noEditFields, field.def.name) >= 0 ||
                field.parent || (field.name && this.buttons[field.name]);

            if (readonlyField) {
                // exclude read only fields
                return;
            }
            if (previousField) {
                previousField.nextField = field;
                field.prevField = previousField;
            } else {
                firstField = field;
            }
            previousField = field;
            this.editableFields.push(field);

        }, this);

        if (previousField) {
            previousField.nextField = firstField;
            firstField.prevField = previousField;
        }
    },

    initButtons: function() {
        if (this.options.meta && this.options.meta.buttons) {
            _.each(this.options.meta.buttons, function(button) {
                this.registerFieldAsButton(button.name);
            }, this);
        }
    },
    showPreviousNextBtnGroup: function() {
        var listCollection = this.context.get('listCollection') || new app.data.createBeanCollection(this.module);
        var recordIndex = listCollection.indexOf(listCollection.get(this.model.id));
        if (listCollection && listCollection.models && listCollection.models.length <= 1) {
            this.showPrevNextBtnGroup = false;
        } else {
            this.showPrevNextBtnGroup = true;
        }
        if (this.collection && listCollection.length !== 0) {
            this.showPrevious = listCollection.hasPreviousModel(this.model);
            this.showNext = listCollection.hasNextModel(this.model);
        }
    },

    registerFieldAsButton: function(buttonName) {
        var button = this.getField(buttonName);
        if (button) {
            this.buttons[buttonName] = button;
        }
    },

    _renderHtml: function() {
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
        this.adjustHeaderpane();
    },

    bindDataChange: function() {
        this.model.on('change', function(fieldType) {
            if (this.inlineEditMode) {
                this.setButtonStates(this.STATE.EDIT);
            }
            if (this.model.isNotEmpty !== true && fieldType !== 'image') {
                this.model.isNotEmpty = true;
                if (!this.disposed) {
                    this.render();
                }
            }
        }, this);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            var showOn = button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
    },

    duplicateClicked: function() {
        var self = this,
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);
        this._copyNestedCollections(this.model, prefill);
        self.model.trigger('duplicate:before', prefill);
        prefill.unset('id');
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                copiedFromModelId: this.model.get('id')
            }
        }, function(context, newModel) {
            if (newModel && newModel.id) {
                app.router.navigate(self.model.module + '/' + newModel.id, {trigger: true});
            }
        });

        prefill.trigger('duplicate:field', self.model);
    },

    /**
     * Clones the attributes that are collections by way of the
     * {@link VirtualCollection} plugin.
     *
     * This guarantees that all related models in nested collection are copied
     * instead of only the ones that have already been fetched.
     *
     * All models of the collection on the source model are fetched
     * asynchronously and then added to the same collection on the target model
     * once there are no more models to retrieve. Note that this leaves open
     * the possibility for a race condition where the user clicks the Save
     * button on the Create View before all models have been received.
     *
     * @param {Data.Bean} source
     * @param {Data.Bean} target
     * @private
     */
    _copyNestedCollections: function(source, target) {
        var collections, view;

        // only model's that utilize the VirtualCollection plugin support this
        // functionality
        if (!_.isFunction(source.getCollectionFieldNames)) {
            return;
        }

        // avoid using the ambiguous `this` since there are references to many
        // objects in this method: view, field, model, collection, source,
        // target, etc.
        view = this;

        /**
         * Removes the `_action` attribute from a model when cloning it.
         *
         * @param {Data.Bean} model
         * @return {Data.Bean}
         */
        function cloneModel(model) {
            var attributes = _.chain(model.attributes).clone().omit('_action').value();
            return app.data.createBean(model.module, attributes);
        }

        /**
         * Copies all of the models from a collection to the same collection on
         * the target model.
         *
         * @param collection
         */
        function copyCollection(collection) {
            var field, relatedFields, options;

            /**
             * Adds all of the records from the source collection to the same
             * collection on the target model.
             *
             * @param {VirtualCollection} sourceCollection
             * @param {Object} [options]
             */
            function done(sourceCollection, options) {
                var targetCollection = target.get(collection.fieldName);

                if (!targetCollection) {
                    return;
                }

                targetCollection.add(sourceCollection.map(cloneModel));
            }

            field = view.getField(collection.fieldName, source);
            relatedFields = [];

            if (field.def.fields) {
                relatedFields = _.map(field.def.fields, function(def) {
                    return _.isObject(def) ? def.name : def;
                });
            }

            options = {success: done};

            // request the related fields from the field definition if possible
            if (relatedFields.length > 0) {
                options.fields = relatedFields;
            }

            collection.fetchAll(options);
        }

        // get all attributes from the source model that are collections
        collections = _.intersection(source.getCollectionFieldNames(), _.keys(source.attributes));

        _.each(collections, function(name) {
            copyCollection(source.get(name));
        });
    },

    editClicked: function() {
        this.setButtonStates(this.STATE.EDIT);
        this.toggleEdit(true);
        this.setRoute('edit');
    },

    saveClicked: function() {
        // Disable the action buttons.
        this.toggleButtons(false);
        var allFields = this.getFields(this.module, this.model);
        var fieldsToValidate = {};
        for (var fieldKey in allFields) {
            if (app.acl.hasAccessToModel('edit', this.model, fieldKey)) {
                _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
            }
        }
        this.model.doValidate(fieldsToValidate, _.bind(this.validationComplete, this));
    },

    /**
     * Handles when the cancel_button view event is triggered.
     *
     * FIXME: This method will be removed as part of BR-3945
     *
     * @private
     *
     * @deprecated Since 7.7. Will be removed in 7.9.
     *   Use the `MetadataEventDriven` plugin events from the
     *   `record.php` button metadata instead.
     */
    _deprecatedCancelClicked: function() {
        var cancelBtn = this.getField('cancel_button');
        if (!cancelBtn || !cancelBtn.def || !cancelBtn.def.events) {
            app.logger.warn(this.module + ': Invoking the cancel_button from `this.events` has been deprecated' +
                ' since 7.7. This handler will be removed in 7.9. Please use the `MetadataEventDriven` plugin' +
                ' events from the \'record.php\' button metadata instead.');
            this.cancelClicked.apply(this, arguments);
        }
    },

    cancelClicked: function() {
        this.handleCancel();
        this.setButtonStates(this.STATE.VIEW);
        this.clearValidationErrors(this.editableFields);
        this.setRoute();
        this.unsetContextAction();
    },

    deleteClicked: function(model) {
        this.warnDelete(model);
    },

    /**
     * Render fields into either edit or view mode.
     *
     * @param {Boolean} isEdit `true` to set the field in edit mode, `false`
     *   otherwise.
     */
    toggleEdit: function(isEdit) {
        var self = this;
        this.toggleFields(this.editableFields, isEdit, function() {
            self.toggleViewButtons(isEdit);
            self.adjustHeaderpaneFields();
        });
    },

    /**
     * Handler for intent to edit. This handler is called both as a callback
     * from click events, and also triggered as part of tab focus event.
     *
     * @param {Event} e Event object (should be click event).
     * @param {jQuery} cell A jQuery node cell of the target node to edit.
     */
    handleEdit: function(e, cell) {
        var target,
            cellData,
            field;

        if (e) { // If result of click event, extract target and cell.
            target = this.$(e.target);
            cell = target.parents('.record-cell');
        }

        cellData = cell.data();
        field = this.getField(cellData.name);

        // Set Editing mode to on.
        this.inlineEditMode = true;

        this.setButtonStates(this.STATE.EDIT);

        this.toggleField(field);

        if (cell.closest('.headerpane').length > 0) {
            this.toggleViewButtons(true);
            this.adjustHeaderpaneFields();
        }
    },

    /**
     * Hide view specific button during edit.
     *
     * @param {Boolean} isEdit `true` to hide some specific buttons, `false`
     *   otherwise.
     *
     * FIXME this should be done in a more generic way (field or metadata
     * property).
     */
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    handleSave: function() {
        if (this.disposed) {
            return;
        }
        this._saveModel();
        this.$('.record-save-prompt').hide();

        if (!this.disposed) {
            this.setButtonStates(this.STATE.VIEW);
            this.setRoute();
            this.unsetContextAction();
            this.toggleEdit(false);
            this.inlineEditMode = false;
        }
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                // Loop through the visible subpanels and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    if (child.get('isSubpanel') && !child.get('hidden')) {
                        child.get('collapsed') ? child.resetLoadFlag(false) : child.reloadData({recursive: false});
                    }
                });
                if (this.createMode) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed && !app.acl.hasAccessToModel('edit', this.model)) {
                    //re-render the view if the user does not have edit access after save.
                    this.render();
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else if (error.status === 403 || error.status === 404) {
                    this.alerts.showNoAccessError.call(this);
                } else {
                    this.editClicked();
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    handleMetadataSyncError: function(error) {
        var self = this;
        //On a metadata sync error, retry the save after the app is synced
        self.resavingAfterMetadataSync = true;
        app.once('app:sync:complete', function() {
            error.request.metadataRetry = true;
            self.model.once('sync', function() {
                self.resavingAfterMetadataSync = false;
                //self.model.changed = {};
                app.router.refresh();
            });
            //add a new success callback to refresh the page after the save completes
            error.request.execute(null, app.api.getMetadataHash());
        });
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    handleCancel: function() {
        this.model.revertAttributes();
        this.toggleEdit(false);
        this.inlineEditMode = false;
        this._dismissAllAlerts();
    },

    /**
     * Pre-event handler before current router is changed.
     *
     * @return {Boolean} `true` to continue routing, `false` otherwise.
     */
    beforeRouteDelete: function() {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages().confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = false;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} The message to be displayed in the browser dialog.
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages().confirmation;
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this;

        self.model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages().success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;

                self.context.trigger('record:deleted', self._modelToDelete);

                self._modelToDelete = false;

                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                app.router.navigate(self.module, {trigger: true});
            }
        });

    },

    /**
     * Key handlers for inline edit mode.
     *
     * Jump into the next or prev target field if `tab` key is pressed.
     * Calls {@link app.plugins.Editable#nextField} to go to next/prev field.
     *
     * @param {Event} e Event object.
     * @param {View.Field} field Current focused field (field in inline-edit mode).
     */
    handleKeyDown: function(e, field) {
        var whichField = e.shiftKey ? 'prevField' : 'nextField';

        if (e.which === 9) { // If tab
            e.preventDefault();
            this.nextField(field, whichField);
            if (field.$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(false);
                this.adjustHeaderpaneFields();
            }
            if (field[whichField] && field[whichField].$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(true);
                this.adjustHeaderpaneFields();
            }
        }
    },

    /**
     * Adjust headerpane fields when they change to view mode
     */
    handleMouseDown: function() {
        this.toggleViewButtons(false);
        this.adjustHeaderpaneFields();
    },

    /**
     * Handles a field validation error for record views.
     * @param field
     * @param {Boolean} hasError True if a field has an error, false if the field is clearing it's error state
     */
    handleFieldError: function(field, hasError) {
        if(!hasError) {
            return;
        }

        var tabLink,
            fieldTab   = field.$el.closest('.tab-pane'),
            fieldPanel = field.$el.closest('.record-panel-content');

        if (field.view.meta && field.view.meta.useTabsAndPanels) {
            // If field's panel is a tab, switch to the tab that contains the field with the error
            if (fieldTab.length > 0) {
                tabLink = this.$('[href="#'+fieldTab.attr('id')+'"].[data-toggle="tab"]');
                tabLink.tab('show');
                // Put a ! next to the tab if one doesn't already exist
                if (tabLink.find('.fa-exclamation-circle').length === 0) {
                    tabLink.append(' <i class="fa fa-exclamation-circle tab-warning"></i>');
                }
            }

            // If field's panel is a panel that is closed, open it and change arrow
            if (fieldPanel && fieldPanel.is(':hidden')) {
                fieldPanel.toggle();
                var fieldPanelArrow = fieldPanel.prev().find('i');
                fieldPanelArrow.toggleClass('fa-chevron-up fa-chevron-down');
            }
        } else if (field.$el.is(':hidden')) {
            this.$('.more[data-moreless]').trigger('click');
            app.user.lastState.set(this.SHOW_MORE_KEY, this.$('.less[data-moreless]'));
        }
        else if (field.$el.closest('.panel_hidden.hide').length > 0) {
            this.toggleMoreLess(this.MORE_LESS_STATUS.MORE, true);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {String} state The {@link #STATE} of the current view.
     */
    setButtonStates: function(state) {
        this.currentState = state;

        _.each(this.buttons, function(field) {
            var showOn = field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        }, this);

        this.toggleButtons(true);
    },

    /**
     * Get the current button state.
     * @return {string} The current button state
     */
    getCurrentButtonState: function() {
        return this.currentState;
    },

    /**
     * Set the title in the header pane.
     *
     * @param {String} title The new title to set on the headerpane.
     *
     * FIXME this should be done with the header pane view + re-render it.
     */
    setTitle: function(title) {
        var $title = this.$('.headerpane .module-title');
        if ($title.length > 0) {
            $title.text(title);
        } else {
            this.$('.headerpane h1').prepend('<div class="record-cell"><span class="module-title">' + title + '</span></div>');
        }
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore('route', this.beforeRouteDelete, this);
        $(window).off('beforeunload.delete' + this.cid);
    },

    _dispose: function() {
        this.unbindBeforeRouteDelete();
        _.each(this.editableFields, function(field) {
            field.nextField = null;
            field.prevField = null;
        });
        this.buttons = null;
        this.editableFields = null;
        this.off('editable:keydown', this.handleKeyDown, this);
        $(window).off('resize.' + this.cid);
        app.view.View.prototype._dispose.call(this);
    },

    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.type === 'fieldset') {
                    if (field.readonly || _.every(field.fields, function(field) {
                        return !app.acl.hasAccessToModel('edit', this.model, field.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },

    /**
     * Handles click event on next/previous button of record.
     * @param {Event} evt
     */
    paginateRecord: function(evt) {
        var el = $(evt.currentTarget),
            data = el.data();
        if (data.id) {
            var list = this.context.get('listCollection'),
                model = list.get(data.id);
            this._doPaginate(model, data.actionType);
        }
    },
    /**
     * paginates record view depeding on direction and model
     * @param {Object} model
     * @param {String} actionType
     * @private
     */
    _doPaginate: function(model, actionType) {
        var list = this.context.get('listCollection');
        switch (actionType) {
            case 'next':
                list.getNext(model, this.navigateModel);
                break;
            case 'prev':
                list.getPrev(model, this.navigateModel);
                break;
            default:
                this._disablePagination(el);
        }
    },
    /**
     * Callback for navigate to new model.
     *
     * @param {Data.Bean} model model New model to navigate.
     * @param {String} actionType actionType Side of navigation (prev/next).
     */
    navigateModel: function(model, actionType) {
        if (model && model.id) {
            if (app.acl.hasAccessToModel('view', model)) {
                app.router.navigate(app.router.buildRoute(this.module, model.id), {trigger: true});
            } else {
                this._doPaginate(model, actionType);
            }
        } else {
            var el = this.$el.find('[data-action=scroll][data-action-type=' + actionType + ']');
            this._disablePagination(el);
        }
    },

    /**
     * Updates url without triggering the router.
     *
     * @param {string} action Action to pass when building the route
     *   with {@link Core.Router#buildRoute}.
     */
    setRoute: function(action) {
        if (!this.meta.hashSync) {
            return;
        }
        app.router.navigate(app.router.buildRoute(this.module, this.model.id, action), {trigger: false});
    },

    /**
     * Unsets the `action` attribute from the current context.
     *
     * Once 'action' is unset, the action is 'detail' and the view will render
     * next in detail mode.
     */
    unsetContextAction: function() {
            this.context.unset('action');
    },

    /**
     * Disabling pagination if we can't paginate.
     * @param {Object} el Element to disable pagination on.
     */
    _disablePagination: function(el) {
        app.logger.error('Wrong data for record pagination. Pagination is disabled.');
        el.addClass('disabled');
        el.data('id', '');
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis
     */
    adjustHeaderpane: function() {
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {Number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return 0;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell,
            ellipsisCellWidth,
            $recordCells;

        if (this.disposed) {
            return;
        }

        $recordCells = this.$('.headerpane h1').children('.record-cell, .btn-toolbar');

        if (($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }

        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url', 'dashboardtitle'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {Number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                         parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');

        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            width -= ellipsifiedCell.getCellPadding();
            ellipsifiedCell.setMaxWidth(width);
        } else {
            $ellipsisCell.children().css({'max-width': width});
        }
    },

    /**
     * Adds the favorite field to app.view.View.getFieldNames() if `favorite` field is within a panel
     * so my_favorite is part of the field list and is fetched
     */
    getFieldNames: function(module, onlyDataFields) {
        //Start with an empty set of fields since the view name in the request will load all fields from the metadata.
        var fields = onlyDataFields ? [ ] : this._super('getFieldNames', arguments),
            favorite = _.find(this.meta.panels, function(panel) {
                return _.find(panel.fields, function(field) {
                    return field.type === 'favorite';
                });
            }),
            follow = _.find(this.meta.panels, function(panel) {
                return _.find(panel.fields, function(field) {
                    return field.type === 'follow';
                });
            });
        if (favorite) {
            fields = _.union(fields, ['my_favorite']);
        }
        if (follow) {
            fields = _.union(fields, ['following']);
        }
        return fields;
    },

    /**
     * Hide or show panel based on click to the panel header
     * @param {Event} e
     */
    togglePanel: function(e) {
        var $panelHeader = this.$(e.currentTarget);
        if ($panelHeader && $panelHeader.next()) {
            $panelHeader.next().toggle();
            $panelHeader.toggleClass('panel-inactive panel-active');
        }
        if ($panelHeader && $panelHeader.find('i')) {
            $panelHeader.find('i').toggleClass('fa-chevron-up fa-chevron-down');
        }
        var panelName = this.$(e.currentTarget).parent().data('panelname');
        var state = 'collapsed';
        if (this.$(e.currentTarget).next().is(":visible")) {
            state = 'expanded';
        }
        this.savePanelState(panelName, state);
    },

    /**
     * Returns true if the first non-header panel has useTabs set to true
     */
    checkFirstPanel: function() {
        if (this.meta && this.meta.panels) {
            if (this.meta.panels[0] && this.meta.panels[0].newTab && !this.meta.panels[0].header) {
                return true;
            }
            if (this.meta.panels[1] && this.meta.panels[1].newTab) {
                return true;
            }
        }
        return false;
    },

    /**
     * Moves overflowing tabs into a dropdown
     */
    overflowTabs: function() {
        var $tabs = this.$('#recordTab > .tab:not(.dropdown)'),
            $dropdownList = this.$('#recordTab .dropdown'),
            $dropdownTabs = this.$('#recordTab .dropdown-menu li'),
            navWidth = this.$('#recordTab').width(),
            activeTabHref = this.getActiveTab(),
            $activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]').parent(),
            // Calculate available width for items in navbar
            // Includes the activetab to ensure it is displayed
            width = $activeTab.outerWidth() + $dropdownList.outerWidth();

        $tabs.each(_.bind(function (index, elem) {
            var $tab = $(elem),
                overflow;

            // Always include the active tab
            if ($tab.hasClass('active')) {
                overflow = false;
            }
            else {
                width += $tab.outerWidth();
                // Check if the tab fits in the navbar
                overflow = width >= navWidth;
            }

            // Toggle tabs in the navbar
            $tab.toggleClass('hidden', overflow);
            // Toggle items in the dropdown
            this.$($dropdownTabs[index]).toggleClass('hidden', !overflow);
        }, this));
        // Toggle the dropdown arrow
        $dropdownList.toggleClass('hidden', !$tabs.is(':hidden'));
    },

    /**
     * Takes a tab dropdown link and triggers the corresponding tab
     * @param {Event} e
     */
    triggerNavTab: function(e) {
        var tabTarget = e.currentTarget.hash,
            activeTab = this.$('#recordTab > .tab > a[href="'+tabTarget+'"]');

        e.preventDefault();
        activeTab.trigger('click');
        this.overflowTabs();
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        app.shortcuts.register('Record:Edit', ['e','ctrl+alt+i'], function() {
            var $editButton = this.$('.headerpane [name=edit_button]');
            if ($editButton.is(':visible') && !$editButton.hasClass('disabled')) {
                $editButton.click();
            }
        }, this);

        app.shortcuts.register('Record:Delete', ['d','ctrl+alt+d'], function() {
            this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
            this.$('.headerpane [name=delete_button]:visible').click();
        }, this);

        app.shortcuts.register('Record:Save', ['ctrl+s','ctrl+alt+a'], function() {
            var $saveButton = this.$('a[name=save_button]');
            if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                $saveButton.click();
            }
        }, this, true);

        app.shortcuts.register('Record:Cancel', ['esc','ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=cancel_button]');
            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.click();
            }
        }, this, true);

        app.shortcuts.register('Record:Previous', 'h', function() {
            var $previous = this.$('.btn.previous-row');
            if ($previous.is(':visible') && !$previous.hasClass('disabled')) {
                $previous.click();
            }
        }, this);

        app.shortcuts.register('Record:Next', 'l', function() {
            var $next = this.$('.btn.next-row');
            if ($next.is(':visible') && !$next.hasClass('disabled')) {
                $next.click();
            }
        }, this);

        app.shortcuts.register('Record:Favorite', 'f a', function() {
            this.$('.headerpane .fa-favorite:visible').click();
        }, this);

        app.shortcuts.register('Record:Follow', 'f o', function() {
            this.$('.headerpane [name=follow]:visible').click();
        }, this);

        app.shortcuts.register('Record:Copy', ['shift+c','ctrl+alt+u'], function() {
            this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
            this.$('.headerpane [name=duplicate_button]:visible').click();
        }, this);

        app.shortcuts.register('Record:Action:More', 'm', function() {
            var $primaryDropdown = this.$('.headerpane .btn-primary[data-toggle=dropdown]:visible');
            if (($primaryDropdown.length > 0) && !$primaryDropdown.hasClass('disabled')) {
                $primaryDropdown.click();
            }
        }, this);
    },

    /**
     * Dismisses all {@link #_viewAlerts alerts} defined in this view.
     *
     * @protected
     */
    _dismissAllAlerts: function() {
        if (_.isEmpty(this._viewAlerts)) {
            return;
        }
        _.each(_.uniq(this._viewAlerts), function(alert) {
            app.alert.dismiss(alert);
        });
        this._viewAlerts = [];
    }
}) },
"saved-reports-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SavedReportsChartView
 * @alias SUGAR.App.view.views.BaseSavedReportsChartView
 * @extends View.View
 */
({
	// Saved-reports-chart View (base) 

    plugins: ['Dashlet'],

    events: {
        'click a[name=editReport]': 'editSavedReport'
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        // check if we're on the config screen
        if (this.meta.config) {
            this.meta.panels = this.dashletConfig.dashlet_config_panels;
            this.getAllSavedReports();
        } else {
            var autoRefresh = this.settings.get('auto_refresh');
            if (autoRefresh > 0) {
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }

                this._scheduleReload(autoRefresh * 1000 * 60);
            }
        }
    },

    /**
     * Schedules chart data reload
     *
     * @param {Number} delay Number of milliseconds which the reload should be delayed for
     * @private
     */
    _scheduleReload: function(delay) {
        this.timerId = setTimeout(_.bind(function() {
            this.context.resetLoadFlag();
            this.loadData({
                success: function() {
                    this._scheduleReload(delay);
                }
            });
        }, this), delay);
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Holds report data from the server's endpoint once we fetch it
        this.reportData = new Backbone.Model();
        this.reportOptions = [];
        this._super('initialize', [options]);
    },

    /**
     * Route to the bwc edit view of the currently selected Saved Report. If User clicks 'save' or 'cancel' or 'delete'
     * from there, return the user to the current page.
     */
    editSavedReport: function() {
        var currentTargetId = this.dashModel.get('saved_report_id'),
            params = {
                dashletEdit: 1
            },
            route = app.bwc.buildRoute('Reports', currentTargetId, 'ReportsWizard', params);

        //If this button was clicked too early, the saved_report_id may not be populated. Then we want to return
        //because moving on will result in a php error
        if (!currentTargetId) {
            return;
        }
        app.alert.show('navigate_confirmation', {
            level: 'confirmation',
            messages: 'LBL_NAVIGATE_TO_REPORTS',
            onConfirm: _.bind(function() {
                //Save current location to this so we can use it in the event listener
                this.currentLocation = Backbone.history.getFragment();

                //Add event listener for when the user finishes up the edit
                $(window).one('dashletEdit', _.bind(this.postEditListener, this));

                //Once we've successfully routed to the dashletEdit location,
                //any successive route should be checked. If the user moves away from the edit without
                //either cancelling or finishing the edit, we should forget that we have to come back to the current location
                var dashletEditVisited = false;
                app.router.on('route', function() {
                    var routeLocation = Backbone.history.getFragment();
                    if (routeLocation.indexOf('dashletEdit=1') >= 0) {
                        dashletEditVisited = true;
                    }
                    if (routeLocation.indexOf('dashletEdit=1') < 0 && dashletEditVisited) {
                        app.router.off('route');
                        $(window).off('dashletEdit');
                    }
                });

                //Go to edit page
                app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Call after the user is done editing the saved report. Return the user to the page that was stored when the
     * event was set
     *
     * @param {object} jquery event
     */
    postEditListener: function(event) {
        //Go back from whence we came
        if (this.currentLocation) {
            app.router.navigate(this.currentLocation, {trigger: true});
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config) {
            this.settings.on('change:saved_report_id', function(model) {
                var reportId = model.get('saved_report_id');

                if (_.isEmpty(reportId)) {
                    return;
                }

                this.getSavedReportById(reportId, {
                    success: _.bind(function(data) {
                        this.setChartParams(data, true);
                    }, this)
                });

                // show or hide 'Edit Selected Report' link
                this.updateEditLink(reportId);
            }, this);

            this.settings.on('change:chart_type', function(model) {
                // toggle display of chart display option controls based on chart type
                this._toggleChartFields();
            }, this);
        }
    },

    /**
     * Check acls to show/hide 'Edit Selected Report' link
     */
    updateEditLink: function(reportId) {
        var acls = this.reportAcls[reportId || this.settings.get('saved_report_id')],
            showEditLink = !acls || acls['edit'] !== 'no';
        this.$('[name="editReport"]').toggle(showEditLink);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        options = options || {};
        if (!_.isEmpty(this.settings.get('saved_report_id'))) {
            _.extend(options, {
                success: _.bind(function(data) {
                    this.setChartParams(data, false);
                }, this)
            });
            this.getSavedReportById(this.settings.get('saved_report_id'), options);
        }
    },

    getDefaultSettings: function() {
        // By default, settings only has: label, type, config, module
        // Module is normally null so we want to rehit that
        var settings = _.clone(this.settings.attributes),
            defaults = {
                module:          this.layout.module,
                auto_refresh:    0,
                show_title:      false,
                show_y_label:    false,
                y_axis_label:    '',
                show_x_label:    false,
                x_axis_label:    '',
                allowScroll:     true,
                showValues:      0,
                hideEmptyGroups: true,
                wrapTicks:       true,
                staggerTicks:    true,
                rotateTicks:     true
            };
        return _.defaults(settings, defaults);
    },

    /**
     * Process the chart data from the server
     *
     * @param {Object|String} serverData The Report Data from the server
     * @param {Boolean} [update] Is this an update to the report?
     */
    setChartParams: function(serverData, update) {
        // only called by bindDataChange when the report id is changed in config panel
        if (!serverData.reportData || !serverData.chartData) {
            if (!this.meta.config && this.chartField) {
                this.chartField.displayNoData(true);
            }
            return;
        }
        update = _.isUndefined(update) ? false : update;

        var data = serverData.reportData,
            properties = serverData.chartData.properties[0],
            config = this.getChartConfig(properties.type),
            params = this.getDefaultSettings(),
            defaults = {
                label: data.name,
                chart_type: config.chartType || properties.type,
                report_title: properties.title,
                show_legend: properties.legend === 'on' ? true : false,
                stacked: config.barType === 'stacked' || config.barType === 'basic' ? true : false,
                x_axis_label: this._getXaxisLabel(data),
                y_axis_label: this._getYaxisLabel(data)
            };

        // override settings when new report is selected
        if (update) {
            _.extend(params, defaults);
        } else {
            _.defaults(params, defaults);
        }

        // persist the chart settings for use by SugarCharts
        this.reportData.set({
            rawChartParams: params
        });

        // update the settings model for use by chart field
        this.settings.set(params);

        // toggle display of chart display option controls based on chart type
        this._toggleChartFields();

        // set the title of the dashlet to the report title
        this.$('[name="label"]').val(this.settings.get('label'));
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartType) {
        var chartConfig;

        switch (chartType) {
            case 'pie chart':
                chartConfig = {
                    chartType: 'pie chart'
                };
                break;

            case 'line chart':
                chartConfig = {
                    chartType: 'line chart'
                };
                break;

            case 'funnel chart 3D':
                chartConfig = {
                    chartType: 'funnel chart'
                };
                break;

            case 'gauge chart':
                chartConfig = {
                    chartType: 'gauge chart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'group by chart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'group by chart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'bar chart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'horizontal group by chart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'horizontal bar chart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'bar chart'
                };
                break;
        }

        return chartConfig;
    },

    /**
     * Returns the x-axis label based on report data
     * @return {String}
     */
    _getXaxisLabel: function(data) {
        var label = '';
        if (data && data.group_defs) {
            label = _.first(data.group_defs).label;
        }
        return label;
    },

    /**
     * Returns the y-axis label based on report data
     * @return {String}
     */
    _getYaxisLabel: function(data) {
        var label = '';
        if (data && data.summary_columns) {
            _.each(data.summary_columns, function(column) {
                if (!_.isUndefined(column.group_function)) {
                    label = column.label;
                }
            });
        }
        return label;
    },

    /**
     * Makes a call to Reports/saved_reports to get any items stored in the saved_reports table
     */
    getAllSavedReports: function() {
        var params = {
                has_charts: true
            },
            url = app.api.buildURL('Reports/saved_reports', null, null, params);

        app.api.call('read', url, null, {
            success: _.bind(this.parseAllSavedReports, this)
        });
    },

    /**
     * Parses items passed back from Reports/saved_reports endpoint into enum options
     *
     * @param {Array} reports an array of saved reports returned from the endpoint
     */
    parseAllSavedReports: function(reports) {
        this.reportOptions = {};
        this.reportAcls = {};

        _.each(reports, function(report) {
            // build the reportOptions key/value pairs
            this.reportOptions[report.id] = report.name;
            this.reportAcls[report.id] = report._acl;
        }, this);

        // find the saved_report_id field
        var reportsField = _.find(this.fields, function(field) {
            return field.name == 'saved_report_id';
        });

        if (reportsField) {
            // set the initial saved_report_id to the first report in the list
            // if there are reports to show and we have not already saved this
            // dashlet yet with a report ID
            if (reports && (!this.settings.has('saved_report_id') || _.isEmpty(this.settings.get('saved_report_id')))) {
                this.settings.set('saved_report_id', _.first(reports).id);
            }

            // set field options and render
            reportsField.items = this.reportOptions;
            reportsField._render();

            // check acls to show or hide 'Edit Selected Report' link
            this.updateEditLink();
        }
    },

    /**
     * Makes a call to Reports/saved_reports/:id to fetch specific saved report data
     *
     * @param {String} reportId the ID for the report we're looking for
     */
    getSavedReportById: function(reportId, options) {
        var dt = this.layout.getComponent('dashlet-toolbar');
        if (dt) {
            // manually set the icon class to spiny
            this.$('[data-action=loading]').removeClass(dt.cssIconDefault).addClass(dt.cssIconRefresh);
        }

        app.api.call('create', app.api.buildURL('Reports/chart/' + reportId), {'ignore_datacheck': true}, {
            success: _.bind(function(serverData) {
                if (options && options.success) {
                    options.success.apply(this, arguments);
                }

                // set reportData's rawChartData to the chartData from the server
                // this will trigger chart.js' change:rawChartData and the chart will update
                this.reportData.set({
                    rawReportData: serverData.reportData,
                    rawChartData: serverData.chartData
                });
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // if we're in config, or if the chartField doesn't exist yet... render
        // otherwise do not render again as this destroys and re-draws the chart and looks awful
        if (this.meta.config || _.isUndefined(this.chartField)) {
            this._super('_render');
        }
    },

    /**
     * Handle the display of the chart display option controls based on chart type
     *
     * @private
     */
    _toggleChartFields: function() {
        if (this.meta.config) {

            var xOptionsFieldset = this.getField('x_label_options'),
                tickDisplayMethods = this.getField('tickDisplayMethods'),
                yOptionsFieldset = this.getField('y_label_options'),
                showValuesField = this.getField('showValues'),
                groupDisplayOptions = this.getField('groupDisplayOptions'),
                stackedField = this.getField('stacked'),
                showDimensionOptions = false,
                showBarOptions = false,
                showTickOptions = false,
                showStacked = false,
                xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL'),
                yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');

            switch (this.settings.get('chart_type')) {
                case 'pie chart':
                case 'gauge chart':
                case 'funnel chart 3D':
                    showDimensionOptions = false;
                    showBarOptions = false;
                    break;

                case 'line chart':
                    showDimensionOptions = true;
                    showBarOptions = false;
                    break;

                case 'stacked group by chart':
                case 'horizontal group by chart':
                case 'group by chart':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = true;
                    break;

                case 'vertical bar chart':
                case 'vertical':
                case 'bar chart':
                case 'horizontal bar chart':
                case 'horizontal':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = false;
                    break;

                default:
                    showDimensionOptions = false;
                    showBarOptions = false;
            }

            if (showDimensionOptions) {
                switch (this.settings.get('chart_type')) {
                    case 'horizontal group by chart':
                    case 'horizontal bar chart':
                    case 'horizontal':
                        showTickOptions = false;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        break;
                    case 'line chart':
                        showTickOptions = false;
                        break;
                    default:
                        showTickOptions = true;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                }
            }

            if (xOptionsFieldset) {
                xOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
                xOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(xOptionsLabel);
                yOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(yOptionsLabel);
            }
            if (tickDisplayMethods) {
                tickDisplayMethods.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions || !showTickOptions);
                tickDisplayMethods.$el.find('.disabled').find('input').prop( 'checked', true ).prop('disabled', true);
            }

            if (yOptionsFieldset) {
                yOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
            }

            if (showValuesField) {
                showValuesField.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
            }
            if (groupDisplayOptions) {
                groupDisplayOptions.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
                if (stackedField) {
                    stackedField.$el.toggleClass('hide', !showStacked);
                }
            }

        }
    },

    /**
     * Handle the conditional display of settings input field based on checkbox toggle state
     *
     * @param {Object} toggle a checkbox control that determines display state of field
     * @param {Object} dependent the input field that holds the setting value
     * @private
     */
    _toggleDepedent: function(toggle, dependent) {
        var inputField = dependent.$el.find(dependent.fieldTag),
            enabled = this.settings.get(toggle.name),
            value = enabled ? this.settings.get(dependent.name) : '';
        inputField
            .prop('disabled', !enabled)
            .val(value);
    },

    /**
     * @inheritdoc
     * When rendering fields, get a reference to the chart field if we don't have one yet
     */
    _renderField: function(field) {
        this._super('_renderField', [field]);

        // Manage display state of fieldsets with toggle
        if (this.meta.config) {

            if (!_.isUndefined(field.def.toggle)) {
                var toggle = this.getField(field.def.toggle),
                    dependent = this.getField(field.def.dependent);

                this._toggleDepedent(toggle, dependent);

                this.settings.on('change:' + toggle.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
                this.settings.on('change:' + dependent.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
            }
        }

        // hang on to a reference to the chart field
        if (_.isUndefined(this.chartField) && field.name === 'chart') {
            this.chartField = field;
        }
    }
}) },
"user-locale-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Locale wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserLocaleWizardPageView
 * @alias SUGAR.App.view.views.BaseUserLocaleWizardPageView
 * @extends View.Views.Base.UserWizardPageView
 */
({
	// User-locale-wizard-page View (base) 

    extendsFrom: "UserWizardPageView",
    TIME_ZONE_KEY: 'timezone',
    TIME_PREF_KEY: 'timepref',
    DATE_PREF_KEY: 'datepref',
    NAME_FORMAT_KEY: 'default_locale_name_format',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        var self = this;
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        // Preset the user prefs for formats
        if (this.model) {
            this.model.set(this.TIME_ZONE_KEY, (app.user.getPreference(this.TIME_ZONE_KEY) || ''));
            this.model.set(this.TIME_PREF_KEY, (app.user.getPreference(this.TIME_PREF_KEY) || ''));
            this.model.set(this.DATE_PREF_KEY, (app.user.getPreference(this.DATE_PREF_KEY) || ''));
            this.model.set(this.NAME_FORMAT_KEY, (app.user.getPreference(this.NAME_FORMAT_KEY) || ''));
        }
        this.action = 'edit';
    },

    _render: function(){
        var self = this;
        // Prepare the metadata so we can prefetch select2 locale options
        this._prepareFields(function() {
            if (!self.disposed) {
                self.fieldsToValidate = self._fieldsToValidate(self.meta);
                self._super("_render");
            }
        });
    },
    _prepareFields: function(callback) {
        var self = this;
        // Fixme this doesn't belong in user. See TY-526.
        app.user.loadLocale(function(localeOptions) {
            // Populate each field def of type enum with returned locale options and use user's pref as displayed
            _.each(self.meta.panels[0].fields, function(fieldDef) {
                var opts = localeOptions[fieldDef.name];
                if (opts) {
                    fieldDef.options = opts;
                }
            });
            callback();
        });
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and locale update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        this.getField("next_button").setDisabled(true);  //temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = this._prepareRequestPayload();
                    app.alert.show('wizardlocale', {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });
                    // 'ut' is, historically, a special flag in user's preferences that is
                    // generally marked truthy upon timezone getting saved. It's also used
                    // to semantically represent "is the user's instance configured"
                    payload['ut'] = true;
                    app.user.updatePreferences(payload, function(err) {
                        app.alert.dismiss('wizardlocale');
                        self.updateButtons();  //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard locale update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, this)
        );
    }

}) },
"sweetspot-searchbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotSearchbarView
 * @alias SUGAR.App.view.views.BaseSweetspotSearchbarView
 * @extends View.View
 */
({
	// Sweetspot-searchbar View (base) 

    className: 'sweetspot-searchbar',
    events: {
        'keyup input': 'keyUpHandler',
        'click [data-action=configure]': 'initConfig'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        app.events.on('app:sync:complete sweetspot:reset', this.initLibrary, this);
        this.lastTerm = '';

        this.layout.on('hide', function() {
            this.lastTerm = '';
        }, this);
    },

    initConfig: function(evt) {
        this.layout.toggle();
        this.layout.trigger('sweetspot:config');
    },

    /**
     * Initializes the libraries.
     *
     * - Adds all the mega menu actions to {@link #internalLibrary}.
     */
    initLibrary: function() {
        /**
         * Static library.
         *
         * Contains mega menu actions and system commands.
         *
         * @type {Array}
         */
        this.internalLibrary = [];

        /**
         * Temporary library.
         *
         * Contains records from the search API, but these are only kept for
         * 5 minutes (for better user experience).
         *
         * @type {Object}
         */
        this.temporaryLibrary = {};

        this.addToInternalLibrary(this.getSweetspotActions());

        this.internalLibrary = this._formatInternalLib();
    },

    /**
     * Formats the {@link #internalLibrary internal library} by parsing it to
     * remove duplicate results.
     *
     * @return {Array} The formatted library of actions/commands.
     */
    _formatInternalLib: function() {
        var lib = _.chain(this.internalLibrary)
            .map(function(item) {
                return JSON.stringify(item);
            })
            .uniq()
            .map(function(item) {
                return JSON.parse(item)
            })
            .value();

        return lib;
    },

    getSweetspotActions: function() {
        var actionsById = app.metadata.getSweetspotActions();
        var prefs = app.user.getPreference('sweetspot');
        var data = prefs && prefs.hotkeys;

        _.each(data, function(customSetting) {
            if (!actionsById[customSetting.action]) {
                return;
            }
            actionsById[customSetting.action].keyword = customSetting.keyword;
        });
        return _.flatten(actionsById);
    },

    /**
     * Adds some items to the {@link #internalLibrary}.
     *
     * @param {Array} items Items to add.
     */
    addToInternalLibrary: function(items) {
        this.internalLibrary = this.internalLibrary.concat(items);
    },

    /**
     * Adds some records to the {@link #temporaryLibrary}
     *
     * @param {Array} items Records to add.
     */
    addToTemporaryLibrary: function(items) {
        _.each(items, function(item) {
            this.temporaryLibrary[item.id] = item;
        }, this);
    },

    /**
     * Gets the records from the {@link #temporaryLibrary}.
     *
     * Records that are here for more than 5 minutes are removed.
     *
     * @return {Array} The list of records.
     */
    getTemporaryLibrary: function() {
        var now = new Date().getTime();
        var tooOld = now - 300000;
        var updatedLibrary = {};
        var recordList = [];
        _.each(this.temporaryLibrary, function(item) {
            if (item.timestamp > tooOld) {
                updatedLibrary[item.id] = item;
                recordList.push(item);
            }
        });
        this.temporaryLibrary = updatedLibrary;
        return recordList;
    },

    /**
     * Gets the library to perform the search.
     *
     * Concats {@link #internalLibrary} and {@link #temporaryLibrary}.
     *
     * @return {Array} The list of items to perform the search.
     */
    getLibrary: function() {
        return this.internalLibrary.concat(this.getTemporaryLibrary());
    },



    /**
     * Triggers the search and send results.
     *
     * @param {boolean} later `true` if triggered from the search API callback.
     */
    applyQuickSearch: function(later) {
        var term = this.$('input').val();
        if (!later && term === this.lastTerm) {
            return;
        }
        var results = {};
        if (!later && !_.isEmpty(term)) {
            this.fireSearchRequest(term);
        }
        if (!_.isEmpty(term)) {
            results = this.doSearch(term);
        }
        this.sendResults(results);
        this.lastTerm = term;
    },

    /**
     * Performs the actual search in the library.
     *
     * @param {string} term The term to search
     * @return {Array} Hopefully a list of results.
     */
    doSearch: function(term) {
        var options = {
            keys: ['module', 'name'],
            threshold: '0.3',
            includeScore: true
        };
        var keywordFuse = new Fuse(this.internalLibrary, {keys: ['keyword'], threshold: '0.0'});
        var keywords = keywordFuse.search(term);
        keywords = keywords.slice(0, 5);

        var actionsFuse = new Fuse(_.difference(this.internalLibrary, keywords), options);
        var actions = actionsFuse.search(term);
        actions = _.sortBy(actions, function(obj) {
            return [obj.score, obj.item.weight];
        });
        actions = actions.slice(0, 6);

        var recordsFuse = new Fuse(_.toArray(this.temporaryLibrary), options);
        var records = recordsFuse.search(term);
        var showMore = records.length > 3;

        records = records.slice(0, 3);
        return {
            actions: _.compact(_.pluck(actions, 'item')),
            keywords: keywords,
            records: _.compact(_.pluck(records, 'item')),
            showMore: showMore,
            term: term
        };
    },

    /**
     * Triggers `sweetspot:results` with the results of the search.
     *
     * @param {Array} Hopefully a list of results.
     */
    sendResults: function(results) {
        this.layout.trigger('sweetspot:results', results);
    },

    /**
     * Handles the keyup events.
     *
     * @param {event} evt The `keyup` event.
     */
    keyUpHandler: function(evt) {
        if (!this.layout.isVisible()) {
            return;
        }
        this.debouncedSearch(evt);
    },

    /**
     * Calls {@link #applyQuickSearch} with a debounce of 200ms.
     */
    debouncedSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 200),

    /**
     * Makes a request to the search API to find records.
     *
     * On success it calls {@link #addToTemporaryLibrary} to add the records
     * to the temporary library and calls {@link #applyQuickSearch} to re-apply
     * the search.
     *
     * @param {string} term The search term.
     */
    fireSearchRequest: function(term) {
        var self = this;
        this.collection.query = term;
        this.collection.fetch({
            query: term,
            fields: ['name', 'id'],
            module_list: [],
            limit: 4,
            success: function(collection) {
                var now = new Date().getTime();
                var formattedRecords = [];
                _.each(collection.toJSON(), function(record) {
                    if (!record.id) {
                        return; // Elastic Search may return records without id and record names.
                    }
                    var formattedRecord = {
                        id: record.id,
                        name: record.name || app.utils.formatNameModel(record._module, record),
                        module: record._module,
                        label: app.lang.getModuleIconLabel(record._module),
                        route: '#' + app.router.buildRoute(record._module, record.id),
                        timestamp: now,
                        weight: 40
                    };

                    formattedRecords.push(formattedRecord);
                });
                self.addToTemporaryLibrary(formattedRecords);
                self.applyQuickSearch(true);
            }
        });
    }

}) },
"baseedit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays edit view on a model
 * @class View.Views.Base.BaseeditView
 * @alias SUGAR.App.view.views.BaseBaseeditView
 * @extends View.View
 */
({
	// Baseedit View (base) 

    /**
     * Resets the error messages for all fields that have been changed and sent on the models change event.
     * @param {object} model that was changed.
     * @param {object} object that holds the changed fields.
     */
    clearValidationError: function(model, fields) {
        var self = this;
        if(!_.isEmpty(fields.changes)){
            _.each(fields.changes, function (num, key) {
                var field = self.getField(key);

                if (field) {
                    var controlGroup = field.$el.parents('.control-group:first');

                    if (controlGroup) {
                        controlGroup.removeClass("error");
                        controlGroup.find('.add-on').remove();
                        controlGroup.find('.help-block').html("");
                    }
                }
            });
        }
    },

    /**
     * Highlights all fields that fails field validation during save.
     * @param {object} Object containing the fields that failed validation.
     */
    handleValidationError:function (errors) {
        var self = this;

        _.each(errors, function (fieldErrors, fieldName) {
            //retrieve the field by name
            var field = self.getField(fieldName);
            var ftag = this.fieldTag || '';

            if (field) {
                var controlGroup = field.$el.parents('.control-group:first');

                if (controlGroup) {
                    controlGroup.addClass("error");
                    controlGroup.find('.add-on').remove();
                    controlGroup.find('.help-block').html("");

                    if (field.$el.parent().parent().find('.input-append').length > 0) {
                        field.$el.unwrap()
                    }
                    // Add error styling
                    field.$el.wrap('<div class="input-append  '+ftag+'">');

                    _.each(fieldErrors, function (errorContext, errorName) {
                        controlGroup.find('.help-block').append(app.error.getErrorString(errorName, errorContext));
                    });

                    $('<span class="add-on"><i class="fa fa-exclamation-circle"></i></span>').insertBefore(controlGroup.find('.help-block'));
                }
            }
        });
    }
}) },
"editmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.EditmodalView
 * @alias SUGAR.App.view.views.BaseEditmodalView
 * @extends View.Views.Base.BaseeditmodalView
 */
({
	// Editmodal View (base) 

    extendsFrom:'BaseeditmodalView',
    fallbackFieldTemplate: 'edit',
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        if (this.layout) {
            this.layout.on('app:view:activity:editmodal', function() {
                this.context.set('createModel',
                    app.data.createRelatedBean(app.controller.context.get('model'), null, 'notes', {})
                );
                this.render();
                this.$('.modal').modal({backdrop: 'static'});
                this.$('.modal').modal('show');
                app.$contentEl.attr('aria-hidden', true);
                $('.modal-backdrop').insertAfter($('.modal'));
                this.context.get('createModel').on('error:validation', function() {
                    this.disableButtons(false);
                }, this);
            }, this);
        }
        this.bindDataChange();
    },
    cancelButton: function() {
        this._super('cancelButton');
        app.$contentEl.removeAttr('aria-hidden');
    },
    saveComplete: function() {
        this._super('saveComplete');
        app.$contentEl.removeAttr('aria-hidden');
    }
  }) },
"merge-duplicates-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MergeDuplicatesProgressView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Merge-duplicates-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    plugins: ['editable'],

    /**
     * @inheritdoc
     */
    _labelSet: {
        TITLE: 'LBL_MERGE_DUPLICATES_TITLE',
        PROGRESS_STATUS: 'TPL_MERGE_DUPLICATES_PROGRESS_STATUS',
        FAIL_TO_ATTEMPT: 'TPL_MERGE_DUPLICATES_FAIL_TO_ATTEMPT',
        FAIL: 'TPL_MERGE_DUPLICATES_FAIL'
    },

    /**
     * @property {Number} processedCount Number of processed elements.
     */
    processedCount: 0,

    /**
     * @property {Number} failsCount Number of fails.
     */
    failsCount: 0,

    /**
     * @inheritdoc
     */
    initLabels: function() {
        this.LABELSET = this._labelSet;
    },

    /**
     * Reset view parameters.
     */
    reset: function() {
        this.processedCount = 0;
        this.failsCount = 0;
        this.totalRecord = 0;
    },

    /**
     * @inheritdoc
     *
     * There are no conditions to check.
     */
    checkAvailable: function() {
        return true;
    },

    /**
     * @inheritdoc
     *
     * No estimate used.
     */
    getEstimate: function() {
        return 0;
    },

    /**
     * Set number of total elements for progress.
     *
     * @param {Number} total Number of total records.
     */
    setTotalRecords: function(total) {
        this.totalRecord = total;
    },

    /**
     * @inheritdoc
     */
    getTotalRecords: function() {
        return this.totalRecord;
    },

    /**
     * @inheritdoc
     */
    getRemainder: function() {
        return '';
    },

    /**
     * Setup count of processed elements.
     *
     * @param {Number} count Count of processed elements.
     */
    setProgressSize: function(count) {
        this.processedCount;
    },

    /**
     * Increments count of processed elements.
     */
    incrementProgressSize: function() {
        this.processedCount = this.processedCount + 1;
    },

    /**
     * @inheritdoc
     */
    getProgressSize: function() {
        return this.processedCount;
    },

    /**
     * @inheritdoc
     *
     * @param {Object} context Object to check errors.
     */
    checkError: function(context) {
        if (_.isUndefined(context) || _.isUndefined(context.attempt)) {
            return;
        }

        if (context.attempt === 0 ||
            context.attempt > (context.maxAllowAttempt || 3)
        ) {
            return;
        }

        app.alert.dismiss('check_error_message');
        app.alert.show('check_error_message', {
            level: 'warning',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                objectName: context.objectName || '',
                num: context.attempt,
                total: (context.maxAllowAttempt || 3)
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * Handler for drawer `reset` event.
     * @return {boolean}
     */
    _onDrawerReset: function() {
        this.showProgress();
        return false;
    },

    /**
     * @inheritdoc
     *
     * Setup handler for drawer to prevent closing it.
     * We need it b/ the operation an be too long and in this time
     * token can be expired.
     */
    showProgress: function() {
        app.drawer.before('reset', this._onDrawerReset, this);
        this._super('showProgress');
    },

    /**
     * Update the progress view when the job is paused.
     * Triggers `massupdate:pause:completed` event on model.
     */
    pauseProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(true);
        }
        this.$holders.bar.removeClass('active');
        this.model.trigger('massupdate:pause:completed');
    },

    /**
     * Update the progress view when the job is resumed.
     * Triggers `massupdate:resume:completed` event on model.
     */
    resumeProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }
        this.model.trigger('massupdate:resume:completed');
    },

    /**
     * Update the progress view when the job is stopped.
     * Triggers `massupdate:stop:completed` event on model.
     */
    stopProgress: function() {
        this.model.trigger('massupdate:stop:completed');
    },

    /**
     * @inheritdoc
     *
     * Dismiss alerts:
     * 1. `stop_confirmation` - confirmation on pause
     * 2. `check_error_message` - check errors status alert
     * Triggers `massupdate:end:completed` event on model.
     * Removes handler for drawer.
     */
    hideProgress: function() {
        app.drawer.offBefore('reset', this._onDrawerReset, this);
        this.hide();
        app.alert.dismiss('stop_confirmation');
        app.alert.dismiss('check_error_message');
        this.model.trigger('massupdate:end:completed');
    },

    /**
     * Called with new item is processed.
     *
     * Increments number of processed elements and
     * calls {@link View.MergeDuplicatesProgressView#updateProgress}.
     * Triggers `massupdate:item:processed:completed` event on model.
     */
    onItemProcessed: function() {
        this.incrementProgressSize();
        this.updateProgress();
        this.model.trigger('massupdate:item:processed:completed');
    },

    /**
     * Called when item go to next attemp.
     * Triggers `massupdate:item:attempt:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onNextAttept: function(context) {
        this.checkError(context);
        this.model.trigger('massupdate:item:attempt:completed');
    },

    /**
     * Called when item cannot be processed after a few attemps.
     *
     * Shows error message.
     * Triggers `massupdate:item:fail:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onItemFail: function(context) {
        this.failsCount = this.failsCount + 1;
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');

        app.alert.dismiss('fail_message');
        app.alert.show('fail_message', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL'], this.module, {
                objectName: context.objectName || ''
            })
        });
        this.model.trigger('massupdate:item:fail:completed');
    },

    /**
     * @inheritdoc
     *
     * Use model to listen events insted of collection.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.before('start', this.checkAvailable, this);
        this.model.on('massupdate:always', this.updateProgress, this);
        this.model.on('massupdate:start', this.showProgress, this);
        this.model.on('massupdate:end', this.hideProgress, this);
        this.model.on('massupdate:fail', this.checkError, this);
        this.model.on('massupdate:resume', this.resumeProgress, this);
        this.model.on('massupdate:pause', this.pauseProgress, this);
        this.model.on('massupdate:stop', this.stopProgress, this);
        this.model.on('massupdate:item:processed', this.onItemProcessed, this);
        this.model.on('massupdate:item:attempt', this.onNextAttept, this);
        this.model.on('massupdate:item:fail', this.onItemFail, this);
    }
}) },
"language-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LanguageActionsView
 * @alias SUGAR.App.view.views.BaseLanguageActionsView
 * @extends View.View
 */
({
	// Language-actions View (base) 

    events: {
        'click [data-action=languageList] .dropdown-menu a' : 'setLanguage'
    },
    tagName: "span",
    plugins: ['Dropdown'],
    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("app:login:success", this.render, this);
        app.events.on("app:logout", this.render, this);
        app.view.View.prototype.initialize.call(this, options);
        $(window).on('resize', _.debounce(_.bind(this.adjustMenuHeight, this), 100));
    },
    /**
     * @override
     * @private
     */
    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.currentLang = app.lang.getLanguage() || "en_us";
        this.languageList = this.formatLanguageList();
        app.view.View.prototype._renderHtml.call(this);
        this.$('[data-toggle="dropdown"]').dropdown();
        this.adjustMenuHeight();
    },
    /**
     * When a user selects a language in the dropdown, set this language.
     * Note that on login, user's preferred language will be updated to this language
     *
     * @param {Event} e
     */
    setLanguage: function(e) {
        var $li = this.$(e.currentTarget),
            langKey = $li.data("lang-key");
        app.alert.show('language', {level: 'warning', title: app.lang.get('LBL_LOADING_LANGUAGE'), autoclose: false});
        app.lang.setLanguage(langKey, function() {
            app.alert.dismiss('language');
        });
    },
    adjustMenuHeight: function(){
        if (this.$('[data-action=languageList]').length === 0) {
            return;
        }
        var linkButton = this.$('[data-action=languageList]'),
            dropupMenu = this.$('[data-action=languageList] .dropdown-menu.bottom-up'),
            linkBottomPosition = parseInt($('footer').height() - linkButton.height() - linkButton.position().top, 10),
            dropupOffset = parseInt(dropupMenu.css('bottom'), 10),
            borderTop = parseInt(dropupMenu.css('border-top-width'), 10),
            menuHeight = Math.round($(window).height() - borderTop - dropupOffset - linkBottomPosition);
        dropupMenu.css('max-height', menuHeight);
    },
    /**
     * Formats the language list for the template
     *
     * @return {Array} of languages
     */
    formatLanguageList: function() {
        // Format the list of languages for the template
        var list = [],
            languages = app.lang.getAppListStrings('available_language_dom');

        _.each(languages, function(label, key) {
            if (key !== '') {
                list.push({ key: key, value: label });
            }
        });
        return list;
    },
    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"profileactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProfileactionsView
 * @alias SUGAR.App.view.views.BaseProfileactionsView
 * @extends View.View
 */
({
	// Profileactions View (base) 

    plugins: ['Dropdown', 'Tooltip'],

    events: {
        'click [data-action=link]': 'linkClicked',
        'click #userTab' : 'hideSubmenuItems',
        'click #userActions' : 'closeSubmenu'
    },

    /**
     * Visibility property for available submenu.
     *
     * @property
     */
    displaySubmenu: false,

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("bwc:avatar:removed", this.bwcAvatarRemoved, this);
        app.user.on("change:picture", this.setCurrentUserData, this);
    },

    /**
     * Render profile actions dropdown menu
     * @private
     */
    _renderHtml: function() {
        // FIXME check why the router is not loaded before all the other components are rendered
        if (!app.router || !app.api.isAuthenticated() || app.config.appStatus === 'offline') {
            return;
        }

        if (!_.isEmpty(this.meta)) {
            this.menulist = this.filterAvailableMenu(app.utils.deepCopy(this.meta));
        }
        this._super('_renderHtml');
    },
    /**
     * Handle the button click event.
     * Stop event propagation in order to keep the dropdown box.
     *
     * @param {Event} evt Mouse event.
     */
    linkClicked: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        var $menuItem = this.$(evt.currentTarget),
            $submenu = $menuItem.closest('li').find('.dropdown-inset');
        $submenu.toggle();
        // Handles the highlight of the dropdown arrow
        $menuItem.toggleClass("open");

        // Handles css properties when height exceed 330, the scrollbar appears
        var maxHeight = 330,
            currentHeight = this.$("#fullmenu").outerHeight();
        this.$('.dropdown-submenu').toggleClass('with-scroll', currentHeight >= maxHeight);
    },
    /**
     * Closes the submenu
     */
    closeSubmenu: function(){
        this.$('.dropdown-submenu').removeClass("open");
    },
    /**
     * Hides the submenu items
     */
    hideSubmenuItems: function() {
        this.$('.dropdown-inset').hide();
    },

    /**
     * Filters menu metadata
     * @param Array menuMeta
     * @return {Array}
     */
    filterAvailableMenu: function(menuMeta){
        var result = [];
        _.each(menuMeta,function(item){
            item = this.filterMenuProperties(item);
            if(!_.isEmpty(item['acl_module'])) {
                if(app.acl.hasAccess(item.acl_action, item.acl_module)) {
                    result.push(item);
                }
            } else if(item['acl_action'] === 'admin' && item['label'] === 'LBL_ADMIN') {
                //Edge case for admin link. We only show the Admin link when
                //user has the "Admin & Developer" or "Developer" (so developer
                //in either case; see SP-1827)
                if (app.acl.hasAccessToAny('developer')) {
                    result.push(item);
                }
            } else {
                // push the menu item if current user is a admin or
                // current user has access to admin or current user
                // is a developer, the last conditon is for
                // if all three acls checks are not met, it will only
                // push if the menu item is not admin, which skips the admin menu
                if(app.acl.hasAccess('admin', 'Administration') ||
                    app.acl.hasAccessToAny('developer') ||
                    item['acl_action'] !== 'admin') {
                    result.push(item);
                }
            }

        },this);
        return result;
    },

    /**
     * Filters single menu data
     * @param Array menu data
     * @return {Array}
     */
    filterMenuProperties:function(singleItem){
        if(singleItem['label'] === 'LBL_PROFILE'){
            singleItem['img_url'] = this.pictureUrl;
        }
        return singleItem;
    },
    //TODO: Remove once bwc is completely pruned out of the product
    bwcProfileEntered: function() {
        //Refetch latest user data (since bwc updated avatar); reset
        var self = this;
        app.user.load(function() {
            self.setCurrentUserData();
        });
    },
    //This will get called when avatar is removed from bwc User profile edit (SP-1949)
    //TODO: Remove once bwc is completely pruned out of the product
    bwcAvatarRemoved: function() {
        app.user.set("picture", '');//so `this.pictureUrl` is falsy and default avatar kicks in on .hbs template
        this.setCurrentUserData();
    },
    /**
     * Sets the current user's information like full name, user name, avatar, etc.
     * @protected
     */
    setCurrentUserData: function() {
        this.fullName = app.user.get("full_name");
        this.userName = app.user.get("user_name");
        this.userId = app.user.get('id');
        var picture = app.user.get("picture");

        this.pictureUrl = picture ? app.api.buildFileURL({
            module: "Users",
            id: this.userId,
            field: "picture"
        }, {
            cleanCache: true
        }) : '';

        this.render();
    },
    _dispose: function() {
        if (app.user) app.user.off(null, null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"login": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Login form view.
 *
 * @class View.Views.Base.LoginView
 * @alias SUGAR.App.view.views.BaseLoginView
 * @extends View.View
 */
({
	// Login View (base) 

    /**
     * @inheritdoc
     */
    plugins: ['ErrorDecoration'],

    /**
     * @inheritdoc
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     */
    events: {
        'click [name=login_button]': 'login',
        'keypress': 'handleKeypress',
        "click [name=external_login_button]": "external_login",
        "click [name=login_form_button]": "login_form"
    },

    /**
     * An object containing the keys of the alerts that may be displayed in this
     * view.
     *
     * @type {Object}
     */
    _alertKeys: {
        adminOnly: 'admin_only',
        invalidGrant: 'invalid_grant_error',
        login: 'login',
        needLogin: 'needs_login_error',
        offsetProblem: 'offset_problem',
        unsupportedBrowser: 'unsupported_browser'
    },

    /**
     * Flag to indicate if the link to reset the password should be displayed.
     *
     * @type {Boolean}
     */
    showPasswordReset: false,

    /**
     * The company logo url.
     *
     * @type {String}
     */
    logoUrl: null,

    /**
     * Process login on key `Enter`.
     *
     * @param {Event} event The `keypress` event.
     */
    handleKeypress: function(event) {
        if (event.keyCode === 13) {
            this.$('input').trigger('blur');
            this.login();
        }
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * Fields metadata needs to be converted to {@link Data.Bean#declareModel}
     * format.
     *
     *     @example
     *      {
     *        "username": { "name": "username", ... },
     *        "password": { "name": "password", ... },
     *        ...
     *      }
     *
     * @param {Object} meta The view metadata.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, 'fields')), function(field) {
            fields[field.name] = field;
        });
        app.data.declareModel('Login', {fields: fields});
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (app.progress) {
            app.progress.hide();
        }
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        this._super('initialize', [options]);

        var config = app.metadata.getConfig();
        if (config && app.config.forgotpasswordON === true) {
            this.showPasswordReset = true;
        }
        
        if (config && 
            app.config.externalLogin === true && 
            app.config.externalLoginSameWindow === true &&
            !_.isEmpty(app.config.externalLoginUrl)
        ) {
            this.externalLoginForm = true;
            this.externalLoginUrl = app.config.externalLoginUrl;
        }

        // Set the page title to 'SugarCRM' while on the login screen
        $(document).attr('title', 'SugarCRM');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.logoUrl = app.metadata.getLogoUrl();
        //It's possible for errors to prevent the postLogin from triggering so contentEl may be hidden.
        app.$contentEl.show();

        this._super('_render');

        this.refreshAdditionalComponents();

        if (!this._isSupportedBrowser()) {
            var linkLabel = Handlebars.Utils.escapeExpression(app.lang.get('LBL_ALERT_SUPPORTED_PLATFORMS_LINK'));
            var link = '<a href="http://support.sugarcrm.com/05_Resources/03_Supported_Platforms/">' +  linkLabel + '</a>';
            var safeLink = new Handlebars.SafeString(link);
            var label = app.lang.get('TPL_ALERT_BROWSER_SUPPORT', null, {link: safeLink});

            app.alert.show(this._alertKeys.unsupportedBrowser, {
                level: 'warning',
                title: '',
                messages: [
                    app.lang.get('LBL_ALERT_BROWSER_NOT_SUPPORTED'),
                    label
                ]
            });
        }

        var config = app.metadata.getConfig(),
            level = config.system_status && config.system_status.level;

        if (level === 'maintenance' || level === 'admin_only') {
            app.alert.show(this._alertKeys.adminOnly, {
                level: 'warning',
                title: '',
                messages: [
                    '',
                    app.lang.get(config.system_status.message)
                ]
            });
        }
        app.alert.dismiss(this._alertKeys.offsetProblem);
        return this;
    },

    /**
     * Refresh additional components
     */
    refreshAdditionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * Process login.
     *
     * We have to manually set `username` and `password` to the model because
     * browser autocomplete does not always trigger DOM change events that would
     * propagate changes into the model.
     */
    login: function() {
        //FIXME: Login fields should trigger model change (SC-3106)
        this.model.set({
            password: this.$('input[name=password]').val(),
            username: this.$('input[name=username]').val()
        });
        this.model.doValidate(null,
            _.bind(function(isValid) {
                if (isValid) {
                    app.$contentEl.hide();

                    app.alert.show(this._alertKeys.login, {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });

                    var args = {
                        password: this.model.get('password'),
                        username: this.model.get('username')
                    };

                    app.login(args, null, {
                        error: function() {
                            app.$contentEl.show();
                            app.logger.debug('login failed!');
                        },
                        success: _.bind(function() {
                            app.logger.debug('logged in successfully!');
                            app.alert.dismiss(this._alertKeys.invalidGrant);
                            app.alert.dismiss(this._alertKeys.needLogin);

                            app.events.on('app:sync:complete', function() {
                                app.logger.debug('sync in successfully!');
                                _.defer(_.bind(this.postLogin, this));
                            }, this);
                        }, this),
                        complete: _.bind(function() {
                            app.alert.dismiss(this._alertKeys.login);
                        }, this)
                    });
                }
            }, this)
        );

        app.alert.dismiss('offset_problem');
    },

    /**
     * After login and app:sync:complete, we need to see if there's any post
     * login setup we need to do prior to rendering the rest of the Sugar app.
     */
    postLogin: function() {
        if (!app.user.get('show_wizard') && !app.user.get('is_password_expired')) {

            this.refreshAdditionalComponents();

            if (new Date().getTimezoneOffset() != (app.user.getPreference('tz_offset_sec') / -60)) {
                var link = new Handlebars.SafeString('<a href="#' +
                    app.router.buildRoute('Users', app.user.id, 'edit') + '">' +
                    app.lang.get('LBL_TIMEZONE_DIFFERENT_LINK') + '</a>');

                var message = app.lang.get('TPL_TIMEZONE_DIFFERENT', null, {link: link});

                app.alert.show(this._alertKeys.offsetProblem, {
                    messages: message,
                    closeable: true,
                    level: 'warning'
                });
            }
        }
        app.$contentEl.show();
    },

    /**
     * Taken from sugar_3.
     *
     * @return {Boolean} `true` if the browser is supported, `false` otherwise.
     * @private
     */
    _isSupportedBrowser: function(currentNavigator) {
        var supportedBrowsers = {
            // For Safari & Chrome jQuery.Browser returns the webkit revision
            // instead of the browser version and it's hard to determine this
            // number.
            msie : {min:11}, // IE 11
            safari : {min:600}, // Safari 8.0.8, 9.0.1
            mozilla : {min:41}, // Firefox 41, 42
            chrome : {min:537.36} // Chrome 47
        };

        var current = parseFloat($.browser.version);
        currentNavigator = currentNavigator || navigator;

        // For IE11, navigator behaves differently in order to conform to HTML5
        // standards. This changes the behavior of jQuery.Browser and so IE11
        // will show up as not supported in the above checks when it should be
        // supported. The following check rectifies this issue.
        if ((/Trident\/7\./).test(currentNavigator.userAgent)) {
            var supported = supportedBrowsers['msie'];
            return current >= supported.min;
        // jquery $.browser returns 'safari' on a Chrome browser
        // we want to make sure the right browser type to be checked
        } else if ($.browser['safari'] && navigator.userAgent.indexOf('Chrome') != -1) {
            var supported = supportedBrowsers['chrome'];
            return current >= supported.min;
        } else {
            for (var b in supportedBrowsers) {
                if ($.browser[b]) {
                    var supported = supportedBrowsers[b];
                    return current >= supported.min;
                }
            }
        }
    },
    
    /**
     * Process Login
     */
    external_login: function() {
        window.location.replace(this.externalLoginUrl);
    },
    
    /**
     * Show Login form
     */
    login_form: function() {
        app.config.externalLogin = false;
        app.controller.loadView({
            module: "Login",
            layout: "login",
            create: true
        });
    }
}) },
"dupecheck-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckFilterDropdownView
 * @alias SUGAR.App.view.views.BaseDupecheckFilterDropdownView
 * @extends View.Views.Base.FilterFilterDropdownView
 */
({
	// Dupecheck-filter-dropdown View (base) 

    extendsFrom: 'FilterFilterDropdownView',

    /**
     * Display `LBL_DUPECHECK_FILTER_DEFAULT` for all record set label.
     */
    labelAllRecordsFormatted: 'LBL_DUPECHECK_FILTER_DEFAULT'
}) },
"dnb-competitors": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbCompetitorsView
 * @alias SUGAR.App.view.views.BaseDnbCompetitorsView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-competitors View (base) 

    extendsFrom: 'DnbView',

    duns_num: null,

    competitorsList: null,

    events: {
        'click a.dnb-company-name': 'getCompanyDetails',
        'click .backToList' : 'backToCompanyList'
    },

    //D&B Firmographic API product codes
    competitorsDD: {
        'dunsnum': {
            'json_path': 'DUNSNumber'
        },
        'orgname': {
            'json_path': 'OrganizationPrimaryName.OrganizationName.$',
            'case_fmt': true
        },
        'town': {
            'json_path': 'PrimaryAddress.PrimaryTownName',
            'case_fmt': true
        },
        'ctrycd': {
            'json_path': 'PrimaryAddress.CountryISOAlpha2Code',
            'case_fmt': false
        },
        'territoryabbreviatedname': {
            'json_path': 'PrimaryAddress.TerritoryAbbreviatedName',
            'case_fmt': true
        },
        'countryofficialname': {
            'json_path': 'PrimaryAddress.CountryOfficialName',
            'case_fmt': true
        },
        'salesrevenueamt': {
            'json_path': 'salesrevenueamt',
            'case_fmt': false
        },
        'topcompetitorindicator': {
            'json_path': 'TopCompetitorIndicator',
            'case_fmt': false
        },
        'isDupe': {
            'json_path': 'isDupe'
        }
    },

    competitorsConst: {
        'responseCode' : 'FindCompetitorResponse.TransactionResult.ResultID',
        'responseMsg' : 'FindCompetitorResponse.TransactionResult.ResultText',
        'competitorsPath' : 'FindCompetitorResponse.FindCompetitorResponseDetail.Competitor',
        'salesRevenuePath' : 'SalesRevenueAmount.0.$'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadCompetitors, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadCompetitors, this);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
    },

    /**
     * Refresh dashlet once Refresh link clicked from geat button
     * To show updated data from D&B Competitors service
     */
    refreshClicked: function() {
        this.loadCompetitors(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadCompetitors: function(isCollapsed) {
        //if the dashlet is not collapsed load data from D&B
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getDNBCompetitors, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Retrieves dnb competitors for the given duns no.
     * @param  {String} duns_num
     */
    getDNBCompetitors: function(duns_num) {
        var self = this;
        if (duns_num) {
            self.template = app.template.get(self.name);
            if (!self.disposed) {
                self.render();
                self.$('div#dnb-competitors-list').hide();
                self.$('div#dnb-no-data').hide();
            }
            //check if cache has this data already
            var cacheKey = 'dnb:competitors:' + duns_num;
            var cacheContent = app.cache.get(cacheKey);
            if (cacheContent) {
                var dupeCheckParams = {
                    'type': 'duns',
                    'apiResponse': cacheContent,
                    'module': 'competitors'
                };
                this.competitorsList = cacheContent;
                this.baseDuplicateCheck(dupeCheckParams, this.renderCompetitors);
            } else {
                var dnbCompetitorsURL = app.api.buildURL('connector/dnb/competitors/' + duns_num, '', {},{});
                var resultData = {'product': null, 'errmsg' : null};
                app.api.call('READ', dnbCompetitorsURL, {},{
                    success: function(data) {
                        var responseCode = self.getJsonNode(data, self.competitorsConst.responseCode),
                            responseMsg = self.getJsonNode(data, self.competitorsConst.responseMsg);
                        if (responseCode && responseCode === self.responseCodes.success) {
                            resultData.product = data;
                            app.cache.set(cacheKey, data);
                            self.competitorsList = data;
                        } else {
                            resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                        }
                        self.renderCompetitors.call(self, resultData);
                    },
                    error: _.bind(self.checkAndProcessError, self)
                });
            }
        } else {
            self.template = app.template.get(self.name + '.dnb-no-duns');
            if (!self.disposed) {
                self.render();
            }
        }
    },

    /**
     * Renders the competitors list
     */
    backToCompanyList: function() {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name);
        this.render();
        this.$('div#dnb-competitors-loading').show();
        this.$('div#dnb-competitors-list').hide();
        if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
            this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().hide();
        }
        var dupeCheckParams = {
            'type': 'duns',
            'apiResponse': this.competitorsList,
            'module': 'competitors'
        };
        this.baseDuplicateCheck(dupeCheckParams, this.renderCompetitors);
    },

    /**
     * Renders competitors list
     * @param {Object} competitorsList
     */
    renderCompetitors: function(competitorsList) {
        this.template = app.template.get(this.name);
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name);
        this.dnbComp = {};
        if (competitorsList.product) {
            var competitors = this.getJsonNode(competitorsList.product, this.competitorsConst.competitorsPath);
            this.dnbComp.product = this.formatCompetitors(competitors, this.competitorsDD);
        } else {
            this.dnbComp.errmsg = competitorsList.errmsg;
        }
        this.render();
        this.$('div#dnb-competitors-loading').hide();
        this.$('div#dnb-no-data').hide();
        this.$('div#dnb-competitors-list').show();
        //hide import button when rendering the list
        if (this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data')) {
            this.layout.getComponent('dashlet-toolbar').getField('import_dnb_data').getFieldElement().hide();
        }
    },

    /**
     * Preprocessing search results
     * @param {Object} competitorsList DNB API Response for Competitors
     * @param {Object} competitorsDD Data Elements Map
     * @return {Array} Formatted array of competitors
     */
    formatCompetitors: function(competitorsList, competitorsDD) {
        var formattedCompetitors = [];

        //grouping top competitors
        var topCompGroup = _.groupBy(competitorsList, function (competitorObj) {
            return competitorObj.TopCompetitorIndicator;
        });
        if (topCompGroup.hasOwnProperty('true') && topCompGroup.hasOwnProperty('false')) {
            competitorsList = _.union(topCompGroup.true, topCompGroup.false);
        }
        //formatting sales revenue
        _.each(competitorsList, function (competitorObj) {
            var salesRevenue = this.getJsonNode(competitorObj,this.competitorsConst.salesRevenuePath);
            if (salesRevenue) {
                competitorObj.salesrevenueamt = '$' + this.formatSalesRevenue(salesRevenue) + app.lang.get('LBL_DNB_MILLION');
            }
        }, this);
        //iterate thru the search results, extract the necessary info
        //populate a js object
        //push it through an array
        _.each(competitorsList, function(competitorObj) {
            var frmtCompetitorsObj = {};
            _.each(competitorsDD, function(value, key) {
                var dataElement = this.getJsonNode(competitorObj, value.json_path);
                if (dataElement) {
                    if (value.case_fmt) {
                        dataElement = this.properCase(dataElement);
                    }
                    frmtCompetitorsObj[key] = dataElement;
                }
            },this);
            formattedCompetitors.push(frmtCompetitorsObj);
        },this);
        return formattedCompetitors;
    },

    /**
     * Gets D&B Company Details For A DUNS number
     * DUNS number is stored as an id in the anchor tag
     * @param {Object} evt
     */
    getCompanyDetails: function(evt) {
        if (this.disposed) {
            return;
        }
        var duns_num = evt.target.id;
        if (duns_num) {
            this.template = app.template.get('dnb.dnb-company-details');
            this.render();
            this.$('div#dnb-company-details').hide();
            this.baseCompanyInformation(duns_num, this.compInfoProdCD.lite, app.lang.get('LBL_DNB_COMPETITORS_LIST'), this.renderCompanyDetails);
        }
    }
}) },
"search-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Headerpane view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSearchHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Search-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('change:searchTerm change:tagParams', function(model, value) {
            var tagParams = this.context.get('tagParams') || [];
            this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
            this.render();
        }, this);

        // Let this.searchTerm hold searchTerm and tag data for headerpane title
        var tagParams = this.context.get('tagParams') || [];
        this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
    },

    /**
     * Formats the title passing the search term.
     *
     * @override
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module, {
            searchTerm: new Handlebars.SafeString(this.searchTerm)
        });
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.searchheader');
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"mass-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassLinkView
 * @alias SUGAR.App.view.views.BaseMassLinkView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Mass-link View (base) 

    extendsFrom: 'MassupdateView',
    massUpdateViewName: 'masslink-progress',
    _defaultLinkSettings: {
        mass_link_chunk_size: 20
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        var configSettings = (app.config.massActions && app.config.massActions.massLinkChunkSize) ?
                {mass_link_chunk_size: app.config.massActions.massLinkChunkSize} :
                {};

        this._settings = _.extend(
            {},
            this._defaultLinkSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
    },

    /**
     * Overrides parent. Sets mass link related events
     */
    delegateListFireEvents: function() {
        this.layout.on('list:masslink:fire', _.bind(this.beginMassLink, this));
    },

    /**
     * Link multiple records in chunks
     */
    beginMassLink: function(options) {
        var parentModel = this.context.get('recParentModel'),
            link = this.context.get('recLink'),
            massLink = this.getMassUpdateModel(this.module),
            progressView = this.getProgressView();

        massLink.setChunkSize(this._settings.mass_link_chunk_size);

        //Extend existing model with a link function
        massLink = _.extend({}, massLink, {
            maxLinkAllowAttempt: options && options.maxLinkAllowAttempt || this.maxAllowAttempt,
            link: function(options) {
                //Slice a new chunk of models from the mass collection
                this.updateChunk();
                var model = this,
                    apiMethod = 'create',
                    linkCmd = 'link',
                    parentData = {
                        id: parentModel.id
                    },
                    url = app.api.buildURL(parentModel.module, linkCmd, parentData),
                    linkData = {
                        link_name: link,
                        ids: _.pluck(this.chunks, 'id')
                    },
                    callbacks = {
                        success: function(data, response) {
                            model.attempt = 0;
                            model.updateProgress();
                            if (model.length === 0) {
                                model.trigger('massupdate:end');
                                if (_.isFunction(options.success)) {
                                    options.success(model, data, response);
                                }
                            } else {
                                model.trigger('massupdate:always');
                                model.link(options);
                            }
                        },
                        error: function() {
                            model.attempt++;
                            model.trigger('massupdate:fail');
                            if (model.attempt <= this.maxLinkAllowAttempt) {
                                model.link(options);
                            } else {
                                app.alert.show('error_while_mass_link', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            }
                        }
                    };
                app.api.call(apiMethod, url, linkData, callbacks);
            }
        });

        progressView.initCollection(massLink);
        massLink.link({
            success: _.bind(function(model, data, response) {
                this.layout.trigger('list:masslink:complete', model, data, response);
            }, this)
        });
    }
}) },
"dnb-contact-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbContactInfoView
 * @alias SUGAR.App.view.views.BaseDnbContactInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-contact-info View (base) 

    extendsFrom: 'DnbView',

    //for storing the duns_num
    duns_num: null,
    //for storing the contacts list
    //to be user for archiving
    contactsList: null,
    //current search parameters
    cntctSrchParams: null,
    //for storing the current contact details
    currentContact: null,
    //for storing the state of dashlet
    dashletState: null,
    searchCacheKey: null,
    detailCacheKey: null,
    //default page size
    pagesz: 10,

    events: {
        'click .dnb-cnt-prem' : 'baseGetContactDetails',
        'click .dnb-cnt-std' : 'baseGetContactDetails',
        'click .backToContactsList' : 'backToContactsList',
        'click #dnb-srch-clear' : 'clearSearchResults',
        'click #dnb-cntct-srch-btn' : 'searchContacts',
        'keyup .input-large': 'validateSearchParams',
        'click [data-action="show-more"]': 'invokePagination'
    },
    selectors: {
        'load': 'div#dnb-contact-list-loading',
        'rslt': 'div#dnb-contact-list',
        'rsltList': 'ul.dnb-short-list'
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function() {
        this._super('initDashlet');
        var pagesz = this.settings.get('pagesz')
        if (_.isUndefined(pagesz)){
            pagesz = 10;
        } else {
            this.pagesz = parseInt(pagesz, 10);
        }
        this.settings.set('pagesz', pagesz);
        this.initPaginationParams(this.pagesz);
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadContacts, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        this.dashletState = {
            'view' : null, //possible values list or detail or search,
            'content' : null, //used to store the cache key to render content
            'params' : null //used to store the search params, when view is search
        };
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadContacts, this);
        this.rowTmpl = app.template.get(this.name + '.dnb-contact-row');
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated contact information from DNB service
     */
    refreshClicked: function() {
        this.initPaginationParams(this.pagesz);
        this.loadContacts(false);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
    },

    /**
     * Triggered when the dashlet is collapsed / expanded
     * @param {Boolean} isCollapsed  true indicating the dashlet was collapsed
     */
    loadContacts: function(isCollapsed) {
        if (!isCollapsed) {
            if (this.checkFieldExists('duns_num')) {
                if (this.duns_num) {
                    //check if account is linked with a D-U-N-S
                    this.renderDashletFromState(this.dashletState);
                } else if (!_.isUndefined(app.controller.context.get('dnb_temp_duns_num'))) {
                    //check if D-U-N-S is set in context by refresh dashlet
                    this.getDNBContacts(app.controller.context.get('dnb_temp_duns_num'));
                } else {
                    this.template = app.template.get('dnb' + '.dnb-no-duns');
                    if (!this.disposed) {
                        this.render();
                    }
                }
            } else {
                this.template = app.template.get('dnb' + '.dnb-no-duns-field');
                if (!this.disposed) {
                    this.render();
                }
            }
        } else {
            //hide the import button if visible when minimized
            this.toggleImportBtn('import_dnb_data', false);
        }
    },

    /**
     * Back to contacts list functionality
     */
    backToContactsList: function() {
        if (this.disposed) {
            return;
        }
        this.template = app.template.get(this.name);
        this.toggleImportBtn('import_dnb_data', false);
        this.render();
        this.$(this.selectors.load).toggleClass('hide', false);
        this.$(this.selectors.rslt).toggleClass('hide', true);
        var dupeCheckParams = {
            'type': 'Contacts',
            'apiResponse': this.currentPage,
            'module': 'contactsPage'
        };
        this.baseDuplicateCheck(dupeCheckParams, this.renderPage);
    },

    /**
     * Renders the list of D&B Contacts
     * @param {Object} dnbApiResponse
     */
    renderContactsList: function(dnbApiResponse) {
        var dnbContactsList = {},
            appendRecords = false;
        if (this.resetPaginationFlag) {
            this.initPaginationParams(this.pagesz);
        }
        this.template = app.template.get(this.name);
        this.resultTemplate = this.template;
        //this is setting the dashlet state
        //required to display search params
        if (!_.isNull(this.searchCacheKey)) {
            this.dashletState.view = 'search';
            this.dashletState.params = this.cntctSrchParams;
            this.dashletState.content = this.searchCacheKey;
        } else {
            this.dashletState.view = 'list';
            this.dashletState.params = null;
            this.dashletState.content = null;
        }

        if (dnbApiResponse.product) {
            var apiContactList = this.getJsonNode(dnbApiResponse.product, this.contactConst.contactsPath);
            //setting the formatted set of records to context
            //will be required when we paginate from the client side itself
            this.formattedRecordSet = this.formatContactList(apiContactList, this.contactsListDD);
            //setting the api recordCount to context
            //will be used to determine if the pagination controls must be displayed
            this.recordCount = this.getJsonNode(dnbApiResponse.product, this.contactConst.srchCount);
            var nextPage = this.paginateRecords();
            //currentPage is set to null by initPaginationParams
            if (_.isNull(this.currentPage)) {
                this.currentPage = nextPage;
                dnbContactsList.product = this.currentPage;
            } else {
                //this loop gets executed when api is called again to obtain more records
                dnbContactsList.product = nextPage;
                appendRecords = true;
            }
            if (this.recordCount) {
                dnbContactsList.count = this.recordCount;
            }
        } else if (dnbApiResponse.errmsg) {
            dnbContactsList.errmsg = dnbApiResponse.errmsg;
        }
        this.renderPage(dnbContactsList, appendRecords);
    },

    /**
     * Overriding the renderPage in base dashlet
     * @param {Object} pageData
     * @param {Boolean} append boolean to indicate if records need to be appended to exsiting list
     */
    renderPage: function(pageData, appendRecords) {
        this._super('renderPage', [pageData, appendRecords]);
        this.toggleImportBtn('import_dnb_data', false);
    },

    /**
     * Clears the search results
     */
    clearSearchResults: function() {
        this.cntctSrchParams = {'fname': null, 'lname': null, 'jobTitle': null};
        this.getDNBContacts(this.duns_num);
        this.initPaginationParams(this.pagesz);
    },

    /**
     * Gets the list of contacts for a DUNS number
     * @param {String} duns_num
     */
    getDNBContacts: function(duns_num) {
        if (this.disposed) {
            return;
        }
        if (duns_num) {
            this.duns_num = duns_num;
            this.template = app.template.get(this.name);
            this.render();
            this.$(this.selectors.load).toggleClass('hide', false);
            this.$(this.selectors.rslt).toggleClass('hide', true);
            //check if cache has this data already
            var cacheKey = 'dnb:cntlist:' + duns_num;
            var cacheContent = app.cache.get(cacheKey);
            //setting dashlet state
            this.dashletState.view = 'list';
            this.dashletState.content = cacheKey;
            this.dashletState.params = null;
            this.searchCacheKey = null;
            if (cacheContent) {
                this.contactsList = cacheContent;
                var dupeCheckParams = {
                    'type': 'Contacts',
                    'apiResponse': cacheContent,
                    'module': 'contacts'
                };
                this.baseDuplicateCheck(dupeCheckParams, this.renderContactsList);
            } else {
                var balParams = {
                    'DUNSNumber-1': duns_num,
                    'contactType': 'Contacts'
                };
                //setting the balParams to context
                //this is required to invoke the api with the altered
                //pagination parameters
                this.balParams = balParams;
                this.baseContactsBAL(this.setApiPaginationParams(balParams), this.renderContactsList);
            }
        } else {
            this.template = app.template.get(this.name + '.dnb-no-duns');
            if (!this.disposed) {
                this.render();
            }
        }
    },

    /*
     * Imports the current contact information
     */
    importDNBContact: function() {
        this.baseImportContact('LinkedContacts');
    },

    /**
     * Searches for contacts from the D&B API
     * Based on the first name or last name or job title
     * Either one of these three inputs must be given in order to
     * perform the search
     * @param {Object} evt
     */
    searchContacts: function(evt) {
        if (this.disposed) {
            return;
        }
        //if search btn is not disabled and a duns exists then invoke contact search
        if (!this.$(evt.target).hasClass('disabled') && this.duns_num) {
            var cntctSrchParams = {}, //used for API
                srchParams = {'name': null, 'jobTitle': null}; //used for rendering view
            var name = $.trim(this.$('#dnb-name').val()),
                jobTitle = $.trim(this.$('#dnb-job').val());
            if (name !== '') {
                cntctSrchParams.ContactName = name;
                srchParams.name = name;
            }
            if (jobTitle !== '') {
                cntctSrchParams.KeywordContactText = jobTitle;
                //setting the scope for keyword search
                cntctSrchParams.KeywordContactScopeText = 'Title';
                srchParams.jobTitle = jobTitle;
            }
            cntctSrchParams['DUNSNumber-1'] = this.duns_num;
            cntctSrchParams.contactType = 'Contacts';
            this.template = app.template.get(this.name);
            this.cntctSrchParams = srchParams;
            this.render();
            this.$(this.selectors.load).toggleClass('hide', false);
            this.$(this.selectors.rslt).toggleClass('hide', true);
            var cacheKey = 'dnb:cntlist';
            _.each(cntctSrchParams, function(val, key) {
                cacheKey = cacheKey + ':' + key + '_' + val;
            });
            var cacheContent = app.cache.get(cacheKey);
            this.dashletState.view = 'detail';
            this.dashletState.content = cacheKey;
            this.dashletState.params = null;
            if (cacheContent) {
                this.contactsList = data;
                this.renderContactsList(cacheContent);
            } else {
                //setting the balParams to context
                //this is required to invoke the api with the altered
                //pagination parameters
                this.balParams = cntctSrchParams;
                this.baseContactsBAL(this.setApiPaginationParams(cntctSrchParams), this.renderContactsList);
            }
        }
    },

    /**
     * Validates the search parameters
     * Either one of the first name / last name / job title must be given in order
     * to enable the search button
     */
    validateSearchParams: function() {
        this.$('#dnb-cntct-srch-btn').addClass('disabled');
        var searchInputsColl = this.$('.input-large');
        //A Search can be performed only if the accounts is associated with a DUNS
        if (this.duns_num) {
            _.each(searchInputsColl, function(searchInputObj) {
                if ($.trim($(searchInputObj).val()) !== '') {
                    this.$('#dnb-cntct-srch-btn').removeClass('disabled');
                }
            }, this);
        }
    },

    /**
     * Render dashlet from previously stored state information
     * @param {Object} dashletState
     */
    renderDashletFromState: function(dashletState) {
        var cacheContent = app.cache.get(dashletState.content),
            view = dashletState.view,
            srchParams = dashletState.params;
        if (!_.isNull(cacheContent) && !_.isNull(dashletState.view)) {
            if (view === 'detail') {
                this.renderContactDetails(cacheContent);
            } else if (view === 'search' && !_.isNull(srchParams)) {
                this.renderContactsList({'product' : cacheContent});
                this.cntctSrchParams = srchParams;
            } else {
                this.getDNBContacts(this.duns_num);
            }
        } else {
            this.getDNBContacts(this.duns_num);
        }
    },

    /**
     * Event handler for pagination controls
     * Renders next page from context if available
     * else invokes the D&B API to get the next page
     */
    invokePagination: function() {
        this._super('invokePagination', [this.baseContactsBAL, this.balParams, this.renderContactsList]);
    }
}) },
"wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * An abstract WizardPageView.
 *
 * Wizard pages should extend this and provide field metadata, custom logic,
 * etc. This view is detached from Wizard layout when it is not the current
 * page. When it becomes the current page it is appended to Wizard layout and
 * render is called.
 *
 * If you want to use the default Wizard template, you'll need to load it in
 * `initialize`.
 *
 * For example,
 *
 *     initialize: function(options){
 *         //Load the default wizard page template, if you want to.
 *         options.template = app.template.getView("wizard-page");
 *         this._super("initialize", [options]);
 *     }
 *
 * @class View.Views.Base.WizardPageView
 * @alias SUGAR.App.view.views.BaseWizardPageView
 * @extends View.View
 */
({
	// Wizard-page View (base) 

    plugins: ['GridBuilder', 'ErrorDecoration'],

    events: {
        'click [name=previous_button]:not(.disabled)': 'previous',
        'click [name=next_button]:not(.disabled)': 'next'
    },
    /**
     * Current progress through wizard, updated automatically on each render.
     */
    progress: null,
    /**
     * Flags if all required fields have at least one character or not. This is
     * used to determine whether we enable or disable the wizard's next button.
     * @type {Boolean}
     */
    areAllRequiredFieldsNonEmpty: false,
    /**
     * Initialize the wizard controller and load header and footer partials
     * @param  {options} options the options
     */
    initialize: function(options){
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        Handlebars.registerPartial("wizard-page.header", app.template.get("wizard-page.header"));
        Handlebars.registerPartial("wizard-page.footer", app.template.get("wizard-page.footer"));
        this._super('initialize', [options]);
    },
    /**
     * Additionally update current progress and button status during a render.
     *
     * @override
     * @private
     */
    _render: function(){
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        this.progress = this.layout.getProgress();
        this.percentComplete = this._getPercentageComplete();
        this.wizardCompleted = (this.progress.page === this.progress.lastPage)?true:false;
        this._super('_render');
        this.checkIfPageComplete();

        this.layout.trigger("wizard-page:render:complete");
        return this;
    },

    /**
     * We have to check if required fields are pre-filled once we've sync'd. For example,
     * user might have valid required field values (in which case we enable next button).
     */
    bindDataChange: function() {
        var self = this;
        if (this.model) {
            this.listenTo(this.model, "sync", function() {
                self.checkIfPageComplete();
            });
            _.each(this.fieldsToValidate, function(field) {
               if (field && field.required) {
                  self.listenTo(self.model, 'change:'+field.name, function() {
                      self.checkIfPageComplete();
                  });
               }
            });
        }
    },
    /**
     * Used to build our multi-column grid (user wizard is 2 col panel).
     * @param  {Object} panels the meta.panels
     * @protected
     */
    _buildGridsFromPanelsMetadata: function(panels) {
        _.each(panels, function(panel) {
            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields:      panel.fields,
                        columns:     panel.columns,
                        labels:      panel.labels,
                        labelsOnTop: panel.labelsOnTop
                    },
                    gridResults = this.getGridBuilder(options).build();
                panel.grid   = gridResults.grid;
            }
        }, this);
    },
    /**
     * Gets the percentage of pages complete. We consider being on a page as counting towards
     * completed pages (as this seems to be the norm) e.g. arriving at 1 of 3 results in 33%
     * @protected
     * @return {Number} Percentage complete as int
     */
    _getPercentageComplete: function() {
        return Math.floor(this.progress.page / this.progress.lastPage * 100);
    },
    /**
     * Called after render to update status of next/previous buttons.
     */
    updateButtons: function(){
        var prevBtn = this.getField("previous_button");
        if (prevBtn) {
            if (this.progress && this.progress.page > 1) {
                prevBtn.show();
            } else {
                prevBtn.hide();
            }
        }
        var nextBtn = this.getField("next_button");
        if (nextBtn) {
            nextBtn.setDisabled(!this.isPageComplete());
        }
    },

    /**
     * Called after initialization of the wizard page but just before it gets
     * added as a component to the Wizard layout.  Allows implementers to
     * control when a wizard page is included. Default implementation hides
     * page if it will not render because of ACL checks.
     *
     * @property {boolean|Function} showPage
     * @return {boolean} `true` to show the page.
     */
    showPage: function() {
        return app.acl.hasAccessToModel(this.action, this.model);
    },

    /**
     * We can advance the page once we know it is complete. Wizard page's
     * should override this function to provide custom validation logic.
     *
     * @return {boolean} `true` if this page is complete
     * @override
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Listen to changes on required fields. If all required fields contain
     * at least one character, we enable the next button. Implementers of
     * wizard pages may override this method to customize if desired, although
     * you may be able to just override `requiredTypesToPrevalidate`.
     *
     * See {@link View.Views.Base.UserWizardPageView}.
     *
     * @param {Object} evt the event
     */
    checkIfPageComplete: function(evt) {
        var self = this;
        this.areAllRequiredFieldsNonEmpty = true;
        _.each(this.fields, function(field) {
            if (!field.def.required) return;
            var value = field.$(field.fieldTag + ".required").val();
            var invalid = app.validation.requiredValidator(field.def, field.name, field.model, value);
            if (invalid) {
                self.areAllRequiredFieldsNonEmpty = false;
            }
        });
        this.updateButtons();
    },
    /**
     * Only validate fields pertinent to wizard page
     * @param  {Object} meta The meta
     * @return {Object} fields The fields to validate on
     * @private
     */
    _fieldsToValidate: function(meta) {
        meta = meta || {};
        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        return fields;
    },
    /**
     * Next button pressed
     */
    next: function() {
        var self = this;
        if (this.progress.page !== this.progress.lastPage) {
            this.beforeNext(function(success) {
                if (success) {
                    self.progress = self.layout.nextPage();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeNext from wizard");
                }
            });
        } else {
            this.beforeFinish(function(success) {
                if (success) {
                    self.finish();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeFinish from wizard");
                }
            });
        }
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to next
     * page. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeNext: function(callback) {
        app.logger.debug("wizard's beforeNext called directly. Derived controllers should have overridden this!");
        callback(true);
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to finish
     * the wizard. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeFinish: function(callback){
        app.logger.debug("wizard's beforeFinish called directly. Derived controller should have overridden this!");
        callback(true);
    },
    /**
     * Previous button pressed
     */
    previous: function(){
        this.progress = this.layout.previousPage();
    },
    /**
     * Next button pressed and this is the last page. We need to PUT /me to indicate that the
     * "instance is configured". Calls finished on WizardLayout on complete.
     */
    finish: function(){
        this.layout.finished();
    }

}) },
"alert": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.AlertView
 * @alias SUGAR.App.view.views.BaseAlertView
 * @extends View.View
 */
({
	// Alert View (base) 

    className: 'alert-wrapper', //override default class

    plugins: ['Tooltip'],

        events: {
            'click [data-action=cancel]': 'cancelClicked',
            'click [data-action=confirm]': 'confirmClicked',
            'click [data-action=close]': 'closeClicked',
            'click a': 'linkClick'
        },

    LEVEL: {
        PROCESS: 'process',
        SUCCESS: 'success',
        WARNING: 'warning',
        INFO: 'info',
        ERROR: 'error',
        CONFIRMATION: 'confirmation'
    },

    /**
     * Initialize alert view.
     *
     * @param {Object} options Options to be passed to the alert view.
     * @param {boolean} options.closeable: boolean flag indicating if the alert
     *   can be closed by the user. Note that non-"info" alerts are closeable by
     *   default if this setting is not specified.
     * @param {Function} options.onConfirm: Handler of action Confirm for
     *   confirmation alerts.
     * @param {Function} options.onCancel: Handler of action Cancel for
     *   confirmation alerts.
     * @param {Function} options.onLinkClicked: Handler for click actions on a
     *   link inside the alert.
     * @param {Function} options.onClose: Handler for the close event on the (x).
     * @param {Object} options.templateOptions: Augment template context with
     *   custom object.
     *
     * @override
     */
    initialize: function(options) {
        app.plugins.attach(this, 'view');

        options || (options = {});
        options.confirm || (options.confirm = {});
        options.cancel || (options.cancel = {});

        this.onConfirm = options.onConfirm || options.confirm.callback;
        this.confirmLabel = options.confirm.label || 'LBL_CONFIRM_BUTTON_LABEL';
        this.onCancel = options.onCancel || options.cancel.callback;
        this.cancelLabel = options.cancel.label || 'LBL_CANCEL_BUTTON_LABEL';
        this.onLinkClick = options.onLinkClick;
        this.onClose = options.onClose;
        this.templateOptions = options.templateOptions;
        this.name = 'alert';
    },

    /**
     * Gets selector for DOM elements that need to be clicked in order to close an alert.
     * @return {Object} jQuery/Zepto selector of the close button.
     */
    getCloseSelector: function() {
        return this.$('.close');
    },

    /**
     * Renders the custom alert view template. Binds `Esc` and `Return` keys for
     * confirmation alerts.
     *
     * @override
     */
    render: function() {
       var options = this.options;

        if (!this.triggerBefore('render')) {
            return false;
        }
        if (_.isUndefined(options)) {
            return this;
        }

        var template = this._getAlertTemplate(options, this.templateOptions);

        this.$el.html(template);

        if (options.level === 'confirmation') {
            this.bindCancelAndReturn();
        }

        this.trigger('render');
    },

    /**
     * Dismiss the alert when user clicks `cancel`
     */
    cancel: function() {
        this.trigger('dismiss');
        app.alert.dismiss(this.key);
    },

    /**
     * Executes assigned handlers when user clicks `cancel`.
     */
    cancelClicked: function() {
        this.cancel();
        app.events.trigger('alert:cancel:clicked');
        if (_.isFunction(this.onCancel)) {
            this.onCancel();
        }
    },

    /**
     * Executes assigned handlers when user clicks `confirm`.
     */
    confirmClicked: function() {
        this.cancel();
        app.events.trigger('alert:confirm:clicked');
        if (_.isFunction(this.onConfirm)) {
            this.onConfirm();
        }
    },

    /**
     * Fired when a link is clicked
     *
     * @param {Event} event
     */
    linkClick: function(event) {
        if (_.isFunction(this.onLinkClick)) {
            this.onLinkClick(event);
        }
    },

    /**
     * Fired when the close (x) is clicked
     * @param {Event} event
     */
    closeClicked: function(event) {
        if (_.isFunction(this.onClose)) {
            this.onClose();
        }
        app.alert.dismiss(this.key);
    },
    /**
     * Gets the HTML string for alert given options.
     *
     * @param {Object} options The options object passed to the alert object when it was
     *   created. See {@link #initialize} documentation to know the available
     *   options.
     * @param {Object} [templateOptions] Optional template options to be passed
     *   to the template.
     * @return {string} The generated template.
     * @private
     */
    _getAlertTemplate: function(options, templateOptions) {
        var template;
        var level = options.level;
        var alertClasses = this.getAlertClasses(level);
        var title = options.title || this.getDefaultTitle(level);

        switch (level) {
            case this.LEVEL.PROCESS:
                //Cut ellipsis at the end of the string
                title = title.substr(-3) === '...' ? title.substr(0, title.length - 3) : title;
                template = app.template.getView(this.name + '.process');
                break;
            case this.LEVEL.SUCCESS:
            case this.LEVEL.WARNING:
            case this.LEVEL.INFO:
            case this.LEVEL.ERROR:
                template = app.template.getView(this.name + '.error');
                break;
            case this.LEVEL.CONFIRMATION:
                template = app.template.getView(this.name + '.confirmation');
                break;
            default:
                template = app.template.empty;
        }
        var seed = _.extend({}, {
            alertClass: alertClasses,
            title: this.getTranslatedLabels(title),
            messages: this.getTranslatedLabels(options.messages),
            closeable: _.isUndefined(options.closeable) || options.closeable,
            alert: this
        }, templateOptions);
        return template(seed);
    },

    /**
     * Get CSS classes given alert level
     * @param {String} level
     * @return {String}
     */
    getAlertClasses: function(level) {
        switch (level) {
            case this.LEVEL.PROCESS:
                return 'alert-process';
            case this.LEVEL.SUCCESS:
                return 'alert-success';
            case this.LEVEL.WARNING:
                return 'alert-warning';
            case this.LEVEL.INFO:
                return 'alert-info';
            case this.LEVEL.ERROR:
                return 'alert-danger';
            case this.LEVEL.CONFIRMATION:
                return 'alert-warning';
            default:
                return '';
        }
    },

    /**
     * Get the default title given alert level
     * @param {String} level
     * @return {String}
     */
    getDefaultTitle: function(level) {
        switch (level) {
            case this.LEVEL.PROCESS:
                return 'LBL_ALERT_TITLE_LOADING';
            case this.LEVEL.SUCCESS:
                return 'LBL_ALERT_TITLE_SUCCESS';
            case this.LEVEL.WARNING:
                return 'LBL_ALERT_TITLE_WARNING';
            case this.LEVEL.INFO:
                return 'LBL_ALERT_TITLE_NOTICE';
            case this.LEVEL.ERROR:
                return 'LBL_ALERT_TITLE_ERROR';
            case this.LEVEL.CONFIRMATION:
                return 'LBL_ALERT_TITLE_WARNING';
            default:
                return '';
        }
    },

    /**
     * Return translated text, given a string or an array of strings.
     * @param {String/Array} stringOrArray
     * @return {String/Array}
     */
    getTranslatedLabels: function(stringOrArray) {
        var result;

        if (_.isArray(stringOrArray)) {
            result = _.map(stringOrArray, function(text) {
                return new Handlebars.SafeString(app.lang.get(text));
            });
        } else {
            result = new Handlebars.SafeString(app.lang.get(stringOrArray));
        }

        return result;
    },

    /**
     * Remove br tags after alerts which are needed to stack alerts vertically.
     */
    close: function() {
        this.unbindCancelAndReturn();
        this.$el.next('br').remove();
        this.dispose();
    },

    /**
     * Used by confirmation alerts so pressing `Esc` will Cancel, pressing
     * `Return` will Confirm
     */
    bindCancelAndReturn: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'Alert:Confirm',
            'Alert:Cancel'
        ], this);

        app.shortcuts.register('Alert:Confirm', ['enter'], function() {
            this.$('[data-action=confirm]').click();
        }, this);

        app.shortcuts.register('Alert:Cancel', ['esc'], function() {
            this.$('[data-action=cancel]').click();
        }, this);
    },

    /**
     * Unbind keydown event
     */
    unbindCancelAndReturn: function() {
        if (this.level === 'confirmation') {
            app.shortcuts.restoreSession();
        }
    },

    /**
     * @override
     */
    bindDataChange: function() {
    }
}) },
"dnb-bal-params": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dnb-bal-params View (base) 

    extendsFrom: 'DnbView',

    plugins: ['ErrorDecoration', 'Tooltip'],

    events: {
        'change [name="dnb_bal_sale"]': 'toggleFormControls',
        'change [name="dnb_bal_founding"]': 'toggleFormControls',
        'change [name="dnb_bal_offer_amt"]': 'toggleFormControls',
        'change [name="dnb_bal_ipo_price_range"]': 'toggleFormControls',
        'change [name="dnb_bal_ipo_date"]': 'toggleFormControls',
        'change [name="dnb_bal_emp_cnt"]': 'toggleFormControls',
        'change [name="dnb_bal_net_income"]': 'toggleFormControls',
        'change [name="dnb_bal_net_income_growth"]': 'toggleFormControls',
        'change [name="dnb_bal_assets"]': 'toggleFormControls',
        'change [name="dnb_bal_emp_grwth"]': 'toggleFormControls',
        'change [name="dnb_bal_mkt_cap"]': 'toggleFormControls',
        'change [name="dnb_bal_ipo_date_option_bef_aft"]': 'toggleFormControls',
        'click .dnb-bal-add-btn': 'populateTagContainer',
        'click .tagcontainer .select2-search-choice-close': 'removeTag',
        'change [name="dnb_bal_ctry"]': 'mapSelect2Params',
        'change [name="dnb_bal_prescreen_score"]': 'mapSelect2Params',
        'change [name="dnb_bal_job_fn"]': 'mapSelect2Params',
        'change [name="dnb_bal_ind_code_type"]': 'modifyIndustryModel',
        'change [name="dnb_bal_cntct_filter"]': 'setBalFilter',
        'shown #dnb_bal_accordian': 'handlePanelShown',
        'hidden #dnb_bal_accordian': 'handlePanelHidden',
        'mouseenter [rel="tooltip"]': 'showTooltip',
        'mouseleave [rel="tooltip"]': 'hideTooltip'
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.balSelector = options.meta.balSelector;
        this.balParamGroups = options.meta.balParamGroups;
        app.events.register('dnbbal:invoke', this);
        app.error.errorName2Keys['comparison'] = 'ERR_DNB_BAL_COMPARISON';
        app.error.errorName2Keys['taglimit'] = 'LBL_DNB_BAL_PARAM_LIMIT_ERR';
        this.modelAttr = _.pluck(this.balSelector, 'modelKey');
        //add validation
        this.model.addValidationTask('comparison_check', _.bind(this._doValidateComparison, this));
        var fields = {};
        _.each(_.pluck(options.meta.panels,'rows'), function(rowObj) {
            _.each(rowObj, function(fieldsList) {
                _.each(_.flatten(fieldsList.fields), function(fieldObj) {
                    fields[fieldObj.name] = fieldObj;
                    if (!_.isUndefined(fieldObj.tooltip)) {
                        fieldObj.tooltip = app.lang.get(fieldObj.tooltip);
                    }
                });
            });
        });
        this.moduleFields = fields;
        var moduleNumber = 1;
        _.each(options.meta.panels, function(panelItem) {
            panelItem.moduleNumber = moduleNumber++;
        }, this);
        app.events.register('dnbbal:param:add', this);
        app.events.register('dnbbal:param:remove', this);
        app.events.register('dnbbal:param:err', this);
        this.layout.on('dnbbal:param:add', this.setPanelComplete, this);
        this.layout.on('dnbbal:param:remove', this.setPanelIncomplete, this);
        this.layout.on('dnbbal:param:err', this.alertValidationError, this);
        this.layout.on('dnbbal:param:clear', this.clearParams, this);
        //initializing tag templates
        this.tagTmpl1 = app.template.get(this.name + '.tagtmpl1');
        this.tagTmpl2 = app.template.get(this.name + '.tagtmpl2');
    },

    loadData: function() {
        this.title = this.meta.title;
        this.render();
    },

    /**
     * when opening a panel make it active
     * @param {Object} event
     */
    handlePanelShown: function(event) {
        this.$(event.target).siblings('div').addClass('active');
        var paramHeader = this.$(event.target).siblings('div').children('.dnb-params-header');
        this.$(paramHeader).addClass('hide');
    },

    /**
     * when closing a panel:
     * @param {Object} event
     * 1. Remove class active from accordion-heading
     * 2. If parameters are set display them in panel header
     */
    handlePanelHidden: function(event) {
        this.$(event.target).siblings('div').removeClass('active');
        var paramGrpKey = this.$(event.target).data('paramgrp');
        if (this.balParamGroups[paramGrpKey]) {
            var paramGrp = this.balParamGroups[paramGrpKey],
                panelHeader = [],
                tempStr;
            //get only this parameters that are set to the model
            var setParamKeys = _.filter(_.keys(paramGrp), function(paramKey) {
                return this.model.has(paramKey);
            }, this);
            _.each(setParamKeys, function(paramKey) {
                //if id is present it must be a tagContainer
                if (paramGrp[paramKey].id) {
                    if (paramGrp[paramKey].label) {
                        tempStr = app.lang.get(paramGrp[paramKey].label) + ':' + this.model.get(paramKey + 'Tags');
                    } else {
                        //if label is not set we need to set it based on user selection for industry
                        var industryCodeType = this.model.get(paramKey).IndustryCodeTypeCode,
                            industryLabel;
                        //If industryCodeType is 3599 then mark it as SIC Industry Code or if it is 700 mark it as NAICS code
                        if (industryCodeType === '3599') {
                            industryLabel = app.lang.get('LBL_DNB_BAL_SIC');
                        } else if (industryCodeType === '700') {
                            industryLabel = app.lang.get('LBL_DNB_BAL_NAICS');
                        }
                        tempStr = industryLabel + ':' + this.model.get(paramKey + 'Tags');
                    }
                } else if (paramGrp[paramKey].select2) {
                    //if select2 is present then get the tags
                    var selector = '[name="' + paramGrp[paramKey].select2 + '"]';
                    var select2Data = this.$(selector).select2('data'),
                        selectedData;
                    //this is when we have a drop down with multiple selection options
                    if (_.isArray(select2Data)) {
                        selectedData = _.map(select2Data, function(selectedObj) {
                            return selectedObj.text;
                        }, this);
                        tempStr = app.lang.get(paramGrp[paramKey].label) + ':' + selectedData.join(',');
                    } else {
                        //this is when we have a drop down with a single select options
                        selectedData = select2Data.text;
                        tempStr = app.lang.get(paramGrp[paramKey].label) + ':' + selectedData;
                    }
                }
                panelHeader.push(tempStr);
            }, this);
            if (panelHeader.length > 0) {
                var panelHeaderStr = ' : ' + panelHeader.join(' , '),
                    paramHeader = this.$(event.target).siblings('div').children('.dnb-params-header');
                this.$(paramHeader).removeClass('hide').text(panelHeaderStr);
            }
        }
    },

    /**
     * show / hide input box when the 'between' value of
     * drop down is selected
     * @param {Object} event
     */
    toggleFormControls: function(event) {
        var selector = event.currentTarget.name;
        if (selector) {
            var formControls = this.$('[name="' + selector + '"]').closest('.record-cell').siblings('.toggleCandidate');
            _.each(formControls, function(frmCntrl) {
               //Remove or hide class if "Between" is selected or unselected in the dropdown
                if (event.val === 'btw') {
                    this.$(frmCntrl).removeClass('hide');
                } else {
                    this.$(frmCntrl).addClass('hide');
                }
            }, this);
        }
    },

    /**
     * populates the tagcontainer with user criteria
     * @param {Object} event
     */
    populateTagContainer: function(event) {
        //get the balSelector key from the data-event property
        //balSelector key has all the meta information
        var balSelectorName = this.$(event.currentTarget).data('event');
        if (balSelectorName) {
            var paramMeta = this.balSelector[balSelectorName];
            //this loop is for greater than equal to like operators
            if (_.isString(paramMeta.operator)) {
                //this is for greater than equal to like operators
                this.handleComparisonOperator(paramMeta);
            } else if (_.isString(paramMeta.modelSubKey)) {
                //this loop is for parameter that are free form text like
                //DUNS, zip codes etc
                this.handleFreeFormTags(paramMeta);
            } else if (_.isArray(paramMeta.operator)) {
                this.handleMiscOperators(paramMeta);
            }
        }
    },

    /**
     * Append tags to container
     * //TODO: use select2 instead
     * @param {String} tagId
     * @param {String} tagText
     * @param {String} contSlct tagcontainer selector
     * @param {String} tmpl hbs template
     * @param {String} tagParent
     */
    appendTag: function(tagId, tagText, contSlct, tmpl, tagParent) {
        var compiledTmpl = tmpl({
            'tagText': tagText,
            'tagId': tagId,
            'tagParent': tagParent
        });
        this.$(contSlct).append(compiledTmpl);
    },

    /**
     * Enable green check box on panel
     * @param {String} selector
     */
    setPanelComplete: function(selector) {
        if (!this.$(selector).hasClass('complete')) {
            this.$(selector).addClass('complete');
        }
    },

    /**
     * Remove tags from the tag container
     * //TODO: use select2 instead
     * @param {Object} event
     */
    removeTag: function(event) {
        var selector = event.currentTarget,
            tagContainer = '#' + this.$(selector).closest('ul').attr('id');
        var modelKey = this.$(selector).siblings('div').attr('id'),
            parentKey = this.$(selector).siblings('div').data('parentkey'),
            triggerParam;
        if (selector) {
            this.$(selector).closest('li').remove();
        }
        if (this.model.has(modelKey)) {
            this.model.unset(modelKey);
            triggerParam = modelKey;
        } else {
            //this part of the code is to handle the case where the model
            // is an object with multiple attributes
            //each model key is an attribute
            var modelAttr = _.clone(this.model.get(parentKey));
            var tagCount = this.$(tagContainer).children().length;
            if (tagCount === 0) {
                this.model.unset(parentKey);
                triggerParam = parentKey;
            } else {
                delete modelAttr[modelKey];
                this.model.set(parentKey, modelAttr);
                triggerParam = modelKey;
            }
        }
        var tags = _.map(this.$(tagContainer).children(), function(tag) {
            return this.$(tag).children('div').text().trim();
        }, this);
        if (tags.length > 0) {
            this.model.set(parentKey + 'Tags', tags.join(','));
        } else {
            this.model.unset(parentKey + 'Tags');
        }
        this.triggerBAL();
        this.layout.trigger('dnbbal:param:remove', triggerParam);
    },

    /**
     * Disable green check box on panel
     * @param {String} modelKey
     */
    setPanelIncomplete: function(modelKey) {
        var disablePanelFlag = false, selector;
        //iterate thru the parameter groups and identify
        //which group the modelKey belongs to
        var paramGrp = _.find(_.keys(this.balParamGroups), function(paramGrpKey) {
            return _.has(this.balParamGroups[paramGrpKey], modelKey);
        }, this);
        if (this.balParamGroups[paramGrp]) {
            //within that paramGrp check if the
            //other parameters are set on the model
            //if no then set the panel as incomplete
            disablePanelFlag = _.find(_.keys(this.balParamGroups[paramGrp]), function(paramKey) {
                return this.model.has(paramKey);
            }, this);
            var balParamMeta = this.balParamGroups[paramGrp][modelKey];
            if (balParamMeta.id) {
                selector = this.$('#' + balParamMeta.id).closest('.accordion-body').siblings('div').children('.step-circle');
            } else if (balParamMeta.select2) {
                var select2Selector = '[name="' + balParamMeta.select2 + '"]';
                selector = this.$(select2Selector).closest('.accordion-body').siblings('div').children('.step-circle');
            }
            //if there are no other parameters in this param group set to model
            //then treat that accordion as incomplete
            if (_.isUndefined(disablePanelFlag) && this.$(selector).hasClass('complete')) {
                this.$(selector).removeClass('complete');
            }
        }
    },

    /**
     * Maps the select2 parameters to API request parameters
     * @param {Object} event
     */
    mapSelect2Params: function(event) {
        var modelMeta = this.balSelector[$(event.target).attr('name')] || {};
        var modelKey = modelMeta.modelKey,
            modelSubKey = modelMeta.modelSubKey,
            modelAttr;
        if (this.model.has(modelKey)) {
            modelAttr = _.clone(this.model.get(modelKey));
        } else {
            modelAttr = {};
        }
        if (event.added) {
            var paramIndex;
            //check if model has modelKey
            if (_.isEmpty(modelAttr)) {
                paramIndex = 1;
            } else {
                paramIndex = _.keys(modelAttr).length + 1;
            }
            //add data to modelKey
            if (modelMeta.multiple) {
                modelAttr[modelSubKey + paramIndex] = event.added.id;
            } else {
                modelAttr[modelSubKey] = event.added.id;
            }
        } else if (event.removed) {
            //remove the data from model
            var removedData = event.removed.id;
            //to do make this code more efficient
            _.each(modelAttr, function(value, key) {
                if (value === removedData) {
                    delete modelAttr[key];
                }
            }, this);
        }
        var accordionHeader = this.$(event.target).closest('.accordion-body').siblings('.accordion-heading').children('.step-circle');
        if (!_.isEmpty(modelAttr)) {
            this.model.set(modelKey, modelAttr);
            this.layout.trigger('dnbbal:param:add', accordionHeader);
        } else {
            this.model.unset(modelKey);
            this.layout.trigger('dnbbal:param:remove', modelKey);
        }
        this.triggerBAL();
        this.showSidePanel();
    },

    /**
     * Get user confirmation to change industry type code
     */
    modifyIndustryModel: function() {
        //check if model has industryCode
        if (this.model.has('industryCode')) {
            //warn user
            app.alert.show('dnb-industry-warning', {
                level: 'confirmation',
                title: 'LBL_WARNING',
                messages: 'LBL_DNB_BAL_INDUSTRY_WARN',
                onConfirm: _.bind(function() {
                    //if user says yes clear earlier parameters and tagcontainer
                    //clear the industryCode from model
                    this.model.unset('industryCode');
                    //clear the industryCode tags
                    this.model.unset('industryCodeTags');
                    this.$('#dnb-ind-code-tags').empty();
                }, this),
                onCancel: _.bind(function() {
                    //else do not allow the industryCode to be changed
                    var changedIndustryCode = this.model.get('dnb_bal_ind_code_type');
                    //If industryCodeType is 3599 then mark it as SIC Industry Code or if it is 700 mark it as NAICS code
                    if (changedIndustryCode === '3599') {
                        this.model.set('dnb_bal_ind_code_type', '700');
                    } else if (changedIndustryCode === '700') {
                        this.model.set('dnb_bal_ind_code_type', '3599');
                    }
                }, this)
            });
        }
    },

    /**
     * Validate and handle comparison operators
     * this is for greater than equal to like operators
     * @param {Object} paramMeta
     */
    handleComparisonOperator: function(paramMeta) {
        var tagCount = this.$(paramMeta.container).children().length;
        if (tagCount < paramMeta.tagLimit) {
            var fields = {};
            var operatorKey = paramMeta.operator;
            fields[operatorKey] = this.moduleFields[operatorKey];
            fields[operatorKey].objType = 'operator';
            fields[paramMeta.upperLimit] = this.moduleFields[paramMeta.upperLimit];
            fields[paramMeta.upperLimit].objType = 'upperLimit';
            fields[paramMeta.upperLimit].required = true;
            if (this.model.get(operatorKey) === 'btw') {
                fields[paramMeta.lowerLimit] = this.moduleFields[paramMeta.lowerLimit];
                fields[paramMeta.lowerLimit].required = true;
                fields[paramMeta.lowerLimit].objType = 'lowerLimit';
            }
            this.model.doValidate(fields, _.bind(function(isValid) {
                if (isValid) {
                    this.mapComparisonToApi(paramMeta);
                } else {
                    this.layout.trigger('dnbbal:param:err');
                }
            }, this));
        } else {
            //throw tag limit error
            this.layout.trigger('dnbbal:param:err', 'taglimit');
        }
    },

    /**
     * called post validation
     * Maps comparison operator inputs to D&B API parameters
     * @param {Object} paramMeta meta data of paramters
     */
    mapComparisonToApi: function(paramMeta) {
        var modelAttr = {}, modelKey = paramMeta.modelKey;
        this.clearValidationErrors(this.moduleFields);
        //if validation succeeds add it to model
        var operator = this.model.get(paramMeta.operator),
            upperLimit = this.model.get(paramMeta.upperLimit),
            lowerLimit = this.model.get(paramMeta.lowerLimit),
            operatorSelector = '[name="' + paramMeta.operator + '"]',
            lowKey, highKey;
        if (paramMeta.keyType) {
            var keyType = this.model.get(paramMeta.keyType);
            lowKey = paramMeta[keyType].lowKey;
            highKey = paramMeta[keyType].highKey;
        } else {
            lowKey = paramMeta.lowKey;
            highKey = paramMeta.highKey;
        }
        var tagText = this.$(operatorSelector).select2('data').text;
        // Check operator for gte => 'Greater than or Equal to' or lte => 'Lesser than or Equal to' or btw => 'Between'
        if (operator === 'btw') {
            tagText = tagText + ' ' + lowerLimit + ' ' + app.lang.get('LBL_DNB_AND') + ' ' + upperLimit;
            modelAttr[lowKey] = lowerLimit;
            modelAttr[highKey] = upperLimit;
        } else {
            tagText = tagText + ' ' + upperLimit;
            if (operator === 'lte') {
                modelAttr[highKey] = upperLimit;
            } else if (operator === 'gte') {
                modelAttr[lowKey] = upperLimit;
            }
        }
        this.model.set(modelKey + 'Tags', tagText);
        this.appendTag(modelKey, tagText, paramMeta.container, this.tagTmpl1);
        this.model.set(modelKey, modelAttr);
        this.triggerBAL();
        this.showSidePanel();
        var accordionHeader = this.$(paramMeta.container).closest('.accordion-body').siblings('.accordion-heading').children('.step-circle');
        this.layout.trigger('dnbbal:param:add', accordionHeader);
        this.model.unset(paramMeta.upperLimit);
        this.model.unset(paramMeta.lowerLimit);
    },

    /**
     * Validate comparison operators
     * @param {Object} fields
     * @param {Object} errors
     * @param {Function} callback
     */
    _doValidateComparison: function(fields, errors, callback) {
        errors = {};
        var comparisonField = _.find(fields, function(fieldObj) {
            return fieldObj.objType === 'operator';
        });
        if (!_.isUndefined(comparisonField)) {
            var comparisonType = this.model.get(comparisonField.name);
            var upperLimitField = _.find(fields, function(fieldObj) {
                return fieldObj.objType === 'upperLimit';
            });
            var upperLimit = this.model.get(upperLimitField.name);
            //check for empty field
            if (_.isUndefined(upperLimit)) {
                errors[upperLimitField.name] = errors[upperLimitField.name] || {};
            }
            if (comparisonType === 'btw') {
                //if operator === btw (between)
                var lowerLimitField = _.find(fields, function(fieldObj) {
                    return fieldObj.objType === 'lowerLimit';
                });
                var lowerLimit = this.model.get(lowerLimitField.name);
                //check for empty field
                if (_.isUndefined(lowerLimit)) {
                    errors[lowerLimitField.name] = errors[lowerLimitField.name] || {};
                } else if (lowerLimit >= upperLimit) {
                    errors[lowerLimitField.name] = errors[lowerLimitField.name] || {};
                    errors[lowerLimitField.name].comparison = true;
                }
            }
        }
        callback(null, fields, errors);
    },

    /**
     * Validate and handle free form text operators
     * @param {Object} paramMeta
     */
    handleFreeFormTags: function(paramMeta) {
        //this loop is for parameter that are free form text like
        //DUNS, zip codes etc
        var tagCount = this.$(paramMeta.container).children().length;
        if (tagCount < paramMeta.tagLimit) {
            var fields = {};
            fields[paramMeta.inputKey] = this.moduleFields[paramMeta.inputKey];
            fields[paramMeta.inputKey].objType = 'freeform';
            this.model.doValidate(fields, _.bind(function(isValid) {
                if (isValid) {
                    this.mapFreeFormToApi(paramMeta, tagCount);
                } else {
                    this.layout.trigger('dnbbal:param:err');
                }
            }, this));
        } else {
            //throw tag limit error
            this.layout.trigger('dnbbal:param:err', 'taglimit');
        }
    },

    /**
     * Post validation maps free form tags to api parameters
     * @param {Object} paramMeta
     * @param {Number} tagCount
     */
    mapFreeFormToApi: function(paramMeta, tagCount) {
        var modelAttr = {}, tagText, modelKey = paramMeta.modelKey, tagIndex;
        this.clearValidationErrors(this.moduleFields);
        //setting tagIndex to tagCount + 1
        tagIndex = tagCount + 1;
        //obtain user input
        tagText = this.model.get(paramMeta.inputKey);
        var tagId = paramMeta.tagLimit > 1 ? paramMeta.modelSubKey + tagIndex : paramMeta.modelSubKey;
        //add tag with tag id to tag container
        this.appendTag(tagId, tagText, paramMeta.container, this.tagTmpl2, modelKey);
        //clearing the input box
        this.model.unset(paramMeta.inputKey);
        //get the list of tags in the tag container
        var tags = _.map(this.$(paramMeta.container).children(), function(tag) {
            return this.$(tag).children('div').text().trim();
        }, this);
        //set it to model
        // this will be used to summarize the criteria selected by user
        // when panel is collapsed
        this.model.set(modelKey + 'Tags', tags.join(','));
        //translates the user tags to D&B api parameters
        _.each(tags, function(tagItem, index) {
            var tagIndex = index + 1;
            if(paramMeta.tagLimit > 1) {
                modelAttr[paramMeta.modelSubKey + tagIndex] = tagItem;
            } else {
                modelAttr[paramMeta.modelSubKey] = tagItem;
            }
        }, this);
        this.model.set(modelKey, modelAttr);
        this.triggerBAL();
        this.showSidePanel();
        //setting the panel header as completer
        var accordionHeader = this.$(paramMeta.container).closest('.accordion-body').siblings('.accordion-heading').children('.step-circle');
        //triggering bal
        this.layout.trigger('dnbbal:param:add', accordionHeader);
    },

    /**
     * Trigger BAL event
     */
    triggerBAL: function() {
        var balAttr = _.intersection(this.modelAttr, _.keys(this.model.attributes)),
            balParams = {};
        if (balAttr.length === 1 && balAttr[0] === 'balFilter') {
            return;
        }
        _.each(balAttr, function(paramName) {
            var tmpAttr = this.model.get(paramName);
            if (!_.isUndefined(tmpAttr)) {
                _.each(_.keys(tmpAttr), function(key) {
                    balParams[key] = tmpAttr[key];
                });
            }
        }, this);
        this.trigger('dnbbal:invoke', balParams);
    },

    /**
     * Validate and handle free form text operators
     * @param {Object} paramMeta
     */
    handleMiscOperators: function(paramMeta) {
        //this loop is for parameter that are free form text like
        //DUNS, zip codes etc
        var tagCount = this.$(paramMeta.container).children().length;
        if (tagCount < paramMeta.tagLimit) {
            var fields = {};
            _.each(paramMeta.operator, function(operatorKey) {
                fields[operatorKey] = this.moduleFields[operatorKey];
            }, this);
            if (paramMeta.tagSource) {
                fields[paramMeta.tagSource] = this.moduleFields[paramMeta.tagSource];
            }
            this.model.doValidate(fields, _.bind(function(isValid) {
                if (isValid) {
                    this.mapMiscOperatorToApi(paramMeta, tagCount);
                } else {
                    this.layout.trigger('dnbbal:param:err');
                }
            },this));
        } else {
            //throw tag limit error
            this.layout.trigger('dnbbal:param:err', 'taglimit');
        }
    },

    /**
     * Maps misc operators to D&B api parameters
     * @param {Object} paramMeta
     * @param {Number} tagCount
     */
    mapMiscOperatorToApi: function(paramMeta, tagCount) {
        var modelAttr = {}, tagText, modelKey = paramMeta.modelKey, tagIndex;
        this.clearValidationErrors(this.moduleFields);
        //this loop is to handle cases where there are multiple
        //drop downs like sic code, postal radius, employee number
        //map operator selections to model subkeys
        _.each(paramMeta.operator, function(operatorKey, index) {
            modelAttr[paramMeta.modelSubKey[index]] = this.model.get(operatorKey);
        }, this);
        //if tagSource exists then we have to create multiple tags
        var tagSource, tagId;
        if (paramMeta.tagSource) {
            tagSource = paramMeta.tagSource;
            tagIndex = tagCount + 1;
            //get the data entered by the user
            tagText = this.model.get(tagSource);
            //creating an id for the tag
            //this will help in detecting if a tag is deleted
            tagId = paramMeta.tagDest + tagIndex;
        } else {
            tagSource = _.last(paramMeta.operator);
            tagText = this.model.get(tagSource);
            tagId = modelKey;
            //need different text for postal radius search
            if (modelKey === 'radiusSearch') {
                var tagTextParts = [];
                tagTextParts.push(this.model.get('dnb_bal_distance'));
                tagTextParts.push(this.$('[name="dnb_bal_distance_units"]').select2('data').text);
                tagTextParts.push(app.lang.get('LBL_DNB_FROM'));
                tagTextParts.push(tagText);
                tagText = tagTextParts.join(' ');
                this.model.unset('dnb_bal_distance');
            }
        }
        this.appendTag(tagId, tagText, paramMeta.container, this.tagTmpl2, modelKey);
        //clearing the input box
        this.model.unset(tagSource);
        var tags = _.map(this.$(paramMeta.container).children(), function(tag) {
            return this.$(tag).children('div').text().trim();
        }, this);
        //adding the list of tags to model
        //this is used to display when accordion is collapsed
        if (modelKey === 'radiusSearch') {
            this.model.set(modelKey + 'Tags', tagText);
        } else {
            this.model.set(modelKey + 'Tags', tags.join(','));
        }
        //this is for the case where the criteria can have multiple tags
        if (paramMeta.tagDest) {
            _.each(tags, function(tagItem, index) {
                var tagIndex = index + 1;
                //for industry codes we need to add a wildcard
                if (paramMeta.tagDest === 'IndustryCode-') {
                    tagItem = tagItem + '*';
                }
                modelAttr[paramMeta.tagDest + tagIndex] = tagItem;
            }, this);
        }
        this.model.set(modelKey, modelAttr);
        this.triggerBAL();
        this.showSidePanel();
        var accordionHeader = this.$(paramMeta.container).closest('.accordion-body').siblings('.accordion-heading').children('.step-circle');
        this.layout.trigger('dnbbal:param:add', accordionHeader);
    },

    /**
     * Alert validation errors
     * @param {String} errorType
     */
    alertValidationError: function(errorType) {
        var msg;
        if (_.isUndefined(errorType)) {
            //generic error message
            msg = app.lang.get('ERR_RESOLVE_ERRORS');
        } else {
            //specific error message
            msg = app.lang.get(app.error.errorName2Keys[errorType]);
        }
        app.alert.show('dnb-bal-param-warning', {
            level: 'error',
            messages: msg
        });
    },

    showTooltip: function(e) {
        this.$(e.currentTarget).tooltip('show');
    },

    hideTooltip: function(e) {
        this.$(e.currentTarget).tooltip('hide');
    },

    unbindDom: function() {
        // Unbind all tooltips on page
        this.$('[rel="tooltip"]').each(function() {
            $(this).tooltip('destroy');
        });
        unbindTooltips('[rel="tooltip"]');
        this._super('unbindDom');
    },

    /**
     * Clear all the parameters from model and tagContainers
     */
    clearParams: function() {
        _.each(this.balSelector, function(balSlctObj) {
            //clear tag containers
            if (balSlctObj.container) {
                this.$(balSlctObj.container).empty();
            }
        }, this);
        this.clearValidationErrors(this.moduleFields);
        this.$('.step-circle').removeClass('complete');
        //remove the summarized parameters from all panels
        this.$('.dnb-params-header').empty();
        this.model.clear();
        this.triggerBAL();
        this.loadData();
    },

    /**
     * To open side-pane in BAL page
     */
    showSidePanel: function(event) {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
	        defaultLayout.trigger('sidebar:toggle', true);
        }
    },

    /**
     * Set filters on BAL
     * @param {Object} event
     */
    setBalFilter: function(event) {
        var name = $(event.target).attr('name');
        if (name) {
            //meta data for filter
            var modelMeta = this.balSelector[name] || {};
            //modelKey  = key to be set on model eb. balFilter
            //modelSubKey = name of property on object set to modelKey on model eg. InclusionDataDescription-1
            //model will look like {'balFilter': {'InclusionDataDescription-1': 'filterValue'}}
            var modelKey = modelMeta.modelKey || null,
                modelSubKey = modelMeta.modelSubKey || null,
                modelAttr;
            //if the model already has the modelKey
            //then clone the object so that it can be modified
            if (!_.isNull(modelKey) && this.model.has(modelKey)) {
                modelAttr = _.clone(this.model.get(modelKey));
            } else {
                modelAttr = {};
            }
            //add the newly added filter
            if (event.added.id) {
                //try to lookup if the event.added.id is a valid value in the filter lookup
                var filterValue = modelMeta.lookup[event.added.id];
                if (_.isUndefined(filterValue)) {
                    //this loop aims at clearing the filter
                    _.each(modelAttr, function(value, key) {
                        if (key.indexOf(modelSubKey) !== -1) {
                            delete modelAttr[key];
                        }
                    });
                } else {
                    //add data to modelKey
                    //modelKeys can have multiple values
                    //eg. InclusionDataDescription-1, InclusionDataDescription-2 .. InclusionDataDescription-n
                    if (modelMeta.multiple) {
                        var paramIndex = 1;
                        //check if model has modelKey
                        if (!_.isEmpty(modelAttr)) {
                            _.each(modelAttr, function(value, key) {
                                if (key.indexOf(modelSubKey) !== -1) {
                                    paramIndex++;
                                }
                            });
                        }
                        modelAttr[modelSubKey + paramIndex] = filterValue;
                    } else {
                        modelAttr[modelSubKey] = filterValue;
                    }
                }
            } else if (event.removed.id) {
                //remove the data from model
                var removedData = event.removed.id;
                //to do make this code more efficient
                _.each(modelAttr, function(value, key) {
                    if (value === removedData) {
                        delete modelAttr[key];
                    }
                }, this);
            }
            if (!_.isEmpty(modelAttr)) {
                //modify the bal panel heading based on the change in model
                var accordionHeader = this.$(event.target).closest('.accordion-body').siblings('.accordion-heading').children('.step-circle');
                this.model.set(modelKey, modelAttr);
                this.layout.trigger('dnbbal:param:add', accordionHeader);
            } else {
                this.model.unset(modelKey);
                this.layout.trigger('dnbbal:param:remove', modelKey);
            }
            //check if parameters apart from the filter are set before triggering bal
            this.triggerBAL();
        }
    }
}) },
"list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListBottomView
 * @alias SUGAR.App.view.views.BaseListBottomView
 * @extends View.View
 */
({
	// List-bottom View (base) 

    events: {
        'click [data-action="show-more"]': 'showMoreRecords'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        // This component should always have a `list` action.
        this.action = 'list';

        /**
         * Label key used for {@link #showMoreLabel}.
         *
         * You can define it in metadata under `label` property. Defaults to
         * `TPL_SHOW_MORE_MODULE`.
         *
         * @type {string}
         * @private
         */
        this._showMoreLabel = this.meta && this.meta.label || 'TPL_SHOW_MORE_MODULE';
        this._initPagination();
    },

    /**
     * Initialize pagination component in order to react the show more link.
     * @private
     */
    _initPagination: function() {
        this.paginationComponent = _.find(this.layout._components, function(component) {
            return _.contains(component.plugins, 'Pagination');
        }, this);
    },

    /**
     * Retrieving the next page records by pagination plugin.
     *
     * Please see the {@link app.plugins.Pagination#getNextPagination}
     * for detail.
     */
    showMoreRecords: function() {
        if (!this.paginationComponent) {
            return;
        }

        var options = {};
        options.success = _.bind(function() {
            this.layout.trigger('list:paginate:success');
            // FIXME: This should trigger on `this.collection` instead of
            // `this.context`. Will be fixed as part of SC-2605.
            this.context.trigger('paginate');
            this.render();
        }, this);

        this.paginationComponent.getNextPagination(options);
        this.render();
    },

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More <module name>...".
     */
    setShowMoreLabel: function() {
        var model = this.collection.at(0);
        var module = model ? model.module : this.context.get('module');
        var context = {
            count: this.collection.length,
            offset: this.collection.next_offset >= 0
        };
        if (module) {
            context.module = new Handlebars.SafeString(app.lang.getModuleName(module, {plural: true}).toLowerCase());
        }

        /**
         * Label used in the template to display Show more message.
         *
         * By default it will display "More {module}...".
         *
         * @type {string}
         * @private
         */
        this.showMoreLabel = app.lang.get(this._showMoreLabel, module, context);
    },

    /**
     * Reset previous collection handlers and
     * bind the listeners for new collection.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, null, this);
        }
        this.collection = this.context.get('collection');
        this.collection.on('add remove reset', this.render, this);
        this.render();
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.setShowMoreLabel();
        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Bind listeners for collection updates.
     * The pagination link synchronizes its visibility with the collection's
     * status.
     */
    bindDataChange: function() {
        this.context.on('change:collection', this.onCollectionChange, this);
        this.collection.on('add remove reset', this.render, this);
    },

    /**
     * @inheritdoc
     *
     * Add dashlet placeholder's class in order to handle the custom css style.
     */
    show: function() {
        this._super('show');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.addClass('pagination');
    },

    /**
     * @inheritdoc
     *
     * Remove pagination custom CSS class on dashlet placeholder.
     */
    hide: function() {
        this._super('hide');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.removeClass('pagination');
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateView
 * @alias SUGAR.App.view.views.BaseMassupdateView
 * @extends View.View
 */
({
	// Massupdate View (base) 

    events: {
        'click [data-action="add"]' : 'addItem',
        'click [data-action="remove"]' : 'removeItem',
        'click .btn[name=update_button]' : 'saveClicked',
        'click .btn.cancel_button' : 'cancelClicked'
    },
    visible: false,
    fieldOptions: null,
    fieldValues: null,
    defaultOption: null,
    fieldPlaceHolderTag: '[name=fieldPlaceHolder]',
    massUpdateViewName: 'massupdate-progress',
    className: 'extend',
    plugins: ['Tooltip'],

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} mass_delete_chunk_size Number of records per chunk while
     *   performing mass delete.
     * - {Number} mass_update_chunk_size Number of records per chunk while
     *   performing mass update.
     * - {Number} max_records_to_merge Default number of records we can merge.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *     'mass_delete_chunk_size' => 20,
     *     'mass_update_chunk_size' => 20,
     *     'max_records_to_merge' => 5,
     *     //...
     * ),
     * //...
     * </code></pre>
     *
     * If 'mass_delete_chunk_size' or 'mass_update_chunk_size' aren't supplied
     * default values fallback to 'app.config.massDeleteChunkSize' and
     * 'app.config.massUpdateChunkSize' respectively.
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        max_records_to_merge: 5,
        mass_delete_chunk_size: 20,
        mass_update_chunk_size: 500
    },

    /**
     * @inheritdoc
     *
     * Try to find the `massupdate` template
     * falls back to `edit` when it does not exist
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     * Retrieves metadata from sugarTemplate and then able to override it from
     * the core metadata. `panels` will only be supported on the core metadata.
     *
     * Each module can override the massupdate default metadata definitions.
     * To do this, please use the following path:
     * `{custom/,}modules/{module}/clients/{platform}/view/massupdate/massupdate.php`
     *
     * Core massupdate metadata (non-module based) doesn't support the `panels` and
     * `fields` properties, since we don't support generic default fields to be added.
     * Keep that in mind when defining your metadata on:
     * `{custom/,}clients/{platform}/view/massupdate/massupdate.php`
     */
    initialize: function(options) {
        var genericMeta = _.omit(app.metadata.getView(null, options.name), 'panels');
        options.meta = _.extend(
            {},
            genericMeta,
            options.meta
        );
        this.fieldValues = [{}];
        this.setMetadata(options);

        this._super('initialize', [options]);
        this._initSettings();

        this.setDefault();

        this.delegateListFireEvents();
        this.before('render', this.isVisible);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before("route", this.beforeRouteDelete, this);
        $(window).on("beforeunload.delete" + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMassupdateView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = {};
        if (app.config.massActions) {
            if (app.config.massActions.massDeleteChunkSize) {
                configSettings.mass_delete_chunk_size = app.config.massActions.massDeleteChunkSize;
            }
            if (app.config.massActions.massUpdateChunkSize) {
                configSettings.mass_update_chunk_size = app.config.massActions.massUpdateChunkSize;
            }
        }

        this._settings = _.extend(
            {},
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    delegateListFireEvents: function() {
        this.layout.on("list:massupdate:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
        this.layout.on("list:massdelete:fire", this.warnDelete, this);
        this.layout.on("list:massexport:fire", this.massExport, this);
        this.layout.on("list:updatecalcfields:fire", this.updateCalcFields, this);
    },

    /**
     * Filter and patch the mass update fields.
     *
     * If the view definition contains an empty list of fields, it will pull all
     * the fields from the module metadata and add those with `massupdate = true`
     *
     * @param {Object} options The options object passed in 'initialize'.
     * @deprecated This will be removed on future versions.
     * Please see {@link view.fields.BaseBoolField} how you should define
     * your fields to be rendered on with a massupdate template.
     */
    //FIXME: remove this method when SC-2554 is implemented
    setMetadata: function(options) {
        var fieldList,
            massFields = [],
            metadataModule = app.metadata.getModule(options.module);
        if (!metadataModule) {
            app.logger.error('Failed to get module ' + options.module);
            return;
        }
        options.meta.panels = options.meta.panels || [{fields: []}];
        fieldList = metadataModule.fields;

        if (!_.isEmpty(options.meta.panels[0].fields)) {
            fieldList = _.map(options.meta.panels[0].fields, function(fieldDef) {
                var def = _.extend({}, fieldList[fieldDef.name], fieldDef);
                return def;
            });
        }
        _.each(fieldList, function(field) {
            // Only fields that are marked with massupdate set to true AND
            // that are not readonly should be used
            if (!field.massupdate || field.readonly) {
                return;
            }

            //we clone the metadata definition
            //to make sure we don't change the original metadata
            //FIXME we should not be faking metadata - (SC-2554)
            var cloneField = app.utils.deepCopy(field);
            cloneField.label = cloneField.label || cloneField.vname;
            if (cloneField.type === 'multienum') {
                cloneField.type = 'enum';
            }
            massFields.push(cloneField);
        });
        options.meta.panels[0].fields = massFields;
    },

    _render: function() {
        var result = app.view.View.prototype._render.call(this),
            self = this;

        if (this.$(".select2.mu_attribute")) {
            this.$(".select2.mu_attribute")
                .select2({
                    width: '100%',
                    minimumResultsForSearch: 5
                })
                .on("change", function(evt) {
                    var $el = $(this),
                        name = $el.select2('val'),
                        index = $el.data('index');
                    var option = _.find(self.fieldOptions, function(field){
                        return field.name == name;
                    });
                    self.replaceUpdateField(option, index);
                    self.placeField($el);
                });
            this.$(".select2.mu_attribute").each(function(){
                self.placeField($(this));
            });
        }

        if(this.fields.length == 0) {
            this.hide();
        }
        return result;
    },
    isVisible: function() {
        return this.visible;
    },
    placeField: function($el) {
        var name = $el.select2('val'),
            index = $el.data('index'),
            fieldEl = this.getField(name).$el;

        if($el.not(".disabled") && fieldEl) {
            var holder = this.$(this.fieldPlaceHolderTag + "[index=" + index + "]");
            this.$("#fieldPlaceHolders").append(holder.children());
            holder.html(fieldEl);
        }
    },
    addItem: function(evt) {
        if(!$(evt.currentTarget).hasClass("disabled")) {
            this.addUpdateField();
            // this will not be called in an async process so no need to
            // check for the view to be disposed
            this.render();
        }
    },
    removeItem: function(evt) {
        var index = $(evt.currentTarget).data('index');
        this.removeUpdateField(index);
        // this will not be called in an async process so no need to
        // check for the view to be disposed
        this.render();
    },
    addUpdateField: function() {
        this.fieldValues.splice(this.fieldValues.length - 1, 0, this.defaultOption);
        this.defaultOption = null;
        this.setDefault();
    },

    /**
     * Removes the field value at the provided index.
     *
     * @param {integer} index
     */
    removeUpdateField: function(index) {
        var fieldValue = this.fieldValues[index];

        if (_.isUndefined(fieldValue)) {
            return;
        }
        // If the fieldValue has a name, we need to remove it from the model and
        // the fieldValues object.
        if (fieldValue.name) {
            this.model.unset(fieldValue.name);
            // For relate fields, we need to clear fieldValue.id_name.
            // Note that if fieldValue.id_name is undefined, this is still safe.
            this.model.unset(fieldValue.id_name);
            this.fieldValues.splice(index, 1);
        // If the fieldValue does not have a name, reset the default option to
        // the last item, which should be empty
        } else {
            var removed = this.fieldValues.splice(index - 1, 1);
            this.defaultOption = removed[0];
        }

        // If there is a populate_list (i.e. this is a relate field)
        // clear the related data.
        // Fixme: This should be cleaned up on the relate field. See TY-651
        if (!_.isUndefined(fieldValue.populate_list)) {
            _.each(fieldValue.populate_list, function(key) {
                this.model.unset(key);
            }, this);
        }
        this.setDefault();
    },

    replaceUpdateField: function(selectedOption, targetIndex) {
        var fieldValue = this.fieldValues[targetIndex];

        if(fieldValue.name) {
            this.model.unset(fieldValue.name);
            this.fieldOptions.push(fieldValue);
            this.fieldValues[targetIndex] = selectedOption;
        } else {
            this.model.unset(this.defaultOption.name);
            this.fieldOptions.push(this.defaultOption);
            this.defaultOption = selectedOption;
        }
    },
    setDefault: function() {
        var assignedValues = _.pluck(this.fieldValues, 'name');
        if(this.defaultOption) {
            assignedValues = assignedValues.concat(this.defaultOption.name);
        }
        //remove the attribute options that has been already assigned
        this.fieldOptions = (this.meta) ? _.reject(_.flatten(_.pluck(this.meta.panels, 'fields')), function(field){
            return (field) ? _.contains(assignedValues, field.name) : false;
        }) : [];
        //set first item as default
        this.defaultOption = this.defaultOption || this.fieldOptions.splice(0, 1)[0];
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MassupdateProgress view component.
     */
    getProgressView: function() {
        var progressView = this.layout.getComponent(this.massUpdateViewName);
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                name: this.massUpdateViewName,
                layout: this.layout
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Create massupdate collection against the parent module.
     * Design the model synchronizing progressively.
     *
     * @param {String} baseModule parent module name.
     * @return {Backbone.Collection} Massupdate collection.
     */
    getMassUpdateModel: function(baseModule) {
        var massModel = this.context.get('mass_collection'),
            progressView = this.getProgressView(),
            massCollection = massModel ? _.extend({}, massModel, {
                defaultMethod: 'update',
                module: 'MassUpdate',
                baseModule: baseModule,

                /**
                 * Maximum number of retrial attempt.
                 *
                 * @property
                 */
                maxAllowAttempt: 3,

                /**
                 * Chunk for each execution.
                 *
                 * @property
                 */
                chunks: null,

                /**
                 * Discarded records due to the permission.
                 *
                 * @property
                 */
                discards: [],

                /**
                 * Current trial attempt number.
                 *
                 * @property
                 */
                attempt: 0,

                /**
                 * Pause status.
                 * If current job is on progress,
                 * the next queue will be paused.
                 *
                 * @property
                 */
                paused: false,

                /**
                 * Number of records per chunk, defaults to '20'.
                 *
                 * @property {Number} chunkSize Number of records.
                 * @protected
                 */
                 _chunkSize: 20,

                /**
                 * Number of update failures
                 *
                 * @property {Number} numFailures Number of failures.
                 * @protected
                 */
                 numFailures: 0,

                /**
                 * Set number of records per chunk.
                 *
                 * @param {Number} chunkSize Number of records.
                 */
                setChunkSize: function(chunkSize) {
                    this._chunkSize = parseInt(chunkSize, 10);
                },

                /**
                 * Reset mass job.
                 */
                resetProgress: function() {
                    massModel.reset();
                    this.length = 0;
                },

                /**
                 * Update current progress job.
                 */
                updateProgress: function() {
                    this.remove(this.chunks.splice(0));
                    massModel.length = this.length;
                },

                /**
                 * Update the next chunk queue.
                 */
                updateChunk: function() {
                    if (!this.chunks) {
                        this.chunks = this.slice(0, this._chunkSize);
                        this.trigger('massupdate:start');
                    }
                    if (_.isEmpty(this.chunks)) {
                        this.chunks = this.slice(0, this._chunkSize);
                    }
                },

                /**
                 * Resume the job from the previous paused status.
                 */
                resumeFetch: function() {
                    if (!this._pauseOptions) {
                        return;
                    }
                    this.paused = false;
                    this.trigger('massupdate:resume');
                    this.fetch(this._pauseOptions);
                },

                /**
                 * Request pausing mass job.
                 */
                pauseFetch: function() {
                    this.paused = true;
                },

                /**
                 * @inheritdoc
                 * Instead of fetching entire set,
                 * split entire set into small chunks
                 * and repeat fetching until entire set is completed.
                 */
                sync: function(default_method, model, options) {
                    if (model.paused) {
                        this._pauseOptions = options;
                        this.trigger('massupdate:pause');
                        return;
                    }
                    this.method = options.method;

                    //split set into chunks.
                    this.updateChunk();
                    var callbacks = {
                            success: function(data, response) {
                                model.numFailures += data.failed;
                                model.updateProgress();
                                model.trigger('massupdate:done');
                                if (model.length === 0) {
                                    model.trigger('massupdate:end');
                                    if (_.isFunction(options.success)) {
                                        //setting data to null since backbone reset will add the data object to the collection
                                        //using the respoonse as options for callback
                                        options.success(model, null, response);
                                    }
                                } else {
                                    model.fetch(options);
                                }
                            },
                            error: function(xhr, status, error) {
                                model.attempt++;
                                model.trigger('massupdate:fail');
                                if (model.attempt <= model.maxAllowAttempt) {
                                    model.fetch(options);
                                } else if (_.isFunction(options.error)) {
                                    model.trigger('massupdate:end');
                                    options.error(xhr, status, error);
                                }
                            },
                            complete: function(xhr, status) {
                                model.trigger('massupdate:always');
                                if (_.isFunction(options.complete)) {
                                    options.complete(xhr, status);
                                }
                            }
                    };
                    var method = options.method || this.defaultMethod;
                    var data = this.getAttributes(options.attributes, method);

                    if (_.isEmpty(data.massupdate_params.uid)) {
                        // No records to update, end the mass update.
                        model.trigger('massupdate:end');
                        return;
                    }
                    var url = app.api.buildURL(baseModule, this.module, data, options.params);
                    app.api.call(method, url, data, callbacks);
                },

                /**
                 * Convert collection attributes into MassUpdate API format.
                 * @param {Object} attributes Collection attributes.
                 * @return {Object} MassUpdate data format.
                 */
                getAttributes: function(attributes, action) {
                    return {
                        massupdate_params: _.extend({
                            'uid': this.getAvailableList(action)
                        }, attributes)
                    };
                },

                /**
                 * Check the access role for entire selection.
                 * Return only available model ids and store the discarded ids.
                 *
                 * @param action
                 * @return {Array} List of available model ids.
                 */
                getAvailableList: function(action) {
                    var action2permission = {
                            'update': 'edit',
                            'delete': 'delete'
                        },
                        list = [];
                    _.each(this.chunks, function(model) {
                        if (app.acl.hasAccessToModel(action2permission[action], model) !== false) {
                            list.push(model.id);
                        } else {
                            this.discards.push(model.id);
                        }
                    }, this);
                    return list;
                }
            }) : null;
        progressView.initCollection(massCollection);
        return massCollection;
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function() {
        this._modelsToDelete = this.getMassUpdateModel(this.module);
        this._modelsToDelete.setChunkSize(this._settings.mass_delete_chunk_size);

        this._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (this._targetUrl !== this._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        this.hideAll();

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE'),
            onConfirm: _.bind(this.deleteModels, this),
            onCancel: _.bind(function() {
                this._modelsToDelete = null;
                app.router.navigate(this._targetUrl, {trigger: false, replace: true});
            }, this)
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelsToDelete) {
            return app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE');
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModels: function() {
        var self = this,
            collection = self._modelsToDelete;
        var lastSelectedModels = _.clone(collection.models);
        if(collection) {
            // massupdate:end could be triggered without triggering success event on collection.
            // For example, when we user has no permissions to perform delete.
            // That's why we need to clear modelsToDelete when massupdate:end triggered too.
            collection.once('massupdate:end', function() {
                self._modelsToDelete = null;
            }, this);

            collection.fetch({
                //Don't show alerts for this request
                showAlerts: false,
                method: 'delete',
                error: function() {
                    app.alert.show('error_while_mass_update', {
                        level:'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                },
                success: function(data, response, options) {
                    self.layout.trigger("list:records:deleted", lastSelectedModels);
                    var redirect = self._targetUrl !== self._currentUrl;
                    if (options.status === 'done') {
                        //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                        //TODO: Need trigger for fetching new record list
                        self.layout.context.reloadData({showAlerts: false});
                    } else if (options.status === 'queued') {
                        app.alert.show('jobqueue_notice', {level: 'success', title: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED'), autoClose: true});
                    }
                    self._modelsToDelete = null;
                    if (redirect) {
                        self.unbindBeforeRouteDelete();
                        //Replace the url hash back to the current staying page
                        app.router.navigate(self._targetUrl, {trigger: true});
                    }
                }
            });
        }
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelsToDelete) {
            this.warnDelete(this._modelsToDelete);
            return false;
        }
        return true;
    },

    /**
     * Called to allow admins to resave records and update thier calculated fields.
     */
    updateCalcFields: function() {
        this.hideAll();
        this.save(true);
    },

    /**
     * Performs mass export on selected records
     */
    massExport: function() {
        this.hideAll();
        var massExport = this.context.get("mass_collection");

        if (massExport) {
            app.alert.show('massexport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

            app.api.exportRecords({
                    module: this.module,
                    uid: massExport.pluck('id')
                },
                this.$el,
                {
                    complete: function(data) {
                        app.alert.dismiss('massexport_loading');
                    }
                });
        }
    },

    /**
     * Called to start the massupdate process. Checks for validation errors
     * before sending down the modified attributes and starting the job queue.
     *
     * @param {Boolean} [forCalcFields=false] Causes the massupdate model to
     *   fetch with empty attributes, prior to saving the records.
     */
    save: function(forCalcFields) {
        forCalcFields = !!forCalcFields;
        var massUpdate = this.getMassUpdateModel(this.module),
            self = this;

        massUpdate.setChunkSize(this._settings.mass_update_chunk_size);

        this.once('massupdate:validation:complete', function(validate) {
            var errors = validate.errors,
                emptyValues = validate.emptyValues,
                confirmMessage = app.lang.get('LBL_MASS_UPDATE_EMPTY_VALUES'),
                attributes = validate.attributes || this.getAttributes();

            this.$(".fieldPlaceHolder .error").removeClass("error");
            this.$(".fieldPlaceHolder .help-block").hide();

            if (_.isEmpty(errors)) {
                confirmMessage += '<br>[' + emptyValues.join(',') + ']<br>' + app.lang.get('LBL_MASS_UPDATE_EMPTY_CONFIRM') + '<br>';
                if (massUpdate) {
                    var fetchMassupdate = _.bind(function() {
                        var successMessages = this.buildSaveSuccessMessages(massUpdate);
                        massUpdate.fetch({
                            //Show alerts for this request
                            showAlerts: true,
                            attributes: attributes,
                            error: function() {
                                app.alert.show('error_while_mass_update', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            },
                            success: function(data, response, options) {
                                self.hide();
                                if (options.status === 'done') {
                                    //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                                    //TODO: Need trigger for fetching new record list
                                    self.collection.fetch({
                                        //Don't show alerts for this request
                                        showAlerts: false,
                                        remove: true,
                                        // Boolean coercion.
                                        relate: !!self.layout.collection.link
                                    });
                                } else if (options.status === 'queued') {
                                    app.alert.show('jobqueue_notice', {level: 'success', messages: successMessages[options.status], autoClose: true});
                                }
                            }
                        });
                    }, this);
                    if (emptyValues.length === 0) {
                        fetchMassupdate.call(this);
                    } else {
                        app.alert.show('empty_confirmation', {
                            level: 'confirmation',
                            messages: confirmMessage,
                            onConfirm: fetchMassupdate
                        });
                    }
                }
            } else {
                this.handleValidationError(errors);
            }
        }, this);

        if (forCalcFields) {
            this.trigger('massupdate:validation:complete', {
                errors: [],
                emptyValues: [],
                attributes: {}
            });
        } else {
            this.checkValidationError();
        }
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * This is overridden by massaddtolist view which requires different success messages
     *
     * @param massUpdateModel - contains the attributes of what records are being updated (used by override in massaddtolist)
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        return {
            done: app.lang.get('LBL_MASS_UPDATE_SUCCESS'),
            queued: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED')
        };
    },

    /**
     * By default attributes are retrieved directly off the model, but broken out to allow for manipulation before handing off to the API
     */
    getAttributes: function() {
        var values = [this.defaultOption].concat(this.fieldValues),
            attributes = [],
            fieldFilter = function(field) {
                return field && field.name;
            };
        values = _.chain(values)
            //Grab the field arrays from any fields that have child fields
            //and merge them with the top level field list
            .union(_.chain(values)
                .pluck("fields")
                .compact()
                .flatten()
                .value()
            )
            //Remove any dupes or empties
            .uniq(fieldFilter)
            .filter(fieldFilter)
            .value();

        _.each(values, function(value) {
            attributes = _.union(attributes,
                _.values(_.pick(value, 'name', 'id_name'))
            );
            //FIXME: remove these hard coded conditions (SC-2836)
            if (value.name === 'parent_name') {
                attributes.push('parent_id', 'parent_type');
            } else if (value.name === 'team_name') {
                attributes.push('team_name_type');
            } else if (value.name === 'tag') {
                attributes.push('tag_type');
            } else if (value.isMultiSelect) {
                attributes.push(value.name + '_replace');
            }
        }, this);
        return _.pick(this.model.attributes, attributes);
    },

    /**
     * Get fields to validate.
     * @return {Object}
     * @private
     */
    _getFieldsToValidate: function() {
        var fields = _.initial(this.fieldValues).concat(this.defaultOption);
        return _.filter(fields, function(f) {
            return f.name;
        })
    },

    checkValidationError: function() {
        var self = this,
            emptyValues = [],
            errors = {},
            validator = {},
            i = 0;

        var fieldsToValidate = this._getFieldsToValidate();

        if (_.size(fieldsToValidate)) {
            _.each(fieldsToValidate, function(field) {
                i++;
                validator = {};
                validator[field.name] = field;
                field.required = (_.isBoolean(field.required) && field.required) || (field.required && field.required == 'true') || false;
                var value = this.model.get(field.name);
                // check if value represents emptiness
                if ((!_.isBoolean(value) && !value) || (_.isArray(value) && value.length === 0)) {
                    // If value is empty, but it's being appended, don't add it to empty values
                    // use == because the value may be a string
                    var appendCheck = this.model.get(field.name + '_type');
                    if (!appendCheck || appendCheck == 0) {
                        emptyValues.push(app.lang.get(field.label, this.model.module));
                        //don't set model if field is a relate collection
                        if (!field.relate_collection) {
                            this.model.set(field.name, '', {silent: true});
                            if (field.id_name) {
                                this.model.set(field.id_name, '', {silent: true});
                            }
                        }
                    }
                }
                this.model._doValidate(validator, errors, function(didItFail, fields, errors, callback) {
                    if (i === _.size(fieldsToValidate)) {
                        self.trigger('massupdate:validation:complete', {
                            errors: errors,
                            emptyValues: emptyValues
                        });
                    }
                });
            }, this);
        } else {
            this.trigger('massupdate:validation:complete', {
                errors: errors,
                emptyValues: emptyValues
            });
        }

        return;
    },
    handleValidationError: function(errors) {
        var self = this;
        _.each(errors, function (fieldErrors, fieldName) {
            var field = self.getField(fieldName);
            if (!_.isUndefined(field)) {
                var fieldEl = field.$el,
                    errorEl = fieldEl.find('.help-block');
                fieldEl.addClass('error');
                if(errorEl.length == 0) {
                    errorEl = $('<span>').addClass('help-block');
                    errorEl.appendTo(fieldEl);
                }
                errorEl.show().html('');
                _.each(fieldErrors, function (errorContext, errorName) {
                    errorEl.append(app.error.getErrorString(errorName, errorContext));
                });
            }
        });
    },
    show: function() {
        this.hideAll();
        this.visible = true;
        this.defaultOption = null;
        this.model.clear();
        var defaults = _.extend({}, this.model._defaults, this.model.getDefault());
        this.model.set(defaults);
        this.setDefault();

        var massModel = this.context.get('mass_collection');
        massModel.off(null, null, this);
        massModel.on('add remove reset massupdate:estimate', this.setDisabled, this);
        massModel.on('massupdate:start massupdate:end', this.setDisabledOnUpdate, this);

        // show will be called only on context.trigger("list:massupdate:fire").
        // therefore this should never be called in a situation in which
        // the view is disposed.
        this.$el.show();
        this.render();

        this.createShortcutSession();
        this.registerShortcuts();
    },
    /**
     * Hide all views that make up the list mass action section (ie. massupdate, massaddtolist)
     */
    hideAll: function() {
        this.layout.trigger("list:massaction:hide");
    },
    hide: function() {
        if (this.disposed) {
            return;
        }
        this.visible = false;
        this.$el.hide();

        this.clearAndRestorePreviousShortcuts();
    },
    /**
     * Create new shortcut session.
     */
    createShortcutSession: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'MassUpdate:Add',
            'MassUpdate:Remove',
            'MassUpdate:Cancel',
            'MassUpdate:Update'
        ], this);
    },
    /**
     * Register shortcuts for mass update inline drawer.
     */
    registerShortcuts: function() {
        app.shortcuts.register('MassUpdate:Add', '+', function() {
            this.$('[data-action=add]').last().click();
        }, this);
        app.shortcuts.register('MassUpdate:Remove', '-', function() {
            this.$('[data-action=remove]').last().click();
        },this);
        app.shortcuts.register('MassUpdate:Cancel', ['esc', 'ctrl+alt+l'], function() {
            this.$('a.cancel_button').click();
        }, this, true);
        app.shortcuts.register('MassUpdate:Update', ['ctrl+s', 'ctrl+alt+a'], function() {
            this.$('[name=update_button]:not(.disabled)').click();
        }, this, true);
    },
    /**
     * Clear shortcuts and restore previous shortcut session.
     */
    clearAndRestorePreviousShortcuts: function() {
        var activeShortcutSession = app.shortcuts.getCurrentSession();
        if (activeShortcutSession && (activeShortcutSession.layout === this)) {
            app.shortcuts.restoreSession();
        }
    },
    setDisabledOnUpdate: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.length == 0) {
            this.$('.btn[name=update_button]').removeClass('disabled');
        } else {
            this.$('.btn[name=update_button]').addClass('disabled');
        }
    },
    setDisabled: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.isEmpty() || massUpdate.fetched === false) {
            this.$('.btn[name=update_button]').addClass('disabled');
        } else {
            this.$('.btn[name=update_button]').removeClass('disabled');
        }
    },
    saveClicked: function(evt) {
        if(this.$(".btn[name=update_button]").hasClass("disabled") === false) {
            this.save();
        }
    },
    cancelClicked: function(evt) {
        this.hide();
    },
    unbindData: function() {
        var massModel = this.context.get("mass_collection");
        if (massModel) {
            massModel.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    _dispose: function() {
        this.unbindBeforeRouteDelete();
        this.$('.select2.mu_attribute').select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"sweetspot-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotResultsView
 * @alias SUGAR.App.view.views.BaseSweetspotResultsView
 * @extends View.View
 */
({
	// Sweetspot-results View (base) 

    className: 'sweetspot-results',
    tagName: 'ul',

    events: {
        'click a[href]': 'triggerHide',
        'click a[data-callback]': 'triggerAction'
    },

    /**
     * @inheritdoc
     *
     * - Listens to `sweetspot:results` on the layout to update the results.
     * - Listens to `keydown` on `window` to highlight an item.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * It serves as a helper for the navigation within the results.
         * Includes:
         *
         *  - {@link #actions}
         *  - {@link #keywords}
         *  - {@link #records}
         *
         * @property {Array}
         */
        this.results = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.records = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.actions = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.keywords = [];

        /**
         * Partial template for rendering a result row.
         *
         * @property {Function}
         */
        this._resultPartial = app.template.get(this.name + '.result');

        /**
         * Template for rendering the show more link.
         *
         * @property {Function}
         */
        this._showMoreTpl = app.template.get(this.name + '.showmore');

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         *
         * @property {number}
         */
        this.activeIndex = null;

        // Listens to new set of results and updates the different sections.
        this.layout.on('sweetspot:results', function(results) {
            // We want to highlight the same item that was highlighted before,
            // so first we get the result that was highlighted.
            var oldHighlighted = this.results[this.activeIndex];
            var options = _.pick(results, 'showMore', 'term');

            // Rendering different sections
            this.renderSection('actions', this._formatResults(results.actions));
            this.renderSection('records', this._formatResults(results.records), options);
            this.renderSection('keywords', this._formatResults(results.keywords));

            if (options.showMore) {
                // This is so we get the moveForward/moveBackward working
                // properly.
                this.records.push(options);
            }

            // Update with the new list of records.
            this.results = this.keywords.concat(this.actions).concat(this.records);

            var newActiveIndex;
            if (oldHighlighted) {
                // Try to find the old highlighted result in the new data set.
                _.find(this.results, function(result, index) {
                    var test;
                    if (oldHighlighted.id) {
                        test = oldHighlighted.id === result.id;
                    }
                    if (oldHighlighted.route) {
                        test = oldHighlighted.route === result.route;
                    }
                    if (test) {
                        // Once we found it, we actually want its new index.
                        newActiveIndex = index;
                        return true;
                    }
                });
            }
            // Sets the item that will be highlighted.
            this.activeIndex = newActiveIndex || 0;
            if (this.results.length) {
                this._highlightActive();
                this.layout.trigger('sweetspot:calc:resultsHeight');
            }
        }, this);

        // Listens to when sweet spot is opened to bind keydown event
        this.layout.on('show', function() {
            this.results = this.actions = this.records = this.keywords = [];
            $(window).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
            this.render();
        }, this);

        // Listens to when sweet spot is opened to unbind keydown event
        this.layout.on('hide', function() {
            $(window).off('keydown.' + this.cid);
        }, this);

        this.layout.on('sweetspot:results:adjustMaxHeight', this.setMaxHeight, this);
    },

    /**
     * Sets the max-height of the element.
     *
     * @param {number} maxHeight The max-height value.
     */
    setMaxHeight: function(maxHeight) {
        if (this.results.length) {
            this.$el.css('maxHeight', maxHeight);
        }
    },

    /**
     * Renders a specific section.
     *
     * - Only if the list of records for that section has changed.
     * - Shows the section if there is at least a record
     * - Hides the section if there are no records.
     *
     * @param {string} section The section name (can be `actions`, `keywords`
     *   or `records`).
     * @param {Array} results The list of results for that section.
     * @param {Object} [options] Custom rendering options per section.
     */
    renderSection: function(section, results, options) {
        options = options || {};
        var allowed = ['actions', 'keywords', 'records'];
        if (!_.contains(allowed, section)) {
            return;
        }
        if (_.isEqual(this[section], results)) {
            return;
        }
        var $section = this.$('[data-section="' + section + '"]');
        var $list = $section.find('ul');
        $list.empty();
        this[section] = results;
        if (results.length === 0) {
            $section.addClass('hide');
            $list.empty();
        } else {
            $section.removeClass('hide');
            _.each(results, function(result) {
                $list.append(this._resultPartial(result));
            }, this);
            if (options.showMore) {
                $list.append(this._showMoreTpl(options));
            }
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.activeIndex = 0;
        if (this.results.length) {
            this._highlightActive();
        }
    },

    /**
     * Formatter function for the list of results.
     *
     * @param {Array} results The list of actions/commands.
     * @return {Array} The formatted list of actions/commands.
     */
    _formatResults: function(results) {
        if (_.isEmpty(results)) {
            return [];
        }

        return results;
    },

    /**
     * Handle the keydown events.
     * @param {event} e The `keydown` event.
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 13: // enter
                this.triggerAction();
                break;
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                break;
            case 38: // up arrow
                this.moveBackward();
                e.preventDefault();
                break;
        }
    },

    /**
     * Hides the {@link View.Layouts.Base.SweetspotLayout sweet spot layout}.
     */
    triggerHide: function() {
        this.layout.hide();
    },

    /**
     * Triggers the action linked to the active element.
     *
     * Navigates to the view or calls the callback method.
     *
     * @param {Event} [evt] The `click` event.
     */
    triggerAction: function(evt) {
        if (_.isEmpty(this.results)) {
            return;
        }

        this.triggerHide();

        var $action = this.$('.active > a');
        var route = $action.attr('href');
        if (route) {
            app.router.navigate(route, {trigger: true});
        }

        var action;
        if (evt) {
            // When the user clicks on an action, we need to select that action
            // instead of the active one.
            action = this.$(evt.currentTarget).data('callback');
        } else {
            action = $action.data('callback');
        }

        if (action) {
            this.layout.triggerSystemAction(action);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nth = this.activeIndex;
        var $active = this.$('[data-sweetaction=true]:nth(' + nth + ')');
        $active.addClass('active');
        $active.find('a').focus();
        this.$el.prev().find('input').focus();
    },

    /**
     * Moves to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        this.activeIndex++;
        if (this.activeIndex < this.results.length) {
            // We're in bounds, just go to the next element in this view.
            this._highlightActive();
        } else {
            this.activeIndex = 0;
            this._highlightActive();
        }
    },

    /**
     * Moves to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            this.activeIndex = this.results.length - 1;
            this._highlightActive();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('keydown.' + this.cid);
        this._super('_dispose');
    }
}) },
"filter-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actions for {@link View.Views.Base.FilterRowsView}.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterActionsView
 * @alias SUGAR.App.view.views.BaseFilterActionsView
 * @extends View.View
 */
({
	// Filter-actions View (base) 

    events: {
        'change input': 'filterNameChanged',
        'keyup input': 'filterNameChanged',
        'click a.reset_button': 'triggerReset',
        'click a.filter-close': 'triggerClose',
        'click a.save_button:not(.disabled)': 'triggerSave',
        'click a.delete_button:not(.hide)': 'triggerDelete'
    },

    className: 'filter-header',

    /**
     * @type {Boolean} `true` if the button is enabled, `false` otherwise.
     */
    saveState: false,

    /**
     * @type {Boolean} Whether or not to display the filter action buttons.
     */
    showActions: true,

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);

        this.layout.on('filter:create:open', function(model) {
            this.toggle(model);
            var name = model ? model.get('name') : '';
            this.setFilterName(name);

            //shortcut keys
            app.shortcuts.register(
                'Filter:Close',
                ['esc', 'ctrl+alt+l'],
                function() {
                    this.$('a.filter-close').click();
                },
                this,
                true
            );
            app.shortcuts.register(
                'Filter:Save',
                ['ctrl+s', 'ctrl+alt+a'],
                function() {
                    this.$('a.save_button:not(.disabled)').click();
                },
                this,
                true
            );
            app.shortcuts.register('Filter:Delete', 'd', function() {
                this.$('a.delete_button:not(.hide)').click();
            }, this);
            app.shortcuts.register('Filter:Reset', 'r', function() {
                this.$('a.reset_button').click();
            }, this);
        }, this);

        this.listenTo(this.layout, 'filter:toggle:savestate', this.toggleSave);
        this.listenTo(this.layout, 'filter:set:name', this.setFilterName);
        this.listenTo(this.context, 'change:filterOptions', this.render);

        this.before('render', this.setShowActions, this);
    },

    /**
     * This function sets the `showActions` object on the controller.
     * `true` when `show_actions` is set to `true` on the `filterOptions`
     * object on the context (originating from filterpanel metadata),
     * `false` otherwise.
     */
    setShowActions: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        this.showActions = !!filterOptions.show_actions;
    },

    /**
     * Get the filter name.
     *
     * @return {String} The value of the input.
     */
    getFilterName: function() {
        var filterName = this.$('input').val();
        return filterName.trim();
    },

    /**
     * Shows or hides this view.
     *
     * This view will be hidden when the filter is a template that is populated
     * on the fly.
     *
     * @param {Data.Bean} filter The filter being edited.
     */
    toggle: function(filter) {
        this.$el.toggleClass('hide', !!filter.get('is_template'));
    },

    /**
     * Set input value and hide the delete button if we're clearing the name.
     *
     * @param {String} name The filter name.
     */
    setFilterName: function(name) {
        var input = this.$('input').val(name);
        //Call placeholder() because IE9 does not support placeholders.
        if (_.isFunction(input.placeholder)) {
            input.placeholder();
        }
        // We have this.context.editingFilter if we're setting the name.
        this.toggleDelete(!_.isUndefined(this.context.get('currentFilterId')));
    },

    /**
     * Fired when the filter name changed.
     *
     * @param {Event} event The `change` event.
     */
    filterNameChanged: _.debounce(function(event) {
        if (this.disposed || !this.context.editingFilter) {
            return;
        }

        var name = this.getFilterName();
        this.context.editingFilter.set('name', name);
        this.layout.trigger('filter:toggle:savestate', true);

        if (this.layout.getComponent('filter-rows')) {
            this.layout.getComponent('filter-rows').saveFilterEditState();
        }
    }, 200),

    /**
     * Toggle delete button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleDelete: function(enable) {
        this.$('.delete_button').toggleClass('hide', !enable);
    },

    /**
     * Toggle save button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleSave: function(enable) {
        this.saveState = _.isUndefined(enable) ? !this.saveState : !!enable;
        var isEnabled = this.getFilterName() && this.saveState;
        this.$('.save_button').toggleClass('disabled', !isEnabled);
    },

    /**
     * Handler for canceling form editing.
     *
     * First, it will revert model attributes (back to synced attributes), and
     * remove the current edit state.
     * Second,
     * - if the filter has changed, the collection is refreshed.
     * - if we were creating a new filter, the cached selected filter id is
     * cleared (so that we will get back to the default filter), otherwise we
     * just close the form.
     *
     * @triggers filter:apply to apply the previous filter definition.
     * @triggers filter:select:filter to switch back to the default filter.
     * @triggers filter:create:close to close the filter creation form.
     */
    triggerClose: function() {
        var filter = this.context.editingFilter,
            filterLayout = this.layout.getComponent('filter'),
            id = filter.get('id'),
            changedAttributes = filter.changedAttributes(filter.getSynced());
            filter.revertAttributes();

        filterLayout.clearFilterEditState();

        //Apply the previous filter definition if something has changed meanwhile
        if (changedAttributes && changedAttributes.filter_definition) {
            this.layout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterPanelLayout#filter:apply}.
                 */
                'filter:apply', null, filter.get('filter_definition'));
        }
        if (!id) {
            filterLayout.clearLastFilter(this.layout.currentModule, filterLayout.layoutType);
            filterLayout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterLayout#filter:select:filter}.
                 */
                'filter:select:filter', filterLayout.filters.collection.defaultFilterFromMeta);
            return;
        }
        this.layout.trigger(
            /**
             * @event
             * See {@link View.Layouts.Base.FilterLayout#filter:create:close}.
             */
            'filter:create:close');
    },

    /**
     * Call a method on filter-rows to reset filter values.
     */
    triggerReset: function() {
        this.layout.getComponent('filter-rows').resetFilterValues();
    },

    /**
     * Trigger `filter:create:save` to save the created filter.
     */
    triggerSave: function() {
        var filterName = this.getFilterName();
        this.context.trigger('filter:create:save', filterName);
    },

    /**
     * Trigger `filter:create:delete` to delete the created filter.
     */
    triggerDelete: function() {
        this.layout.trigger('filter:create:delete');
    }
}) },
"dnb-financial-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbFinancialInfoView
 * @alias SUGAR.App.view.views.BaseDnbFinancialInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-financial-info View (base) 

    extendsFrom: 'DnbView',
    duns_num: null,

    events: {
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadFinancials, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadFinancials, this);
    },

    loadData: function(options) {
        if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
        }
    },

    /**
     * D&B Finncial Response Data Dictionary
     * json_path -- refers to the json path to traverse to obtain the data element
     * label -- refers to the label to be used to name the data element
     * desc -- refers to the label used to describe the data element
     * case_fmt -- boolean -- when true specifies that this data element needs to be formatted to proper case
     * sub_array -- refers to meta data for nested json objects
     */
    financialDD: {
        'marketAnalysis' : {
            'json_path' : 'ThirdPartyAssessment.ThirdPartyAssessment.0.ThirdPartyInformation.OtherInformation',
            'label' : 'LBL_DNB_REC_MARK_ANALYSIS'
        },
        'finStmt' : {
            'json_path' : 'Financial.KeyFinancialFiguresOverview',
            'label' : 'LBL_DNB_FIN_STMT',
            'sub_array' : {
                'finStmtDate' : 'StatementHeaderDetails.FinancialStatementToDate.$',
                'salesRevenue' : 'SalesRevenueAmount.0.$',
                'salesUnits' : 'SalesRevenueAmount.0.@UnitOfSize'
            }
        },
        'stckSym' : {
            'json_path' : 'OrganizationDetail.ControlOwnershipTypeText.$',
            'label' : 'LBL_DNB_FIN_COMP_TYPE',
            'sub_array' : {
                'stckDet' : 'RegisteredDetail.StockExchangeDetails'
            }
        }
    },

    finConst: {
        'mktAnalysisPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.ThirdPartyAssessment.ThirdPartyAssessment.0.ThirdPartyInformation.OtherInformation',
        'finStmtPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.Financial.KeyFinancialFiguresOverview',
        'stckSymPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.RegisteredDetail.StockExchangeDetails',
        'ownTypePath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.OrganizationDetail.ControlOwnershipTypeText.$'
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated financial information from DNB service
     */
    refreshClicked: function() {
        this.loadFinancials(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadFinancials: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getCompanyFinancials, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Gets D&B Financial Information for the duns_num
     * @param  {String} duns_num
     */
    getCompanyFinancials: function(duns_num) {
        var self = this;
        self.template = app.template.get(self.name);
        if (!self.disposed) {
            self.render();
            self.$('#dnb-financials-loading').show();
            self.$('#dnb-financials-details').hide();
        }
        var cacheKey = 'dnb:financial:' + duns_num;
        if (app.cache.get(cacheKey)) {
            self.renderFinancialDetails.call(self, app.cache.get(cacheKey));
        } else {
            var dnbFinancialsURL = app.api.buildURL('connector/dnb/financial/' + duns_num, '', {},{});
            var resultData = {'product': null, 'errmsg': null};
            app.api.call('READ', dnbFinancialsURL, {},{
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        if (self.isDataExists(data)) {
                            resultData.product = data;
                        } else {
                            resultData.errmsg = app.lang.get('LBL_DNB_NO_DATA');
                        }
                        app.cache.set(cacheKey, resultData);
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderFinancialDetails.call(self, resultData);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     *  to prevent a blank dashlet from being displayed
     * @param {Object} financialDetails dnb financial details json
     * @return {Boolean}
     */
    isDataExists: function(financialDetails) {
        if (!this.checkJsonNode(financialDetails, this.finConst.mktAnalysisPath) &&
            !this.checkJsonNode(financialDetails, this.finConst.annlIncPath) &&
            !this.checkJsonNode(financialDetails, this.finConst.stckSymPath)) {
            return false;
        } else {
            return true;
        }
    },

    /**
     * Renders the financial details
     * @param {Object} financial details
     */
    renderFinancialDetails: function(financialDetails) {
        if (this.disposed) {
            return;
        }
        var formattedFinancials, dnbFin = {};
        if (financialDetails.product) {
            formattedFinancials = this.formatFinancials(financialDetails.product, this.financialDD);
            dnbFin.product = formattedFinancials;
        }
        if (financialDetails.errmsg) {
            dnbFin.errmsg = financialDetails.errmsg;
        }
        this.dnbFin = dnbFin;
        this.render();
        this.$('#dnb-financials-loading').hide();
        this.$('#dnb-financials-details').show();
        this.$('.showLessData').hide();
    },

    /**
     * Preprocessing financial information
     * @param  {Object} dnbApiResponse DNB API Response for Firmographics
     * @param  {Object} financialDD financials data dictionary
     * @return {Object}  to be passed to the hbs file
     */
    formatFinancials: function(dnbApiResponse, financialDD) {
        var frmtFinancials = {};
        var marketAnalysis = this.getJsonNode(dnbApiResponse, this.finConst.mktAnalysisPath),
            finStmt = this.getJsonNode(dnbApiResponse, this.finConst.finStmtPath),
            stckSym = this.getJsonNode(dnbApiResponse, this.finConst.stckSymPath);
        //formatting market analysis
        if (marketAnalysis) {
            frmtFinancials.marketAnalysis = marketAnalysis;
        }
        //formatting financial statements
        if (finStmt) {
            frmtFinStmtList = [];
            _.each(finStmt, function(finStmtObj) {
                var frmtFinStmt = null;
                _.each(financialDD.finStmt.sub_array, function(value, key) {
                    var dataElement = this.getJsonNode(finStmtObj, value);
                    if (dataElement) {
                        if (_.isNull(frmtFinStmt)) {
                            frmtFinStmt = {};
                        }
                        if (key === 'salesRevenue') {
                            dataElement = this.formatSalesRevenue(dataElement);
                        }
                        frmtFinStmt[key] = dataElement;
                    }
                },this);
                if (!_.isNull(frmtFinStmt)) {
                    frmtFinStmtList.push(frmtFinStmt);
                }
            },this);
            if (frmtFinStmtList.length > 0) {
                frmtFinancials.finStmt = frmtFinStmtList;
            }
        }
        //formatting stock symbols
        var ownerType = this.getJsonNode(dnbApiResponse, this.finConst.ownTypePath),
            frmtStckSymL = {};
        if (ownerType) {
            frmtStckSymL.ownerType = ownerType;
        }
        if (stckSym) {
            frmtStckSymL.stckSymList = stckSym;
        }
        if (frmtStckSymL.ownerType || frmtStckSymL.stckSymList) {
            frmtFinancials.stckSym = frmtStckSymL;
        }
        return frmtFinancials;
    }
}) },
"history": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * History dashlet takes advantage of the tabbed dashlet abstraction by using
 * its metadata driven capabilities to configure its tabs in order to display
 * historic information about specific modules.
 *
 * @class View.Views.Base.HistoryView
 * @alias SUGAR.App.view.views.BaseHistoryView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// History View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.filter Number of past days against
     *   which retrieved records will be filtered, supported values are '7',
     *   '30' and '90' days, defaults to '7'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        filter: 7,
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this._super('initialize', [options]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * Retrieves custom filters.
     *
     * @param {Integer} index Tab index.
     * @return {Array} Custom filters.
     * @protected
     */
    _getFilters: function(index) {
        var filterStr = app.date().subtract('days', this.settings.get('filter')).format('YYYY-MM-DD');

        var tab = this.tabs[index],
            filter = {},
            filters = [];

        filter[tab.filter_applied_to] = {$gte: filterStr};

        filters.push(filter);

        return filters;
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$('.select2').select2('destroy');

        this._super("_dispose");
    },

    /**
     * Open up a drawer to archive email.
     * @param event
     * @param params
     */
    archiveEmail: function(event, params) {
        var self = this;
        app.drawer.open({
            layout: 'archive-email',
            context: {
                create: true,
                module: 'Emails',
                prepopulate: {
                    related: this.model,
                    to_addresses: [{bean: this.model}]
                }
            }
        }, function(model) {
            if (model) {
                self.layout.reloadDashlet();
                self.context.parent.trigger('panel-top:refresh', 'emails');
                self.context.parent.trigger('panel-top:refresh', 'archived_emails');
            }
        });
    }
}) },
"activitystream-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamBottomView
 * @alias SUGAR.App.view.views.BaseActivitystreamBottomView
 * @extends View.View
 */
({
	// Activitystream-bottom View (base) 

    events: {
        'click [data-action=show-more]': 'paginate'
    },

    /**
     * Load list-bottom template.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        this.tplName = 'list-bottom';
        this.template = app.template.getView(this.tplName);
    },

    /**
     * Display appropriate label depending on the state of activity stream collection.
     * @inheritdoc
     */
    _renderHtml: function() {
        if ((this.collection.next_offset === -1) && (this.collection.length > 0)) {
            this.$el.addClass('hide');
        } else {
            this.dataFetched = this.collection.dataFetched;
            this.showMoreLabel = app.lang.get('TPL_SHOW_MORE_MODULE', this.module);
            this.showLoadMsg = true;
            this._super('_renderHtml');
            this.$el.removeClass('hide');
        }
    },

    /**
     * Re-render when activity stream is fetched.
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset add', this.render, this);
    },

    /**
     * Call to paginate activity stream.
     */
    paginate: function() {
        this.context.trigger('activitystream:paginate', true);
    }
}) },
"activitystream-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Activitystream-dashlet View (base) 

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet'],

    events: {
        'click .addComment' : 'addComment'
    },

    className: 'block filtered activitystream-layout',

    /**
     * The default settings for activity stream.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * Omnibar ActivityStream view
     */
    omnibarView: null,

    initialize: function(opts) {
        this.opts = opts;
        this.renderedActivities = {};

        var moduleMeta = app.metadata.getModule(opts.context.parent.get('module'));
        this.activityStreamEnabled = moduleMeta.activityStreamEnabled;
        if (this.activityStreamEnabled && this.activityStreamEnabled === true) {
            this.plugins.push('Pagination');
        }

        this._super('initialize', [opts]);

        this.setCollectionOptions();
        this.context.on('activitystream:post:prepend', this.prependPost, this);

        this.omnibarView = app.view.createView({
            context: this.context,
            name: 'activitystream-omnibar',
            module: this.module,
            layout: this
        });

        if (this.meta.config) {
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.layout.before('dashletconfig:save', this.saveDashletFilter, this);
        }
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function()
    {
        var options = {};
        var self = this;
        var refreshRate;

        options.limit = this.settings.get('limit') || this._defaultSettings.limit;
        this.settings.set('limit', options.limit);

        options.auto_refresh = this.settings.get('auto_refresh') || this._defaultSettings.auto_refresh;
        this.settings.set('auto_refresh', options.auto_refresh);

        options = _.extend({}, this.context.get('collectionOptions'), options);
        this.context.set('collectionOptions', options);

        // Set the refresh rate for setInterval so it can be checked ahead of
        // time.  60000 is 1000 miliseconds times 60 seconds in a minute.
        refreshRate = options.auto_refresh * 60000;

        // Only set up the interval handler if there is a refreshRate higher than 0
        if (refreshRate > 0) {
            if (this.timerId) {
                clearInterval(this.timerId);
            }
            this.timerId = setInterval(_.bind(function() {
                if (self.context) {
                    self.context.resetLoadFlag();
                    self.loadData();
                }
            }, this), refreshRate);
        }
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('asdashlet-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'asdashlet-filter'
        }]);
    },

    /**
     * Gets Filter Definition from metadata given a filter id
     */
    _getFilterDefFromMeta: function(id) {
        if (!id) {
            return;
        }

        var moduleMeta = app.utils.deepCopy(app.metadata.getModule('Activities'));
        if (_.isObject(moduleMeta)) {
            var filters = _.compact(_.flatten(_.pluck(_.compact(_.pluck(moduleMeta.filters, 'meta')), 'filters')));
            var filter = _.find(filters, function(filter) {
                return filter.id === id;
            }, this);

            if (filter) {
                return filter;
            }
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;

        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId = self.context.parent.get('modelId'),
                action = model.module, // equal to 'Activities'
                url;

            // For :Home/:record case we should call for global ActivityStream
            if (real_module == 'Home' && layoutType == 'record') {
                real_module = self.module;
                layoutType = 'activities';
            }

            switch (layoutType) {
                case 'activities':
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case 'records':
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case 'record':
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }

            return app.api.call('read', url, null, callbacks);
        };

        this.context.set('collectionOptions', {
            endpoint: endpoint,
            success: function(collection) {
                // Toogle no-data visibility
                self.$el.find('.block-footer').toggleClass('hide', (collection.length > 0));
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            limit: this._defaultSettings.limit
        });
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. It takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet mo`del.
     */
    saveDashletFilter: function() {
        this.layout.trigger('asdashlet:config:save');
    },

    /**
     * Show\hide activity stream omnibar
     */
    addComment: function()
    {
        this.$el.find('.omnibar-dashlet').toggleClass('hide');
    },

    /**
     * Bind data changes and comments\post adding
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();

                // Clean up post container
                this.$el.find('.activitystream-list').html('');
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            this.listenTo(model, 'sync', _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, 'sync', function() {
                    var options = this.context.get('collectionOptions');
                    var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
                    if (filterDef) {
                        options.filter = filterDef.filter_definition;
                    }
                    this.collection.fetch(options);
                });
            }));
        }
    },

    /**
     * Add posts to activity stream on data change
     *
     * @param model
     */
    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }

        // If activity streams are disabled for the current module on which the dashlet sits
        // then display a warning saying as much
        if (!this.activityStreamEnabled) {
            this.template = app.template.get(this.name + '.disabled');
            this._super('_render', [options]);
            return;
        }

        options = _.extend({}, options, this.context.get('collectionOptions'));

        if (this.collection) {
            var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
            if (filterDef) {
                options.filter = filterDef.filter_definition;
            }

            this.collection.fetch(options);
        }
    },

    /**
     * Render each ActivityStream model
     *
     * @param model
     * @return {Mixed}
     */
    renderPost: function(model) {
        var view;

        if (_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                name: 'activitystream',
                module: this.module,
                layout: this,
                model: model,
                nopreview: true  // hide preview button
            });

            // Place view to dashlet layout container
            this.$el.find('.activitystream-list').append(view.el);
            this.renderedActivities[model.id] = view;
            view.render();
        }

        return view;
    },

    /**
     * Skip rendering on pagination update
     * This is a hack to prevent dashlet re-render
     *
     * @param options
     */
    render: function(options)
    {
        if (!this.rendered) {
            this.rendered = true;
            this._super('render', [options]);

            // Append sub view - aka add component
            this.$el.find('.omnibar-dashlet').append(this.omnibarView.el);
            this.omnibarView.render();
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get('model');
            collection = this.context.parent.get('collection');

            if (model) {
                model.off('change sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        var nonActivities = [];
        _.each(this._components, function(component) {
            if (component.name !== 'activitystream') {
                nonActivities.push(component);
            } else {
                component.dispose();
            }
        });
        this._components = nonActivities;
        this.renderedActivities = {};
    }
}) },
"password-expired": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PasswordExpiredView
 * @alias SUGAR.App.view.views.BasePasswordExpiredView
 * @extends View.View
 */
({
	// Password-expired View (base) 

    plugins: ['ErrorDecoration'],
    events: {
        'click [name=save_button]': 'savePassword'
    },
    /**
     * @override
     * @param options
     */
    initialize: function(options){
        var meta = options.meta || {},
            fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        this.fieldsToValidate = fields;
        app.view.View.prototype.initialize.call(this, options);
    },
    /**
     * @override
     * @private
     */
    _render: function() {
        var self = this;
        var message = app.lang.get('LBL_PASSWORD_EXPIRATION_LOGIN');

        //Hack: Gets rid of leftover loading...
        app.alert.dismissAll();
        this.logoUrl = app.metadata.getLogoUrl();

        // Check if we have any password requirements messages and if so
        // push in to our passwordRequirements so hbs displays 'em
        this._showPasswordRequirements = false;
        this.passwordRequirements = [];
        if (app.user && app.user.has('password_requirements')) {
            this._showPasswordRequirements = true;
            var preqs = app.user.get('password_requirements');
            _.each(preqs, function(val, key) {
                self.passwordRequirements.push(val);
            });
        }
        app.view.View.prototype._render.call(this);

        //Render password expired message (after view rendered)
        if (app.user && app.user.has('password_expired_message')) {
            message = app.user.get('password_expired_message');
        }
        this.$('.password-reqs-status').text(message);
        return this;
    },
    savePassword: function() {
        var self = this, callbacks, newPass, oldPass = self.$('[name=current_password]').val();
        self.model.doValidate(this.fieldsToValidate, function(isValid) {
            if (isValid) {
                // A robot has reached into the honey pot. Do not submit (name_field not real)
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="name_field"]').val() || self.model.get('name_field'))) return;
                newPass = self.model.get('expired_password_update');//see change-my-password field

                if (newPass) {
                    app.alert.dismiss('changePassword');
                    app.alert.show('passreset', {level: 'process', title: app.lang.get('LBL_CHANGE_PASSWORD'), messages: app.lang.get('LBL_PROCESSING'), autoClose: false});
                    app.api.updatePassword(oldPass, newPass, {
                        success: function(data) {
                            app.alert.dismiss('passreset');
                            app.$contentEl.show();

                            //Password was valid and update successful
                            if (data && data.valid) {
                                callbacks = self.context.get("callbacks");
                                if (callbacks && callbacks.complete) {
                                    callbacks.complete();
                                }
                            } else if (data.message) {
                                //Password was deemed invalid by server. Display provided message
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: data.message
                                });
                            } else {
                                //Server should have provided data.message; use a generic message as fallback
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: app.lang.get('ERR_GENERIC_TITLE') + ': ' +
                                        app.lang.get('ERR_CONTACT_TECH_SUPPORT')
                                });
                            }
                        },
                        error: function(error) {
                            app.alert.dismiss('passreset');
                            app.error.handleHttpError(error, self);
                        }
                    });
                }
            }
        }, self);
    }
}) },
"dnb-news-and-media": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbNewAndMediaView
 * @alias SUGAR.App.view.views.BaseDnbNewsAndMediaView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-news-and-media View (base) 

    extendsFrom: 'DnbView',

    events: {
        'click .showMoreData' : 'showMoreData',
        'click .showLessData' : 'showLessData',
        'change #fb' : 'selectSocialMedia',
        'change #youtube' : 'selectSocialMedia',
        'change #twitter' : 'selectSocialMedia'
    },

    //JSON paths for news
    newsConst: {
        'newsPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.News.NewsDetails',
        'socialPath' : 'OrderProductResponse.OrderProductResponseDetail.Product.Organization.Telecommunication.SocialMediaDetail',
        'socialMediaNamePath' : 'SocialMediaPlatformName.$',
        'fburl' : 'https://www.facebook.com/',
        'twitterurl' : 'https://twitter.com/',
        'youtubeurl' : 'http://www.youtube.com/'
    },

    //social media meta data map
    //code represent the DNB Code value
    //url is the base url for the social media
    //label is the label for the social media
    //list is the list of user keys for the social media
    socialMediaMeta: {
        'youtube' : {
            'code' : 25866,
            'url' : 'http://www.youtube.com/',
            'label' : 'LBL_DNB_NEWS_YOUTUBE',
            'list' : null
        },
        'twitter' : {
            'code' : 25867,
            'url' : 'https://twitter.com/',
            'label' : 'LBL_DNB_NEWS_TWITTER',
            'list' : null
        },
        'wiki' : {
            'code' : 25868,
            'url' : 'http://www.youtube.com/',
            'label' : 'LBL_DNB_NEWS_WIKI',
            'list' : null
        },
        'fb' : {
            'code' : 25869,
            'url' : 'https://www.facebook.com/',
            'label' : 'LBL_DNB_NEWS_FACEBOOK',
            'list' : null
        }
    },

    //social media data dictionary
    socialMediaDD: {
        'mediaName': {
            'json_path': 'SocialMediaPlatformName.$'
        },
        'contentKey': {
            'json_path': 'UserContentKey'
        },
        'displayName': {
            'json_path': 'UserDisplayName'
        }
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadNews, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadNews, this);
    },

    loadData: function(options) {
       if (this.model.get('duns_num')) {
            this.duns_num = this.model.get('duns_num');
       }

    },

    _render: function() {
        app.view.View.prototype._renderHtml.call(this);
        //applying the select 2 plugins to all the social media data
        _.each(this.socialMediaMeta, function(value, key) {
            if (value.list && value.list.length > 0) {
                var listSelector = '#' + key;
                this.$(listSelector).select2({
                    placeholder: app.lang.get(value.label),
                    data: value.list,
                    containerCss: {'width': '100%'}
                });
            }
        }, this);
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated new and media information from DNB service
     */
    refreshClicked: function() {
        this.loadNews(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadNews: function(isCollapsed) {
        if (!isCollapsed) {
            //check if account is linked with a D-U-N-S
            this.loadDNBData('duns_num', 'dnb_temp_duns_num', this.getNewsandMediaInfo, null, 'dnb.dnb-no-duns', 'dnb.dnb-no-duns-field');
        }
    },

    /**
     * Handles the change event when a social media drop down is selected
     * based on the link selected, user is redirected to the social media page
     * @param {Object} event
     */
    selectSocialMedia: function(event) {
        var selectedMedia = event.target.id;
        if (selectedMedia) {
            var baseUrl = this.socialMediaMeta[selectedMedia].url;
            var selector = '#' + selectedMedia;
            var contentKey = this.$(selector).val();
            window.open(baseUrl + contentKey);
            //clearing the selection value
            //so that a user can be redirected when clicking mulitple times
            this.$(selector).val('');
        }
    },

    /**
     * Invokes D&B News and Social Media API
     * @param {String} duns_num
     */
    getNewsandMediaInfo: function(duns_num) {
        var self = this;
        self.template = app.template.get(self.name);
        if (!self.disposed) {
            self.render();
        }
        self.$('div#dnb-news-detail-loading').show();
        self.$('div#dnb-news-detail').hide();
        if (duns_num && duns_num !== '') {
            var dnbNewInfoURL = app.api.buildURL('connector/dnb/news/' + duns_num, '', {},{});
            var resultData = {'product': null, 'errmsg': null};
            app.api.call('READ', dnbNewInfoURL, {}, {
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        var newsData = self.getJsonNode(data, self.newsConst.newsPath),
                            socialData = self.getJsonNode(data, self.newsConst.socialPath);
                        if (newsData || socialData) {
                            resultData.news = {}, resultData.social = {};
                            if (newsData) {
                                resultData.news.product = newsData;
                            }
                            if (socialData) {
                                resultData.social.product = socialData;
                            }
                        } else {
                            resultData.errmsg = app.lang.get('LBL_DNB_NO_DATA');
                        }
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderNewsAndSocial(resultData);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     * Renders D&B News and Social Media API
     * @param {Object} dnbApiResponse
     */
    renderNewsAndSocial: function(dnbApiResponse) {
        if (this.disposed) {
            return;
        }
        var dnbNews = {};
        if (dnbApiResponse.news || dnbApiResponse.social) {
            dnbNews.news = {},dnbNews.social = {};
            if (dnbApiResponse.news.product) {
                dnbNews.news.product = dnbApiResponse.news.product;
            } else {
                dnbNews.news.errmsg = app.lang.get('LBL_DNB_NO_DATA');
            }
            if (dnbApiResponse.social.product) {
                dnbNews.social.product = this.formatSocial(dnbApiResponse.social.product, this.socialMediaDD);
            } else {
                dnbNews.social.errmsg = app.lang.get('LBL_DNB_NO_DATA');
            }
        }
        if (dnbApiResponse.errmsg) {
            dnbNews.errmsg = dnbApiResponse.errmsg;
        }
        this.dnbNews = dnbNews;
        this.render();
        this.$('div#dnb-news-detail-loading').hide();
        this.$('div#dnb-news-detail').show();
        this.$('.showLessData').hide();
    },

    /**
     * Format Social Media Response
     * @param {Object} dnbApiResponse
     * @param {Object} socialDD
     * @return {Object} formattedSocialData
     */
    formatSocial: function(dnbApiResponse, socialDD) {
        //grouping social media by DNB Code values
        //socialMedia variable will be a map
        //whose keys will be DNB Code values
        //whose values will be social media information in an array
        var socialMedia = _.groupBy(dnbApiResponse, function(socialObj) {
            return socialObj.SocialMediaPlatformName['@DNBCodeValue'];
        });
        var formattedSocialData = [];
        //iterate through each social media meta data map
        _.each(this.socialMediaMeta, function(socialMetaValue, socialMetaKey) {
            if (socialMedia[socialMetaValue.code]) {
                formattedSocialData.push({'label': socialMetaValue.label, 'mediaId': socialMetaKey});
                socialMetaValue.list = [];
                //iterate through every social media array
                //extract the necessary information
                _.each(socialMedia[socialMetaValue.code], function(socialMediaDetails) {
                    var contentKey = this.getJsonNode(socialMediaDetails, this.socialMediaDD.contentKey.json_path),
                        displayName = this.getJsonNode(socialMediaDetails, this.socialMediaDD.displayName.json_path);
                    var dropDownData = null;
                        dropDownData = {
                            id: contentKey,
                            text: displayName || contentKey
                        };
                    socialMetaValue.list.push(dropDownData);
                }, this);
            }
        }, this);
        return formattedSocialData;
    }
}) },
"passwordmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PasswordmodalView
 * @alias SUGAR.App.view.views.BasePasswordmodalView
 * @extends View.Views.Base.BaseeditmodalView
 * @deprecated 7.7 It will be removed in 7.8.
 */
({
	// Passwordmodal View (base) 

    extendsFrom:'BaseeditmodalView',
    fallbackFieldTemplate: 'edit',
    initialize: function(options) {
        app.logger.warn('The class `View.Views.Base.PasswordmodalView` has' +
            ' been deprecated since 7.7.0.0 and will be removed in 7.8.0.0.');
        app.view.View.prototype.initialize.call(this, options);
        if (this.layout) {
            this.layout.on("app:view:password:editmodal", function() {
                this.model = this.context.get('model');
                this.render();
                this.$('.modal').modal('show');
                this.model.on("error:validation", function() {
                    this.resetButton();
                }, this);
            }, this);
        }
        this.bindDataChange();
    },
    _renderHtml: function() {
        this.saveButtonWasClicked = false;
        this.events = _.clone(this.events);
        _.extend(this.events, {
            "focusin input[name=new_password]" : "verifyCurrentPassword",
            "focusin input[name=confirm_password]" : "verifyCurrentPassword"
        });
        app.view.View.prototype._renderHtml.call(this);
    },
    verifyCurrentPassword: function() {
        var self = this, currentPassword;
        currentPassword = self.$('[name=current_password]').val();

        // If user leaving old password text field, actually entered something, and we're sure the user
        // hasn't already clicked save (potentially a race condition if this completes after saveComplete, etc.)
        if(currentPassword && currentPassword.length && !self.saveButtonWasClicked) {
            app.api.verifyPassword(currentPassword, {
                success: function(data) {
                    // Since we're essentially looking for valid:true, this works ;=)
                    if(!self.checkUpdatePassWorked(data)) {
                        app.alert.show('pass_verification_failed', {
                            level: 'error',
                            title: app.lang.get('LBL_PASSWORD', self.module),
                            messages: app.lang.get('ERR_PASSWORD_MISMATCH', self.module)
                        });
                        self.$('[name=current_password]').val('');
                        self.$('[name=current_password]').focus();
                    } else {
                        app.alert.dismiss('pass_verification_failed');
                    }
                },
                error: function(error) {
                    app.error.handleHttpError(error, self);
                    self.resetButton();
                }
            });
        }
    },
    // Since we don't have a true Bean/meta driven validation for matching two temp fields
    // (password and confirmation password), etc., we manually add validation errors here
    handleCustomValidationError: function(field, errorMsg) {
        field = field.parents('.control-group')
        field.addClass('error');// Note the field is row fluid control group
        field.find('.help-block').html("");
        field.find('.help-block').append(errorMsg);
        field.find('.add-on').remove();
        field.find('input:last').after('<span class="add-on"><i class="fa fa-exclamation-circle"></i></span>');
    },
    setLoading: function() {
        this.$('[name=save_button]').attr('data-loading-text', app.lang.get('LBL_LOADING'));
        this.$('[name=save_button]').button('loading');
    },
    verify: function() {
        var self = this, currentPassword, password, confirmPassword, confirmPasswordField, isError=false,
            passwordField, maxLen, currentPasswordField;
        self.setLoading();

        currentPasswordField = this.$('[name=current_password]');
        currentPassword = currentPasswordField.val();
        // TODO: Here we will call a password verification endpoint which does not yet exist

        passwordField = this.$('[name=new_password]');
        password = passwordField.val();
        confirmPasswordField = this.$('[name=confirm_password]');
        confirmPassword = confirmPasswordField.val();

        if(!currentPassword) {
            self.handleCustomValidationError(currentPasswordField,app.lang.get('ERR_ENTER_OLD_PASSWORD', self.module));
            isError=true;
        }
        if(!password) {
            self.handleCustomValidationError(passwordField,app.lang.get('ERR_ENTER_NEW_PASSWORD', self.module));
            isError=true;
        }
        if(!confirmPassword) {
            self.handleCustomValidationError(confirmPasswordField,app.lang.get('ERR_ENTER_CONFIRMATION_PASSWORD', self.module));
            isError=true;
        }
        if(password !== confirmPassword) {
            self.setLoading();
            self.handleCustomValidationError(confirmPasswordField,app.lang.get('ERR_REENTER_PASSWORDS'), self.module);
            isError=true;
        }

        var passwordField = self.context.get('passwordField'),
            mod = app.metadata.getModule(self.module);
        maxLen = mod[passwordField] ? parseInt(mod[passwordField].len, 10) : 0;
        if(maxLen > 0 && confirmPassword.length > maxLen) {
            self.handleCustomValidationError(confirmPasswordField, app.error.getErrorString('ERROR_MAX_FIELD_LENGTH', maxLen) );
            isError=true;
        }
        return !isError;
    },
    saveButton: function() {
        if(this.verify()) {
            this.saveModel();
        } else {
            this.resetButton();
        }
    },
    saveModel: function() {
        var self = this,
            oldPass = self.model.get('current_password'),
            newPass = self.model.get('new_password');

        this.saveButtonWasClicked = true;

        app.alert.show('passreset', {level: 'process', title: app.lang.get('LBL_PASSWORD', self.module), messages: app.lang.get('LBL_PROCESSING', self.module), autoClose: false});

        app.api.updatePassword(oldPass, newPass, {
            success: function(data) {
                app.alert.dismiss('passreset');
                if(self.checkUpdatePassWorked(data)) {
                    self.saveComplete();
                } else {
                    app.alert.show('pass_update_failed', {
                        level: 'error',
                        title: app.lang.get('LBL_PASSWORD', self.module),
                        messages: app.lang.get('LBL_CANNOT_SEND_PASSWORD')
                    });
                    self.$('.modal').modal().find('input:text, input:password').val('');
                    self.resetButton();
                }
            },
            error: function(error) {
                app.alert.dismiss('passreset');
                app.error.handleHttpError(error, self);
                self.resetButton();
            }
        });
    },
    checkUpdatePassWorked: function(data) {
        if(!data || !data.valid) {
            app.logger.error("Failed to update password.");
            return false;
        }
        return true;
    },
    saveComplete: function() {
        var self = this;
        // Remove temp fields
        self.model.unset('current_password', {silent: true});
        self.model.unset('confirm_password', {silent: true});
        self.model.unset('new_password', {silent: true});

        //reset the form
        self.$('.modal').modal('hide').find('form').get(0).reset();
        //reset the `Save` button
        self.resetButton();
        //"Your password has been successfully updated."
        app.alert.show('pass_successfully_changes', {
            level: 'success',
            title: app.lang.get('LBL_PASSWORD', self.module),
            messages: app.lang.get('LBL_NEW_USER_PASSWORD_1', self.module),
            autoClose: true});
    }
}) },
"dupecheck-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListView
 * @alias SUGAR.App.view.views.BaseDupecheckListMenuView
 * @extends View.Views.Base.FlexListView
 */
({
	// Dupecheck-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListDisableSort', 'ListRemoveLinks', 'Pagination'],
    collectionSync: null,
    additionalTableClasses: null,

    /**
     * @inheritdoc
     *
     * The metadata used is the default `dupecheck-list` metadata, extended by
     * the module specific `dupecheck-list` metadata, extended by subviews
     * metadata.
     */
    initialize: function(options) {
        var dupeListMeta = app.metadata.getView(null, 'dupecheck-list') || {},
            moduleMeta = app.metadata.getView(options.module, 'dupecheck-list') || {};

        options.meta = _.extend({}, dupeListMeta, moduleMeta, options.meta || {});

        this._super('initialize', [options]);
        this.context.on('dupecheck:fetch:fire', this.fetchDuplicates, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset', function() {
            this.context.trigger('dupecheck:collection:reset');
        }, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        var classesToAdd = 'duplicates highlight';
        this._super('_renderHtml');
        if (this.additionalTableClasses) {
            classesToAdd = classesToAdd + ' ' + this.additionalTableClasses;
        }
        this.$('table.table-striped').addClass(classesToAdd);
    },

    /**
     * Fetch the duplicate collection.
     *
     * @param {Backbone.Model} model Duplicate check model.
     * @param {Object} options Fetch options.
     */
    fetchDuplicates: function(model, options) {
        this.collection.dupeCheckModel = model;
        this.collection.fetch(options);
    }
}) },
"dashboard-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashboardHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashboardHeaderpaneView
 * @extends View.Views.Base.RecordView
 */
({
	// Dashboard-headerpane View (base) 

    extendsFrom: 'RecordView',
    buttons: null,
    editableFields: null,
    className: 'preview-headerbar',
    events: {
        'click [name=edit_button]' : 'editClicked',
        'click [name=cancel_button]' : 'cancelClicked',
        'click [name=create_cancel_button]' : 'createCancelClicked',
        'click [name=delete_button]' : 'deleteClicked',
        'click [name=add_button]': 'addClicked',
        'click [name=collapse_button]': 'collapseClicked',
        'click [name=expand_button]': 'expandClicked'
    },
    initialize: function(options) {
        if(options.context.parent) {
            options.meta = app.metadata.getView(options.context.parent.get("module"), options.name);
            options.template = app.template.getView(options.name);
        }
        this._super("initialize", [options]);
        this.context.set('dataView', '');
        this.model.on("change change:layout change:metadata", function() {
            if (this.inlineEditMode) {
                this.changed = true;
            }
        }, this);
        this.model.on("error:validation", this.handleValidationError, this);

        if(this.context.get("create")) {
            this.changed = true;
            this.action = 'edit';
            this.inlineEditMode = true;
        } else {
            this.action = 'detail';
        }
        this.buttons = {};

        this._bindEvents();
    },

    /**
     * Binds the events that are necessary for this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('record:set:state', this.setRecordState, this);
    },

    /**
     * Handles the logic done when the state changes in the record.
     * This is the callback for the `record:set:state` event.
     *
     * @param {string} state The state that the record is set to.
     */
    setRecordState: function(state) {
        this.model.trigger('setMode', state);
        this.setButtonStates(state);
        this.inlineEditMode = state === 'edit';
        this.toggleEdit(this.inlineEditMode);
    },

    editClicked: function(evt) {
        this.previousModelState = app.utils.deepCopy(this.model.attributes);
        this.inlineEditMode = true;
        this.setButtonStates('edit');
        this.toggleEdit(true);
        this.model.trigger("setMode", "edit");
    },
    cancelClicked: function(evt) {
        this.changed = false;
        this.model.unset('updated');
        this.clearValidationErrors();
        this.setButtonStates('view');
        this.handleCancel();
        this.model.trigger("setMode", "view");
    },

    /**
     * Compare with last fetched data and return true if model contains changes
     *
     * See {@link app.plugins.view.editable}.
     *
     * @return true if current model contains unsaved changes
     */
    hasUnsavedChanges: function() {
        if (this.model.get('updated')) {
            return true;
        }
        if (this.model.isNew()) {
            return this.model.hasChanged();
        }
        return !_.isEmpty(this.model.changedAttributes(this.model.getSynced()));
    },

    /**
     * @override
     *
     * The save function is handled by {@link View.Layouts.Base.DashboardLayout#handleSave}.
     */
    saveClicked: $.noop,

    createCancelClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('list');
        } else {
            app.navigate(this.context);
        }
    },
    deleteClicked: function(evt) {
        this.handleDelete();
    },
    addClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('create');
        } else {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        }
    },
    collapseClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", true);
    },
    expandClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", false);
    },
    _render: function() {
        app.view.View.prototype._render.call(this);

        this.initButtons();
        this.setButtonStates(this.context.get("create") ? 'create' : 'view');
        this.setEditableFields();
    },
    handleCancel: function() {
        this.inlineEditMode = false;
        if (!_.isEmpty(this.previousModelState)) {
            this.model.set(this.previousModelState);
        }
        this.toggleEdit(false);
    },
    handleDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                var message = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
                    name: app.lang.get(this.model.get('name'), this.module)
                });
                this.model.destroy({
                    success: _.bind(function() {
                        //dispose safe
                        if (this.disposed) {
                            return;
                        }
                        if (this.context.parent) {
                            var contextBro = this.context.parent.getChildContext({module: 'Home'});
                            contextBro.get('collection').remove(this.model);
                            this.layout.navigateLayout('list');
                        } else {
                            var route = app.router.buildRoute(this.module);
                            app.router.navigate(route, {trigger: true});
                        }
                    }, this),
                    error: function() {
                        app.alert.show('error_while_save', {
                            level: 'error',
                            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                        });
                    },
                    //Show alerts for this request
                    showAlerts: {
                        'process': true,
                        'success': {
                            messages: message
                        }
                    }
                });
            }, this)
        });
    },

    bindDataChange: function() {
        //empty out because dashboard header does not need to switch the button sets while model is changed
    },
    toggleEdit: function(isEdit) {
        this.toggleFields(this.editableFields, isEdit);
    }
}) },
"quicksearch-tags": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagsView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagsView
 * @extends View.View
 */

({
	// Quicksearch-tags View (base) 

    events: {
        'click .qs-tag': 'handleTagSelection'
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        // Initialize tag collections (search results and selected tags)
        this.tagCollection = [];
        this.selectedTags = this.layout.selectedTags || [];
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // If the layout has `quicksearch:close` called on it, that means the
        // whole thing is hidden
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
            this.close();
        }, this);

        this.collection.on('sync', this.quicksearchHandler,  this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            this.activeIndex = 0;
            this._highlightActive();
            this.attachKeyEvents();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
        }, this);
    },

    /**
     * Handles the layout event indicating quicksearch fire
     * @param collection
     */
    quicksearchHandler: function(collection) {
        var selectedTags = this.selectedTags;

        if (collection && collection.tags) {
            // Filter out tags that already exist in selectedTags
            this.tagCollection = _.filter(collection.tags, function(tag) {
                return _.isUndefined(_.find(selectedTags, function(selectedTag) {
                    return selectedTag.name === tag.name;
                }));
            });
            this.render();
            if (this.tagCollection.length) {
                this.open();
            } else {
                this.close();
            }
        } else {
            this.close();
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        if (_.isNull(this.activeIndex)) {
            return;
        }

        this.$('.active').removeClass('active');
        this.$('.qs-tag:eq(' + this.activeIndex + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Handler for tag selection
     * @param {Event} e
     */
    handleTagSelection: function(e) {
        if (e.target && e.target.text) {
            var self = this;
            var selectedTag = _.find(this.tagCollection, function(tag) {
                return tag.name === e.target.text;
            });

            this.layout.trigger('quicksearch:bar:clear:term');
            this.layout.trigger('quicksearch:tag:add', selectedTag);

            // Focus back to quicksearch-bar after tag selection. Defer it to prevent enter key-up
            // from navigating away
            _.defer(function() {
                self.layout.trigger('navigate:to:component', 'quicksearch-bar')
            });
        }
    },

    /**
     * Return true if tag view contains any tags. False if not
     * @return boolean
     */
    isFocusable: function() {
        return this.tagCollection &&
            this.tagCollection.length;
    },

    /**
     * Show the tag ribbon
     */
    open: function() {
        this.layout.trigger('quicksearch:tag:open');
        this.$('.quicksearch-tags').show();
    },

    /**
     * Hide the tag ribbon
     */
    close: function() {
        this.layout.trigger('quicksearch:tag:close');
        this.$('.quicksearch-tags').hide();
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.disposeKeyEvents();
            this.$('.active').removeClass('active');
            this.layout.trigger(event);
        }
    },

    moveDown: function() {
        this._handleBoundary(true);
    },

    moveRight: function() {
        var maxIndex = this.tagCollection.length;
        if (this.activeIndex < --maxIndex) {
            this.activeIndex++;
            this._highlightActive();
        }
    },

    moveLeft: function() {
        if (this.activeIndex > 0) {
            this.activeIndex--;
            this._highlightActive();
        }
    },

    moveUp: function() {
        this._handleBoundary(false);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveDown();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 38: // up arrow
                this.moveUp();
                break;
            case 37: // left arrow
                this.moveLeft();
                break;
            case 13: //enter
                e.preventDefault();
                e.stopImmediatePropagation();
                break;
        }
    },

    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 13: //enter
                this.handleTagSelection(e);
                break;
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeyEvents: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
        this.$el.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeyEvents: function() {
        this.$el.off();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"subpanel-list-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used for SubpanelCreate layouts.
 *
 * @class View.Views.Base.SubpanelListCreateView
 * @alias SUGAR.App.view.views.BaseSubpanelListCreateView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Subpanel-list-create View (base) 

    extendsFrom: 'SubpanelListView',

    contextEvents: {
        'list:deleterow:fire': 'onDeleteRow',
        'list:addrow:fire': 'onAddRow'
    },

    /**
     * Flag if the view has all valid models
     */
    hasValidModels: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // undo flex-list's hardcoding and re-hardcode to use the subpanel-list-create.hbs
        this.template = app.template.getView('subpanel-list-create');

        this.dataView = 'subpanel-list-create';
        this.context.set({
            dataView: this.dataView,
            isCreateSubpanel: true
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        var link = this.context.get('link');

        // listen to revalidate the collection
        this.context.parent.on('subpanel:validateCollection:' + link, this.validateModels, this);

        // listen to reset the collection
        this.context.parent.on('subpanel:resetCollection:' + link, this.resetSubpanel, this);

        this.collection.on('add remove', this.render, this);

        this.resetSubpanel();
    },

    /**
     * Resets the subpanel's collection and adds a new bean to the list
     */
    resetSubpanel: function() {
        this.collection.reset();
        this._addBeanToList(true);
    },

    /**
     * @inheritdoc
     *
     * Toggles all fields in the SubpanelList to Edit view
     */
    render: function() {
        this._super('render');

        // toggle fields to edit view
        this._toggleFields(true);

        _.defer(_.bind(function() {
            this.checkButtons();
        }, this));
    },

    /**
     * Handles toggling collection fields to edit or detail
     *
     * @param {Boolean} isEdit If we're toggling fields TO Edit view or not
     * @private
     */
    _toggleFields: function(isEdit) {
        isEdit = isEdit || false;

        // toggle the fields in the list to be in edit mode
        _.each(this.collection.models, function(model) {
            this.toggleFields(this.rowFields[model.get('id')], isEdit)
            if (isEdit) {
                // this is a subpanel specific logic: when the subpanel is back to edit mode,
                // manually fire the dependency trigger on all its models
                this.context.trigger("list:editrow:fire", model, {def: {}});
            }
        }, this);
    },

    /**
     * Checks the -/+ buttons to enable/disable
     */
    checkButtons: function() {
        var delBtns = this.$('.deleteBtn'),
            addBtns = this.$('.addBtn');
        if (delBtns && delBtns.length === 1 && !delBtns.hasClass('disabled')) {
            // if we have only one button, disable it, otherwise leave them all open
            delBtns.addClass('disabled');
        }

        if (addBtns && addBtns.length > 1) {
            // disable all add buttons except the last row
            _.each(addBtns, function(btn, index) {
                if (index < addBtns.length - 1) {
                    $(btn).addClass('disabled');
                }
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Overriding RecordList/FlexList addActions to use actionmenu-create for the left column
     *
     * @override
     */
    addActions: function() {
        if (this.actionsAdded) {
            return;
        }

        // just need the right-side actions
        if (this.meta && _.isObject(this.meta.rowactions)) {
            // add the fieldset and init rightColumns
            this.addRowActions();
        }

        this.actionsAdded = true;
    },

    /**
     * @inheritdoc
     *
     * Overriding flex-list addRowActions to make the rowactions-create type
     *
     * @override
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions-create',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || [],
                        'no_default_action': true
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },

    /**
     * Validates the models in the subpanel
     *
     * @param {Function} callback The callback function to call after validation
     * @param {undefined|Boolean} [fromCreateView] If this function is being called from Create view or not
     */
    validateModels: function(callback, fromCreateView) {
        fromCreateView = fromCreateView || false;

        var returnCt = 0;
        this.hasValidModels = true;

        _.each(this.collection.models, function(model) {
            // loop through all models and call doValidate on each model
            model.doValidate(this.getFields(this.module), _.bind(function(isValid) {
                returnCt++;

                if (this.hasValidModels && !isValid) {
                    // hasValidModels was true, but a model returned false from validation
                    this.hasValidModels = isValid;
                }

                // check if all model validations have occurred
                if (returnCt === this.collection.length) {
                    if (fromCreateView) {
                        // the create waterfall wants the opposite of if this is validated
                        callback(!this.hasValidModels);
                    } else {
                        // this view wants if the models are valid or not
                        callback(this.hasValidModels);
                    }
                }
            }, this));
        }, this);
    },

    /**
     * Click handler for the Add (+) button.
     * Validates each model on the collection and if they all validate, calls
     */
    onAddRow: function() {
        this.validateModels(_.bind(this._addBeanToList, this));
    },

    /**
     * Handler for when the delete button is clicked
     *
     * @param model
     */
    onDeleteRow: function(model) {
        this.context.get('collection').remove(model);
        this.checkButtons();
    },

    /**
     * Adds a bean for this.module to the collection
     *
     * @param {Boolean} hasValidModels If this collection has validated models
     * @private
     */
    _addBeanToList: function(hasValidModels) {
        if (hasValidModels) {
            var beanId = app.utils.generateUUID(),
                bean = app.data.createBean(this.module);

            bean.set({
                id: beanId
            });
            bean._module = this.module;

            // check the parent record to see if an assigned user ID/name has been set
            if (this.context.parent && this.context.parent.has('model')) {
                var parentModel = this.context.parent.get('model'),
                    userId = parentModel.get('assigned_user_id'),
                    userName = parentModel.get('assigned_user_name');

                if (userId) {
                    bean.setDefault('assigned_user_id', userId);
                }

                if (userName) {
                    bean.setDefault('assigned_user_name', userName);
                }
            }

            bean = this._addCustomFieldsToBean(bean);

            // must add to this.collection so the bean shows up in the subpanel list
            this.collection.add(bean);
        }

        this.checkButtons();
    },

    /**
     * Allows child functions to override and add module-specific properties to the bean
     * before it gets added to the collection
     *
     * @param {Data.Bean} bean The bean to add new properties to
     * @return {Data.Bean}
     * @private
     */
    _addCustomFieldsToBean: function(bean) {
        return bean;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.context.parent.off(null, null, this);
        this._super('_dispose');
    }
}) },
"merge-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates header pane.
 *
 * @class View.Views.Base.MergeDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Merge-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=save_button]': 'save'
    },

    /**
     * @inheritdoc
     *
     * Gets the selected duplicates from the context and defines the title based
     * on the number of selected records.
     */
    _formatTitle: function(title) {
        var records = this.context.get('selectedDuplicates');
        return app.lang.get(title, this.module, {mergeCount: records.length});
    },

    /**
     * Cancel and close the drawer.
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Save primary and delete other records.
     */
    save: function() {
        this.layout.trigger('mergeduplicates:save:fire');
    }
}) },
"config-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigPanelView
 * @alias SUGAR.App.view.views.BaseConfigPanelView
 * @extends View.View
 */
({
	// Config-panel View (base) 

    /**
     * Holds the changing date value for the title
     */
    titleSelectedValues: '',

    /**
     * Holds the view's title name
     */
    titleViewNameTitle: '',

    /**
     * Holds the collapsible toggle title template
     */
    toggleTitleTpl: {},

    /**
     * Holds the vars for the title template
     * <pre><code>
     * {
     *  title: this.titleViewNameTitle,
     *  selectedValues: this.titleSelectedValues,
     *  viewName: this.name
     * }
     * <pre><code>
     */
    titleTemplateVars: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.toggleTitleTpl = app.template.getView('config-panel.title');

        if (this.meta.label) {
            this.titleViewNameTitle = app.lang.get(this.meta.label, this.module);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // add accordion-group class to wrapper $el div
        this.$el.addClass('accordion-group');

        // update the title every render
        this.updateTitle();
    },

    /**
     * Updates the accordion toggle title
     */
    updateTitle: function() {
        // update the title values
        this._updateTitleValues();
        // update the title template vars
        this._updateTitleTemplateVars();

        // then inject them into the template
        this.$('#' + this.name + 'Title').html(this.toggleTitleTpl(this.titleTemplateVars));
    },

    /**
     * Updates `this.titleSelectedValues` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleValues: function() {
        this.titleSelectedValues = this.model.get(this.name);
    },

    /**
     * Updates `this.titleTemplateVars` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleTemplateVars: function() {
        this.titleTemplateVars = {
            title: this.titleViewNameTitle,
            selectedValues: this.titleSelectedValues,
            viewName: this.name
        };
    }
}) },
"massaddtolist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistView
 * @alias SUGAR.App.view.views.BaseMassaddtolistView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Massaddtolist View (base) 

    extendsFrom: 'MassupdateView',
    addToListFieldName: 'prospect_lists',
    listModule: 'ProspectLists',
    massUpdateViewName: 'massaddtolist-progress',
    className: 'extend',

    initialize: function(options) {
        var additionalEvents = {};
        additionalEvents['click .btn[name=create_button]'] = 'createAndSelectNewList';
        this.events = _.extend({}, this.events, additionalEvents);
        this._super("initialize", [options]);
    },

    /**
     * Listen for just the massaddtolist event from the list view
     */
    delegateListFireEvents: function() {
        this.layout.on("list:massaddtolist:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
    },

    /**
     * Pull out the target list link field from the field list and treat it like a relate field for later rendering
     * @param options
     */
    setMetadata: function(options) {
        var moduleMetadata = app.metadata.getModule(options.module);

        if (!moduleMetadata) {
            return;
        }

        var addToListField = _.find(moduleMetadata.fields, function(field) {
            return field.name === this.addToListFieldName;
        }, this);

        if (addToListField) {
            addToListField = app.utils.deepCopy(addToListField);
            addToListField.id_name = this.addToListFieldName + '_id';
            addToListField.name = this.addToListFieldName + '_name';
            addToListField.label = addToListField.label || addToListField.vname;
            addToListField.type = 'relate';
            addToListField.required = true;
            this.addToListField = addToListField;
        }
    },

    /**
     * Hide the view if we were not able to find the appropriate list field and somehow render is triggered
     */
    _render: function() {
        var result = this._super("_render");

        if(_.isUndefined(this.addToListField)) {
            this.hide();
        }
        return result;
    },

    /**
     * There is only one field for this view, so it is the default as well
     */
    setDefault: function() {
        this.defaultOption = this.addToListField;
    },

    /**
     * When adding to a target list, the API is expecting an array of IDs
     */
    getAttributes: function() {
        var attributes = {};
        attributes[this.addToListFieldName] = [
            this.model.get(this.addToListField.id_name)
        ];
        return attributes;
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * Overridden to build different success messages from massupdate
     *
     * @param massUpdateModel - contains the attributes of what records are being updated
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        var doneLabel = 'TPL_MASS_ADD_TO_LIST_SUCCESS',
            queuedLabel = 'TPL_MASS_ADD_TO_LIST_QUEUED',
            listName = this.model.get(this.addToListField.name),
            listId = this.model.get(this.addToListField.id_name),
            listUrl = '#' + app.router.buildRoute(this.listModule, listId);

        return {
            done: app.lang.get(doneLabel, null, {
                listName: listName,
                listUrl: listUrl
            }),
            queued: app.lang.get(queuedLabel, null, {
                listName: listName,
                listUrl: listUrl
            })
        };
    },

    /**
     * Create a new target list and select it in the list
     */
    createAndSelectNewList: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                create: true,
                module: this.listModule
            }
        }, _.bind(this.selectNewlyCreatedList, this));
    },

    /**
     * Callback for create new target list - sets relate field with newly created list
     * @param context
     * @param model newly created target list model
     */
    selectNewlyCreatedList: function(context, model) {
        var relateField = this.getField('prospect_lists_name');
        if (relateField) {
            model.value = model.get('name');
            relateField.setValue(model);
        }
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateNodupecheckView
 * @alias SUGAR.App.view.views.BaseCreateNodupecheckView
 * @extends View.Views.Base.CreateView
 */
({
	// Create-nodupecheck View (base) 

    extendsFrom: 'CreateView',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.enableDuplicateCheck = false;
    }
}) },
"dnb-industry-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DnbIndustryInfoView
 * @alias SUGAR.App.view.views.BaseDnbIndustryInfoView
 * @extends View.Views.Base.DnbView
 */
({
	// Dnb-industry-info View (base) 

    extendsFrom: 'DnbView',

    events: {
        'click .showMoreData': 'showMoreData',
        'click .showLessData': 'showLessData'
    },

    //industry information data dictionary
    industryInfoDD: {
        'industryExplanation': {
            'json_path': 'IndustryCode.0.IndustryExplanationText',
            'case_fmt': true
        },
        'industryChapters': {
            'json_path': 'IndustryProfileChapterDetail',
            'case_fmt': true
        }
    },

    //industry info constants
    industryConst: {
        'industryInfoPath': 'OrderProductResponse.OrderProductResponseDetail.Product.IndustryProfile.IndustryProfileDetail.0'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout.collapse) {
            this.layout.collapse(true);
        }
        this.layout.on('dashlet:collapse', this.loadIndustryInfo, this);
        app.events.on('dnbcompinfo:duns_selected', this.collapseDashlet, this);
        //listen on expand all button click on the dashboard
        this.layout.layout.context.on('dashboard:collapse:fire', this.loadIndustryInfo, this);
    },

    /**
     * Refresh dashlet once Refresh link clicked from gear button
     * To show updated industry information from DNB service
     */
    refreshClicked: function() {
        this.loadIndustryInfo(false);
    },

    /**
     * Handles the dashlet expand | collapse events
     * @param  {Boolean} isCollapsed
     */
    loadIndustryInfo: function(isCollapsed) {
        //if the dashlet is not collapsed load data from D&B
        if (!isCollapsed) {
            //check if Hoovers Industry Code is set in context by refresh dashlet
            if (this.checkFieldExists('sic_code')) {
                var sicFromContext = app.controller.context.get('dnb_temp_hoovers_ind_code'),
                    sicFromModel = this.model.get('sic_code');
                if (!_.isUndefined(sicFromContext)) {
                    this.getDNBIndustryInfo(sicFromContext);
                } else if (sicFromModel) {
                    this.getDNBIndustryInfoFromSIC(sicFromModel);
                } else {
                    this.template = app.template.get(this.name + '.dnb-no-sic');
                    if (!this.disposed) {
                        this.render();
                    }
                }
            } else {
                this.template = app.template.get(this.name + '.dnb-no-sic-field');
                if (!this.disposed) {
                    this.render();
                }
            }
        }
    },

    /**
     * Get D&B industry information from SIC codes
     * @param  {String} sicCode
     */
    getDNBIndustryInfoFromSIC: function(sicCode) {
        var self = this;
        var sicToHicParams = {
            'industryType': this.commonConst.sic_to_hic,
            'industryCode': sicCode.substring(0,4) //use only the first 4 digits of the sic
        };
        self.template = app.template.get(self.name);
        if (!self.disposed) {
            self.render();
        }
        self.$('#dnb-industry-list-loading').show();
        self.$('#dnb-industry-info').hide();
        //check if cache has this data already
        var cacheKey = 'dnb:industrydet:' + sicToHicParams.industryType + ':' + sicToHicParams.industryCode;
        if (app.cache.get(cacheKey)) {
            self.renderIndustryInfo.call(self, app.cache.get(cacheKey));
        } else {
            var dnbIndustryURL = app.api.buildURL('connector/dnb/industry', '', {}, {});
            var resultData = {'product': null, 'errmsg': null};
            app.api.call('create', dnbIndustryURL, {'qdata': sicToHicParams}, {
                success: function(data) {
                    var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                        responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                    if (responseCode && responseCode === self.responseCodes.success) {
                        resultData.product = data;
                        app.cache.set(cacheKey, resultData);
                    } else {
                        resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                    }
                    self.renderIndustryInfo.call(self, resultData);
                },
                error: _.bind(self.checkAndProcessError, self)
            });
        }
    },

    /**
     * Get D&B industry information from HIC codes
     * @param {Object} industryCodeValue
     */
    getDNBIndustryInfo: function(industryCodeValue) {
        var self = this;
        if (industryCodeValue) {
            self.template = app.template.get(self.name);
            if (!self.disposed) {
                self.render();
            }
            self.$('#dnb-industry-list-loading').show();
            self.$('#dnb-industry-info').hide();
            //check if cache has this data already
            var cacheKey = 'dnb:industrydet:' + industryCodeValue;
            if (app.cache.get(cacheKey)) {
                self.renderIndustryInfo.call(self, app.cache.get(cacheKey));
            } else {
                var dnbIndustryURL = app.api.buildURL('connector/dnb/industry/' + industryCodeValue, '', {}, {});
                var resultData = {'product': null, 'errmsg': null};
                app.api.call('READ', dnbIndustryURL, {}, {
                    success: function(data) {
                        var responseCode = self.getJsonNode(data, self.appendSVCPaths.responseCode),
                            responseMsg = self.getJsonNode(data, self.appendSVCPaths.responseMsg);
                        if (responseCode && responseCode === self.responseCodes.success) {
                            resultData.product = data;
                            app.cache.set(cacheKey, resultData);
                        } else {
                            resultData.errmsg = responseMsg || app.lang.get('LBL_DNB_SVC_ERR');
                        }
                        self.renderIndustryInfo.call(self, resultData);
                    },
                    error: _.bind(self.checkAndProcessError, self)
                });
            }
        } else {
            self.template = app.template.get(self.name + '.dnb-no-duns');
            if (!self.disposed) {
                self.render();
            }
        }
    },

    /**
     * Render industry information from D&B API Response
     * @param  {Object} dnbApiResponse
     */
    renderIndustryInfo: function(dnbApiResponse) {
        if (this.disposed) {
            return;
        }
        var formattedIndustryInfo;
        this.dnbIndustryInfo = {};
        if (dnbApiResponse.product) {
            var industryProduct = this.getJsonNode(dnbApiResponse.product, this.industryConst.industryInfoPath);
            if (industryProduct) {
                formattedIndustryInfo = this.formatIndustryInfo(industryProduct, this.industryInfoDD);
                if (!_.isNull(formattedIndustryInfo)) {
                    this.dnbIndustryInfo.product = formattedIndustryInfo;
                } else {
                    this.dnbIndustryInfo.errmsg = app.lang.get('LBL_DNB_NO_DATA');
                }
            } else {
                this.dnbIndustryInfo.errmsg = app.lang.get('LBL_DNB_NO_DATA');
            }
        } else {
            this.dnbIndustryInfo.errmsg = dnbApiResponse.errmsg || app.lang.get('LBL_DNB_NO_DATA');
        }
        this.template = app.template.get(this.name);
        this.render();
        this.$('#dnb-industry-list-loading').hide();
        this.$('#dnb-industry-info').show();
        this.$('.showLessData').hide();
    },

    /**
     * Preprocessing industry information
     * @param {Object} industryDetails DNB API Response for IndustryInfo
     * @param {Object} industryInfoDD Data Dictionary for industry information
     * @return {Object}
     */
    formatIndustryInfo: function(industryDetails, industryInfoDD) {
        var formattedIndustryInfo = {};
        //iterate through data dictionary and extract required
        //data elements
        //populate them as key value pairs in the JS object
        _.each(industryInfoDD, function(value, key) {
            var dataElement = this.getJsonNode(industryDetails, value.json_path);
            if (dataElement) {
                formattedIndustryInfo[key] = dataElement;
            }
        }, this);
        if (formattedIndustryInfo.industryExplanation && formattedIndustryInfo.industryChapters) {
            return formattedIndustryInfo;
        } else {
            return null;
        }
    }
}) },
"dashletselect-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletselectHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletselectHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Dashletselect-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        "click a[name=cancel_button]": "close"
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register('Dashlet:Select:Cancel', ['esc','ctrl+alt+l'], function() {
            var $cancelButton = this.$('a[name=cancel_button]');
            if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                $cancelButton.click();
            }
        }, this, true);
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    }
}) },
"find-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FindDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseFindDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Find-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=merge_duplicates_button]:not(".disabled")': 'mergeDuplicatesClicked'
    },

    plugins: ['MergeDuplicates'],

    /**
     * Wait for the mass_collection to be set up so we can add listener
     */
    bindDataChange: function() {
        this._super("bindDataChange");
        this.on('mergeduplicates:complete', this.mergeComplete, this);
        this.context.on('change:mass_collection', this.addMassCollectionListener, this);
    },

    /**
     * @inheritdoc
     * Dispose safe for mass_collection
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');

        if (massCollection) {
            massCollection.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can enable/disable the merge button whenever the collection changes.
     */
    addMassCollectionListener: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.toggleMergeButton, this);
    },

    /**
     * Enable the merge button when a duplicate has been checked
     * Disable when all are unchecked
     */
    toggleMergeButton: function() {
        var disabled;
        if (this.context.get('mass_collection').length > 0) {
            disabled = false;
        } else {
            disabled = true;
        }
        this.$("[name='merge_duplicates_button']").toggleClass('disabled', disabled);
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Close the current drawer window by passing merged primary record
     * once merge process is complete.
     *
     * @param {Backbone.Model} primaryRecord Primary Record.
     */
    mergeComplete: function(primaryRecord) {
        app.drawer.closeImmediately(true, primaryRecord);
    },

    /**
     * Merge records handler.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'), this.collection.dupeCheckModel);
    }
}) },
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamView
 * @alias SUGAR.App.view.views.BaseActivitystreamView
 * @extends View.View
 */
({
	// Activitystream View (base) 

    events: {
        'change div[data-placeholder]': 'checkPlaceholder',
        'keydown div[data-placeholder]': 'checkPlaceholder',
        'keypress div[data-placeholder]': 'checkPlaceholder',
        'input div[data-placeholder]': 'checkPlaceholder',
        'click .reply': 'showAddComment',
        'click .reply-btn': 'addComment',
        'click .preview-btn:not(.disabled)': 'previewRecord',
        'click .comment-btn': 'toggleReplyBar',
        'click .more': 'fetchComments'
    },

    tagName: "li",
    className: "activitystream-posts-comments-container",
    plugins: ['RelativeTime', 'FileDragoff', 'QuickSearchFilter', 'Taggable', 'Tooltip'],
    cacheNamePrefix: "user:avatars:",
    cacheNameExpire: ":expiry",
    expiryTime: 36000000,   //1 hour in milliseconds
    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    _unformattedPost: null,
    _unformattedComments: {},

    // Based on regular expression from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
    // It is the JavaScript regular expression version of the one in LinkEmbed.php
    urlRegExp: /\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?]))/ig,

    _attachImageSelector: 'img[data-note-id]',

    /**
     * Modules placed in this array will have links to the module removed from the display
     * e.g. Quotas isn't a real module, has no record view, shouldn't have a link
     */
    blacklistModules: [
        'Quotas'
    ],

    initialize: function(options) {
        this.opts = {params: {}};
        this.readonly = !!options.readonly;
        this.nopreview = !!options.nopreview;

        app.view.View.prototype.initialize.call(this, options);

        var lastComment = this.model.get("last_comment");
        this.commentsCollection = app.data.createRelatedCollection(this.model, "comments");

        if (lastComment && !_.isUndefined(lastComment.id)) {
            this.commentsCollection.reset([lastComment]);
        }

        this.model.set("comments", this.commentsCollection);

        // If comment_count is 0, we don't want to decrement the count by 1 since -1 is truthy.
        var count = parseInt(this.model.get('comment_count'), 10);
        this.remaining_comments = 0;
        this.more_tpl = "TPL_MORE_COMMENT";
        if (count) {
            this.remaining_comments = count - 1;

            // Pluralize the comment count label
            if (count > 2) {
                this.more_tpl += "S";
            }
        }

        this.preview = this.getPreviewData();
        var data = this.model.get('data');
        var activity_type = this.model.get('activity_type');

        this.tpl = "TPL_ACTIVITY_" + activity_type.toUpperCase();

        switch(activity_type) {
            case 'post':
                if (!data.value) {
                    this.tpl = null;
                }
                break;
            case 'update':
                data.updateStr = this.processUpdateActivityTypeMessage(data.changes);
                this.model.set('data', data);
                break;
            case 'attach':
                var url,
                    urlAttributes = {
                    module: 'Notes',
                    id: data.noteId,
                    field: 'filename'
                };

                if (data.mimetype && data.mimetype.indexOf("image/") === 0) {
                    url = app.api.buildFileURL(urlAttributes, {
                        htmlJsonFormat: false,
                        passOAuthToken: false,
                        cleanCache: true,
                        forceDownload: false
                    });

                    data.embeds = [{
                        type: "image",
                        src: url,
                        noteId: data.noteId
                    }];
                } else {
                    url = app.api.buildFileURL(urlAttributes);
                }

                data.url = url;
                this.$el.data(data);
                this.model.set('data', data);
                this.model.set('display_parent_type', 'Files');
                break;
        }

        this.processEmbed();

        // Resize video when the browser window is resized
        this.resizeVideo = _.bind(_.throttle(this.resizeVideo, 500), this);
        $(window).on('resize.' + this.cid, this.resizeVideo);

        // specify the record that the tags are associated with
        this.setTaggableRecord(this.model.get('parent_type'), this.model.get('parent_id'));
    },

     /**
     * Creates the update message for the activity stream based on the fields changed.
     * @param {object} changes Object containing the changes for the fields of an update activity message
     * @return {string} The formatted message for the update
     */
     processUpdateActivityTypeMessage: function (changes) {
         var updateTpl = Handlebars.compile(app.lang.get('TPL_ACTIVITY_UPDATE_FIELD', 'Activities')),
             parentType = this.model.get("parent_type"),
             fields = app.metadata.getModule(parentType).fields,
             self = this,
             updateStr;

         updateStr = _.reduce(changes, function (memo, changeObj) {
             var fieldMeta = fields[changeObj.field_name],
                 field = app.view.createField({
                     def: fieldMeta,
                     view: self,
                     model: self.model,
                     viewName: 'detail'
                 });

             changeObj.before = field.format(changeObj.before);
             changeObj.after = field.format(changeObj.after);
             changeObj.field_label = app.lang.get(fields[changeObj.field_name].vname, parentType);

             if (memo) {
                 return updateTpl(changeObj) + ', ' + memo;
             }
             return updateTpl(changeObj);
         }, '');

         return updateStr;
     },

    /**
     * Get embed templates to be processed on render
     */
    processEmbed: function() {
        var data = this.model.get('data');

        if (!_.isEmpty(data.embeds)) {
            this.embeds = [];
            _.each(data.embeds, function(embed) {
                var typeParts = embed.type.split('.'),
                    type = typeParts.shift(),
                    embedTpl;

                _.each(typeParts, function(part) {
                    type = type + part.charAt(0).toUpperCase() + part.substr(1);
                });

                embedTpl = app.template.get(this.name + '.' + type + 'Embed');
                if (embedTpl) {
                    this.embeds.push(embedTpl(embed));
                }
            }, this);
        }
    },

    fetchComments: function() {
        var self = this;
        this.commentsCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            relate: true,
            success: function(collection) {
                self.remaining_comments = 0;
                self.render();
            }
        });
    },

    /**
     * Event handler for clicking comment button -- shows a post's comment box.
     * @param  {Event} e
     */
    showAddComment: function(e) {
        var currentTarget = this.$(e.currentTarget);

        currentTarget.closest('li').find('.activitystream-comment').toggle();
        currentTarget.closest('li').find('.activitystream-comment').find('.sayit').focus();

        e.preventDefault();
    },

    /**
     * Creates a new comment on a post.
     * @param {Event} event
     */
    addComment: function (event) {
        var self = this,
            parentId = this.model.id,
            payload = {
                parent_id: parentId,
                data: {}
            },
            bean;

        payload.data = this.getComment();

        if (payload.data.value && (payload.data.value.length > 0)) {
            bean = app.data.createRelatedBean(this.model, null, 'comments');
            bean.save(payload, {
                relate: true,
                success: _.bind(self.addCommentCallback, self)
            });
        }
    },

    /**
     * Callback for rendering a newly added comment into the activity stream view
     * @param  {Object} model
     */
    addCommentCallback: function (model) {
        var template, data;

        this.$('div.reply').empty().trigger('change');
        this.commentsCollection.add(model);
        this.toggleReplyBar();

        template = app.template.getView('activitystream.comment');

        data = model.get('data');
        data.value = this.formatTags(data.value);
        data.value = this.formatLinks(data.value);

        this.processAvatars();
        this.$('.comments').prepend(template(model.attributes));
        this.initializeAllPluginTooltips();
        this.context.trigger('activitystream:post:prepend', this.model);
    },

    /**
     * Handler for previewing a record listed on the activity stream.
     * @param  {Event} event
     */
    previewRecord: function(event) {
        var el = this.$(event.currentTarget),
            data = el.data(),
            module = data.module,
            id = data.id;

        // Remove highlighted styling from all activities
        this.layout.clearRowDecorations();

        // If module/id data attributes don't exist, this user
        // doesn't have access to that record due to team security.
        if (module && id) {
            var model = app.data.createBean(module),
                collection = this.context.get("collection");

            model.set("id", id);
            this.decorateRow();
            app.events.trigger("preview:module:update", this.context.get("module"));
            app.events.trigger("preview:render", model, collection, true, this.cid);
        }

        event.preventDefault();
    },

    /**
     * Handles highlighting of current activity item and active state of preview button.
     */
    decorateRow: function() {
        this.$el.addClass('highlighted');
        this.$('.preview-btn').addClass('active');
    },

    _renderHtml: function(model) {
        // Save state of the reply bar before rendering
        var isReplyBarOpen = this.$(".comment-btn").hasClass("active") && this.$(".comment-btn").is(":visible"),
            replyVal = this.$(".reply").html();

        this.processAvatars();
        this.formatAllTagsAndLinks();

        this._setRelativeTimeAvailable();

        app.view.View.prototype._renderHtml.call(this);

        this.resizeVideo();

        // If the reply bar was previously open, keep it open (render hides it by default)
        if (isReplyBarOpen) {
            this.toggleReplyBar();
            this.$(".reply").html(replyVal);
        }

        this._addBrokenImageHandler();
    },

    /**
     * Add a listener for when activity has a broken image for attach type posts
     * Remove the broken image and remove link to broken image
     *
     * @private
     */
    _addBrokenImageHandler: function() {
        this.$(this._attachImageSelector).error(_.bind(function(event) {
            var $brokenImg = $(event.currentTarget),
                linkSelector = 'a[data-note-id="' + $brokenImg.data('note-id') + '"]';

            //first remove the link to the image which will also be broken
            //FIXME: this is hacky, but temporary until we fix how attachment posts are displayed in MAR-780
            this.$(linkSelector).contents().unwrap();
            //then remove the broken image
            $brokenImg.closest('div[class="embed"]').remove();
        }, this));
    },

    /**
     * Sets property on activity to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function() {
        var diffInDays = app.date().diff(this.model.get('date_entered'), 'days', true);
        this.useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
    },

    /**
     * Format all tags and link in post and comments.
     */
    formatAllTagsAndLinks: function() {
        var post = this.model.get('data');

        // Check to see if the post's module is in the blacklist, if so, delete
        // the module property from the object so it will not create a link to the record
        if (post.object && post.object.module && _.contains(this.blacklistModules, post.object.module)) {
            delete post.object.module;
        }

        this.unformatAllTagsAndLinks();

        if (post) {
            this._unformattedPost = post.value;
            post.value = this.formatLinks(post.value);
            post.value = this.formatTags(post.value);
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            this._unformattedComments[model.get('id')] = data.value;
            data.value = this.formatLinks(data.value);
            data.value = this.formatTags(data.value);
        }, this);
    },

    /**
     * Revert back to the unformatted version of tags and links
     */
    unformatAllTagsAndLinks: function() {
        var post = this.model.get('data');
        if (post) {
            post.value = this._unformattedPost || post.value;
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            data.value = this._unformattedComments[model.get('id')] || data.value;
        }, this);
    },

    /**
     * Searches the post to identify links and make them as actual links
     *
     * @param {String} post
     * @return {string}
     */
    formatLinks: function(post) {
        var formattedPost = '';

        if (post && (post.length > 0)) {
            formattedPost = post.replace(this.urlRegExp, function(url) {
                var href = url;
                if ((url.indexOf('http://') !== 0) && (url.indexOf('https://') !== 0)) {
                    href = 'http://' + url;
                }
                return '<a href="' + href + '" target="_blank">' + url + '</a>';
            });
        }

        return formattedPost;
    },

    /**
     * Resize the iframe that embeds video
     */
    resizeVideo: function() {
        // if this is disposed, then just bail as the code below with throw errors
        if (this.disposed === true) {
            return;
        }
        var data = this.model.get('data'),
            $embed = this.$('.embed'),
            $iframes = $embed.find('iframe'),
            videoCount = 0,
            embedWidth;

        if (_.isArray(data.embeds)) {
            embedWidth = $embed.width();
            _.each(data.embeds, function(embed) {
                var $iframe, iframeWidth, iframeHeight;

                if (((embed.type === 'video') || (embed.type === 'rich')) && ($iframes.length > 0)) {
                    $iframe = $iframes.eq(videoCount);

                    iframeWidth = Math.min(embedWidth, 480);
                    iframeHeight = parseInt(embed.height, 10) * (iframeWidth / parseInt(embed.width, 10));

                    $iframe.prop({
                        width: iframeWidth,
                        height: iframeHeight
                    });

                    videoCount++;
                }
            });
        }
    },

    /**
     * Sets the profile picture for activities based on the created by user.
     */
    processAvatars: function () {
        var comments = this.model.get('comments'),
            postPictureUrl;

        if (this.model.get('activity_type') === 'post' && !this.model.get('picture_url')) {
            postPictureUrl = this.getAvatarUrlForUser(this.model, 'post');
            this.model.set('picture_url', postPictureUrl);
        }

        if (comments) {
            comments.each(function (comment) {
                var commentPictureUrl = this.getAvatarUrlForUser(comment, 'comment');
                comment.set('picture_url', commentPictureUrl);
            }, this);
        }
    },

    /**
     * Builds and returns the url for the user's profile picture based on fetching from cache
     * @param model
     * @param activityType
     * @return {string}
     */
    getAvatarUrlForUser: function (model, activityType){
        var createdBy = model.get('created_by'),
            hasPicture = this.checkUserHasPicture(model, activityType);

        return hasPicture ? this.buildAvatarUrl(createdBy) : '';
    },

    /**
     * Checks cache to see if user has a picture, calls API if needed
     *
     * @param model The User
     * @param activityType
     * @return {boolean} whether user has a picture
     */
    checkUserHasPicture: function (model, activityType) {
        var createdBy = model.get('created_by'),
            hasPicture;

        // If processing the current user's avatar, no need to fetch
        if (createdBy === app.user.get('id')) {
            hasPicture = !_.isEmpty(app.user.get('picture'));
        } else {
            // Check cache
            hasPicture = this.getUserPictureStatus(createdBy);
        }

        // If not current user or cached, call api to check if user has a picture
        if (_.isUndefined(hasPicture)) {
            this.fetchUserPicture(model, activityType);
            hasPicture = false; // Use placeholder until api call finishes
        }

        return hasPicture;
    },

    /**
     * Retrieves a user and caches the results of whether the user has a profile picture.
     * Replaces the default icon with an image tag of the profile picture.
     *
     * @param model
     * @param activityType
     */
    fetchUserPicture: function(model, activityType) {
        var self = this,
            createdBy = model.get('created_by'),
            user = app.data.createBean('Users', {id: createdBy});

        user.fetch({
            fields: ["picture"],
            success: function () {
                var pictureUrl = self.buildAvatarUrl(createdBy),
                    hasPicture = !_.isEmpty(user.get('picture'));

                self.setUserPictureStatus(createdBy, hasPicture);

                // If picture exists, replace the activity image with the user's profile picture
                if (hasPicture) {
                    self.$('#avatar-' + activityType + '-' + model.get('id')).html("<img src='" + pictureUrl + "' alt='" + model.get('created_by_name') + "'>");
                }
            },
            error: function () {
                // Problem retrieving picture, use placeholder
                self.setUserPictureStatus(createdBy, false);
            }
        });
    },

    /**
     * Retrieve from the app cache whether user has a picture
     * Respects cache TTL, returns undefined if expired
     *
     * @param userId
     * @return {boolean|undefined} whether user has picture or `undefined` if cache not set or expired
     * @private
     */
    getUserPictureStatus: function(userId) {
        var hasPicture = app.cache.get(this.cacheNamePrefix + userId),
            cachedTTL = app.cache.get(this.cacheNamePrefix + userId + this.cacheNameExpire);

        return (cachedTTL < $.now()) ? undefined : hasPicture;
    },

    /**
     * Cache whether the user has a picture or not
     *
     * @param userId
     * @param hasPicture
     * @private
     */
    setUserPictureStatus: function(userId, hasPicture) {
        app.cache.set(this.cacheNamePrefix + userId, hasPicture);
        app.cache.set(this.cacheNamePrefix + userId + this.cacheNameExpire, $.now() + this.expiryTime);
    },

    /**
     * Build the file url for the given user's avatar
     *
     * @param userId
     * @return {string} The avatar url
     * @private
     */
    buildAvatarUrl: function(userId) {
        return app.api.buildFileURL({
            module: 'Users',
            id: userId,
            field: 'picture'
        });
    },

    toggleReplyBar: function() {
        this.$(".comment-btn").toggleClass("active");
        this.$(".reply-area").toggleClass("hide");
    },

    /**
     * Retrieve comment entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getComment: function() {
        return this.unformatTags(this.$('div.reply'));
    },

    /**
     * Determines the status and label for the preview button.
     *
     * @return {Object}
     * @return {Boolean} return.enabled Whether the preview is enabled.
     * @return {String} return.label The label to display in the preview button
     *   tooltip.
     */
    getPreviewData: function () {
        var parentModel,
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            },
            isBwcEnabled,
            module = this.model.get('display_parent_type');

        if (module) {
            // assume modules without metadata are BWC by default.
            isBwcEnabled = true;
            var moduleMetadata = app.metadata.getModule(module);
            if (moduleMetadata && _.has(moduleMetadata, 'isBwcEnabled')) {
                isBwcEnabled = moduleMetadata.isBwcEnabled;
            }
        } else {
            isBwcEnabled = false;
        }

        if (isBwcEnabled) {
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else if (this.model.get("activity_type") === 'attach') { //no preview for attachments
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_ATTACHMENT';
        } else if (_.isEmpty(this.model.get('display_parent_id')) || _.isEmpty(this.model.get('display_parent_type'))) {  //no related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
        } else if (!app.acl.hasAccess("view", this.model.get('display_parent_type'))) { //no access to related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
        } else if (this.model.get('preview_enabled') === false) { //deleted or no team access to related record
            preview.enabled = false;
            preview.label = this.model.get('preview_disabled_reason');
        } else {
            parentModel = this._getParentModel('record', this.context);
            // Check if the bean to be previewed is the same as the context.
            if (parentModel && parentModel.module == this.model.get('display_parent_type') && parentModel.id === this.model.get('display_parent_id')) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_SAME_RECORD';
            }
        }

        return preview;
    },

    /**
     * Traverse up the context hierarchy and look for given layout, retrieve the model from the layout's context
     *
     * @param layoutName to look for up the context hierarchy
     * @param context start of context hierarchy
     * @return {Mixed}
     * @private
     */
    _getParentModel: function(layoutName, context) {
        if (context) {
            if (context.get('layout') === layoutName) {
                return context.get('model');
            } else {
                return this._getParentModel(layoutName, context.parent);
            }
        } else {
            return null;
        }
    },

    checkPlaceholder: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
        } else {
            el.removeAttribute('data-hide-placeholder');
        }
    },

    /**
     * Data change event.
     */
    bindDataChange: function () {
        if (this.commentsCollection) {
            this.commentsCollection.on("add", function () {
                this.model.set('comment_count', this.model.get('comment_count') + 1);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    unbindData: function() {
        if (this.commentsCollection) {
            this.commentsCollection.off();
        }
        app.view.View.prototype.unbindData.call(this);
    },

    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this.$(this._attachImageSelector).off('error');
        app.view.View.prototype._dispose.call(this);
        this.commentsCollection = null;
        this.opts = null;
    }
}) }
}}
,
"layouts": {
"base": {
"default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DefaultLayout
 * @alias SUGAR.App.view.layouts.BaseDefaultLayout
 * @extends View.Layout
 */
/**
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `toggleSidebar` has been migrated to `sidebar:toggle`. It allows one param
 *    to indicate the state. {@link Layout.Default#toggleSidePane}
 *
 * - `openSidebar` has been removed. You can open the sidebar by triggering
 *    `sidebar:toggle` and passing `true`. Note that you can also close the
 *    sidebar by triggering `sidebar:toggle` and passing `false`.
 *
 * - `toggleSidebarArrows` has been removed. Trigger `sidebar:state:changed`
 *    with the value `open` or `close` instead.
 *
 * - `openSidebarArrows` has been removed. Trigger `sidebar:state:changed` with
 *    the value `open` instead.
 */
({
	// Default Layout (base) 

    className: 'row-fluid',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * Name of the last state. This can be overridden in metadata, please
         * refer to the example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @cfg {String}
         */
        this.HIDE_KEY = 'hide';

        /**
         * Default value for hiding the sidepane. `1` is hidden, `0` is show.
         * This is because the code which retrieves data from local storage
         * checks the value of the data and will return undefined if the result
         * resolves to a boolean false.
         *
         * Since an undefined hide value means "use the default" and int 0 means
         * show, but they both resolve to false, this causes complications. As a
         * result, we have to use a string.
         *
         * Using a string `0` or `1` is superior to something like "yes" and
         * "no" because we can use parseInt instead of an if/else setup.
         *
         * This setting can be overridden in metadata, please refer to the
         * example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @property {String}
         * @protected
         */
        this._defaultHide = '0';

        /**
         * Key for storing the last state. This key is used in localstorage of the
         * browser. It is generated using `HIDE_KEY`
         *
         * Example:
         *
         *     state:Accounts:default:hide_last_state_key
         *
         *
         * @property {String}
         * @protected
         */
        this._hideLastStateKey = null;

        this._super('initialize', [options]);
        if (!_.isUndefined(this.meta.default_hide)) {
            this._defaultHide = this.meta.default_hide;
        }
        if (!_.isUndefined(this.meta.hide_key)) {
            this.HIDE_KEY = this.meta.hide_key;
        }

        this.on('sidebar:toggle', this.toggleSidePane, this);

        this.meta.last_state = this.meta.last_state || { id: 'default' };

        this._hideLastStateKey = app.user.lastState.key(this.HIDE_KEY, this);

        //Update the panel to be open or closed depending on how user left it last
        this._toggleVisibility(this.isSidePaneVisible());
    },

    /**
     * Check whether the side pane is currently visible.
     *
     * @return {Boolean} `true` if visible, `false` otherwise.
     */
    isSidePaneVisible: function() {
        var hideLastState = app.user.lastState.get(this._hideLastStateKey);
        var hidden = hideLastState || this._defaultHide;
        return !parseInt(hidden, 10);
    },

    /**
     * Toggle sidebar and save the current state.
     *
     * Both the hidden and show state is stored. In the default configuration,
     * the side pane is `visible`.
     * In the non-default case, the hidden state is represented by `0`, and the
     * show state is represented by `1`.
     *
     * @param {Boolean} [visible] Pass `true` to show the sidepane, `false` to
     *  hide it, otherwise will toggle the current state.
     */
    toggleSidePane: function(visible) {
        var isVisible = this.isSidePaneVisible();

        visible = _.isUndefined(visible) ? !isVisible : visible;

        if (isVisible === visible) {
            return;
        }

        app.user.lastState.set(
            this._hideLastStateKey,
            visible ? '0' : '1'
        );

        this._toggleVisibility(visible);
    },

    /**
     * Toggle visibility of the side pane.
     *
     * Toggling visibility can affect the content width in the same way as a
     * window resize. Thus we will trigger window `resize` so that any content
     * listening for a window `resize` can readjust themselves.
     *
     * @param {Boolean} visible `true` to show the side pane, `false` otherwise.
     * @private
     */
    _toggleVisibility: function(visible) {
        this.$('.main-pane').toggleClass('span12', !visible).toggleClass('span8', visible);

        this.$('.side').toggleClass('side-collapsed', !visible);

        $(window).trigger('resize');

        this.trigger('sidebar:state:changed', visible ? 'open' : 'close');
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (component.meta.name) {
            this.$('.' + component.meta.name).append(component.$el);
        }
    },

    /**
     * Get the width of either the main or side pane depending upon where the
     * component resides.
     *
     * @param {View.Component} component The component.
     * @return {Number} The component width.
     */
    getPaneWidth: function(component) {
        if (!this.$el) {
            return 0;
        }
        var paneSelectors = ['.main-pane', '.side'],
            pane = _.find(paneSelectors, function(selector) {
                return ($.contains(this.$(selector).get(0), component.el));
            }, this);

        return this.$(pane).width() || 0;
    }
}) },
"dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The outer layout of the dashboard.
 *
 * This layout contains the header view and wraps the daslet-main layout.
 * The layouts for each dashboard are stored in the server.
 *
 * @class View.Layouts.Base.DashboardLayout
 * @alias SUGAR.App.view.layouts.BaseDashboardLayout
 * @extends View.Layout
 */
({
	// Dashboard Layout (base) 

    className: 'row-fluid',
    //FIXME We need to remove this. SC-4210 will address it.
    dashboardLayouts: {
        'record': 'record-dashboard',
        'records': 'list-dashboard',
        'search': 'search-dashboard'
    },
    events: {
        'click [data-action=create]': 'createClicked'
    },
    error: {
        //Dashboard is a special case where a 404 here shouldn't break the page,
        //it should just send us back to the default homepage
        handleNotFoundError: function(error) {
            var currentRoute = Backbone.history.getFragment();
            if (currentRoute.substr(0, 5) === 'Home/') {
                app.router.redirect('#Home');
                //Prevent the default error handler
                return false;
            }
        },
        handleValidationError: function(error) {
            return false;
        }
    },

    /**
     * What is the current Visible State of the dashboard
     */
    dashboardVisibleState: 'open',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var context = options.context,
            module = context.parent && context.parent.get('module') || context.get('module');

        if (options.meta && options.meta.method && options.meta.method === 'record' && !context.get('modelId')) {
            context.set('create', true);
        }

        var hasDashboardModels;

        // The dashboard can be used to display facets on the search page.
        // This is a special use case for dashboards.
        // This checks to see if we're in the search context (i.e. the search page).
        if (context.parent && context.parent.get('search')) {
            // Note that dashboard.js is initialized twice because `navigateLayout` will call initComponents directly,
            // which creates a new context for each dashboard.
            // See `navigateLayout` for more details.
            // Also note that the module for the facets dashboard is set to `Home` in the search layout metadata.
            // Therefore, we have two brother contexts, both of which are in the `Home` module.
            // One is the initial dashboard that is created when the search layout is created.
            // The other is instantiated by the dashboard's `navigateLayout` method.
            var contextBro = context.parent.getChildContext({module: 'Home'});
            hasDashboardModels = contextBro.get('collection') && contextBro.get('collection').length;
            if (hasDashboardModels) {
                context.set({
                    // currentDashboardIndex is the index of the dashboard that is currently being displayed.
                    // For the search page, we hardcode the dashboard indexes.
                    // This is possible because in search, we only allow the
                    //   help and facets dashboards.
                    // index 1 is for the search help dashboard
                    // index 2 is for the search facets dashboard
                    // 'currentDashboardIndex' is 1-based to be in sync with `model.id`.
                    // See `loadData` for more details.
                    model: contextBro.get('collection').at(contextBro.get('currentDashboardIndex') - 1),
                    collection: this._getNewDashboardObject('collection', context),
                    skipFetch: true
                });
            }
        }

        if (!hasDashboardModels) {
            var model = this._getNewDashboardObject('model', context);
            if (context.get('modelId')) {
                model.set('id', context.get('modelId'), {silent: true});
            }
            context.set({
                model: model,
                collection: this._getNewDashboardObject('collection', context)
            });
        }

        this._super('initialize', [options]);

        this._bindButtonEvents();

        this.model.on('setMode', function(mode) {
            if (mode === 'edit' || mode === 'create') {
                this.$('.dashboard').addClass('edit');
            } else {
                this.$('.dashboard').removeClass('edit');
            }
        }, this);

        // help dashboard triggers
        app.events.on('app:help:show', function() {
            this.openHelpDashboard(true);
        }, this);
        app.events.on('app:help:hide', function() {
            this.closeHelpDashboard(true);
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.dashboardVisibleState = state;
                if (state === 'open' && this.isHelpDashboard(true)) {
                    app.events.trigger('app:help:shown');
                } else {
                    app.events.trigger('app:help:hidden');
                }
            }, this);

            try {
                this.dashboardVisibleState = defaultLayout.isSidePaneVisible() ? 'open' : 'close';
            } catch (error) {
                // this happens when the dashboard component is initially created because the defaultLayout doesn't
                // have _hideLastStateKey key set yet.  Just ignore this for now as with the way dashboards work
                // it this code will get run again once the logic below selects which dashboard to show.
            }
        }

        // listen to the model sync event to figure out if we need to highlight the help button in the footer
        this.model.on('sync', function() {
            if (this.dashboardVisibleState === 'open' && this.isHelpDashboard(true)) {
                // when on the home page and the dashboard is a help dashboard, we need to hide the edit button
                // which means we need to re-render the dashboard-headerpane to contain the meta from
                // the help-dashboard-headerpane view
                if (this.module === 'Home') {
                    var list = this.getComponent('list'),
                        headerpane = (!_.isUndefined(list)) ? list.getComponent('dashboard-headerpane') : undefined;

                    if (headerpane) {
                        var help_headerpane_meta = app.metadata.getView(this.module, 'help-dashboard-headerpane');
                        help_headerpane_meta.last_state = headerpane.meta.last_state;
                        headerpane.meta = help_headerpane_meta;
                        headerpane.render();
                    }
                }
            }
        }, this);

        if (module === 'Home' && context.has('modelId')) {
            // save it as last visit
            var lastVisitedStateKey = this.getLastStateKey();
            app.user.lastState.set(lastVisitedStateKey, context.get('modelId'));
        }
    },

    /**
     * Binds the button events that are specific to the record pane.
     *
     * @protected
     */
    _bindButtonEvents: function() {
        this.context.on('button:save_button:click', this.handleSave, this);
    },

    /**
     * Overrides {@link View.Layout#initComponents} to trigger `change:metadata`
     * event if we are in the search results page.
     *
     * For other dashboards than the facet dashboard, `change:metadata` is
     * triggered by {@link View.Fields.Base.Home.LayoutbuttonField} but we don't
     * use this field in the facets dashboard so we need to trigger it here.
     *
     * @override
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);
        if (this.isSearchContext()) {
            // For non-search dashboards, `change:metadata` is triggered by the
            // `layoutbutton.js`. We don't use this field in the facets
            // dashboard, so we need to trigger it here.
            this.model.trigger('change:metadata');
        }
    },

    /**
     * Indicates if we are in the search page or not.
     *
     * @return {boolean} `true` means we are in the search page.
     */
    isSearchContext: function() {
        return this.context.parent && this.context.parent.get('search');
    },

    /**
     * Method to open the help dashboard if it's not already loaded. This will
     * also toggle the sidebar to open if it's collapsed.
     *
     * @param {boolean} [fromEvent] Flag to indicate if the fuction was called
     *   from an event. `true` if called from an event and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9. Use the event
     *   {@link App#event-app:help:show} instead.
     */
    openHelpDashboard: function(fromEvent) {
        if (!fromEvent) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#openHelpDashboard is deprecated since 7.7. Will be removed in 7.9. Use the event "app:help:show" instead.');
        }

        if (this.dashboardVisibleState === 'close') {
            var defaultLayout = this.closestComponent('sidebar');
            if (defaultLayout) {
                defaultLayout.toggleSidePane(true);
            }
        }
        if (!this.isHelpDashboard(fromEvent)) {
            if (this.isSearchContext()) {
                var contextBro = this.getContextBro(this.context.get('module'));
                // Index 1 is the help dashboard.
                // See comments in `initialize` for more details.
                contextBro.set('currentDashboardIndex', 1);
                this.showHelpDashboard(contextBro.get('collection'), fromEvent);
                return;
            } else {
                // if the help dashboard is already visible, just leave it
                this.collection.fetch({
                    silent: true,
                    success: _.bind(function(collection) {
                        this.showHelpDashboard.apply(this, [collection, fromEvent]);
                    }, this)
                });
            }
        }
    },

    /**
     * Method to close the help dashbaord, if the help dashboard is visible.
     *
     * @param {boolean} [fromEvent] Flag to indicate if the fuction was called
     *   from an event. `true` if called from an event and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9. Use the event
     *   {@link App#event-app:help:hide} instead.
     */
    closeHelpDashboard: function(fromEvent) {
        if (!fromEvent) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#closeHelpDashboard is deprecated since 7.7. Will be removed in 7.9. Use the event "app:help:hide" instead.');
        }

        if (this.isHelpDashboard(fromEvent)) {
            if (this.isSearchContext()) {
                var contextBro = this.getContextBro(this.context.get('module'));
                // Index 2 is the facet dashboard.
                // See comments in `initialize` for more details.
                contextBro.set('currentDashboardIndex', 2);
                this.hideHelpDashboard(contextBro.get('collection'), fromEvent);
                return;
            }
            // the active one is not a help dashboard, don't bother refreshing the page
            this.collection.fetch({
                silent: true,
                success: _.bind(function(collection) {
                    this.hideHelpDashboard.apply(this, [collection, fromEvent]);
                }, this)
            });
        }
    },

    /**
     * Load the dashboards for the current module/view and then find the help
     * dashboard and display it, it should always exists but if it doesn't,
     * just ignore it.
     *
     * @param {Object} collection The collection of dashboards returned from the
     *   fetch.
     * @param {boolean} [fromEvent] Flag to indicate if the fuction was called
     *   from an event. `true` if called from an event and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9. Use the event
     *   {@link App#event-app:help:show} instead.
     */
    showHelpDashboard: function(collection, fromEvent) {
        if (!fromEvent) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#showHelpDashboard is deprecated since 7.7. Will be removed in 7.9. Use the event "app:help:show" instead to open the help dashboard.');
        }

        var dashboard = _.find(collection.models, function(model) {
            return (model.get('dashboard_type') === 'help-dashboard');
        });
        this._navigate(dashboard);
        app.events.trigger('app:help:shown');
    },

    /**
     * Load the dashboards for the current module/view and then find the first
     * non-help dashboard and display it.
     *
     * @param {Object} collection The collection of dashboards returned from the
     *   fetch.
     * @param {boolean} [fromEvent] Flag to indicate if the fuction was called
     *   from an event. `true` if called from an event and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9. Use the event
     *   {@link App#event-app:help:hide} instead.
     */
    hideHelpDashboard: function(collection, fromEvent) {
        if (!fromEvent) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#hideHelpDashboard is deprecated since 7.7. Will be removed in 7.9. Use the event "app:help:hide" instead to close the help dashboard.');
        }

        var dashboard = _.find(collection.models, function(model) {
            return (model.get('dashboard_type') != 'help-dashboard');
        });

        // clear out the last state key for the help dashboard,
        // it will be reset
        app.user.lastState.set(this.getLastStateKey(), '');

        this._navigate(dashboard);
    },

    /**
     * Is the current open dashboad a help dashboard.
     *
     * @param {boolean} [fromEvent] Flag to indicate if the fuction was called
     *   from an event. `true` if called from an event and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9.
     */
    isHelpDashboard: function(fromEvent) {
        if (!fromEvent) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#isHelpDashboard is deprecated since 7.7. Will be removed in 7.9.');
        }

        return (this.model.get('dashboard_type') === 'help-dashboard');
    },

    /**
     * Gets the brother context.
     *
     * @param {string} module The module to get the brother context from.
     * @return {Core.Context} The brother context.
     */
    getContextBro: function(module) {
        return this.context.parent.getChildContext({module: module});
    },

    /**
     * @inheritdoc
     */
    loadData: function(options, setFields) {
        // Dashboards store their own metadata as part of their model.
        // For search facet dashboard, we do not want to load the dashboard
        // metadata from the database. Instead, we build the metadata below.
        if (this.isSearchContext()) {
            // The model does not have metadata the first time this function
            // is called. In subsequent calls, the model should have metadata
            // so we do not need to fetch it.
            if (this.model.has('metadata')) {
                return;
            }

            this._loadSearchDashboards();

            this.context.set('skipFetch', true);
            // Index 2 is the facet dashboard. We display it by default in the
            // search page.
            this.context.set('currentDashboardIndex', 2);
            this.navigateLayout(null, 'search-dashboard');
            return;
        }

        if (this.context.parent && !this.context.parent.isDataFetched()) {
            var parent = this.context.parent.get('modelId') ?
                this.context.parent.get('model') : this.context.parent.get('collection');

            if (parent) {
                parent.once('sync', function() {
                    this._super('loadData', [options, setFields]);
                }, this);
            }
        } else {
            this._super('loadData', [options, setFields]);
        }
    },

    /**
     * Loads the facet and help dashboards for the search page, and add them in
     * the collection.
     *
     * @private
     */
    _loadSearchDashboards: function() {
        var dashboardsMeta = this._getInitialDashboardMetadata();
        _.each(dashboardsMeta, function(dashMeta, index) {
            var model = this._getNewDashboardObject('model', this.context);
            // The `id` has to be 1-based, otherwise `data-id` has no value
            // in dashboardtitle/detail.hbs because 0 is falsy.
            model.set('id', ++index);
            // In `dashMeta`, we have a `metadata` property which contains all
            // the metadata needed for the dashboard.
            model.set(dashMeta);
            this.collection.add(model);
        }, this);
    },

    /**
     * Navigate to the create layout when create button is clicked.
     *
     * @param {Event} evt Mouse event.
     */
    createClicked: function(evt) {
        if (this.model.dashboardModule === 'Home') {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        } else {
            this.navigateLayout('create');
        }
    },

    /**
     * Places only components that include the Dashlet plugin and places them in the 'main-pane' div of
     * the dashlet layout.
     * @param {app.view.Component} component
     * @private
     */
    _placeComponent: function(component) {
        var dashboardEl = this.$('[data-dashboard]'),
            css = this.context.get('create') ? ' edit' : '';
        if (dashboardEl.length === 0) {
            dashboardEl = $('<div></div>').attr({
                'class': 'cols row-fluid'
            });
            this.$el.append(
                $('<div></div>')
                    .addClass('dashboard' + css)
                    .attr({'data-dashboard': 'true'})
                    .append(dashboardEl)
            );
        } else {
            dashboardEl = dashboardEl.children('.row-fluid');
        }
        dashboardEl.append(component.el);
    },

    /**
     * If current context doesn't contain dashboard model id,
     * it will trigger set default dashboard to create default metadata
     */
    bindDataChange: function() {
        if (this.isSearchContext()) {
            return;
        }
        var modelId = this.context.get('modelId');
        if (!(modelId && this.context.get('create')) && this.collection) {
            // On the search page, we don't want to save the facets dashboard
            // in the database, so we don't need to listen to changes on the
            // collection nor do we need to call `setDefaultDashboard`.
            this.collection.on('reset', this.setDefaultDashboard, this);
        }
    },

    /**
     * Build the default dashboard metadata only if dashboards are empty.
     *
     * Default dashboard metadata are stored in the following layout metadata
     * <pre>
     * listview - list-dashboard
     * recordview - record-dashboard
     * </pre>
     * If the default dashboard is not assigned,
     * the layout will render dashboard-empty template.
     */
    setDefaultDashboard: function() {
        if (this.disposed) {
            return;
        }
        var lastVisitedStateKey = this.getLastStateKey(),
            lastViewed = app.user.lastState.get(lastVisitedStateKey),
            hasHelpOnly = (this.collection.models.length == 1 &&
                _.first(this.collection.models).get('dashboard_type') === 'help-dashboard'),
            helpLastShown = (hasHelpOnly && lastViewed === _.first(this.collection.models).get('id'));

        if (hasHelpOnly && !helpLastShown) {
            // If the collection contains exactly one model that is a help dashboard,
            // and the user saw the help dashboard last and chose to hide it, show the empty template
            this._renderEmptyTemplate();
        } else if (this.collection.models.length > 0) {
            var currentModule = this.context.get('module'),
                model;

            if (currentModule !== 'Home') {
                model = _.first(this.collection.models);
            } else {
                // get the first model that is not a help-dashboard
                model = this.collection.find(function(dash) {
                    return dash.get('dashboard_type') === 'dashboard';
                });
            }

            if (lastViewed) {
                var lastVisitedModel = this.collection.get(lastViewed);
                //if last visited dashboard not in the fetching list,
                //it should navigate to the first searched dashboard.
                //And it should clean out the previous last visited dashboard,
                //since it is no longer existed.
                if (!_.isEmpty(lastVisitedModel)) {
                    app.user.lastState.set(lastVisitedStateKey, '');
                    model = lastVisitedModel;
                }
            }

            if (currentModule == 'Home' && _.isString(lastViewed) && lastViewed.indexOf('bwc_dashboard') !== -1) {
                app.router.navigate(lastViewed, {trigger: true});
            } else {
                // use the _navigate helper
                this._navigate(model);
            }
        } else {
            var _initDashboard = this._getInitialDashboardMetadata();

            if (_initDashboard && !_.isEmpty(_initDashboard.metadata)) {
                // Drill-down to the dashlet level to check permissions for that module.
                _.each(_initDashboard.metadata['components'], function(component, component_key) {
                    _.each(component['rows'], function(row, row_key) {
                        // Loop the cells checking access, rebuilding the cell array to only contain permitted dashlets.
                        _initDashboard.metadata['components'][component_key]['rows'][row_key] =
                            _.filter(row, function(cell) {
                                var module = (cell.context && cell.context.module) ? cell.context.module : this.module;
                                return (!app.acl.hasAccess('access', module));
                            });
                    }, this);

                    // Now that we've processed all the rows in this component,
                    // rebuild the array to only have rows with dashlets.
                    _initDashboard.metadata['components'][component_key]['rows'] =
                        _.filter(_initDashboard.metadata['components'][component_key]['rows'], function(row) {
                            return (row.length > 0);
                        });
                }, this);
            }

            _.each(_initDashboard, function(dash) {
                var model = this._getNewDashboardObject('model', this.context);
                model.set(dash);
                if (this.context.get('modelId')) {
                    model.set('id', this.context.get('modelId'), {silent: true});
                }
                // make sure that the model actually has some metadata
                if (!_.isUndefined(model.get('metadata'))) {
                    model.save({}, this._getDashboardModelSaveParams());
                    this.collection.add(model);
                }
            }, this);
        }
    },

    /**
     * Gets initial dashboard metadata and adds help dashboard if it doesnt exist
     *
     * @return {Array} an array of dashboard metadata
     * @private
     */
    _getInitialDashboardMetadata: function() {
        var layoutName = this.dashboardLayouts[this.context.parent && this.context.parent.get('layout') || 'record'],
            initDash = app.metadata.getLayout(this.model.dashboardModule, layoutName) || {};

        // check to make sure this module has initial dashboards assigned for this view
        if (_.has(initDash, 'metadata')) {
            // make sure there's a dashboard_type of "dashboard" by default
            // unless there's a specific custom dashboard_type already defined
            initDash.dashboard_type = initDash.dashboard_type || 'dashboard';
        }

        return this.addHelpDashboardMetadata(initDash, true);
    },

    /**
     * Adds the help-dashboard metadata to a metadata Object.
     *
     * @param {Object} _initDashboard The default dashboard for a module.
     * @param {boolean} [suppressWarning] Flag to suppress the deprecation
     *   warning. `true` if this method was called within
     *   {@link View.Layouts.Base.DashboardLayout} and `false` if called
     *   directly. Added for deprecation logging purposes only.
     *
     * @deprecated Since 7.7. Will be removed in 7.9.
     */
    addHelpDashboardMetadata: function(_initDashboard, suppressWarning) {
        if (!suppressWarning) {
            app.logger.warn('View.Layouts.Base.DashboardLayout#addHelpDashboardMetadata is deprecated since 7.7. Will be removed in 7.9.');
        }

        var _helpDB = app.metadata.getLayout(this.model.dashboardModule, 'help-dashboard');
        if (_.has(_initDashboard, 'metadata')) {
            _initDashboard = [_helpDB, _initDashboard];
        } else {
            _initDashboard = [_helpDB];
        }
        return _initDashboard;
    },

    /**
     * Build the cache key for last visited dashboard
     * Combine parent module and view name to build the unique id
     *
     * @return {String} hash key.
     */
    getLastStateKey: function() {
        if (this._lastStateKey) {
            return this._lastStateKey;
        }
        var model = this.context.get('model'),
            view = model.get('view_name'),
            module = model.dashboardModule,
            key = module + '.' + view;
        this._lastStateKey = app.user.lastState.key(key, this);
        return this._lastStateKey;
    },


    /**
     * Utility method to use when trying to figure out how we need to navigate when switching dashboards
     *
     * @param {Backbone.Model} (dashboard) The dashboard we are trying to navigate to
     * @private
     */
    _navigate: function(dashboard) {
        // if we get here and it's disposed, just return out
        if (this.disposed) {
            return;
        }
        var hasParentContext = (this.context && this.context.parent),
            hasModelId = (dashboard && dashboard.has('id')),
            actualModule = (hasParentContext) ? this.context.parent.get('module') : this.module,
            isHomeModule = (actualModule === 'Home');

        if (hasParentContext && hasModelId) {
            // we are on a module and we have an dashboard id
            this._navigateLayout(dashboard.get('id'), dashboard.get('dashboard_type'));
        } else if (hasParentContext && !hasModelId) {
            // we are on a module but we don't have a dashboard id
            this._navigateLayout('list');
        } else if (!hasParentContext && hasModelId && isHomeModule) {
            // we on the Home module and we have a dashboard id
            app.navigate(this.context, dashboard);
        } else if (isHomeModule) {
            // we on the Home module and we don't have a dashboard
            var route = app.router.buildRoute(this.module);
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Intercept the navigateLayout calls to make sure that the dashboard we are currently one didn't change,
     * if it did, we need to prompt and make sure they want to continue or cancel.
     *
     * @param {String} dashboard What dashboard do we want to display
     * @param {string} [type] What type of dashboard are we loading, default `dashboard`
     * @return {Boolean}
     * @private
     */
    _navigateLayout: function(dashboard, type) {
        var onConfirm = _.bind(function() {
                this.navigateLayout(dashboard, type);
            }, this),
            headerpane = this.getComponent('dashboard-headerpane');

        // if we have a headerpane and it was changed then run the warnUnsavedChanges method
        if (headerpane && headerpane.changed) {
            return headerpane.warnUnsavedChanges(
                onConfirm,
                undefined,
                _.bind(function() {
                    // when the cancel button is presses, we need to clear out the collection
                    // because it messes with the add dashlet screen.
                    this.collection.reset([], {silent: true});
                }, this)
            );
        }

        // if we didn't have a headerpane or we did have one, but nothing changed, just run the normal method
        onConfirm();
    },

    /**
     * For the RHS dashboard, this method loads entire dashboard component and adds the
     * <pre><code>dashboard_type</code></pre> member to the context of the dashboard.
     * <pre><code>dashboard_type</code></pre> gets used in dashletselect to filter dashlets
     *
     * @param {String} id dashboard id
     * @param {String} [type] what type of dashboard are we dealing with, default: `dashboard`
     */
    navigateLayout: function(id, type) {
        var layout = this.layout;
        var lastVisitedStateKey = this.getLastStateKey();
        var type = !_.isUndefined(type) ? type : 'dashboard';

        // Default to using dashboard-headerpane for the header.
        var headerPaneView = 'dashboard-headerpane';

        // In the search page, we can't use the standard help dashboard
        // headerpane for the help dashboard because we don't want the
        // action buttons.
        // Also, we can't use the same as the facets dashboard headerpane
        // because that headerpane contains a search specific cog button.
        // Therefore, we created a special headerpane for the help dashboard in
        // the search page.
        if (this.isSearchContext() && type === 'help-dashboard') {
            headerPaneView = 'search-help-dashboard-headerpane';
        } else if (app.metadata.getView('Home', type + '-headerpane')) {
            headerPaneView = type + '-headerpane';
        }

        this.dispose();

        if (type === 'help-dashboard') {
            app.events.trigger('app:help:shown');
        } else {
            app.events.trigger('app:help:hidden');
        }

        //if dashboard layout navigates to the different dashboard,
        //it should store last visited dashboard id.
        if (!_.contains(['create', 'list'], id)) {
            app.user.lastState.set(lastVisitedStateKey, id);
        }

        // add dashboard type to context variables,
        // can only create dashboards with dashboard_type of 'dashboard'
        var ctxVars = { dashboard_type: 'dashboard' };
        if (id === 'create') {
            ctxVars.create = true;
        } else if (id !== 'list') {
            ctxVars.modelId = id;
        }

        layout.initComponents([
            {
                // Note that we reinitialize the dashboard layout itself, creating a new context (forceNew: true)
                layout: {
                    type: 'dashboard',
                    components: (id === 'list') ? [] : [
                        {
                            view: headerPaneView
                        },
                        {
                            layout: 'dashlet-main'
                        }
                    ],
                    last_state: {
                        id: 'last-visit'
                    }
                },
                context: _.extend({
                    module: 'Home',
                    forceNew: true
                }, ctxVars)
            }
        ]);

        layout.removeComponent(0);
        layout.loadData({}, false);
        layout.render();
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        var model, collection;
        if (this.collection) {
            this.collection.off('reset', this.setDefaultDashboard, this);
        }
        if (this.context.parent) {
            model = this.context.parent.get('model');
            collection = this.context.parent.get('collection');

            if (model) {
                model.off('sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Returns a Dashboard Model or Dashboard Collection based on modelOrCollection
     *
     * @param {String} modelOrCollection The return type, 'model' or 'collection'
     * @param {Object} context
     * @return {Bean|BeanCollection}
     * @private
     */
    _getNewDashboardObject: function(modelOrCollection, context) {
        var obj,
            ctx = context && context.parent || context,
            module = ctx.get('module') || context.get('module'),
            layoutName = ctx.get('layout') || '',
            sync = function(method, model, options) {

                options = app.data.parseOptionsForSync(method, model, options);
                // there is no max limit for number of dashboards permodule view
                if (options && options.params ) {
                    options.params.max_num = -1;
                }

                var callbacks = app.data.getSyncCallbacks(method, model, options),
                    path = (this.dashboardModule === 'Home' || model.id) ?
                                this.apiModule : this.apiModule + '/' + this.dashboardModule;
                if (method === 'read') {
                    options.params.view_name = layoutName;
                }

                app.data.trigger('data:sync:start', method, model, options);
                model.trigger('data:sync:start', method, options);

                app.api.records(method, path, model.attributes, options.params, callbacks);
            };

        if (module === 'Home') {
            layoutName = '';
        }
        switch (modelOrCollection) {
            case 'model':
                obj = this._getNewDashboardModel(module, layoutName, sync);
                break;

            case 'collection':
                obj = this._getNewDashboardCollection(module, layoutName, sync);
                break;
        }

        return obj;
    },

    /**
     * Returns a new Dashboard Bean with proper view_name and sync function set
     *
     * @param {String} module The name of the module we're in
     * @param {String} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {Boolean} getNew If you want a new instance or just the the Dashboard definition (optional)
     * @return {Dashboard} a new Dashboard Bean
     * @private
     */
    _getNewDashboardModel: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;
        var Dashboard = app.Bean.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            maxColumns: (module === 'Home') ? 3 : 1,
            minColumnSpanSize: (module === 'Home') ? 4 : 12,
            defaults: {
                view_name: layoutName
            }
        });
        return (getNew) ? new Dashboard() : Dashboard;
    },

    /**
     * Returns a new DashboardCollection with proper view_name and sync function set
     *
     * @param {String} module The name of the module we're in
     * @param {String} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {Boolean} getNew If you want a new instance or just the the DashboardCollection definition (optional)
     * @return {DashboardCollection} A new Dashboard BeanCollection
     * @private
     */
    _getNewDashboardCollection: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;
        var Dashboard = this._getNewDashboardModel(module, layoutName, syncFn, false),
            DashboardCollection = app.BeanCollection.extend({
                sync: syncFn,
                apiModule: 'Dashboards',
                module: 'Home',
                dashboardModule: module,
                model: Dashboard
            });
        return (getNew) ? new DashboardCollection() : DashboardCollection;
    },

    /**
     * Collects params for Dashboard model save
     *
     * @return {Object} The dashboard model params to pass to its save function
     * @private
     */
    _getDashboardModelSaveParams: function() {
        var params = {
            silent: true,
            //Don't show alerts for this request
            showAlerts: false
        };

        params.error = _.bind(this._renderEmptyTemplate, this);

        params.success = _.bind(function(model) {
            if (!this.disposed) {
                if (model.get('dashboard_module') !== 'Home') {
                    // if this is not the Home module, only navigate to the Help dashboards
                    if (model.get('dashboard_type') === 'help-dashboard') {
                        this._navigate(model);
                    }
                } else {
                    // if this is the Home module, navigate to the non-Help My Dashboard
                    if (model.get('dashboard_type') === 'dashboard') {
                        this._navigate(model);
                    }
                }
            }
        }, this);

        return params;
    },

    /**
     * Gets the empty dashboard layout template
     * and renders it to <pre><code>this.$el</code></pre>
     *
     * @private
     */
    _renderEmptyTemplate: function() {
        var tplName = this.type || this.name,
            template = app.template.getLayout(tplName + '.dashboard-empty');
        this.$el.html(template(this));
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // always trigger the help button off
        app.events.trigger('app:help:hidden');

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.stopListening(defaultLayout);
        }

        this.dashboardLayouts = null;
        this._super('_dispose');
    },

    /**
     * Saves the dashboard to the server.
     */
    handleSave: function() {
        this.model.save({}, {
            //Show alerts for this request
            showAlerts: true,
            fieldsToValidate: {
                'name' : {
                    required: true
                },
                'metadata' : {
                    required: true
                }
            },
            success: _.bind(function() {
                this.model.unset('updated');
                if (this.context.get('create')) {
                    // We have a parent context only for dashboards in the RHS.
                    if (this.context.parent) {
                        this.getContextBro('Home').get('collection').add(this.model);
                        this.navigateLayout(this.model.id);
                    } else {
                        app.navigate(this.context, this.model);
                    }
                } else {
                    this.context.trigger('record:set:state', 'view');
                }
            }, this),
            error: function() {
                app.alert.show('error_while_save', {
                    level: 'error',
                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                });
            }
        });
    }
}) },
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerLayout
 * @extends View.Layout
 */
({
	// Config-drawer Layout (base) 


    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * Check to make sure the module actually has a config in metadata
     */
    configMetadataOK: false,

    /**
     * If User access to this module is OK
     */
    accessUserOK: false,

    /**
     * If User's access to module-specific ACLs are OK
     */
    accessModuleOK: false,

    /**
     * If DB or other module-specific configuration are OK
     */
    accessConfigOK: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        Object.defineProperty(this, 'currentModule', {
            /**
             * @property {string}
             * @deprecated since 7.7.0.0 and will be removed in 7.8.0.0.
             *   Please use {@link #module} instead.
             */
            get: function () {
                app.logger.warn('ConfigDrawerLayout\'s `currentModule` property is deprecated since 7.7.0 and will be removed in 7.8.0. ' +
                    'Please use `module` instead.');
                return this.module;
            }
        });

        this.moduleLangObj = {
            module: this.module
        };

        if (this.checkAccess()) {
            // get the context model
            var ctxModel = options.context.get('model'),
                metadata = app.metadata.getModule(this.module);
            // empty the model
            ctxModel.clear({silent: true});

            if (_.has(metadata, 'config')) {
                // load the model with module's config
                ctxModel.set(metadata.config);
            }

            this.loadConfig(options);
        }
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        if (this.checkAccess()) {
            this._super('_render');
        } else {
            this.blockModule();
        }
    },

    /**
     * Continues initializing Config and loads data
     *
     * @param {Object} [options] The `options` param passed in to initialize
     */
    loadConfig: function(options) {
        this._super('loadData');
    },

    /**
     * Checks if User has access to this module
     * Should be overridden in modules to provide module-specific access requirements
     *
     * @return {boolean}
     */
    checkAccess: function() {
        this.configMetadataOK = this._checkConfigMetadata();
        this.accessUserOK = this._checkUserAccess();
        this.accessModuleOK = this._checkModuleAccess();
        this.accessConfigOK = this._checkModuleConfig();
        return (this.configMetadataOK && this.accessUserOK && this.accessModuleOK && this.accessConfigOK);
    },

    /**
     * Checks if there's actually config in the metadata for the current module
     *
     * @return {boolean}
     * @private
     */
    _checkConfigMetadata: function() {
        return !_.isEmpty(app.metadata.getModule(this.module, 'config'));
    },

    /**
     * Checks if the User has access to the current module
     *
     * @return {boolean}
     * @private
     */
    _checkUserAccess: function() {
        return !_.has(app.user.getAcls()[this.module], 'access');
    },

    /**
     * Allow modules to have specific access checks to allow configuration
     * Ex. Forecasts is only configurable by SystemAdmins & Forecasts Developers, not Forecasts admins
     *
     * @return {boolean}
     * @private
     */
    _checkModuleAccess: function() {
        return true;
    },

    /**
     * Adds an extra level for if the config cannot be loaded because of some module-specific case
     * Ex. Forecasts config doesn't have the right Sales Stage Won/Lost
     *
     * @return {boolean}
     * @private
     */
    _checkModuleConfig: function() {
        return true;
    },

    /**
     * Blocks config from continuing to load
     */
    blockModule: function() {
        var title = app.lang.get('LBL_CONFIG_BLOCKED_TITLE', this.module, this.moduleLangObj),
            msg;

        if (!this.configMetadataOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_NO_CONFIG_METADATA', this.module, this.moduleLangObj);
        } else if (!this.accessUserOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_USER_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessModuleOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_MODULE_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessConfigOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_CONFIG_ACCESS', this.module, this.moduleLangObj);
        }

        this.displayNoAccessAlert(title, msg);
    },

    /**
     * Displays an Error Alert with the passed in title and message
     *
     * @param {String} title Already-translated language string for the Alert's title
     * @param {String} msg Already-translated language string for the Alert's message
     */
    displayNoAccessAlert: function(title, msg) {
        var alert = app.alert.show('no_access_to_module_' + this.module, {
            level: 'error',
            title: title,
            messages: [msg]
        });

        var $close = alert.getCloseSelector();
        $close.on('click', function() {
            $close.off();
            app.router.navigate('#Home', {trigger: true});
        });
        app.accessibility.run($close, 'click');

        app.drawer.close(this.context, this.module);
    },

    /**
     * Overrides loadData to defer it running until we call it in _onceInitSelectedUser
     *
     * @override
     */
    loadData: function() {
    }
}) },
"subpanels-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsCreateLayout
 * @extends View.Layouts.Base.SubpanelsLayout
 */
({
	// Subpanels-create Layout (base) 

    extendsFrom: 'SubpanelsLayout'
}) },
"multi-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.MultiSelectionListLayout
 * @alias SUGAR.App.view.layouts.BaseMultiSelectionListLayout
 * @extends View.Layouts.Base.SelectionListLayout
 */
({
	// Multi-selection-list Layout (base) 

    extendsFrom: 'SelectionListLayout'
}) },
"dashlet-cell": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletCellLayout
 * @alias SUGAR.App.view.layouts.BaseDashletCellLayout
 * @extends View.Layouts.Base.DashletRowLayout
 */
({
	// Dashlet-cell Layout (base) 

    extendsFrom: 'DashletRowLayout',
    tagName: 'ul',
    className: 'dashlet-cell rows row-fluid',

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def) {
        var span = 'dashlet-container span' + (def.width || 12),
            self = this;
        this.$el.append($("<li>", {'class': span}).data("index", function() {
            var index = def.layout.index.split('').pop();
            return self.index + '' + index;
        }).append(comp.el));
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            if(!(component.view || component.layout)) {
                meta.components[index] = _.extend({}, {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        empty: true,
                        components: [
                            {
                                view: 'dashlet-cell-empty',
                                context:{
                                    module:'Home',
                                    create:true
                                }
                            }
                        ]
                    }
                }, component);
            } else {
                var def = component.view || component.layout;
                if (!_.isObject(def)) {
                    def = component;
                }
                if(component.context) {
                    _.extend(component.context, {
                        forceNew: true
                    })
                }
                meta.components[index] = {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        label: def.label || def.name || "",
                        components: [
                            component
                        ]
                    },
                    width: component.width
                };
            }
        }, this);

        return meta;
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashletselect Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Dashlet:Select:Cancel']
}) },
"module-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module list sets all the user defined modules visible in the main menu.
 *
 * This layout is responsible to keep the all the menus (created using
 * {@link View.Views.BaseModuleMenuView}) in a valid state.
 * It shows the menu in the main bar as well as in the dropdown (show more)
 * and keeps it in sync to provide the best user experience possible, while
 * keeping the DOM changes to a minimum.
 *
 * @class View.Layouts.Base.ModuleListLayout
 * @alias SUGAR.App.view.layouts.BaseModuleListLayout
 * @extends View.Layout
 */
({
	// Module-list Layout (base) 

    className: 'module-list',
    plugins: ['Dropdown'],

    /**
     * The catalog of modules linked to their menus (short and long).
     *
     * The menu element is to the partial created at {@link #_placeComponent}
     * method.
     *
     * @property {Object} A hash of module name with each short and long menus:
     * <pre><code>
     *     {
     *         'Home': {long: el1, short: el2},
     *         'Accounts': {long: el3, short: el4},
     *         //...
     *     }
     * </code></pre>
     *
     * @protected
     */
    _catalog: {},

    /**
     * The cached `[data-action=more-modules]` since this view can be quite
     * big.
     *
     * @property {jQuery} The jQuery element pointing to our
     *   `[data-action=more-modules]` element.
     *
     * @protected
     */
    _$moreModulesDD: undefined,

    /**
     * @inheritdoc
     *
     * Hooks to `app:sync:complete` to handle the refresh of the menu items
     * that are available after a complete sync.
     * Hooks to `app:view:change` to keep the active module highlighted.
     */
    initialize: function(options) {

        app.events.on('app:sync:complete', this._resetMenu, this);
        app.events.on('app:view:change', this.handleViewChange, this);

        this._super('initialize', [options]);

        if (this.layout) {
            this.toggleResize(true);
        }
    },

    /**
     * Toggles the resize listener on or off.
     * Pass `true` to turn the listener on, or `false` to turn the listener off.
     * @param {boolean} resize
     */
    toggleResize: function(resize) {
        this.layout.off('view:resize');
        if (resize) {
            this.layout.on('view:resize', this.resize, this);
        }
    },

    /**
     * Method called on `app:view:change` hooked in
     * {@link BaseModuleListLayout#initialize}.
     *
     * It sets the active module to the one set in the context and fires a
     * `header:update:route` event to it's parent layout.
     */
    handleViewChange: function() {
        var module = app.controller.context.get('module');
        var component = app.drawer.getActive();
        if (component && component.context.get('fromRouter')) {
            module = component.context.get('module');
        }

        this._setActiveModule(module);
        this.layout.trigger('header:update:route');
    },

    /**
     * @inheritdoc
     *
     * If it is a `module-menu` component, we wrap it with our `list` template
     * and place it before the `more-modules` drop down or inside the drop down
     * if we are handling a short version of the menu.
     * The short version is always hidden, since it will be toggled on the
     * first resize call (when it overflows the existing width).
     *
     * @param {View.View/View.Layout} component View or layout component.
     * @protected
     */
    _placeComponent: function(component) {
        if (component.name !== 'module-menu') {
            this.$el.append(component.el);
            return;
        }

        var tpl = app.template.getLayout(this.name + '.list', component.module) ||
            app.template.getLayout(this.name + '.list'),
            $content = $(tpl({module: component.module})).append(component.el);

        // initialize catalog if isn't initialized
        this._catalog[component.module] = this._catalog[component.module] || {};

        if (component.meta && component.meta.short) {
            $content.addClass('hidden');
            this._catalog[component.module].short = $content;
            this._$moreModulesDD.find('[data-container="overflow"]').append($content);
        } else {
            this._catalog[component.module].long = $content;
            this.$('[data-action="more-modules"]').before($content);
        }
    },

    /**
     * Resets the menu based on new metadata information.
     *
     * It resets components, catalog and template (html), and calls
     * {@link #resize} with the last known space available for this view.
     *
     * @protected
     */
    _resetMenu: function() {

        this._components = [];
        this._catalog = {};
        this.$el.html(this.template(this, this.options));

        // cache the more-dropdown now
        this._$moreModulesDD = this.$('[data-action="more-modules"]');

        this._addDefaultMenus();
        this._setActiveModule(app.controller.context.get('module'));
        this.render();
        this.resize(this._width);
    },

    /**
     * Adds all default menu views as components in both full and short
     * version.
     *
     * This will set the menu as sticky to differentiate from the others that
     * are added based on navigation/reference only.
     *
     * @private
     */
    _addDefaultMenus: function() {

        var moduleList = app.metadata.getModuleNames({filter: 'display_tab', access: 'read'});

        _.each(moduleList, function(module) {
            this._addMenu(module, true);
        }, this);
    },

    /**
     * Adds a menu as a component. Sticky menus aren't added to `more-modules`
     * list.
     *
     * @param {String} module The module
     * @param {Boolean} [sticky=false] Set to `true` if this is a menu that is
     *   part of user preferences.
     * @return {Object} The `menu.long` and `menu.short` components created.
     *   If `sticky` param is `false`, then no `menu.short` is provided.
     * @private
     */
    _addMenu: function(module, sticky) {
        var menu = {};

        var def = {
            view: {
                name: 'module-menu',
                sticky: sticky,
                short: false
            }
        };
        menu.long = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.long, def);

        if (!sticky) {
            return menu;
        }

        def = {
            view: {
                name: 'module-menu',
                short: true
            }
        };
        menu.short = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.short, def);

        return menu;
    },

    /**
     * Resize the module list to the specified width and move the extra module
     * names to the `more-modules` drop down.
     *
     * @param {number} width The width that we have available.
     */
    resize: function(width) {
        /**
         * Cached version of last width available for this view.
         *
         * @type {number}
         * @private
         */
        this._width = width;

        if (width <= 0 || _.isEmpty(this._components)) {
            return;
        }

        var $moduleList = this.$('[data-container=module-list]'),
            $dropdown = this._$moreModulesDD.find('[data-container=overflow]');

        if ($moduleList.outerWidth(true) >= width) {
            this.removeModulesFromList($moduleList, width);
        } else {
            this.addModulesToList($moduleList, width);
        }
        this._$moreModulesDD.toggleClass('hidden', $dropdown.children('li').not('.hidden').length === 0);
    },

    /**
     * Computes the minimum width required for the module list.
     * This includes: the cube, the current module, and the more modules drop down.
     * @return {number}
     */
    computeMinWidth: function() {
        var minWidth = 0;
        var $moduleChildren = this.$('[data-container=module-list]').children();

        // The cube
        var $first = $moduleChildren.first();
        minWidth += $first.outerWidth() + 1;

        // The current active module
        var firstModule = $moduleChildren.filter('.active').not($first);
        if (firstModule.length) {
            minWidth += firstModule.outerWidth() + 1;
        } else {
            // or the first module
            minWidth += $moduleChildren.eq(1).outerWidth() + 1;
        }

        // More Modules dropdown
        minWidth += $moduleChildren.last().outerWidth() + 1;
        return minWidth;
    },

    /**
     * Move modules from the dropdown to the list to fit the specified width.
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    addModulesToList: function($modules, width) {
        var $dropdown = this._$moreModulesDD.find('[data-container=overflow]'),
            $toHide = $dropdown.children('li').not('.hidden').first(),
            currentWidth = $modules.outerWidth(true);

        while (currentWidth < width && $toHide.length > 0) {
            this.toggleModule($toHide.data('module'), true);

            $toHide = $dropdown.children('li').not('.hidden').first();

            currentWidth = $modules.outerWidth(true);
        }

        if (currentWidth >= width) {
            this.removeModulesFromList($modules, width);
        }
    },

    /**
     * Move modules from the list to the dropdown to fit the specified width
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    removeModulesFromList: function($modules, width) {

        var $toHide = this._$moreModulesDD.prev();

        while ($modules.outerWidth(true) > width && $toHide.length > 0) {
            if (!this.isRemovableModule($toHide.data('module'))) {
                $toHide = $toHide.prev();
                continue;
            }

            this.toggleModule($toHide.data('module'), false);

            $toHide = $toHide.prev();
        }
    },

    /**
     * Toggle module menu given. This will make sure it will be always in sync.
     *
     * We decided to assume that the `more-modules` drop down is the master of
     * the information to keep in sync.
     *
     * If we don't have a short menu version (on `more-modules` drop down),
     * it means that we don't need to keep it in sync and just show/hide based
     * on the module name. Think at this as a cached menu until we get another
     * `app:sync:complete` event.
     *
     * @param {String} module The module you want to turn on/off.
     * @param {Boolean} [state] `true` to show it on mega menu, `false`
     *   otherwise. If no state given, will toggle.
     *
     * @chainable
     */
    toggleModule: function(module, state) {
        // cache version only
        if (!this._catalog[module].short) {
            state = !_.isUndefined(state) ? !state : undefined;
            this._catalog[module].long.toggleClass('hidden', state);
            return this;
        }

        // keep it in sync
        var newState = this._catalog[module].short.toggleClass('hidden', state).hasClass('hidden');
        this._catalog[module].long.toggleClass('hidden', !newState);

        return this;
    },

    /**
     * Sets the module given as active and shown in the main nav bar.
     *
     * This waits for the full `this._components` to be set first. If we fail
     * to do that, we will see the current module context as the first menu.
     *
     * The module to be shown as active in the main nav bar is mapped by
     * {@link Core.MetadataManager#getTabMappedModule} to be displayed.
     *
     * Cached versions of the modules are always hidden if not active.
     *
     * @param {String} module the Module to set as Active on the menu.
     *
     * @protected
     * @chainable
     */
    _setActiveModule: function(module) {

        if (_.isEmpty(this._components)) {
            // wait until we have the mega menu in place
            return this;
        }

        var tabMap = app.metadata.getModuleTabMap(),
            mappedModule = _.isUndefined(tabMap[module]) ? module : tabMap[module],
            $activeModule = this.$('[data-container=module-list]').children('.active').removeClass('active'),
            activeModule = $activeModule.data('module'),
            moduleList = app.metadata.getFullModuleList(),
            inModuleList = !_.isUndefined(moduleList[mappedModule]);

        if (this._catalog[activeModule] && !this._catalog[activeModule].short) {
            // hide the cached version only module
            this.toggleModule(activeModule, false);
        }

        // If this is a tab-mapped module, but not mapped to anything
        // or invalid mapping, don't continue execution.
        if (!mappedModule || !inModuleList) {
            return this;
        }

        if (!this._catalog[mappedModule]) {
            this._addMenu(mappedModule, false).long.render();
        }

        this._catalog[mappedModule].long.addClass('active');
        this.toggleModule(mappedModule, true);

        return this;
    },

    /**
     * Returns `true` if a certain module can be removed from the main nav bar,
     * `false` otherwise.
     *
     * Currently we can't remove the Home module (sugar cube) neither the
     * current active module.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isRemovableModule: function(module) {
        return !(module === 'Home' || this.isActiveModule(module));
    },

    /**
     * Returns `true` when the module is active in main nav bar, `false`
     * otherwise.
     *
     * This is normally based on the `App.controller.context` current module
     * and then sets a fallback mechanism to determine which module it is,
     * that you can see described in {@link #_setActiveModule}.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isActiveModule: function(module) {
        return this._catalog[module].long.hasClass('active');
    }

}) },
"create-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.CreateActionsLayout
 * @alias SUGAR.App.view.layouts.CreateActionsLayout
 * @extends View.Layouts.Base.CreateLayout
 *
 * @deprecated 7.7.0 Will be removed in 7.8.0. Use
 *   {@link View.Layouts.Base.CreateLayout} instead.
 */
({
	// Create-actions Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel',
        'Dropdown:More'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.logger.warn('Warning: View.Layouts.Base.CreateActionsLayout is deprecated since 7.7.0 and will be ' +
            'removed in 7.8.0. Use View.Layouts.Base.CreateLayout instead.');
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewLayout
 * @alias SUGAR.App.view.layouts.BasePreviewLayout
 * @extends View.Layout
 */
({
	// Preview Layout (base) 

    events: {
        "click .closeSubdetail": "hidePreviewPanel"
    },
    initialize: function(opts) {
        app.view.Layout.prototype.initialize.call(this, opts);
        app.events.on("preview:open", this.showPreviewPanel, this);
        app.events.on("preview:close", this.hidePreviewPanel, this);
        app.events.on("preview:pagination:hide", this.hidePagination, this);
    },

    /**
     * Show the preview panel, if it is part of the active drawer
     * @param event (optional) DOM event
     */
    showPreviewPanel: function(event) {
        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)){
            var layout = this.$el.parents(".sidebar-content");
            layout.find(".side-pane").removeClass("active");
            layout.find(".dashboard-pane").hide();
            layout.find(".preview-pane").addClass("active");

            var defaultLayout = this.closestComponent('sidebar');
            if (defaultLayout) {
                defaultLayout.trigger('sidebar:toggle', true);
            }
        }
    },

    /**
     * Hide the preview panel, if it is part of the active drawer
     * @param event (optional) DOM event
     */
    hidePreviewPanel: function(event) {
        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)){
            var layout = this.$el.parents(".sidebar-content");
            layout.find(".side-pane").addClass("active");
            layout.find(".dashboard-pane").show();
            layout.find(".preview-pane").removeClass("active");
        }
    },

    hidePagination: function() {
        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this.hideNextPrevious = true;
            this.trigger('preview:pagination:update');
        }
    }
}) },
"dashletconfiguration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletconfigurationLayout
 * @alias SUGAR.App.view.layouts.BaseDashletconfigurationLayout
 * @extends View.Layout
 */
({
	// Dashletconfiguration Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Dashlet:Config:Cancel',
        'Dashlet:Config:Save'
    ],

    initialize: function(options) {
        var meta = app.metadata.getLayout(options.module, options.name),
            main_panel;

        _.each(meta.components, function(component) {
            main_panel = _.find(component.layout.components, function(childComponent) {
                return childComponent.layout && childComponent.layout.name === 'main-pane';
            }, this);
        }, this);
        if(main_panel){
            main_panel.layout.components = _.union(main_panel.layout.components, options.meta.components);
        }
        options.meta = meta;
        this._super('initialize', [options]);
    }
}) },
"panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PanelLayout
 * @alias SUGAR.App.view.layouts.BasePanelLayout
 * @extends View.Layout
 */
({
	// Panel Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'filtered tabbable tabs-left',

    /**
     * @inheritdoc
     */
    attributes: function() {
        return {
            'data-subpanel-link': this.options.context.get('link')
        };
    },

    // "Hide/Show" state per panel
    HIDE_SHOW_KEY: 'hide-show',
    HIDE_SHOW: {
        HIDE: 'hide',
        SHOW: 'show'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initPanelState();
    },

    /**
     * Sets the `collapsed` state of the panel's context, depending on if
     * `app.config.collapseSubpanels` is configured or if the panel was
     * previously shown/hidden.
     *
     * @protected
     */
    _initPanelState: function() {
        var collapse;
        this.hideShowLastStateKey = app.user.lastState.key(this.HIDE_SHOW_KEY, this);

        if (app.config.collapseSubpanels) {
            collapse = true;
        } else {
            var hideShowLastState = app.user.lastState.get(this.hideShowLastStateKey);
            collapse = _.isUndefined(hideShowLastState) || hideShowLastState !== this.HIDE_SHOW.SHOW;
        }
        this.context.set('collapsed', collapse);
    },

    /**
     * @inheritdoc
     *
     * Decorate the subpanel based on if the collection is empty or not.
     *
     * When context is reloaded, we open the panel only if `skipFetch` is
     * `false`.
     *
     * When the context's collapse attribute changes, we confirm that the
     * panel's status is in sync with the flag (expanded/collapsed).
     */
    bindDataChange: function() {
        this.listenTo(this.collection, 'reset add remove', function() {
            this.$('.subpanel').toggleClass('empty', this.collection.length === 0);
        }, this);

        this.listenTo(this.context, 'refresh:count', function(hasAtLeast, properties) {
            this.$('.subpanel').toggleClass('empty', !properties.length);
        }, this);

        this.listenTo(this.context.parent, 'panel-top:refresh', function(link) {
            app.logger.warn('`panel-top:refresh` is deprecated. Use `context.reloadData()` to reload and expand.');
            if (this.context.get('link') === link) {
                this.context.resetLoadFlag();
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'reload', function() {
            if (!this.context.get('skipFetch')) {
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'change:collapsed', function(context, collapsed) {
            this.toggle(!collapsed);
        });
    },

    /**
     * Places layout component in the DOM.
     * @override
     * @param {Component} component
     */
    _placeComponent: function(component) {
        this.$(".subpanel").append(component.el);
    },

    /**
     * Renders the `panel-top` component if the subpanel is in a collapsed
     * state, otherwise renders the subpanel.
     */
    _render: function() {
        var collapsed = this.context.get('collapsed');
        if (collapsed) {
            // FIXME: We're assuming that the first component is always the
            // panel-top. This should be fixed when panel-top-create is removed
            // from core in SC-4535.
            this._components[0].render();
        } else {
            /**
             * Internal flag used to determine if we are rendering the
             * component(s) in the panel layout for the first time.
             *
             * @protected
             * @property {boolean}
             */
            this._canToggle = true;
            this._super('_render');
        }

        this.$('.subpanel').toggleClass('closed', collapsed);
    },

    /**
     * Saves the collapsed/expanded state of the subpanel in localStorage.
     *
     * @private
     * @param {boolean} [show] `true` to expand, `false` to collapse. Collapses
     *   by default.
     */
    _setCollapsedState: function(show) {
        var state = show ? this.HIDE_SHOW.SHOW : this.HIDE_SHOW.HIDE;
        app.user.lastState.set(this.hideShowLastStateKey, state);
    },

    /**
     * Toggles the panel.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined` to
     *   toggle.
     */
    toggle: function(show) {
        if (this.context.get('isCreateSubpanel')) {
            // no toggle available on create
            return;
        }

        show = _.isUndefined(show) ? this.context.get('collapsed') : show;

        this.$('.subpanel').toggleClass('closed', !show);
        this.context.set('collapsed', !show);
        this._toggleComponents(show);

        // no longer need to skip
        this.context.set('skipFetch', false);
        this.context.loadData();

        this._setCollapsedState(show);
    },

    /**
     * Show or hide component except `panel-top`(subpanel-header) component.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide. Defaults to
     *   `false`.
     */
    _toggleComponents: function(show) {
        _.each(this._components, function(component) {
            // FIXME: The layout should not be responsible for this. Will be
            // addressed as part of SC-4533.
            if (this._stopComponentToggle(component)) {
                return;
            }
            if (!this._canToggle) {
                component.render();
            } else if (show) {
                component.show();
            } else {
                component.hide();
            }
        }, this);
        this._canToggle = true;
    },

    /**
     * Extensible check to see if this component should be allowed to be toggled.
     * If this returns true: _toggleComponent will return without further render/show/hide checks
     * If this returns false: _toggleComponent will continue through render/show/hide checks
     *
     * @param component
     * @return {boolean}
     * @private
     */
    _stopComponentToggle: function(component) {
        return component.$el.hasClass('subpanel-header');
    }
}) },
"togglepanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for tabbing between filterable components.
 * Mostly to toggle between Activity Stream and list views
 *
 * @class View.Layouts.Base.TogglepanelLayout
 * @alias SUGAR.App.view.layouts.BaseTogglepanelLayout
 * @extends View.Layout
 */
({
	// Togglepanel Layout (base) 

    events: {
        "click .toggle-actions a.btn": "toggleView"
    },

    plugins: ['Tooltip'],

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function (opts) {
        this.toggleComponents = [];
        this.componentsList = {};
        this.processToggles();
        this._super('initialize', [opts]);
    },

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        _.each(this.componentsList, function(comp) {
            if (_.isFunction(comp.initComponents)) {
                comp.initComponents();
            }
        });
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');
        // get the last viewed layout
        this.toggleViewLastStateKey = app.user.lastState.key('toggle-view', this);
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);

        // show the first toggle if the last viewed state isn't set in the metadata
        if (_.isUndefined(lastViewed) || this.isToggleButtonDisabled(lastViewed)) {
            var enabledToggles = _.filter(this.toggles, function(toggle) {
                return !toggle.disabled;
            });
            if (enabledToggles.length > 0) {
                lastViewed = _.first(enabledToggles).toggle;
            }
        }

        this.showComponent(lastViewed, true);//SP-1766-don't double render!
        // Toggle the appropriate button and layout for initial render
        this.$('[data-view="' + lastViewed + '"]').button('toggle');
    },

    /**
     * Checks whether the toggle button is disabled
     * @param {string} name  The name of the button to check
     * @return {boolean}
     */
    isToggleButtonDisabled: function (name) {
        var disabled = false,
            toggleButton;

        toggleButton = _.find(this.toggles, function (toggle) {
            return toggle.toggle === name;
        });

        if (toggleButton) {
            disabled = toggleButton.disabled;
        }
        return disabled;
    },

    /**
     * Get components from the metadata and declare toggles
     */
    processToggles: function () {
        // Enable toggles
        this.toggles = [];
        var temp = {};

        //Go through components and figure out which toggles we should add
        _.each(this.options.meta.components, function (component) {
            var toggle;
            if (component.view) {
                toggle = component.view;
            } else if (component.layout) {
                toggle = (_.isString(component.layout)) ? component.layout : component.layout.name;
            }

            var availableToggle = _.find(this.options.meta.availableToggles, function (curr) {
                return curr.name === toggle;
            }, this);
            if (toggle && availableToggle) {
                var disabled = !!availableToggle.disabled;
                temp[toggle] = {toggle: toggle, title: availableToggle.label, 'class': availableToggle.icon, disabled: disabled};
            }
        }, this);

        if (this.options.meta.availableToggles) {
            // Sort the toggles by the order in the availableToggles list
            for (var i = 0; i < this.options.meta.availableToggles.length; i++) {
                var curr = this.options.meta.availableToggles[i];
                if (temp[curr.name]) {
                    this.toggles.push(temp[curr.name]);
                }
            }
        }

    },

    /**
     * @override
     * @private
     * @param {Component} component
     * @param {Object} def
     */
    _placeComponent: function (component, def) {
        if (def && def.targetEl) {
            if (def.position == 'prepend') {
                this.$(def.targetEl).prepend(component.el);
                return;
            } else {
                this.$(def.targetEl).append(component.el);
            }
        } else {
            // If we recognize the view, prevent it from rendering until it's
            // requested explicitly by the user.
            var toggleAvailable = _.isObject(_.find(this.options.meta.availableToggles, function (curr) {
                return curr.name === component.name;
            }));
            if (toggleAvailable) {
                this.toggleComponents.push(component);
                this.componentsList[component.name] = component;
                this._components.splice(this._components.indexOf(component), 1);
            } else {
                // Safety check, just in case we've got a view that the layout
                // doesn't recognize.
                component.render();
                this.$(".main-content").append(component.el);
            }
        }
    },

    /**
     * Show a toggle
     * @param {Event} e
     */
    toggleView: function (e) {
        var $el = this.$(e.currentTarget);
        // Hack: With a real <button> with attribute disabled="disabled", events won't fire on the button. However,
        // since we're using <a> anchor to allow tooltips even if btn disabled, we have to "fudge" disabled behavior
        // See SP-1055, http://jsfiddle.net/hMQYZ/17/, https://github.com/twitter/bootstrap/issues/2373
        if ($el.attr('disabled') === 'disabled') {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        // Only toggle if we click on an inactive button
        if (!$el.hasClass("active")) {
            var data = $el.data();
            app.user.lastState.set(this.toggleViewLastStateKey, data.view);
            this.showComponent(data.view);
            this.reloadData(data.view);
        }
    },

    /**
     * Show a component and triggers "filterpanel:change"
     * @param {String} name
     * @param {Boolean} silent
     */
    showComponent: function (name, silent) {
        if (!name) return;
        if (this.componentsList[name]) {
            this.componentsList[name].render();
            this._components.push(this.componentsList[name]);
            this.$(".main-content").append(this.componentsList[name].el);
        }

        _.each(this.toggleComponents, function (comp) {
            if (comp.name == name) {
                comp.show();
            } else {
                comp.hide();
            }
        }, this);
        //Need to respect silent param if true as it prevents double rendering:
        //SP-1766-Filter for sidecar modules causes two requests to list view
        this.trigger('filterpanel:change', name, silent);
    },

    /**
     * Reload the toggled component
     * @param name
     */
    reloadData: function(name) {
        var layout = this.componentsList[name];
        if (layout) {
            layout.context.resetLoadFlag(true);
            layout.loadData();
        }
    },

    /**
     * @override
     * @private
     */
    _dispose: function () {
        _.each(this.componentsList, function (component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        this.toggleComponents = null;
        app.view.Layout.prototype._dispose.call(this);
    }
}) },
"drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DrawerLayout
 * @alias SUGAR.App.view.layouts.BaseDrawerLayout
 * @extends View.Layout
 */
({
	// Drawer Layout (base) 

    backdropHtml: '<div class="drawer-backdrop"></div>',
    plugins: ['Tooltip'],
    onCloseCallback: null, //callbacks to be called once drawers are closed
    scrollTopPositions: [], //stores scroll positions for main and side pane

    pixelsFromFooter: 80, //how many pixels from the footer the drawer will drop down to

    initialize: function(options) {
        var self = this;

        /**
         * The fragments queue of the open drawers.
         *
         * @property {Array}
         * @private
         */
        this._fragments = [];

        if (!this.$el.is('#drawers')) {
            app.logger.error('Drawer layout can only be included as an Additional Component.');
            return;
        }

        app.drawer = this;
        this.onCloseCallback = [];

        // define the states the drawer can be in
        this.STATES = {
            IDLE: 'idle',
            OPENING: 'opening',
            CLOSING: 'closing'
        };
        // start in the IDLE state; the drawer will be IDLE most of the time
        this._enterState(this.STATES.IDLE);

        //clear out drawers before routing to another page
        this.name = 'drawer';

        app.view.Layout.prototype.initialize.call(this, options);

        // Browser find functionality auto-scrolls even when overflow is set to hidden.
        // Prevent scrolling only when there are active drawers.
        $(window).on('scroll.prevent', function() {
            self._preventScroll($(this));
        });
        app.$contentEl.on('scroll.prevent', function() {
            self._preventScroll($(this));
        });

        app.before('app:view:load', function() {
            return this.reset();
        }, this);
    },

    /**
     * Open the specified layout or view in a drawer.
     *
     * You can pass the current context if you want the context created to be a
     * child of that current context. If you don't pass a `scope`, it will
     * create a child of the main context (`app.controller.context`).
     *
     * @param {Object} def The component definition.
     * @param {Core.Context/Object} [def.context] The context to pass to
     *  the drawer.
     * @param {Core.Context} [def.context.parent] The parent context of
     *  the context to pass to the drawer.
     * @param {Function} [onClose] Callback method when the drawer closes.
     */
    open: function(def, onClose) {
        var component;

        app.shortcuts.saveSession();
        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        //store the callback function to be called later
        if (_.isUndefined(onClose)) {
            this.onCloseCallback.push(function(){});
        } else {
            this.onCloseCallback.push(onClose);
        }

        //initialize layout definition components
        this._initializeComponentsFromDefinition(def);

        component = _.last(this._components);

        this._updateFragments();

        //scroll both main and sidebar to the top
        this._scrollToTop();

        //open the drawer
        this._animateOpenDrawer(_.bind(function() {
            this._afterOpenActions();
        }, this));

        //load and render new layout in drawer
        component.loadData();
        component.render();
    },

    /**
     * Closes the top-most drawer.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback.
     */
    close: function() {
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        this._updateFragments(true);

        if (!Modernizr.csstransitions) {
            this.closeImmediately.apply(this, args);
            return;
        }

        if (this._components.length > 0) {
            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //close the drawer
            this._animateCloseDrawer(function() {
                self._afterCloseActions(args);
            });
        }
    },

    /**
     * Updates the fragments array according to the passed parameter.
     *   - Adds the current fragment to the fragments queue if no
     *   argument or `false` is passed.
     *   - Navigates back to the previous fragment if `true` is passed.
     *
     * @param {boolean} goBack `true` to navigate back to the previous fragment.
     *   No argument or `false` to add the current fragment to the queue.
     * @private
     */
    _updateFragments: function(goBack) {
        var component = _.last(this._components);
        if (!component.context.get('fromRouter')) {
            return;
        }
        if (goBack) {
            this._fragments.pop();
            app.router.navigate(_.last(this._fragments));
            if (this.count() === 1) {
                this._fragments = [];
            }
        } else {
            if (this.count() === 1) {
                this._fragments = [app.router.getPreviousFragment(), app.router.getFragment()];
            } else {
                this._fragments.push(app.router.getFragment());
            }
        }
    },

    /**
     * Close the top-most drawer immediately without transitions.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback
     */
    closeImmediately: function() {
        if (this._components.length > 0) {
            var args = Array.prototype.slice.call(arguments, 0),
                drawers = this._getDrawers(false),
                drawerHeight = this._determineDrawerHeight();

            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //move the bottom drawer to the top and the next drawer to be viewed on the bottom.
            drawers.$bottom.css('top','');
            if (drawers.$next) {
                drawers.$next.css('top', this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight);
            }

            this._removeTabAndBackdrop(drawers.$bottom);
            this._cleanUpAfterClose(drawers);
            this._afterCloseActions(args);
        }
    },

    /**
     * Reload the current drawer with a new layout or view.
     *
     * @param def The layout or view definition.
     */
    load: function(def) {
        var comp = this._components.pop(),
            top = comp.$el.css('top'),
            height = comp.$el.css('height'),
            drawers;

        comp.dispose();

        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        this._initializeComponentsFromDefinition(def);

        drawers = this._getDrawers(true);
        drawers.$next
            .addClass('drawer active')
            .css({
                top: top,
                height: height
            });

        //refresh tab and backdrop
        this._removeTabAndBackdrop(drawers.$top);
        this._createTabAndBackdrop(drawers.$next, drawers.$top);

        comp = _.last(this._components);
        comp.loadData();
        comp.render();

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Retrieves the number of drawers in the stack.
     *
     * @return {Number}
     */
    count: function() {
        return this._components.length;
    },

    /**
     * Test if element is part of active drawer.  Always returns true if there's no inactive components on page.
     * @param el DOM element to test if it is in the active drawer
     * @return boolean
     */
    isActive: function(el) {
        return ((this.count() === 0) || ($(el).parents('.drawer.active').length > 0));
    },

    /**
     * Gets the active drawer.
     *
     * @return {View.Component} The active drawer's component. `undefined` if
     *   no drawer is open.
     */
    getActive: function() {
        return _.last(this._components);
    },

    /**
     * Get currently active drawer layout.
     *
     * @return {View.Layout}
     * @deprecated Since 7.7. Will be removed in 7.9.
     */
    getActiveDrawerLayout: function() {
        app.logger.warn('Drawer\'s `getActiveDrawerLayout` is deprecated and will be removed in 7.9,' +
            'please use `getActive` instead.');
        return this.count() ? this.getActive() : app.controller.layout;
    },

    /**
     * Remove all drawers and reset
     * @param trigger Indicates whether to triggerBefore (defaults to true if anything other than `false`)
     */
    reset: function(triggerBefore) {
        triggerBefore = triggerBefore === false ? false : true;
        if (triggerBefore && !this.triggerBefore("reset", {drawer: this})) {
            return false;
        }

        var $main = app.$contentEl.children().first();

        this._enterState(this.STATES.CLOSING);

        _.each(this._components, function(component) {
            component.dispose();
        }, this);

        this._components = [];
        this.onCloseCallback = [];

        if ($main.hasClass('drawer')) {
            $main
                .removeClass('drawer inactive')
                .removeAttr('aria-hidden')
                .css('top','');
            this._removeTabAndBackdrop($main);
        }

        $('body').removeClass('noscroll');
        app.$contentEl.removeClass('noscroll');

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Force to create a new context and create components from the layout/view
     * definition. If the parent context is defined, make the new context as a
     * child of the parent context.
     *
     * @param {Object} def The layout or view definition.
     * @private
     */
    _initializeComponentsFromDefinition: function(def) {
        var parentContext;

        if (_.isUndefined(def.context)) {
            def.context = {};
        }

        if (_.isUndefined(def.context.forceNew)) {
            def.context.forceNew = true;
        }

        if (!(def.context instanceof app.Context) && def.context.parent instanceof app.Context) {
            parentContext = def.context.parent;
            // Remove the `parent` property to not mess up with the context
            // attributes.
            delete def.context.parent;
        }

        this.initComponents([def], parentContext);
    },

    /**
     * Animate opening of a new drawer.
     *
     * @private
     * @param {Function} callback Called when open animation is finished.
     */
    _animateOpenDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(true),
            drawerHeight = this._determineDrawerHeight(),
            topDrawerCurrentTopPos = drawers.$top.offset().top,
            aboveWindowTopPos = topDrawerCurrentTopPos - drawerHeight, //top position above the browser window
            bottomDrawerTopPos = this._isMainAppContent(drawers.$top) ? drawerHeight : topDrawerCurrentTopPos + drawerHeight,
            belowWindowTopPos; //top position below the browser window

        if (drawers.$bottom) {
            belowWindowTopPos = drawers.$bottom.offset().top + drawerHeight
        }

        if (this._isMainAppContent(drawers.$top)) {
            //make sure that the main application content is set as a drawer
            drawers.$top.addClass('drawer');
            $('body').addClass('noscroll');
            app.$contentEl.addClass('noscroll');
        }

        //add the expand tab and the backdrop to the top drawer
        this._createTabAndBackdrop(drawers.$next, drawers.$top);

        //indicate that it's an active drawer
        drawers.$next.addClass('drawer active');
        //set the height of the new drawer
        drawers.$next.css('height', drawerHeight);
        //set the animation starting point for the new drawer
        drawers.$next.css('top', aboveWindowTopPos);
        //mark the top drawer as inactive
        drawers.$top
            .addClass('inactive')
            .removeClass('active')
            .attr('aria-hidden', true); //accessibility
        //prevent scrolling on drawer
        drawers.$top.on('scroll.prevent', _.bind(function() {
            this._preventScroll(drawers.$top);
        }, this));

        // Need to do a defer so that transition can be applied when the drawer is coming down
        // but not when it's being setup above browser window.
        _.defer(_.bind(function() {
            this._setTransition(drawers);
            this._onTransitionEnd(drawers.$next, function() {
                this._removeTransition(drawers);
                if (_.isFunction(callback)) {
                    callback();
                }
                this.trigger('drawer:resize', drawerHeight);
            });

            //start animation to open the drawer
            drawers.$next.css('top','');
            drawers.$top.css('top', bottomDrawerTopPos);
            if (drawers.$bottom) {
                drawers.$bottom.css('top', belowWindowTopPos);
            }

            //resize the visible drawer when the browser resizes
            if (this._components.length === 1) {
                $(window).on('resize.drawer', _.bind(this._resizeDrawer, this));
            }
        }, this));
    },

    /**
     * Animate closing of the top-most drawer.
     *
     * @param {Function} callback Function to be called after drawer has been
     * closed.
     * @private
     */
    _animateCloseDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(false),
            drawerHeight = this._determineDrawerHeight(),
            aboveWindowTopPos = drawers.$top.offset().top - drawerHeight, //top position above the browser window
            bottomDrawerTopPos; //top position of the bottom drawer

        if (drawers.$next) {
            bottomDrawerTopPos = this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight;
        }

        this._setTransition(drawers);
        this._onTransitionEnd(drawers.$bottom, function() {
            this._removeTransition(drawers);
            this._cleanUpAfterClose(drawers);
            if (_.isFunction(callback)) {
                callback();
            }
        });

        //start the animation to close the drawer
        drawers.$top.css('top', aboveWindowTopPos);
        drawers.$bottom.css('top','');
        if (drawers.$next) {
            drawers.$next.css('top', bottomDrawerTopPos);
        }

        this._removeTabAndBackdrop(drawers.$bottom);
    },

    /**
     * Get all (top, bottom, next) drawers layouts depending upon whether or not
     * a drawer is being opened or closed.
     *
     * @param {boolean} open `true` if the drawer is being opened.
     * @return {Object}
     * @private
     */
    _getDrawers: function(open) {
        var $main = app.$contentEl.children().first(),
            $nextDrawer, $topDrawer, $bottomDrawer,
            open = _.isUndefined(open) ? true : open,
            drawerCount = this._components.length;

        switch (drawerCount) {
            case 0: //no drawers
                break;
            case 1: //only one drawer
                $nextDrawer = open ? this._components[drawerCount-1].$el : undefined;
                $topDrawer = open ? $main : this._components[drawerCount-1].$el;
                $bottomDrawer = open? undefined : $main;
                break;
            case 2: //two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : $main;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? $main : this._components[drawerCount-2].$el;
                break;
            default: //more than two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : this._components[drawerCount-3].$el;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? this._components[drawerCount-3].$el : this._components[drawerCount-2].$el;
        }

        return {
            $next: $nextDrawer,
            $top: $topDrawer,
            $bottom: $bottomDrawer
        };
    },

    /**
     * Is this drawer the main application content area?
     * @param $layout
     * @return {Boolean}
     * @private
     */
    _isMainAppContent: function($layout) {
        return !$layout.parent().is(this.$el);
    },

    /**
     * Calculate how far down the drawer should drop down, i.e. the height of the drawer
     * @param $mainContent
     * @return {Number}
     * @private
     */
    _determineDrawerHeight: function() {
        var windowHeight = $(window).height(),
            headerHeight = $('#header .navbar').outerHeight(),
            footerHeight = $('footer').outerHeight();

        return windowHeight - headerHeight - footerHeight - this.pixelsFromFooter;
    },

    /**
     * Calculate how much to collapse the drawer
     * @return {Number}
     * @private
     */
    _determineCollapsedHeight: function() {
        return $(window).height()/2; //middle of the window
    },

    /**
     * Create tab and the backdrop. Add the ability to expand and collapse the drawer when the tab is clicked
     * @param $top
     * @param $bottom
     * @private
     */
    _createTabAndBackdrop: function($top, $bottom) {
        var $drawerTab;

        //add the expand tab and the backdrop to the top drawer
        this.expandTpl = app.template.getLayout(this.name + '.expand');
        this.expandTabHtml = this.expandTpl();

        $bottom
            .append(this.expandTabHtml)
            .append(this.backdropHtml);

        //add tooltip
        $drawerTab = $bottom.find('.drawer-tab');
        this.addPluginTooltips($drawerTab);

        //add expand/collapse tab behavior
        $drawerTab.on('click', _.bind(function(event) {
            if ($('i', event.currentTarget).hasClass('fa-chevron-up')) {
                this._collapseDrawer($top, $bottom);
            } else {
                this._expandDrawer($top, $bottom);
            }
            return false;
        }, this));
        app.accessibility.run($drawerTab, 'click');
    },

    /**
     * Remove the tab and the backdrop and the event listener that handles the ability to expand and collapse the drawer.
     * @param $drawer
     * @private
     */
    _removeTabAndBackdrop: function($drawer) {
        //remove drawer tab
        var $drawerTab = $drawer.find('.drawer-tab')
            .off('click')
            .remove();

        //remove tooltip
        this.removePluginTooltips($drawerTab);

        //remove backdrop
        $drawer.find('.drawer-backdrop')
            .remove();
    },

    /**
     * Process clean up after the drawer has been closed.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _cleanUpAfterClose: function(drawers) {
        drawers.$top.removeClass('active');

        drawers.$bottom
            .removeClass('inactive')
            .addClass('active')
            .removeAttr('aria-hidden') //accessibility
            .off('scroll.prevent'); //remove event handler that prevents scrolling

        if (this._isMainAppContent(drawers.$bottom)) {
            drawers.$bottom.removeClass('drawer active');
            $('body').removeClass('noscroll');
            app.$contentEl.removeClass('noscroll');
        } else {
            //refresh drawer position and height for collapsed or resized drawers
            this._expandDrawer(drawers.$bottom, drawers.$next);
        }

        //set scrollable elements back its original position
        this._scrollBackToOriginal(drawers.$bottom);

        //remove resize handler
        if (this._components.length === 1) {
            $(window).off('resize.drawer');
        }
    },

    /**
     * Trigger view change event and return to idle state.
     *
     * @private
     */
    _afterOpenActions: function() {
        var layout = _.last(this._components);

        // Forecasts config route uses the drawer but if user
        // does not have access, initialize is never called so the
        // context on the layout never gets set. Adding check to make
        // sure there actually is a context to use on the layout
        if (layout.context) {
            app.trigger('app:view:change', layout.options.name, layout.context.attributes);
        }

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Trigger view change event and restore shortcuts session.
     * @param {array} callbackArgs Arguments that will be passed to the callback
     * @private
     */
    _afterCloseActions: function(callbackArgs) {
        var layout;

        this._components.pop().dispose(); //dispose top-most drawer

        layout = _.last(this._components);
        if (layout) { // still have layouts in the drawer
            app.trigger("app:view:change", layout.options.name, layout.context.attributes);
        } else { //we've returned to base layout
            app.trigger("app:view:change", app.controller.context.get("layout"), app.controller.context.attributes);
        }

        this._enterState(this.STATES.IDLE);

        app.shortcuts.restoreSession();

        (this.onCloseCallback.pop()).apply(window, callbackArgs); //execute callback
    },

    /**
     * Expand the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _expandDrawer: function($top, $bottom) {
        var expandHeight = this._determineDrawerHeight();
        $top.css('height', expandHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', expandHeight);
        } else {
            $bottom.css('top', expandHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('fa-chevron-down')
            .addClass('fa-chevron-up');

        this.trigger('drawer:resize', expandHeight);
    },

    /**
     * Collapse the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _collapseDrawer: function($top, $bottom) {
        var collapseHeight = this._determineCollapsedHeight();
        $top.css('height', collapseHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', collapseHeight);
        } else {
            $bottom.css('top', collapseHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('fa-chevron-up')
            .addClass('fa-chevron-down');

        this.trigger('drawer:resize', collapseHeight);
    },

    /**
     * Add transition to the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _setTransition: function(drawers) {
        drawers.$top.addClass('transition');

        if (drawers.$next) {
            drawers.$next.addClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.addClass('transition');
        }
    },

    /**
     * Remove transition from the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _removeTransition: function(drawers) {
        drawers.$top.removeClass('transition');

        if (drawers.$next) {
            drawers.$next.removeClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.removeClass('transition');
        }
    },

    /**
     * Is the drawer in a middle of a transition?
     * @param {jQuery} drawer top, bottom, or next drawer layout
     * @return {boolean}
     * @private
     */
    _isInTransition: function(drawer) {
        return drawer.hasClass('transition');
    },

    /**
     * Attach transition end event handler for a given drawer.
     * @param {jQuery} $drawer Drawer to attach the event
     * @param {Function} callback Event handler
     * @private
     */
    _onTransitionEnd: function($drawer, callback) {
        var self = this,
            transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';

        //once the animation is done, reset to original state and execute callback parameter
        $drawer.one(transitionEndEvents, function() {
            $drawer.off(transitionEndEvents); //some browsers fire multiple transitionend events
            callback.call(self);
        });

        //this is a failsafe to ensure that drawer will always close
        //in Chrome the css change to 'top' sometimes (randomly) doesn't actually change the css value
        _.delay(function() {
            $drawer.trigger('transitionend');
        }, 400);
    },

    /**
     * Scroll the scrollable divs to the top and save its position.
     * Content needs to be scrolled as well because in small width screens,
     * the responsive layout changes the #content div to be a scrollable container
     * @private
     */
    _scrollToTop: function() {
        var drawers = this._getDrawers(true),
            $mainpane = drawers.$top.find('.main-pane'),
            $sidepane = drawers.$top.find('.sidebar-content'),
            $content = app.$contentEl;

        this.scrollTopPositions.push({
            main: $mainpane.scrollTop(),
            side: $sidepane.scrollTop(),
            drawer: drawers.$top.scrollTop(),
            content: $content.scrollTop()
        });

        drawers.$top.scrollTop(0);
        $mainpane.scrollTop(0);
        $sidepane.scrollTop(0);
        $content.scrollTop(0);
    },

    /**
     * Scroll the scrollable elements back to its original position.
     * @param {jQuery} [$drawer] Drawer to scroll back
     * @private
     */
    _scrollBackToOriginal: function($drawer) {
        var scrollPositions = this.scrollTopPositions.pop();

        if ($drawer) {
            $drawer.scrollTop(scrollPositions.drawer);
        } else {
            $drawer = app.$contentEl;
        }

        $drawer.find('.main-pane').scrollTop(scrollPositions.main);
        $drawer.find('.sidebar-content').scrollTop(scrollPositions.side);
        app.$contentEl.scrollTop(scrollPositions.content);
    },

    /**
     * Get the current height of the active drawer
     * @return {Number}
     */
    getHeight: function(){
        if (_.isEmpty(this._components)) {
            return 0; // No drawers on page
        }
        var $top = this._getDrawers(false).$top;
        return $top.height();
    },

    /**
     * Prevent scrolling when drawer is open.  This feature is needed because browsers
     * automatically scroll when the Find feature is used (Ctrl+F) even when the scrollable
     * elements have been set with hidden overflow.
     * @param {jQuery} $scrollable Scrollable element that needs to be prevented from scrolling
     * @private
     */
    _preventScroll: function($scrollable) {
        // Preventing scrolls in iOS 7 causes AJAX calls to be paused (MAR-2768). No problems in iOS 8.
        if (!Modernizr.touch && (app.drawer.count() > 0)) {
            $scrollable.scrollTop(0);
        }
    },

    _dispose: function() {
        this.reset();
        app.offBefore(null, null, this);
        $(window).off('resize.drawer');
        $(window).off('scroll.prevent');
        app.$contentEl.on('scroll.prevent');
        this._super('_dispose');
    },

    /**
     * Resize the height of the drawer by expanding.
     */
    _resizeDrawer: _.throttle(function() {
        var drawers = this._getDrawers(false);
        // Do not resize the drawer when the drawer is opening or closing.
        if (drawers.$top && !this.isOpening() && !this.isClosing()) {
            this._expandDrawer(drawers.$top, drawers.$bottom);
        }
    }, 300),

    /**
     * Enter the drawer into one of the allowed states.
     *
     * @param {string} state
     * @return {string} If the returned state is the same as the previous
     * state, then the parameter was not a valid state.
     * @private
     */
    _enterState: function(state) {
        if (_.contains(this.STATES, state)) {
            this.state = state;
        }

        return this.state;
    },

    /**
     * Confirms or denies that the current state of the drawer is the expected
     * state.
     *
     * @param state
     * @return {boolean}
     */
    isInState: function(state) {
        return state === this.state;
    },

    /**
     * Is the drawer currently in the idle state?
     *
     * The drawer will be in the IDLE state unless a drawer is currently
     * opening or closing.
     *
     * @return {boolean}
     */
    isIdle: function() {
        return this.isInState(this.STATES.IDLE);
    },

    /**
     * Is the drawer currently opening?
     *
     * The drawer will be in the OPENING state while a drawer is opening. Once
     * the open animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isOpening: function() {
        return this.isInState(this.STATES.OPENING);
    },

    /**
     * Is the drawer currently closing?
     *
     * The drawer will be in the CLOSING state while a drawer is closing. Once
     * the close animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isClosing: function() {
        return this.isInState(this.STATES.CLOSING);
    }
}) },
"header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.HeaderLayout
 * @alias SUGAR.App.view.layouts.BaseHeaderLayout
 * @extends View.Layout
 */
({
	// Header Layout (base) 

    /**
     * Listen to events to resize the header to fit the browser width
     * @param options
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.on('header:update:route', this.resize, this);
        app.events.on('app:view:change', this.resize, this);
        // Event listeners for showing and hiding the megamenu on auth expiration
        app.events.on('app:login', this.hide, this);
        app.events.on('app:login:success', this.show, this);

        var resize = _.bind(this.resize, this);
        $(window)
            .off('resize.header')
            .on('resize.header', resize);
    },

    /**
     * Places all components within this layout inside nav-collapse div
     * @param component
     * @private
     */
    _placeComponent: function(component) {
        this.$el.find('.nav-collapse').append(component.$el);
    },

    /**
     * Calculates the width that the module list should resize to and triggers an event
     * that tells the module list to resize
     */
    resize: function() {
        var resizeWidth = this.getModuleListWidth();
        this.trigger('view:resize', resizeWidth);
    },

    /**
     * Returns the calculated module list width.
     * @return {number}
     */
    getModuleListWidth: function() {
        var maxMenuWidth = $(window).width();
        var totalWidth = 0;

        _.each(this._components, function(component) {
            if (component.name !== 'module-list') {
                // only calculate width for visible components
                if (component.$el.is(':visible')) {
                    totalWidth += component.$el.outerWidth(true);
                }
            }
        });
        return maxMenuWidth - totalWidth;
    },

    /**
     * Returns the minimum module list width.
     * @return {number}
     */
    getModuleListMinWidth: function() {
        var moduleListView = this.getComponent('module-list');
        if (moduleListView) {
            return moduleListView.computeMinWidth();
        }
    },

    /**
     * Sets whether or not the module-list should listen to the window resize.
     * @param {boolean} resize
     */
    setModuleListResize: function(resize) {
        this.getComponent('module-list').toggleResize(resize);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // If we are authenticated show the megamenu
        if (app.api.isAuthenticated()) {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this._super('show');
        this.resize();
    },

    /**
     * Shows the megamenu
     * @deprecated since 7.7 and will be removed in 7.8, use {@link #show}.
     */
    showMenu: function () {
        app.logger.warn('showMenu is deprecated, please use show instead.');
        this.show();
    },

    /**
     * Hides the megamenu
     * @deprecated since 7.7 and will be removed in 7.8, use {@link #hide}.
     */
    hideMenu: function () {
        app.logger.warn('hideMenu is deprecated, please use hide instead.');
        this.hide();
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.CreateLayout
 * @alias SUGAR.App.view.layouts.CreateLayout
 * @extends View.Layout
 */
({
	// Create Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel',
        'Dropdown:More'
    ]
}) },
"sweetspot-config-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigListLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigListLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config-list Layout (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged. It won't
    // work until then, because 'Editable' can only be attached to a view.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initRows();
        this._bindEvents();
    },

    /**
     * Initializes this layout by adding
     * {@link View.Views.Base.SweetspotConfigListRowView rows} of configured
     * hotkeys if they exist in user preferences.
     *
     * @protected
     * @return {undefined} Returns `undefined` if there are no configured
     *   hotkeys.
     */
    _initRows: function() {
        var data = app.user.getPreference('sweetspot');
        data = data && data.hotkeys;
        if (_.isEmpty(data)) {
            // Always add an empty row if we don't have anything configured.
            this.addRow();
            return;
        }

        _.each(data, function(row) {
            _.each(row.keyword, function(word) {
                this._initRow(row, word);
            }, this);
        }, this);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout, and sets the `keyword` and `action` attributes on the model of
     * the added row component.
     *
     * @param {Object} row The object containing row attributes.
     * @param {string} keyword The `keyword` attribute of the row.
     * @param {string} action The `action` attribute of the row.
     */
    _initRow: function(row, keyword, action) {
        action = action || row.action;
        keyword = keyword || row.keyword;

        var rowComponent = this.addRow();
        rowComponent.model.set('action', action);
        rowComponent.model.set('keyword', keyword);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        // Config data events
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);

        // Config list row events
        this.context.on('sweetspot:config:addRow', this.addRow, this);
        this.context.on('sweetspot:config:removeRow', this.removeRow, this);
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('[data-sweetspot=actions]').append(component.el);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     *
     * @param {View.View} component The component that triggered this event.
     */
    addRow: function(component) {
        var def = _.extend(
                {view: 'sweetspot-config-list-row'},
                app.metadata.getView(null, 'sweetspot-config-list-row')
            );
        var rowComponent = this.createComponentFromDef(def, this.context, this.module);

        if (component) {
            // Add the row after the row where the user clicked the '+' sign.
            component.$el.after(rowComponent.el);
        } else {
            this.addComponent(rowComponent, def);
        }
        rowComponent.render();
        return rowComponent;
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     *
     * @param {View.View} component The component that triggered this event.
     */
    removeRow: function(component) {
        this.collection.remove(component.model);
        component.dispose();
        this.removeComponent(component);

        if (this.$('[data-sweetspot=actions]').children().length === 0) {
            this.addRow();
        }
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     */
    generateConfig: function() {
        var data = this.collection.toJSON();
        data = this._formatData(data);

        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * Formatter method that sanitizes and prepares the data to be used by
     * {@link View.Layouts.Base.SweetspotConfigLayout#saveConfig}. Also allows
     * for multiple hotkeys to be associated with a single action.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The formatted data.
     */
    _formatData: function(data) {
        var result = this._sanitizeConfig(data);
        result = this._joinKeywordConfigs(result);
        result = this._formatForUserPrefs(result);

        return result;
    },

    /**
     * This is a helper function that takes in the sanitized configuration data
     * and analyzes if there are actions being assigned to multiple keywords.
     *
     * If there are actions with more than one keyword, the corresponding
     * keywords are joined together in an array. For example:
     *
     *     [{action: '#Bugs', keyword: 'b1'}, {action: '#Bugs', keyword: 'b2'}]
     *
     * would be transformed to:
     *
     *     [{action: '#Bugs', keyword: ['b1', 'b2']}]
     *
     * By default, this function transforms the keyword attribute to an array.
     * For example:
     *
     *    [{action: '#Bugs', keyword: 'b1'}]
     *
     * would be transformed to:
     *
     *    [{action: '#Bugs', keyword: ['b1']}]
     *
     * @private
     * @param {Array} data The sanitized configuration data.
     * @return {Array} The configuration data, with single/multiple keywords per
     *   action stored in an array.
     */
    _joinKeywordConfigs: function(data) {
        var result = {};

        _.each(data, function(obj) {
            result[obj.action] = result[obj.action] || obj;
            var keyword = _.isArray(obj.keyword) ? obj.keyword : [obj.keyword];
            result[obj.action].keyword = _.union(result[obj.action].keyword, keyword);
        });
        return _.toArray(result);
    },

    /**
     * Sanitizes the configuration data by removing empty/falsy values.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The sanitized configuration data.
     */
    _sanitizeConfig: function(data) {
        data = _.reject(data, function(row) {
            return !row.keyword || !row.action;
        });

        return data;
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Array} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {hotkeys: data};
    },

    /**
     * Compare with the user preferences and return true if the collection
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.hotkeys;
        var newConfig = this.collection.toJSON();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for filtering a collection.
 *
 * Composed of a module dropdown(optional), a filter dropdown and an input.
 *
 * @class View.Layouts.Base.FilterLayout
 * @alias SUGAR.App.view.layouts.BaseFilterLayout
 * @extends View.Layout
 */
({
	// Filter Layout (base) 

    className: 'filter-view search',

    plugins: ['QuickSearchFilter'],

    events: {
        'click .add-on.fa-times': function() { this.trigger('filter:clear:quicksearch'); }
    },

    /**
     * The collection of filters.
     *
     * @property {Data.BeanCollection}
     */
    filters: null,

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        var filterLayout = app.view._getController({type:'layout',name:'filter'});
        filterLayout.loadedModules = filterLayout.loadedModules || {};
        app.view.Layout.prototype.initialize.call(this, opts);

        this.layoutType = app.utils.deepCopy(this.options.meta.layoutType) || this.context.get('layout') || this.context.get('layoutName') || app.controller.context.get('layout');

        this.aclToCheck = (this.layoutType === 'record')? 'view' : 'list';

        // Can't use getRelevantContextList here, because the context may not
        // have all the children we need.
        if (this.layoutType === 'records' || this.layoutType === 'activities') {
            // filters will handle data fetching so we skip the standard data fetch
            this.context.set('skipFetch', true);
        } else {
            if(this.context.parent) {
                this.context.parent.set('skipFetch', true);
            }
            this.context.on('context:child:add', function(childCtx) {
                if (childCtx.get('link')) {
                    // We're in a subpanel.
                    childCtx.set('skipFetch', true);
                }
            }, this);
        }

        /**
         * bind events
         */
        this.on('filter:apply', this.applyFilter, this);

        this.on('filter:create:close', function() {
            if (!this.createPanelIsOpen()) {
                return;
            }
            this.layout.trigger('filter:create:close');
            // When canceling creating a new filter, we want to go back to the `all_records` filter
            if (this.getLastFilter(this.layout.currentModule, this.layoutType) === 'create') {
                // For that we need to remove the last state key and trigger reinitialize
                this.clearLastFilter(this.layout.currentModule, this.layoutType);
                this.layout.trigger("filter:reinitialize");
            }
            this.context.editingFilter = null;
        }, this);

        this.on('filter:create:open', function(filterModel) {
            this.context.editingFilter = filterModel;
            this.layout.trigger('filter:create:open', filterModel);
        }, this);

        this.on('subpanel:change', function(linkName) {
            this.layout.trigger('subpanel:change', linkName);
        }, this);

        this.on('filter:get', this.initializeFilterState, this);

        this.on('filter:change:filter', this.handleFilterChange, this);

        this.layout.on('filter:apply', function(query, def) {
            this.trigger('filter:apply', query, def);
        }, this);

        this.layout.on('filterpanel:change', this.handleFilterPanelChange, this);
        this.layout.on('filterpanel:toggle:button', this.toggleFilterButton, this);

        //When a filter is saved, update the cache and set the filter to be the currently used filter
        this.context.on('filter:add', this.addFilter, this);

        // When a filter is deleted, update the cache and set the default filter
        // to be the currently used filter.
        this.layout.on('filter:remove', this.removeFilter, this);

        this.layout.on('filter:reinitialize', function() {
            this.initializeFilterState(this.layout.currentModule, this.layout.currentLink);
        }, this);

        this.listenTo(app.events, 'dashlet:filter:save', this.refreshDropdown);
    },

    /**
     * This function refreshes the list of filters in the filter dropdown, and
     * is invoked when a filter is saved on a dashlet (`dashlet:filter:save`).
     * It triggers a `filter:reinitialize` event and resets the cached
     * module in `loadedModules` on the filter layout if the dashlet module
     * matches the `currentModule` on the filter layout.
     *
     * @param {String} module
     */
    refreshDropdown: function(module) {
        if (module === this.layout.currentModule) {
            var filterLayout = app.view._getController({type:'layout', name:'filter'});
            filterLayout.loadedModules[module] = false;
            this.layout.trigger('filter:reinitialize');
        }
    },

    /**
     * handles filter removal
     * @param model
     */
    removeFilter: function(model) {
        this.filters.collection.remove(model);
        this.context.set('currentFilterId', null);
        this.clearLastFilter(this.layout.currentModule, this.layoutType);
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Saves last filter id to app cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @param {String} filterId The filter id.
     */
    setLastFilter: function(filterModule, layoutName, filterId) {
        var filterOptions = this.context.get('filterOptions') || {};
        this.context.set('currentFilterId', filterId);
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            app.user.lastState.set(key, filterId);
        }
    },

    /**
     * Gets last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @return {String} The filter id.
     */
    getLastFilter: function(filterModule, layoutName) {
        // Check if we've already loaded it.
        var filter = this.context.get('currentFilterId');
        if (!_.isEmpty(filter)) {
            return filter;
        }

        var filterOptions = this.context.get('filterOptions') || {};
        // Load from cache.
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            filter = app.user.lastState.get(key);
        }

        // Check if there is an initial filter defined that we should use instead.
        if (_.isEmpty(filter) && filterOptions.initial_filter) {
            filter = filterOptions.initial_filter;
        }

        this.context.set('currentFilterId', filter);
        return filter;
    },

    /**
     * Clears last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     */
    clearLastFilter: function(filterModule, layoutName) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            app.user.lastState.remove(key);
        }
        this.clearFilterEditState();
    },

    /**
     * Retrieves the current edit state from cache.
     *
     * @return {Object} The filter attributes if found.
     */
    retrieveFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            return app.user.lastState.get(key);
        }
    },

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} filter
     */
    saveFilterEditState: function(filter) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            app.user.lastState.set(key, filter);
        }
    },

    /**
     * Removes the edit state from the cache
     */
    clearFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            app.user.lastState.remove(key);
        }
    },

    /**
     * Removes deprecated cache entries of one module.
     *
     * The {@link Data.Base.FiltersBeanCollection} is now responsible for
     * storing the list of filters in memory. This list is no longer saved to
     * the local storage.
     *
     * First version, the list was stored with a key looking like this:
     *
     *     this.module + ':filter:saved-' + this.layout.currentModule
     *
     * Second version, the list was stored with a key looking like this:
     *
     *     module + ':filter:saved-filters
     *
     * Examples of keys we need to remove:
     *
     *     Home:filter:saved-Accounts
     *     Accounts:filter:saved-Accounts
     *     Contacts:filter:saved-Accounts
     *     Accounts:filter:saved-filters
     *     Contacts:filter:saved-filters
     *
     * @param {String} module The module name.
     */
    removeDeprecatedCache: function(module) {
        app.user.lastState.remove(app.user.lastState.key('saved-' + module, this));

        var layoutModule = this.module;
        this.module = module;
        // The filter collection used to be cached. It's now only saved in
        // memory so we need to remove the potential existing cache entry.
        app.user.lastState.remove(app.user.lastState.key('saved-filters', this));
        this.module = layoutModule;
    },

    /**
     * Handles filter addition or update.
     *
     * @param {Data.Base.FiltersBean} model The filter model that is created or
     *   updated.
     */
    addFilter: function(model) {
        var id = model.get('id');
        this.filters.collection.add(model, {merge: true});
        this.filters.collection.trigger('cache:update', model);
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);
        this.context.set('currentFilterId', id);
        this.clearFilterEditState();
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Enables or disables a filter toggle button (e.g. activity or subpanel toggle buttons)
     * @param {String} toggleDataView the string used in `data-view` attribute for that toggle element (e.g. 'subpanels', 'activitystream')
     * @param {Boolean} on pass true to enable, false to disable
     */
    toggleFilterButton: function (toggleDataView, on) {
        var toggleButtons = this.layout.$('.toggle-actions a.btn');

        // Loops toggle buttons for 'data-view' that corresponds to `toggleDataView` and enables/disables per `on`
        _.each(toggleButtons, function(btn) {
            if($(btn).data('view') === toggleDataView) {
                if(on) {
                    $(btn).removeAttr('disabled').removeClass('disabled');
                } else {
                    $(btn).attr('disabled', 'disabled').addClass('disabled');
                    $(btn).attr('title', app.lang.get('LBL_NO_DATA_AVAILABLE'));
                }
            }
        });
    },

    /**
     * Handles filter panel changes between activity and subpanels
     * @param {String} name Name of panel
     * @param {Boolean} silent Whether to trigger filter events
     * @param {Boolean} setLastViewed Whether to set last viewed to `name` panel
     */
    handleFilterPanelChange: function(name, silent, setLastViewed) {
        this.showingActivities = name === 'activitystream';
        var module = this.showingActivities ? "Activities" : this.module;
        var link;

        this.$el.css('visibility', app.acl.hasAccess(this.aclToCheck, module) ? 'visible' : 'hidden');
        if(this.layoutType === 'record' && !this.showingActivities) {
            // FIXME: TY-499 will address removing the dependancy on this.layout
            module = link = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) || 'all_modules';
            if (link !== 'all_modules') {
                module = app.data.getRelatedModule(this.module, link);
            }
        } else {
            link = null;
        }
        if (!silent) {
            this.trigger("filter:render:module");
            this.trigger("filter:change:module", module, link);
        }
        if (setLastViewed) {
            // Asks filterpanel to update user.lastState with new panel name as last viewed
            this.layout.trigger('filterpanel:lastviewed:set', name);
        }
    },

    /**
     * Handles filter change.
     *
     * @param {String} id The filter id.
     */
    handleFilterChange: function(id) {
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);

        var filter, editState = this.retrieveFilterEditState();
        // Figure out if we have an edit state. This would mean user was editing the filter so we want him to retrieve
        // the filter form in the state he left it.
        filter = this.filters.collection.get(id) || app.data.createBean('Filters', {module_name: this.moduleName});
        if (editState && (editState.id === id || (id==='create' && !editState.id))) {
            filter.set(editState);
        } else {
            editState = false;
        }

        this.context.set('currentFilterId', filter.get('id'));

        var editable = filter.get('editable') !== false;

        // If the user selects a filter that has an incomplete filter
        // definition (i.e. filter definition != filter_template), open the
        // filterpanel to indicate it is ready for further editing.
        var isIncompleteFilter = filter.get('filter_template') &&
            JSON.stringify(filter.get('filter_definition')) !== JSON.stringify(filter.get('filter_template'));

        // If the user selects a filter template that gets populated by values
        // passed in the context/metadata, open the filterpanel to show the
        // actual search.
        var isTemplateFilter = filter.get('is_template');

        var modelHasChanged = !_.isEmpty(filter.changedAttributes(filter.getSynced()));

        if (editable &&
            (isIncompleteFilter || isTemplateFilter || editState || id === 'create' || modelHasChanged)
        ) {
            this.layout.trigger('filter:set:name', '');
            this.trigger('filter:create:open', filter);
            this.layout.trigger('filter:toggle:savestate', true);
        } else {
            // FIXME: TY-1457 should improve this
            this.context.editingFilter = null;
            this.layout.trigger('filter:create:close');
        }

        var ctxList = this.getRelevantContextList();
        var clear = false;
        //Determine if we need to clear the collections
        _.each(ctxList, function(ctx) {
            var filterDef = filter.get('filter_definition');
            var orig = ctx.get('collection').origFilterDef;
            ctx.get('collection').origFilterDef = filterDef;  //Set new filter def on each collection
            if (_.isUndefined(orig) || !_.isEqual(orig, filterDef)) {
                clear = true;
            }
        });
        //If so, reset collections and trigger quicksearch to repopulate
        if (clear) {
            _.each(ctxList, function(ctx) {
                ctx.get('collection').resetPagination();
                // Silently reset the collection otherwise the view is re-rendered.
                // It will be re-rendered on request response.
                ctx.get('collection').reset(null, { silent: true });
            });
            this.trigger('filter:apply');
        }
    },
    /**
     * Applies filter on current contexts
     * @param {String} query search string
     * @param {Object} dynamicFilterDef(optional)
     */
    applyFilter: function(query, dynamicFilterDef) {
        // TODO: getRelevantContextList needs to be refactored to handle filterpanels in drawer layouts,
        // as it will return the global context instead of filtering a list view within the drawer context.
        // As a result, this flag is needed to prevent filtering on the global context.
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.auto_apply === false) {
            return;
        }

        // to make sure quick filter is handled properly
        if (_.isEmpty(query)) {
            var filterQuicksearchView = this.getComponent('filter-quicksearch');
            query = filterQuicksearchView && filterQuicksearchView.$el.val() || '';
        }

        //If the quicksearch field is not empty, append a remove icon so the user can clear the search easily
        this._toggleClearQuickSearchIcon(!_.isEmpty(query));
        var self = this;
        var ctxList = this.getRelevantContextList();

        // Here we split the relevant contexts into two groups, 'count', and
        // 'fetch'. For the 'count' contexts, we do a 'fetchOnlyIds' on their
        // collection so we can update the count and highlight the subpanel
        // icon, even though they are collapsed. For the 'fetch' group, we do a
        // full collection fetch so the subpanel can render its list view.
        var relevantCtx = _.groupBy(ctxList, function(ctx) {
            return ctx.get('collapsed') ? 'count' : 'fetch';
        });

        var batchId = relevantCtx.count && relevantCtx.count.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.count, function(ctx) {
            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
            var filterDef = self.buildFilterDef(origFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;
            ctxCollection.resetPagination();

            options = _.extend(options, ctx.get('collectionOptions'));
            ctx.resetLoadFlag(false);
            ctx.set('skipFetch', true);
            ctx.loadData(options);

            // We need to reset twice so we can trigger the other bulk call.
            ctx.resetLoadFlag(false);
            options.success = _.bind(function(hasAmount, properties) {
                if (!this.disposed) {
                    ctx.trigger('refresh:count', hasAmount, properties);
                }
            }, this);
            ctxCollection.hasAtLeast(ctx.get('limit'), options);
        });

        // FIXME: Filters should not be triggering the bulk request and should
        // be moved to subpanels instead. Will be fixed as part of SC-4533.
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }

        batchId = relevantCtx.fetch && relevantCtx.fetch.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.fetch, function(ctx) {
            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
            var filterDef = self.buildFilterDef(origFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                },
                success: function(collection, response, options) {
                    // Close the preview pane to ensure that the preview
                    // collection is in sync with the list collection.
                    app.events.trigger('preview:close');
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;

            ctx.resetLoadFlag(false);
            if (!_.isEmpty(ctx._recordListFields)) {
                ctx.set('fields', ctx._recordListFields);
            }
            ctx.set('skipFetch', false);
            ctx.loadData(options);
        });
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }
    },

    /**
     * Look for the relevant contexts. It can be
     * - the activity stream context
     * - the list view context on records layout
     * - the selection list view context on records layout
     * - the contexts of the subpanels on record layout
     * @return {Array} array of contexts
     */
    getRelevantContextList: function() {
        var contextList = [];
        if (this.showingActivities) {
            _.each(this.layout._components, function(component) {
                var ctx = component.context;
                if (component.name == 'activitystream' && !ctx.get('modelId') && ctx.get('collection')) {
                    //FIXME: filter layout's _components array has multiple references to same activitystreams layout object
                    contextList.push(ctx);

                }
            });
        } else {
            if (this.layoutType === 'records') {
                var ctx = this.context;
                if (!ctx.get('modelId') && ctx.get('collection')) {
                    contextList.push(ctx);
                }
            } else {
                //Locate and add subpanel contexts
                _.each(this.context.children, function(ctx) {
                    if (ctx.get('isSubpanel') && !ctx.get('hidden') && !ctx.get('modelId') && ctx.get('collection')) {
                        contextList.push(ctx);
                    }
                });
            }
        }
        return _.uniq(contextList);
    },

    /**
     * Builds the filter definition based on preselected filter and module quick search fields
     * @param {Object} oSelectedFilter
     * @param {String} searchTerm
     * @param {Context} context
     * @return {Array} array containing filter def
     */
    buildFilterDef: function(oSelectedFilter, searchTerm, context) {
        var selectedFilter = app.utils.deepCopy(oSelectedFilter),
            isSelectedFilter = _.size(selectedFilter) > 0,
            module = context.get('module'),
            filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
            searchFilter = filtersBeanPrototype.buildSearchTermFilter(module, searchTerm),
            isSearchFilter = _.size(searchFilter) > 0;

        selectedFilter = _.isArray(selectedFilter) ? selectedFilter : [selectedFilter];
        /**
         * Filter fields that don't exist either on vardefs or search definition.
         *
         * Special fields (fields that start with `$`) like `$favorite` aren't
         * cleared.
         *
         * TODO move this to a plugin method when refactoring the code (see SC-2555)
         * TODO we should support cleanup on all levels (currently made on 1st
         * level only).
         */
        var specialField = /^\$/,
            meta = app.metadata.getModule(module);
        selectedFilter = _.filter(selectedFilter, function(def) {
            var fieldName = _.keys(def).pop();
            return specialField.test(fieldName) || meta.fields[fieldName];
        }, this);

        if (isSelectedFilter && isSearchFilter) {
            selectedFilter.push(searchFilter[0]);
            return [{'$and': selectedFilter }];
        } else if (isSelectedFilter) {
            return selectedFilter;
        } else if (isSearchFilter) {
            return searchFilter;
        }

        return [];
    },

    /**
     * Loads the full filter panel for a module.
     *
     * @param {String} moduleName The module name.
     * @param {String} [linkName] The related module link name, by default it
     *   will load the last selected filter,
     * @param {String} [filterId] The filter ID to initialize with. By default
     *   it will load the last selected filter or the default filter from
     *   metadata.
     */
    initializeFilterState: function(moduleName, linkName, filterId) {

        if (this.showingActivities) {
            moduleName = 'Activities';
            linkName = null;
        } else {
            moduleName = moduleName || this.module;

            if (this.layoutType === 'record') {
                // FIXME: TY-499 will address removing the dependancy on this.layout
                linkName = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) ||
                    linkName ||
                    'all_modules';

                // if the incoming module is the same as the layoutModule then we need to find the other side.
                if (linkName !== 'all_modules' && this.layout.module === moduleName) {
                    moduleName = app.data.getRelatedModule(moduleName, linkName) || moduleName;
                }
            }
        }

        filterId = filterId || this.getLastFilter(moduleName, this.layoutType);

        this.layout.trigger('filterpanel:change:module', moduleName, linkName);
        this.trigger('filter:change:module', moduleName, linkName, true);
        this.getFilters(moduleName, filterId);
    },

    /**
     * Retrieves the appropriate list of filters from cache if found, otherwise
     * from the server.
     *
     * @param {String} moduleName The module name.
     * @param {String} [defaultId] The filter `id` to select once loaded.
     */
    getFilters: function(moduleName, defaultId) {
        if (moduleName === 'all_modules') {
            this.selectFilter('all_records');
            return;
        }
        var filterOptions = this.context.get('filterOptions') || {};

        if (this.filters) {
            this.filters.dispose();
        }

        // Remove deprecated cache entries.
        this.removeDeprecatedCache(moduleName);

        this.filters = app.data.createBeanCollection('Filters');
        this.filters.setModuleName(moduleName);
        this.filters.setFilterOptions(filterOptions);

        this.filters.load({
            success: _.bind(function() {
                if (this.disposed) {
                    return;
                }
                defaultId = defaultId || this.filters.collection.defaultFilterFromMeta;
                this.selectFilter(defaultId);

            }, this)
        });
    },

    /**
     * Selects a filter.
     *
     * @triggers filter:select:filter to select the filter in the dropdown.
     *
     * @param {String} filterId The filter id to select.
     * @return {String} The selected filter id.
     */
    selectFilter: function(filterId) {
        var possibleFilters,
            selectedFilterId = filterId;

        if (selectedFilterId !== 'create') {
            possibleFilters = [selectedFilterId, this.filters.collection.defaultFilterFromMeta, 'all_records'];
            possibleFilters = _.filter(possibleFilters, this.filters.collection.get, this.filters.collection);
            selectedFilterId = _.first(possibleFilters);
        }
        this.trigger('filter:render:filter');
        this.trigger('filter:select:filter', selectedFilterId);
        return selectedFilterId;
    },

    /**
     * Utility function to know if the create filter panel is opened.
     * @return {boolean} `true` if opened, `false` otherwise
     */
    createPanelIsOpen: function() {
        return !this.layout.$(".filter-options").is(":hidden");
    },

    /**
     * Determines whether a user can create a filter for the current module.
     * @return {boolean} `true` if creatable, `false` otherwise
     */
    canCreateFilter: function() {
        // Check for create in meta and make sure that we're only showing one
        // module, then return false if any is false.
        var contexts = this.getRelevantContextList(),
            creatable = app.acl.hasAccess("create", "Filters"),
            meta;
        // Short circuit if we don't have the ACLs to create Filter beans.

        if (creatable && contexts.length === 1) {
            meta = app.metadata.getModule(contexts[0].get("module"));
            if (meta && _.isObject(meta.filters)) {
                _.each(meta.filters, function(value) {
                    if (_.isObject(value)) {
                        creatable = creatable && value.meta.create !== false;
                    }
                });
            }
        }

        return creatable;
    },

    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily
     * @param {Boolean} addIt TRUE if you want to add it, FALSO to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.fa-times.add-on')[0]) {
            this.$el.append('<i class="fa fa-times add-on"></i>');
        } else if (!addIt) {
            this.$('.fa-times.add-on').remove();
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (app.acl.hasAccess(this.aclToCheck, this.module)) {
            app.view.Layout.prototype._render.call(this);
        }
    },

    /**
     * @override
     */
    unbind: function() {
        if (this.filters) {
            this.filters.dispose();
        }
        this.filters = null;
        app.view.Layout.prototype.unbind.call(this);
    }

}) },
"history-summary-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.HistorySummaryPreviewLayout
 * @alias SUGAR.App.view.layouts.BaseHistorySummaryPreviewLayout
 * @extends View.Layouts.Base.PreviewLayout
 */
({
	// History-summary-preview Layout (base) 

    extendsFrom: 'PreviewLayout'
}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListLayout
 * @extends View.Layout
 */
({
	// Selection-list Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ],

    loadData: function(options) {
        var fields = _.union(this.getFieldNames(), (this.context.get('fields') || []));
        this.context.set('fields', fields);
        this._super('loadData', [options, false]);
    }
}) },
"subpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelLayout
 * @extends View.Layouts.Base.PanelLayout
 */
({
	// Subpanel Layout (base) 

    extendsFrom: 'PanelLayout',

    /**
     * What is our current dataview
     */
    dataView: 'subpanel-list',

    /**
     * @override
     */
    initialize: function(options) {
        options.type = 'panel';
        //Check for the override_subpanel_list_view from the parent layout metadata and replace the list view if found.
        if (options.meta && options.def && options.def.override_subpanel_list_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view.indexOf('subpanel-list') !== -1) {
                    def.view = options.def.override_subpanel_list_view;
                }
            });
            // set the dataview if we override it
            this.dataView = options.def.override_subpanel_list_view;
            // override last_state.id with "override_subpanel_list_view" for unique state name.
            if (options.meta.last_state.id) {
                options.meta.last_state.id = options.def.override_subpanel_list_view;
            }
        }

        if (options.meta && options.def && options.def.override_paneltop_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view == 'panel-top') {
                    def.view = options.def.override_paneltop_view;
                }
            });
        }

        this._super('initialize', [options]);

        // if the dataView variable does not equal 'subpanel-list', it means it was changed
        // and we need to set the correct dataView on the context so when the data is fetched via
        // the api, it pulls the correct fields.
        if (this.dataView !== 'subpanel-list') {
            this.context.set('dataView', this.dataView);
        }

        // FIXME in SC-3360 - this is a hacky flag to be able to fetch a collection of
        // links. We will be able to remove this code once we introduce the CollectionsAPI.
        var ignoreRole = this.context.get('ignore_role');
        if (ignoreRole) {
            var collection = this.collection;
            var options = collection.getOption() || {};
            var params = options.params || {};
            params.ignore_role = ignoreRole;
            collection.setOption('params', params);
        }

        // binding so subpanels can trigger other subpanels to reload by link name
        // example: ctx.trigger('subpanel:reload', {links: ['opportunities','revenuelineitems']});
        if (this.context.parent) {
            this.context.parent.on('subpanel:reload', function(args) {
                app.logger.warn('`subpanel:reload` is deprecated. Use `context.reloadData()` to reload and expand.');
                if (!_.isUndefined(args) && _.isArray(args.links) && _.contains(args.links, this.context.get('link'))) {
                    this.context.reloadData({recursive: false});
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this.context.set('hidden', false);
        this._super('show');
    },

    /**
     * @inheritdoc
     */
    hide: function() {
        this.context.set('hidden', true);
        this._super('hide');
    }
}) },
"find-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Find-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"dashlet-main": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletMainLayout
 * @alias SUGAR.App.view.layouts.BaseDashletMainLayout
 * @extends View.Layout
 */
({
	// Dashlet-main Layout (base) 

    tagName: "ul",
    className: "dashlets row-fluid",

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.model) {
            this.model.on("change:metadata", this.setMetadata, this);
            this.model.on("change:layout", this.setWidth, this);
            this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
            this.model.on("setMode", function(mode) {
                this.model._previousMode = this.model.mode;
                this.model.mode = mode;
            }, this);
            this.model.trigger('setMode', this.context.get("create") ? 'edit' : 'view');
        }
    },

    /**
     * Replace all components based on the dashboard metadata value
     */
    setMetadata: function() {
        if(!this.model.get("metadata")) return;
        //Clean all components
        _.each(this._components, function(component) {
            component.dispose();
        }, this);
        this._components = [];
        this.$el.children().remove();

        var components = app.utils.deepCopy(this.model.get("metadata")).components;
        _.each(components, function(component, index) {
            this.initComponents([{
                layout: {
                    type: 'dashlet-row',
                    width: component.width,
                    components: component.rows,
                    index: index + ''
                }
            }]);
        } , this);

        this.loadData();
        this.render();
    },

    /**
     * Set current main layout's width proportion
     */
    setWidth: function() {
        var metadata = this.model.get("metadata"),
            $el = this.$el.children();

        _.each(metadata.components, function(component, index){
            $el.get(index).className = $el.get(index).className.replace(/span\d+\s*/, '');
            $($el.get(index)).addClass("span" + component.width);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Resets the original css classes, and adds the dashboard classes if
     * defined.
     */
    _render: function() {
        this.$el.removeClass();
        this.$el.addClass(this.className);
        this._super('_render');
        if (this.model.has('css_class')) {
            this.$el.addClass(this.model.get('css_class'));
        }
    },

    /**
     * Set all appended dashlets drag-and-droppable
     */
    applyDragAndDrop: function() {
        if (this.model.get('drag_and_drop') === false) {
            return;
        }
        var self = this;
        this.$('.dashlet:not(.empty)').draggable({
            revert: 'invalid',
            handle: 'h4',
            scroll: true,
            scrollSensitivity: 100, //pixel
            appendTo: this.$el,
            start: function(event, ui) {
                $(this).css({visibility: 'hidden'});
                self.model.trigger("setMode", "drag");
                self.context.trigger('dashlet:draggable:start');
            },
            stop: function() {
                self.model.trigger("setMode", self.model._previousMode);
                self.$(".dashlet.ui-draggable").attr("style", "");
                self.context.trigger('dashlet:draggable:stop');
            },
            helper: function() {
                var $clone = $(this).clone();
                $clone
                    .addClass('helper')
                    .css({opacity: 0.8})
                    .width($(this).width());
                $clone.find('.btn-toolbar').remove();
                return $clone;
            }
        });

        this.$('.dashlet-container').droppable({
            activeClass: 'ui-droppable-active',
            hoverClass: 'active',
            tolerance: 'pointer',
            accept: function($el) {
                return $el.data('type') === 'dashlet' && self.$(this).find('[data-action=droppable]').length === 1;
            },
            drop: function(event, ui) {
                var sourceIndex = ui.draggable.parents(".dashlet-container:first").data('index')(),
                    targetIndex = self.$(this).data('index')();
                self.switchComponent(targetIndex, sourceIndex);
            }
        });
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata and its dashlet frame layout
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split(''),
            component = metadata.components;
        _.each(position, function(index) {
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var layout = this;
        _.each(position, function(index) {
            layout = layout._components[index];
        }, this);
        return {
            metadata: component,
            layout: layout
        };
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        if (target === source) {
            return;
        }
        var metadata = this.model.get('metadata'),
            targetComponent = this.getCurrentComponent(metadata, target),
            sourceComponent = this.getCurrentComponent(metadata, source);

        //Swap the metadata except 'width' property since it's previous size
        var cloneMeta = app.utils.deepCopy(targetComponent.metadata);
        _.each(targetComponent.metadata, function(value, key) {
            if (key !== 'width') {
                delete targetComponent.metadata[key];
            }
        }, this);
        _.each(sourceComponent.metadata, function(value, key) {
            if (key !== 'width') {
                targetComponent.metadata[key] = value;
                delete sourceComponent.metadata[key];
            }
        }, this);
        _.each(cloneMeta, function(value, key) {
            if (key !== 'width') {
                sourceComponent.metadata[key] = value;
            }
        }, this);

        this.model.set('metadata', app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger('change:layout');
        if (this.model._previousMode === 'view') {
            //Autosave for view mode
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        }
        //Swap the view components
        var targetDashlet = targetComponent.layout._components.splice(0);
        var sourceDashlet = sourceComponent.layout._components.splice(0);

        //switch the metadata
        var targetMeta = app.utils.deepCopy(targetComponent.layout.meta);
        var sourceMeta = app.utils.deepCopy(sourceComponent.layout.meta);
        targetComponent.layout.meta = sourceMeta;
        sourceComponent.layout.meta = targetMeta;

        _.each(targetDashlet, function(comp) {
            sourceComponent.layout._components.push(comp);
            comp.layout = sourceComponent.layout;
        }, this);
        _.each(sourceDashlet, function(comp) {
            targetComponent.layout._components.push(comp);
            comp.layout = targetComponent.layout;
        }, this);
        //switch invisibility
        var targetInvisible = targetComponent.layout._invisible;
        var sourceInvisible = sourceComponent.layout._invisible;
        if (targetInvisible) {
            sourceComponent.layout.setInvisible();
        } else {
            sourceComponent.layout.unsetInvisible();
        }
        if (sourceInvisible) {
            targetComponent.layout.setInvisible();
        } else {
            targetComponent.layout.unsetInvisible();
        }

        //Swap the DOM
        var cloneEl = targetComponent.layout.$el.children(':first').get(0);
        targetComponent.layout.$el.append(sourceComponent.layout.$el.children(':not(.helper)').get(0));
        sourceComponent.layout.$el.append(cloneEl);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var $dashlets = this.$('.dashlet');
        var $dashletContainers = this.$('.dashlet-container');

        // Make sure the element is initialized to be draggable before destroying.
        _.each($dashlets, function(dashlet) {
            var $dashlet = $(dashlet);
            if (!_.isUndefined($dashlet.draggable('instance'))) {
                $dashlet.draggable('destroy');
            }
        });

        // Make sure the element is initialized to be droppable before destroying.
        _.each($dashletContainers, function(dashletContainer) {
            var $dashletContainer = $(dashletContainer);
            if (!_.isUndefined($dashletContainer.droppable('instance'))) {
                $dashletContainer.droppable('destroy');
            }
        });

        this._super('_dispose');
    }
}) },
"dashlet-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletRowLayout
 * @alias SUGAR.App.view.layouts.BaseDashletRowLayout
 * @extends View.Layout
 */
({
	// Dashlet-row Layout (base) 

    tagName: 'li',

    events: {
        'click .remove-row': 'removeClicked'
    },
    plugins: ['Tooltip'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        options.meta = this.setMetadata(options.meta);

        this._super('initialize', [options]);

        this.model.on("setMode", this.setMode, this);
        this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
        this.setMode(this.model.mode);
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            meta.components[index] = {
                layout: {
                    type : 'dashlet-cell',
                    index : this.index + '' + index,
                    components: component
                }
            };
        }, this);

        var addRowDashlet = {
            layout: {
                type: 'dashlet',
                index: this.index + '' + meta.components.length,
                empty: true,
                components: [
                    {
                        view: 'dashlet-row-empty',
                        context: {
                            module:'Home',
                            forceNew:true,
                            create:true
                        }
                    }
                ]
            }
        };
        meta.components.push(addRowDashlet);
        if(meta.css_class) meta.css_class += ' ';
        meta.css_class = 'span' + (meta.width || 12);
        return meta;
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def, prepend) {
        var $body = this.$el.children(".dashlet-row");
        if($body.length === 0) {
            $body = $("<ul></ul>").addClass("dashlet-row");
            this.$el.append($body);
        }
        var headerTemplate = app.template.getLayout(this.name + '.header') || app.template.empty,
            $container = $("<div></div>", {'class': 'rows well well-invisible'})
                .append(headerTemplate())
                .append(comp.el),
            $el = $("<li></li>", {'class': 'row-fluid', 'data-sortable': '1'}).data('index', function() {
                return comp.index + '';
            }).append($container);

        if(prepend) {
            $body.children("li:last").before($el);
        } else {
            $body.append($el);
        }
    },

    /**
     * @inheritdoc
     */
    addComponent: function(component, def) {
        if(this.prependComponent) {
            if (!component.layout) component.layout = this;
            this._components.splice(this._components.length - 1, 0, component);
            this._placeComponent(component, def, true);
            this.prependComponent = false;
        } else {
            this._super('addComponent', [component, def]);
        }
    },

    /**
     * Adds a row to the dashboard
     *
     * @param {Number} columns the number of columns in this row
     */
    addRow: function(columns) {
        var span = 12 / columns,
            components = [];
        _.times(columns, function() {
            components.push({
                width: span
            });
        });
        var metadata = this.model.get('metadata'),
            position = this.index.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.push(app.utils.deepCopy(components));
        this.model.set("metadata", metadata, {silent: true});
        this.model.trigger("change:layout");

        this.prependComponent = true;
        _.each(this._components, function(component){
            component.index++;
        }, this);
        this._addComponentsFromDef([{
            layout: {
                type : 'dashlet-cell',
                index: this.index + '' + (this._components.length - 1),
                components: components
            }
        }]);
        _.each(this._components, function(component, index){
            component.index = this.index + '' + index;
        }, this);

        //init components of the most recently created row
        this._components[this._components.length-2].initComponents();

        this.setMode(this.model.mode);
    },

    /**
     * Displays a confirmation alert when removing a row.
     *
     * @param {Event} evt The `click` event.
     */
    removeClicked: function(evt) {
        var cell = $(evt.currentTarget).closest('.row-fluid'),
            index = (cell.data('index')()).split('').pop();
        if (!cell.find('[data-dashlet]').length) {
            this.removeRow(index);
            return;
        }
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_ROW_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.removeRow(index);
            }, this)
        });
    },

    /**
     * Removes a row.
     *
     * @param {Number} index The index of the row to remove.
     */
    removeRow: function(index) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.splice(index, 1);
        this._components[index].dispose();
        this._components.splice(index, 1);
        _.each(this._components, function(component, index) {
            // Update each row,
            component.index = this.index + '' + index;
            // And each cell of each row.
            _.each(component._components, function(cell, cellIndex) {
                cell.index = component.index + '' + cellIndex;
            });
        }, this);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        this.$el.children(".dashlet-row").children("li:eq(" + index + ")").remove();
    },

    /**
     * @inheritdoc
     */
    setMode: function(type) {
        if(type === 'edit' || (this.model._previousMode === 'edit' && type === 'drag')) {
            this.$el.children(".dashlet-row").sortable("enable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").removeClass("well-invisible").children(".btn-link").toggleClass("hide", false);
        } else {
            this.$el.children(".dashlet-row").sortable("disable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").addClass("well-invisible").children(".btn-link").toggleClass("hide", true);
        }
    },

    /**
     * Adds drag-and-drop functionality to the row
     */
    applyDragAndDrop: function() {
        var self = this;
        this.$el.children(".dashlet-row").sortable({
            axis: "y",
            items: "li.sortable",
            handle: ".move",
            forcePlaceholderSize: true,
            placeholder: "placeholder",
            update: function(event, ui) {
                var sourceIndex = ui.item.first().data('index')(),
                    targetIndex = ui.item.first().next().data('index')();

                self.switchComponent(targetIndex, sourceIndex);
            }
        });
        this.setMode(this.model.mode);
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = metadata.components,
            targetIndex = target.split('').pop(),
            sourceIndex = source.split('').pop();
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var sourceMetadata = component.rows[sourceIndex],
            sourceComponent = this._components[sourceIndex];

        if(sourceIndex > targetIndex) {
            //dragging up
            component.rows.splice(sourceIndex, 1);
            component.rows.splice(targetIndex, 0, sourceMetadata);

            this._components.splice(sourceIndex, 1);
            this._components.splice(targetIndex, 0, sourceComponent);
        } else {
            //dragging down
            component.rows.splice(targetIndex, 0, sourceMetadata);
            component.rows.splice(sourceIndex, 1);

            this._components.splice(targetIndex, 0, sourceComponent);
            this._components.splice(sourceIndex, 1);
        }

        _.each(this._components, function(component, index){
            component.index = this.index + '' + index;
        }, this);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$el.children(".dashlet-row").sortable("destroy");
        this.model.off("applyDragAndDrop", null, this);
        this.model.off("setMode", null, this);
        this._super('_dispose');
    }
}) },
"selection-list-module-switch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListModuleSwitchLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListModuleSwitchLayout
 * @extends View.Layouts.Base.SelectionListLayout
 */
({
	// Selection-list-module-switch Layout (base) 

    extendsFrom: 'SelectionListLayout',

    /**
     * Build the module list for the dropdown from filterList attribute that is set
     * on the context.
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._filterList = this.context.get('filterList');
        this.context.set('filterList', this._buildModuleSwitchList(this._filterList));

        this.context.on('selection-list:reload', this.reload, this);
    },

    /**
     * Given a list of modules, it checks to see if the user has access to those modules
     * and returns a list in a form that Select2 dropdown accepts.
     * @param {Array} modules - List of modules to be displayed in the dropdown.
     * @return {Array}
     * @private
     */
    _buildModuleSwitchList: function(modules) {
        var filter = [];

        _.each(modules, function(module) {
            if (app.acl.hasAccess('list', module)) {
                filter.push({id: module, text: app.lang.get('LBL_MODULE_NAME', module)});
            }
        }, this);

        return filter;
    },

    /**
     * Reload this drawer layout.
     * @param {string} module
     */
    reload: function(module) {
        var self = this;
        // Need to defer so that we do not reload and dispose the drawer before all event
        // callbacks have completely finished.
        _.defer(function() {
            app.drawer.load({
                layout: 'selection-list-module-switch',
                context: {
                    module: module,
                    fields: self.context.get('fields'),
                    filterOptions: self.context.get('filterOptions'),
                    filterList: self._filterList
                }
            });
        });
    }
}) },
"preview-activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewActivityStreamLayout
 * @alias SUGAR.App.view.layouts.BasePreviewActivityStreamLayout
 * @extends View.Layouts.Base.ActivitystreamLayout
 */
({
	// Preview-activitystream Layout (base) 

    extendsFrom: 'ActivitystreamLayout',

    _previewOpened: false, //is the preview pane open?

    /**
     * Fetch and render activities when 'preview:render' event has been fired.
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        app.events.on("preview:render", this.fetchActivities, this);
        app.events.on('preview:open', function() {
            this._previewOpened = true;
        }, this);
        app.events.on('preview:close', function() {
            this._previewOpened = false;
            this.disposeAllActivities();
        }, this);
    },

    /**
     * Fetch and render activities.
     *
     * @param model
     * @param collection
     * @param fetch
     * @param previewId
     * @param {boolean} showActivities
     */
    fetchActivities: function(model, collection, fetch, previewId, showActivities) {
        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // don't fetch activities for BWC modules
            return;
        }
        this.disposeAllActivities();
        this.collection.dataFetched = false;
        this.$el.hide();

        showActivities = _.isUndefined(showActivities) ? true : showActivities;
        if (showActivities) {
            this.collection.reset();
            this.collection.resetPagination();
            this.collection.setOption('endpoint', function(method, collection, options, callbacks) {
                var url = app.api.buildURL(model.module, null, {id: model.get('id'), link: 'activities'}, options.params);

                return app.api.call('read', url, null, callbacks);
            });
            this.collection.fetch({
                /*
                 * Render activity stream
                 */
                success: _.bind(this.renderActivities, this)
            });
        }
    },

    /**
     * Render activity stream once the preview pane opens. Hide it when there are no activities.
     * @param collection
     */
    renderActivities: function(collection) {
        var self = this;
        if (this.disposed) {
            return;
        }

        if (this._previewOpened) {
            if (collection.length === 0) {
                this.$el.hide();
            } else {
                this.$el.show();
                collection.each(function(activity) {
                    self.renderPost(activity, true);
                });
            }
        } else {
            //FIXME: MAR-2798 prevent the possibility of an infinite loop
            _.delay(function(){
                self.renderActivities(collection);
            }, 500);
        }
    },

    /**
     * No need to set collectionOptions.
     */
    setCollectionOptions: function() {},

    /**
     * No need to expose data transfer object since this activity stream is readonly.
     */
    exposeDataTransfer: function() {},

    /**
     * Don't load activity stream until 'preview:render' event has been fired.
     */
    loadData: function() {},

    /**
     * No need to bind events here because this activity stream is readonly.
     */
    bindDataChange: function() {
        this.collection.on('add', function(activity) {
            if (!this.disposed) {
                this.renderPost(activity, true);
            }
        }, this);
    }
}) },
"dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletLayout
 * @alias SUGAR.App.view.layouts.BaseDashletLayout
 * @extends View.Layout
 */
({
	// Dashlet Layout (base) 

    /**
     * A reference to the main dashboard
     */
    dashboard: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        this._super('initialize', [options]);

        if (!(this.meta.preview || this.meta.empty)) {
            // grab a reference to the dashboard to pass down
            this.dashboard = this.findLayout('dashboard', options.layout);
        }

        //set current model draggable
        this.on("render", function() {
            this.model.trigger("applyDragAndDrop");
        }, this);
        this.context.on("dashboard:collapse:fire", this.collapse, this);
    },

    /**
     * Search recursively through the <pre><code>layout.layout</code></pre> list
     * until the <pre><code>layout.name == name</code></pre>
     *
     * @param {String} name the name of the layout you're looking for
     * @param {Object} layout the layout object to look through
     * @return {Mixed}
     */
    findLayout: function(name, layout) {
        return (layout.name == name || layout.type == name) ? layout : this.findLayout(name, layout.layout);
    },

    /**
     * @inheritdoc
     * Append dashlet toolbar view based on custom_toolbar definition
     *
     * @param {Array} list of component metadata
     */
    _addComponentsFromDef: function(components) {
        if (!(this.meta.preview || this.meta.empty)) {
            var dashletDef = _.first(components),
                dashletMeta,
                dashletModule,
                toolbar = {},
                pattern = /^(LBL|TPL|NTC|MSG)_(_|[a-zA-Z0-9])*$/,
                label = this.meta.label;
            //try to get the dashlet dashlet metadata
            if(dashletDef.view) {
                toolbar = dashletDef.view['custom_toolbar'] || {};
                dashletMeta = app.metadata.getView(dashletDef.view.module, dashletDef.view.name || dashletDef.view.type);
                dashletModule = dashletDef.view.module ? dashletDef.view.module : null;
            } else if (dashletDef.layout) {
                toolbar = dashletDef.view['custom_toolbar'] || {};
                dashletMeta = app.metadata.getLayout(dashletDef.layout.module, dashletDef.layout.name || dashletDef.layout.type);
                dashletModule = dashletDef.layout.module ? dashletDef.layout.module : null;
            }
            if (!dashletModule && dashletDef.context && dashletDef.context.module) {
                dashletModule = dashletDef.context.module;
            }
            if (pattern.test(this.meta.label)) {
                label = app.lang.get(label, dashletModule, dashletDef.view || dashletDef.layout);
            }
            //determine whether it contains custom_toolbar or not
            if (_.isEmpty(toolbar) && dashletMeta && dashletMeta['custom_toolbar']) {
                toolbar = dashletMeta['custom_toolbar'];
            }
            if(toolbar !== "no") {
                components.push({
                    view: {
                        type: 'dashlet-toolbar',
                        label: label,
                        toolbar: toolbar
                    },
                    context: {
                        module: 'Home',
                        skipFetch: true
                    }
                });
            } else {
                this.hasToolbar = false;
            }
        }
        if (this.meta.empty) {
            this.$el.html(app.template.empty(this));
        } else {
            this.$el.html(this.template(this));
        }

        var context = this.context.parent || this.context;
        this._super('_addComponentsFromDef', [components, context, context.get("module")]);
    },

    /**
     * @inheritdoc
     * Set default skipFetch as false.
     * Able to get the custom title label from the dashlet component.
     */
    createComponentFromDef: function(def, context, module) {
        //pass the parent context only to the main dashlet component
        if (def.view && !_.isUndefined(def.view.toolbar)) {
            var dashlet = _.first(this._components);
            if (_.isFunction(dashlet.getLabel)) {
                def.view.label = dashlet.getLabel();
            }
            context = dashlet.context;
        }
        //set default skipFetch as false
        var skipFetch = def.view ? def.view.skipFetch : def.layout.skipFetch;
        if (def.context && skipFetch !== false) {
            def.context.skipFetch = true;
        }
        return this._super('createComponentFromDef', [def, context, module]);
    },

    /**
     * Set current dashlet as invisible
     */
    setInvisible: function() {
        if (this._invisible === true) {
            return;
        }
        var comp = _.first(this._components);
        this.model.on("setMode", this.setMode, this);
        this._invisible = true;
        this.$el.addClass('hide');
        this.listenTo(comp, "render", this.unsetInvisible, this);
    },

    /**
     * Set current dashlet back as visible
     */
    unsetInvisible: function() {
        if (this._invisible !== true) {
            return;
        }
        var comp = _.first(this._components);
        comp.trigger("show");
        this._invisible = false;
        this.model.off("setMode", null, this);
        this.$el.removeClass('hide');
        this.stopListening(comp, "render");
    },

    /**
     * @inheritdoc
     * Place the each component to the right location
     *
     * @param comp
     * @param def
     */
    _placeComponent: function(comp, def) {
        if(this.meta.empty) {
            //add-a-dashlet component
            this.$el.append(comp.el);
        } else if(this.meta.preview) {
            //preview mode
            this.$el.addClass('preview-data');
            this.$('[data-dashlet=dashlet]').append(comp.el);
        } else if (_.isUndefined(def)) {
            this.$('[data-dashlet=dashlet]').after(comp.el);
        } else if(def.view && !_.isUndefined(def.view.toolbar)) {
            //toolbar view
            this.$('[data-dashlet=toolbar]').append(comp.el);
        } else {
            //main dashlet component
            this.$('[data-dashlet=dashlet]').append(comp.el);
        }
    },

    /**
     * Convert the dashlet setting metadata into the dashboard model data
     *
     * @param {Object} setting metadata
     * @return {Object} component metadata
     */
    setDashletMetadata: function(meta) {
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);

        _.each(meta, function(value, key){
            this[key] = value;
        }, component);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                silent: true,
                //Show alerts for this request
                showAlerts: true,
                success: _.bind(function() {
                    this.model.unset('updated');
                }, this)
            });
        }
        return component;
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        return component;
    },

    /**
     * Append the dashlet component from the setting metadata
     *
     * @param {Object} setting metadata
     */
    addDashlet: function(meta) {
        var component = this.setDashletMetadata(meta),
            def = component.view || component.layout || component;

        this.meta.empty = false;
        this.meta.label = def.label || def.name || "";
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];

        if(component.context) {
            _.extend(component.context, {
                forceNew: true
            })
        }
        this.meta.components = [component];
        this.initComponents(this.meta.components);
        this.model.set('updated', true);
        this.loadData();
        this.render();
    },

    /**
     * Remove the current attached dashlet component
     */
    removeDashlet: function() {
        var cellLayout = this.layout,
            rowLayout = cellLayout.layout;
        if (this.model.mode === 'view' && cellLayout._components.length === 1) {
            var dashletRow = this.closestComponent('dashlet-row');
            // this.layout needs to have method to return all the components
            dashletRow.removeRow(this.layout.index.split('').pop());
            dashletRow.model.save(null, {showAlerts: true});
            return;
        }
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);
        _.each(component, function(value, key){
            if(key!=='width') {
                delete component[key];
            }
        }, this);
        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        } else {
            this.model.set('updated', true);
        }
        this.meta.empty = true;
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];
        this.initComponents([
            {
                view: 'dashlet-cell-empty',
                context: {
                    module: 'Home',
                    skipFetch: true
                }
            }
        ]);
        this.render();
    },

    /**
     * Calls the layout's addRow function to add another row
     *
     * @param {Number} columns the number of columns to add
     */
    addRow: function(columns) {
        this.layout.addRow(columns);
    },

    /**
     * Refresh the dashlet
     *
     * Call dashlet's loadData to refetch the remote data
     *
     * @param {Object} options
     */
    reloadDashlet: function(options) {
        var component = _.first(this._components),
            context = component.context;
        context.resetLoadFlag();
        component.loadData(options);
    },

    /**
     * Edit current dashlet's settings
     *
     * Convert the current componenet's metadata into setting metadata
     * and then it loads its dashlet's configuration view
     *
     * @param {Window.Event}
     */
    editDashlet: function(evt) {
        var self = this,
            meta = app.utils.deepCopy(_.first(this.meta.components)),
            type = meta.layout ? "layout" : "view";
        if(_.isString(meta[type])) {
            meta[type] = {name:meta[type], config:true};
        } else {
            meta[type].config = true;
        }
        meta[type] = _.extend({}, meta[type], meta.context);

        if(meta.context) {
            meta.context.skipFetch = true;
            delete meta.context.link;
        }

        app.drawer.open({
            layout: {
                name: 'dashletconfiguration',
                components: [meta]
            },
            context: {
                model: new app.Bean(),
                forceNew: true
            }
        }, function(model) {
            if(!model) return;

            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module") || (meta.context ? meta.context.module : null),
                        link: model.get("link") || null
                    }
                };
            delete conf.config;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.addDashlet(dash);
        });
    },

    /**
     * Fold/Unfold the dashlet
     *
     * @param {Boolean} true if it needs to be collapsed
     */
    collapse: function(collapsed) {
        if (this.hasToolbar === false) {
            return;
        }
        this.$(".dashlet-toggle > i").toggleClass("fa-chevron-down", collapsed);
        this.$(".dashlet-toggle > i").toggleClass("fa-chevron-up", !collapsed);
        this.$(".thumbnail").toggleClass("collapsed", collapsed);
        this.$("[data-dashlet=dashlet]").toggleClass("hide", collapsed);
    },

    /**
     * Displays current invisible dashlet when current mode is on edit/drag
     *
     * @param {String} (edit|drag|view)
     */
    setMode: function(type) {
        if (!this._invisible) {
            return;
        }
        if (type === 'edit' || type === 'drag') {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * Sets the Dashlet layout Title
     * @param title
     */
    setTitle: function(title) {
        // make sure we've got an $el before using it
        if (this.$el) {
            var $titleEl = this.$('h4.dashlet-title');
            if($titleEl.length) {
                $titleEl.text(title);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.off("setMode", null, this);
        this.off("render");
        this.context.off("dashboard:collapse:fire", null, this);
        this._super('_dispose');
    }
}) },
"multi-selection-list-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.MultiSelectionListLinkLayout
 * @alias SUGAR.App.view.layouts.BaseMultiSelectionListLinkLayout
 * @extends View.Layouts.Base.MultiSelectionListLayout
 */
({
	// Multi-selection-list-link Layout (base) 

    extendsFrom: 'MultiSelectionListLayout'
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.ListLayout
 * @alias SUGAR.App.view.layouts.BaseListLayout
 * @extends View.Layout
 */
({
	// List Layout (base) 

    /**
     * Places a view's element on the page. This shoudl be overriden by any custom layout types.
     * @param {View.View} comp
     * @protected
     * @method
     */
    _placeComponent: function(comp, def) {
        var size = def.size || 12;

        // Helper to create boiler plate layout containers
        function createLayoutContainers(self) {
            // Only creates the containers once
            if (!self.$el.children()[0]) {
                comp.$el.addClass('list');
            }
        }

        createLayoutContainers(this);

        // All components of this layout will be placed within the
        // innermost container div.
        this.$el.append(comp.el);
    }

}) },
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsLayout
 * @extends View.Layout
 */
({
	// Subpanels Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanels-layout',

    /**
     * Default settings used for the sortable plugin.
     *
     * - `{Boolean} sortable` Whether or not this layout should be sortable.
     * - `{Boolean} showAlerts` Whether or not to show alerts when the subpanel
     *   ordering is changed.
     *
     * These defaults can be overridden through the metadata (shown below) or by
     * customizing this layout.
     *
     *     // ...
     *     'settings' => array(
     *         'sortable' => false,
     *         //...
     *     ),
     *     //...
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        showAlerts: true,
        sortable: true
    },

    /**
     * Settings after applying metadata settings on top of
     * {@link #_defaultSettings}.
     *
     * @property {Object}
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSettings();
        this._bindEvents();
    },

    /**
     * Merges settings defined in the metadata with {@link #_defaultSettings}.
     *
     * @protected
     * @chainable
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        if (this.layout) {
            this.listenTo(this.layout, 'subpanel:change', this.showSubpanel);
        }

        this.on('subpanels:reordered', this._saveNewOrder, this);
    },

    /**
     * Initializes the jQuery Sortable plugin to this layout, only if the
     * `sortable` property on the {@link #_settings} object is set to `true`.
     *
     * By default, the `handle` to drag subpanels is specified as the
     * `panel-top` component. The `helper` attribute is set to `clone` because
     * Firefox dispatches a click event when the dragged element is removed and
     * inserted by jQuery, see:
     * [bug ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=787944).
     *
     * @protected
     * @chainable
     */
    _initSortablePlugin: function() {
        if (this._settings && this._settings.sortable === true) {
            this.$el.sortable({
                axis: 'y',
                containment: this.$el,
                handle: '[data-sortable-subpanel=true]',
                helper: 'clone',
                tolerance: 'pointer',
                scrollSensitivity: 50,
                scrollSpeed: 15,
                update: _.bind(this.handleSort, this)
            });
        }
        return this;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._initSortablePlugin();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.$el.data('sortable'))) {
            this.$el.sortable('destroy');
        }
        this._super('_dispose');
    },

    /**
     * The subpanels list is saved into local storage.
     *
     * Displays a `success` alert message if the `showAlerts` setting is `true`.
     *
     * This method is called by the `subpanel:reordered` event, see
     * {@link #initialize}.
     *
     * @protected
     * @param {Object} component The `subpanel` component
     * @param {String[]} order The new order of `subpanel` components.
     */
    _saveNewOrder: function(component, order) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module);
        app.user.lastState.set(key, order);

        if (this._settings.showAlerts === true) {
            app.alert.show('subpanel_order_updated', {
                level: 'success',
                messages: app.lang.get('LBL_SAVED_LAYOUT', this.module),
                autoClose: true
            });
        }
    },

    /**
     * Handler for subpanel re-order.
     *
     * @param {Event} evt The jQuery update event.
     * @param {Object} ui The jQuery UI object.
     */
    handleSort: function(evt, ui) {
        var newOrder = this.$el.sortable('toArray', {
                attribute: 'data-subpanel-link'
            });

        this.trigger('subpanels:reordered', this, newOrder);
    },

    /**
     * Removes subpanels that user doesn't have access to. SP-924: Error message when opening subpanel
     * user doesn't have access to.
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneNoAccessComponents: function(components) {
        var prunedComponents = [];
        var layoutFromContext = this.context ? this.context.get('layout') || this.context.get('layoutName') : null;
        this.layoutType = layoutFromContext ? layoutFromContext : app.controller.context.get('layout');
        this.aclToCheck = this.aclToCheck || 'list';
        _.each(components, function(component) {
            var relatedModule,
                link = component.context ? component.context.link : null;
            if (link) {
                relatedModule = app.data.getRelatedModule(this.module, link);
                if (!relatedModule || relatedModule && app.acl.hasAccess(this.aclToCheck, relatedModule)) {
                    prunedComponents.push(component);
                }
            }
        }, this);
        return prunedComponents;
    },

    /**
     *
     * Removes hidden subpanels from list of components before adding them to layout
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneHiddenComponents: function(components) {
        var hiddenSubpanels = app.metadata.getHiddenSubpanels();
        var visibleSubpanels = _.filter(components, function(component){
            var relatedModule = app.data.getRelatedModule(this.module, component.context.link);
            return _.isEmpty(_.find(hiddenSubpanels, function(hiddenPanel){
                if (relatedModule !== false) {
                    //hidden subpanels seem to come back in lower case, so we do a case insenstiive compare of module names
                    return hiddenPanel.toLowerCase() === relatedModule.toLowerCase();
                }
                return true;
            }));
        }, this);
        return visibleSubpanels;
    },

    /**
     * @inheritdoc
     *
     * We override this method which is called early in the Sidecar framework to
     * prune any hidden or acl prohibited components.
     */
    _addComponentsFromDef: function(components, context, module) {
        // First checks for hidden components, then checks for ACLs on those components.
        var allowedComponents = this._pruneHiddenComponents(components);
        allowedComponents = this._pruneNoAccessComponents(allowedComponents);
        allowedComponents = this.reorderSubpanels(allowedComponents);

        // Call original Layout with pruned components
        this._super('_addComponentsFromDef', [allowedComponents, context, module]);
        this._markComponentsAsSubpanels();
        this._disableSubpanelToggleButton(allowedComponents);
    },

    /**
     * Orders the `subpanel` components and strips out any components from the
     * specified `order` that are no longer available.
     *
     * @param {Array} components The list of `subpanel` component objects.
     * @return {Array} The ordered list of `subpanel` component objects.
     */
    reorderSubpanels: function(components) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module),
            order = app.user.lastState.get(key);

        if (_.isEmpty(order)) {
            return components;
        }

        var componentOrder = _.pluck(_.pluck(components, 'context'), 'link');
        order = _.intersection(order, componentOrder);

        _.each(order, function(link, index) {
            var comp = _.find(components, function(comp) {
                return comp.context.link === link;
            });
            comp.position = ++index;
        });

        components = _.sortBy(components, function(comp) {
            return comp.position;
        });

        return components;
    },

    /**
     * If no subpanels are left after pruning hidden and ACL-prevented
     * subpanels, we disable the filter panel's subpanel toggle button.
     *
     * @param {Array} allowedComponents The pruned subpanels.
     */
    _disableSubpanelToggleButton: function(allowedComponents) {
        if (!this.layout || !_.isEmpty(allowedComponents)) {
            return;
        }

        this.layout.trigger('filterpanel:change', 'activitystream', true, true);
        this.layout.trigger('filterpanel:toggle:button', 'subpanels', false);
    },

    /**
     * Show the subpanel for the given linkName and hide all others
     * @param {String} linkName name of subpanel link
     */
    showSubpanel: function(linkName) {
        if (!app.config.collapseSubpanels) {
            // this.layout is the filter layout which subpanels is child of; we
            // use it here as it has a last_state key in its meta
            // FIXME: TY-499 will address removing the dependancy on this.layout
            var cacheKey = app.user.lastState.key('subpanels-last', this.layout);
            if (linkName) {
                app.user.lastState.set(cacheKey, linkName);
            } else {
                // Fixes SP-836; esentially, we need to clear subpanel-last-<module>
                // anytime 'All' selected.
                app.user.lastState.remove(cacheKey);
            }
        }

        _.each(this._components, function(component) {
            var link = component.context.get('link');
            if (!linkName) {
                component.show();
            } else if (linkName === link) {
                component.show();
                component.context.set('collapsed', false);
            } else {
                component.hide();
            }
        });
    },

    /**
     * Mark component context as being subpanels
     */
    _markComponentsAsSubpanels: function() {
        _.each(this._components, function(component) {
            component.context.set("isSubpanel", true);
        });
    },

    /**
     * Load data for all subpanels. Need to override the layout's loadData() because
     * it calls loadData() for the context, which we do not want to do here.
     * @param options
     */
    loadData: function(options) {
        var self = this,
            load = function(){
                _.each(this._components, function(component) {
                    component.loadData(options);
                });
            };
        if (self.context.parent && !self.context.parent.isDataFetched()) {
            var parent = this.context.parent.get("model");
            parent.once("sync", load);
        }
        else {
            load();
        }
    }
}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Audit Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['AuditHeaderPanel:Close']
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.BwcLayout
 * @alias SUGAR.App.view.layouts.BaseBwcLayout
 * @extends View.Layout
 */
({
	// Bwc Layout (base) 

    className: 'bwc layout',

    loadData: function() {
        // don't load record list for bwc modules
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Merge-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Headerpane:Save',
        'Sidebar:Toggle'
    ]
}) },
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Records Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'List:Headerpane:Create',
        'List:Select:Down',
        'List:Select:Up',
        'List:Scroll:Left',
        'List:Scroll:Right',
        'List:Select:Open',
        'List:Inline:Edit',
        'List:Delete',
        'List:Inline:Cancel',
        'List:Inline:Save',
        'List:Favorite',
        'List:Follow',
        'List:Preview',
        'List:Select',
        'SelectAll:Checkbox',
        'SelectAll:Dropdown',
        'Filter:Search',
        'Filter:Create',
        'Filter:Edit',
        'Filter:Show'
    ]
}) },
"resolve-conflicts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Resolve-conflicts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"history-default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the extension of {@link View.Layouts.Base.DefaultLayout} that is used
 * for the history summary drawer.
 *
 * The aim of this extension is to make the right pane collapsed by default, and
 * to remove stickiness so the pane is always collapsed when you initialize the
 * layout.
 *
 * @class View.Layouts.Base.HistoryDefaultLayout
 * @alias SUGAR.App.view.layouts.BaseHistoryDefaultLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// History-default Layout (base) 

    extendsFrom: 'DefaultLayout',

    /**
     * Extend to return `false` the first time this method is called, so the
     * pane is always collapsed on first load.
     *
     * @inheritdoc
     */
    isSidePaneVisible: function() {
        if (this._isSidePaneVisibleCalledOnce !== true) {
            this._isSidePaneVisibleCalledOnce = true;
            app.user.lastState.set(this._hideLastStateKey, 1);
            return false;
        }
        return this._super('isSidePaneVisible');
    },

    /**
     * Removes the cache entry because it is unnecessary to keep it since we
     * reset it on first load.
     *
     * @inheritdoc
     */
    _dispose: function() {
        app.user.lastState.remove(this._hideLastStateKey);

        this._super('_dispose');
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Record:Edit',
        'Record:Delete',
        'Record:Save',
        'Record:Cancel',
        'Record:Previous',
        'Record:Next',
        'Record:Favorite',
        'Record:Follow',
        'Record:Copy',
        'Record:Action:More'
    ]
}) },
"footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FooterLayout
 * @alias SUGAR.App.view.layouts.BaseFooterLayout
 * @extends View.Layout
 */
({
	// Footer Layout (base) 

    events: {
        'click [data-action=home]': 'home'
    },
    /**
     * Places all components within this layout inside btn-toolbar div
     * @param component
     * @private
     */
    _placeComponent: function(component) {
        this.$el.find('.btn-toolbar').append(component.$el);
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.logoUrl = app.metadata.getLogoUrl();
        //For a layout we need to
        this.$el.html(this.template(this));
        _.each(this._components, function(component) {
            this._placeComponent(component);
        }, this);
        app.view.Layout.prototype._render.call(this);
    },

    home: function() {
        app.router.navigate('#Home', {
            trigger: true
        });
    }
}) },
"shortcuts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Shortcuts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Shortcuts:Help:Close'],

    events: {
        'click [name=cancel_button]': 'close'
    },

    shortcutsHelpTableTemplate: '',

    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);

        // get templates
        this.shortcutsHelpTableTemplate = app.template.getLayout(this.name + '.shortcuts-help-table');

        // populate help tables
        this.$('[data-display=global]').append(this.buildGlobalHelpTable().children());
        this.$('[data-display=contextual]').append(this.buildContextualHelpTable().children());

        app.shortcuts.register('Shortcuts:Help:Close', ['esc', 'ctrl+alt+l'], function() {
            this.close();
        }, this);
    },

    /**
     * Close drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * Build the help table for global shortcuts.
     * @return {jQuery}
     */
    buildGlobalHelpTable: function() {
        var $html = $('<div></div>'),
            globalShortcuts = app.shortcuts.getRegisteredGlobalShortcuts(),
            help = this.prepareShorcutsHelpDataForDisplay(globalShortcuts);

        $html.append(this.shortcutsHelpTableTemplate(help));

        return $html;
    },

    /**
     * Build the help table for contextual shortcuts.
     * @return {jQuery}
     */
    buildContextualHelpTable: function() {
        var $html = $('<div></div>'),
            lastShortcutSession = app.shortcuts.getLastSavedSession(),
            contextualShortcuts,
            help;

        if (lastShortcutSession) {
            contextualShortcuts = lastShortcutSession.getRegisteredShortcuts();
            if (contextualShortcuts) {
                help = this.prepareShorcutsHelpDataForDisplay(contextualShortcuts);
                $html.append(this.shortcutsHelpTableTemplate(help));
            }
        }

        return $html;
    },

    /**
     * Take the available shortcuts data and transform it for displaying the data
     * in a help table.
     * @param {Array} shortcuts
     * @return {Array}
     */
    prepareShorcutsHelpDataForDisplay: function(shortcuts) {
        // FIXME SC-5196: deprecate me, I'm misspelled
        var help = [];

        _.each(shortcuts, function(shortcut) {
            help.push({
                keys: this.getKeyString(shortcut.keys),
                help: this.getHelpString(shortcut.id)
            });
        }, this);

        return help;
    },

    /**
     * Build text for keys needed to perform shortcut action.
     * @param {Array} keys
     * @return {string}
     */
    getKeyString: function(keys) {
        return keys.join(', ');
    },

    /**
     * Build the help text for what the shortcut does.
     * @param {String} shortcutId
     * @return {string}
     */
    getHelpString: function(shortcutId) {
        if (this.meta.help && this.meta.help[shortcutId]) {
            return app.lang.get(this.meta.help[shortcutId]);
        } else {
            return '';
        }
    },

    loadData: function(options) {}
}) },
"sweetspot": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotLayout
 * @extends View.Layout
 */
({
	// Sweetspot Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = app.data.createMixedBeanCollection();

        app.shortcuts.register(app.shortcuts.GLOBAL + 'Sweetspot', 'mod+shift+space', this.toggle, this, true);
        app.events.on('app:logout app:login', this.hide, this);
        app.events.on('app:sync:complete sweetspot:reset', this._setTheme, this);

        this.on('sweetspot:config', this.openConfigPanel, this);
        this.on('sweetspot:calc:resultsHeight', this.calculateResultsHeight, this);

        /**
         * Flag to indicate the visible state of the sweet spot.
         *
         * @type {boolean}
         * @private
         */
        this._isVisible = false;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isReady()) {
            return;
        }
        this._super('_render');
        this._setTheme();
    },

    /**
     * Sets the theme for sweetspot.
     *
     * @protected
     */
    _setTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.$el.removeAttr('data-theme');
        if (theme) {
            this.$el.attr('data-theme', theme);
        }
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.createShortcuts();
        this.bindOutsideClick();
        this.bindResize();
    },

    /**
     * Unbinds events that this layout uses.
     *
     * @protected
     */
    _unbindEvents: function() {
        this.removeShortcuts();
        this.unbindOutsideClick();
        this.unbindResize();
    },

    /**
     * Binds the outside `click` event.
     */
    bindOutsideClick: function() {
        $('body').bind('click.' + this.cid, _.bind(function(e) {
            if ($(e.target).closest('#sweetspot').length === 0) {
                this.hide();
            }
        }, this));
    },

    /**
     * Unbinds the outside `click` event.
     */
    unbindOutsideClick: function() {
        $('body').unbind('click.' + this.cid);
    },

    /**
     * Create new shortcut session and add shortcut to hide SweetSpot
     */
    createShortcuts: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession(['SweetSpot:Toggle:Off'], this);
        app.shortcuts.register('SweetSpot:Toggle:Off', 'esc', this.hide, this, true);
    },

    /**
     * Remove shortcuts for SweetSpot and restore previous session.
     */
    removeShortcuts: function() {
        app.shortcuts.restoreSession();
    },

    /**
     * Binds the `resize` event.
     */
    bindResize: function() {
        $(window).on('resize.sweetspot-' + this.cid, _.bind(this.calculateResultsHeight, this));
    },

    /**
     * Unbinds the `resize` event.
     */
    unbindResize: function() {
        $(window).off('resize.sweetspot-' + this.cid);
    },

    /**
     * Checks if this layout is ready to be {@link #show displayed}, or
     * {@link #_render rendered}.
     *
     * FIXME SC-2761: Checking `isVisible` on the header component is necessary
     * for disabling this layout on full-page modal views like the first login
     * wizard. However, hiding additionalComponents should be event driven,
     * see https://github.com/sugarcrm/Mango/pull/18722#discussion_r11782561.
     *
     * @return {boolean} `true` if this layout is OK to render/show, `false`
     *   otherwise.
     */
    isReady: function() {
        return app.api.isAuthenticated() && app.isSynced && app.additionalComponents.header.isVisible();
    },

    /**
     * @override
     */
    isVisible: function() {
        return this._isVisible;
    },

    /**
     * @override
     */
    show: function() {
        if (this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('show')) {
            return false;
        }
        if (!this.isReady()) {
            return;
        }

        this._isVisible = true;
        this.$('input').val('');
        this.$el.fadeToggle(50, 'linear', _.bind(this.focusInput, this));
        this.trigger('show');
        this.calculateResultsHeight();
        this._bindEvents();
    },

    /**
     * @override
     */
    hide: function() {
        if (!this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('hide')) {
            return false;
        }

        this._isVisible = false;
        this._unbindEvents();
        this.$el.fadeToggle(50, 'linear');
        this.$el.removeClass('has-results');
        this.trigger('hide');
    },

    /**
     * Toggles the Sweet Spot.
     */
    toggle: function() {
        if (this.isVisible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Focuses on the Sweet Spot input.
     */
    focusInput: function() {
        this.$('input').focus();
    },

    /**
     * Opens a drawer with the {@link View.Layouts.Base.SweetspotConfigLayout}
     * to configure the Sweet Spot.
     */
    openConfigPanel: function() {
        // TODO: This is bad and there should be an option in drawer.js to
        // prevent opening an already-open drawer of the same type.
        var activeDrawerLayout = app.drawer.getActive();
        if (activeDrawerLayout && activeDrawerLayout.type === 'sweetspot-config') {
            return;
        }

        app.drawer.open({
            layout: 'sweetspot-config',
            context: {
                skipFetch: true,
                forceNew: true
            }
        });
    },

    /**
     * Trigger a system action.
     *
     * @param {string} method Name of the method in {@link #_systemActions}.
     */
    triggerSystemAction: function(method) {
        if (!_.isFunction(this._systemActions[method])) {
            return;
        }
        this._systemActions[method].call(this);
    },

    /**
     * List of system action callbacks.
     *
     * Use {@link #triggerSystemAction} to trigger them.
     */
    _systemActions: {
        openConfig: function() {
            this.openConfigPanel();
        }
    },

    /**
     * Calculates the results dropdown height based on the window height and
     * triggers 'sweetspot:results:adjustMaxHeight' passing the value.
     */
    calculateResultsHeight: function() {
        var distanceToFooter = 80;
        var resultsMaxHeight = $(window).height() - this.$el.offset().top - $('footer').height() - distanceToFooter;
        if (resultsMaxHeight > 460) {
            resultsMaxHeight = 460;
        }

        this.trigger('sweetspot:results:adjustMaxHeight', resultsMaxHeight);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._unbindEvents();
        this._super('_dispose');
    }
}) },
"toggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that provides basic functionality for toggling visibility of
 * sub-layouts & views.
 *
 * @class View.Layouts.Base.ToggleLayout
 * @alias SUGAR.App.view.layouts.BaseToggleLayout
 * @extends View.Layout
 */
({
	// Toggle Layout (base) 

    /**
     * Components to be toggled
     * Key is the name of the layout or view
     * Value is an object with icon/label if toggle buttons are to be displayed, empty object otherwise
     */
    availableToggles: {},

    /**
     * Default component to show when this layout is initialized
     */
    defaultToggle: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.toggleComponents = [];
        this.componentsList = {};
        this.availableToggles = this.options.meta.available_toggles || this.availableToggles;
        this.defaultToggle = this.options.meta.default_toggle || this.defaultToggle;

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        _.each(this.componentsList, function(comp) {
            if (_.isFunction(comp.initComponents)) {
                comp.initComponents();
            }
        });

        if (this.defaultToggle) {
            this.showComponent(this.defaultToggle);
        }

        this.on('toggle:showcomponent', this.showComponent, this);
    },

    /**
     * Defer rendering/appending of toggle-able components and render/append the rest
     * @param component
     */
    _placeComponent: function(component) {
        if (!_.isUndefined(this.availableToggles[component.name])) {
            this.toggleComponents.push(component);
            this.componentsList[component.name] = component;
            this._components.splice(this._components.indexOf(component), 1);
        } else {
            component.render();
            this.getContainer(component).append(component.el);
        }
    },

    /**
     * Container where the content should be placed (topmost layout element by default)
     * Override for a different container
     * @param component useful if the container is dependent on the component - not used in base implementation
     */
    getContainer: function(component) {
        return this.$el;
    },

    /**
     * Show the given component and hide the other toggle-able components.
     * Render the named component if it is in our list of components that have
     * not yet been rendered and append it to the appropriate container.
     *
     * The firing of the 'append' event is done after showing the component to
     * ensure that its DOM surroundings (ie. element width) are completely set
     * up - allowing anything listening to adjust accordingly.
     *
     * @param {string} name Name of the component to show
     */
    showComponent: function(name) {
        var oldToggle = this.currentToggle;

        _.each(this.toggleComponents, function(component) {
            if (component.name === name) {
                component.show();
            } else {
                component.hide();
            }
        }, this);

        if (this.componentsList[name]) {
            this.componentsList[name].render();
            this._components.push(this.componentsList[name]);
            this.getContainer(this.componentsList[name]).append(this.componentsList[name].el);
            // notify the component it's been appended to the container.
            // it may want to adapt to its new neighborhood
            this.componentsList[name].trigger("append");
            this.componentsList[name] = null;
        }

        this.currentToggle = name;
        this.trigger('toggle:change', name, oldToggle);
    },

    /**
     * Clean up any components that were never rendered and added to _components
     * @private
     */
    _dispose: function() {
        _.each(this.componentsList, function(component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        this.toggleComponents = null;
        app.view.Layout.prototype._dispose.call(this);
    }

}) },
"asdashlet-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ASDashletFilterLayout
 * @alias SUGAR.App.view.layouts.BaseASDashletFilterLayout
 * @extends View.Layout
 */
({
	// Asdashlet-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Set up a listener for the configuration save
        this.listenTo(this.layout, 'asdashlet:config:save', this.saveFilterToDashlet);
    },

    /**
     * Set the current filter ID and def to be seen on the dashlet
     *
     * @private
     */
    saveFilterToDashlet: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        this.model.set('currentFilterId', filterPanelLayout.context.get('currentFilterId'));
    }
}) },
"subpanel-with-massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelWithMassupdateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelWithMassupdateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-with-massupdate Layout (base) 

    extendsFrom:"SubpanelLayout",

    /**
     * Overriding to just check the items in a subpanel-with-massupdate
     * @inheritdoc
     * @override
     */
    _stopComponentToggle: function(component) {
        // subpanel header top should always render
        return component.name === "panel-top" || component.name === 'massupdate'
        || (!_.isUndefined(component.$el)
        && component.$el.hasClass('subpanel-header'));
    }
}) },
"subpanel-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelCreateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-create Layout (base) 

    extendsFrom: 'SubpanelLayout'
}) },
"wizard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout used for Wizards (like the first time login wizard).
 * Extend this layout and provide metadata for your wizard page components.
 *
 * Default implementation allows you to register a callback on the context
 * to get notified when Wizard is finished.
 *
 * For example,
 *
 *     context.set("callbacks", {
 *         complete: function(){...}
 *     }
 *
 * @class View.Layouts.Base.WizardLayout
 * @alias SUGAR.App.view.layouts.BaseWizardLayout
 * @extends View.Layout
 */
({
	// Wizard Layout (base) 


    /**
     * Current page index shown in Wizard
     * @private
     */
    _currentIndex: 0,

    /**
     * @param {Object} options
     * @override
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
    },

    /**
     * Place only initial wizard page at first
     * @param component Wizard page component
     * @override
     * @private
     */
    _placeComponent: function(component){
        if (component == this._components[this._currentIndex]) {
            this.$el.append(component.el);
        }
    },

    /**
     * Add only wizard pages that the current user needs to see.
     *
     * @param {View.Layout/View.View} component Component (view or layout) to add
     * @param {Object} def Metadata definition
     * @override
     */
    addComponent: function(component, def) {
        component = this._addButtonsForComponent(component);
        if (_.result(component, 'showPage')) {
            this._super('addComponent', [component, def]);
        }
    },
    /**
     * Helper to add appropriate buttons based on which page of wizard we're on.
     * Assumes that button 0 is previous, 1 is next, 2 is finish (Start Sugar).
     * Should only be called internal by `addComponent`.
     * @param {Object} component component from `addComponent`
     * @private
     */
    _addButtonsForComponent: function(component) {
        var buttons = [];
        component.meta = component.meta || {};
        //Adds appropriate button for component based on position in wizard
        _.each(this.meta.components, function(comp, i) {
            //found a match, add appropriate buttons based on wizard position
            if (comp.view === component.name) {
                if (i===0) {
                    //next button only
                    buttons.push(this.meta.buttons[1]);
                } else if (i === this.meta.components.length-1) {
                    // previous/start sugar buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[2]);
                } else {
                    // previous/next buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[1]);
                }
            }
        }, this);
        component.meta.buttons = buttons;
        return component;
    },

    /**
     * Renders a different page from the wizard
     * @param {number} newIndex New page index to select
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    setPage: function(newIndex){
        if (newIndex !== this._currentIndex &&
                (newIndex >= 0 && newIndex < this._components.length)) {
            //detach preserves jQuery event listeners, etc.
            this._components[this._currentIndex].$el.detach();
            this._currentIndex = newIndex;
            this.$el.append(this._components[this._currentIndex].el);

            // Wait for the wizard-page to tell us it's ready for interactions from keypresses.
            this.on('wizard-page:render:complete', function() {
                $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
            });

            this._components[this._currentIndex].render();
        }
        return this.getProgress();
    },

    /**
     * Only render the current component (WizardPageView) instead of each component in layout
     * @override
     * @private
     */
    _renderHtml: function() {
        if (Modernizr.touch) {
            app.$contentEl.addClass('content-overflow-visible');
        }
        if (this._components) {
            this._components[this._currentIndex].render();
        }
    },

    /**
     * Returns current progress through wizard
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    getProgress: function(){
        return {
            page: this._currentIndex + 1,
            lastPage: this._components.length
        };
    },

    /**
     * Moves to previous page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    previousPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex - 1);
    },

    /**
     * Moves to next page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    nextPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex + 1);
    },

    /**
     * Disposes of layout then calls finished callback if registered
     */
    finished: function(){
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        var callbacks = this.context.get("callbacks"); //save callbacks first
        this.dispose();
        if (callbacks && callbacks.complete) {
            callbacks.complete();
        }
    },

    /**
     * Process next on key 'Enter'
     * @param e
     */
    handleKeypress: function(e) {
        var wizardPage = this._components[this._currentIndex];
        // Check wizardPage no matter which key we're trapping (for future expansion).
        if (wizardPage) {
            // Check if we're catching enter.
            if (e.keyCode === 13) {
                document.activeElement.blur();
                if (wizardPage.isPageComplete()) {
                    // Once we're navigating, don't get any more keypresses.
                    $(window).off('keypress.' + this.cid);
                    wizardPage.next();
                }
            }
        }
    },

    /**
     * @private
     * @override
     */
    _dispose: function() {
        // We're done with this view, remove the keypress bind.
        $(window).off('keypress.' + this.cid);
        this._super('_dispose');
    }
}) },
"search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for the global search results page.
 *
 * @class View.Layouts.Base.SearchLayout
 * @alias SUGAR.App.view.layouts.BaseSearchLayout
 * @extends View.Layout
 */
({
	// Search Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.set('search', true);
        this.collection.query = this.context.get('searchTerm') || '';

        /**
         * Flag to indicate if the search has been filtered using facets or not.
         *
         * @property {boolean} `true` if the search has been filtered.
         */
        this.filteredSearch = false;
        /**
         * Object containing the selected facets in the current search.
         *
         * @property {Object} selectedFacets
         */
        this.selectedFacets = {};

        this.context.on('search:fire:new', function() {
            this.search();
        }, this);

        this.context.on('facet:apply', this.filter, this);

        this.collection.on('sync', function(collection) {
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            app.utils.GlobalSearch.formatRecords(collection, true);

            if (!_.isEmpty(collection.xmod_aggs)) {
                if (!this.filteredSearch) {
                    this._initializeSelectedFacets(collection.xmod_aggs);
                }

                this.context.set('selectedFacets', this.selectedFacets);
                this.context.set('facets', collection.xmod_aggs, {silent: true});
                this.context.trigger('facets:change', collection.xmod_aggs);
            }

        }, this);

        this.context.on('facets:reset', this.search, this);

        this.collection.setOption('params', {xmod_aggs: true});
    },

    /**
     * Builds the selected facets object to be sent to the server.
     *
     * @param {Object} facets The facets object that comes from the server.
     * @private
     */
    _initializeSelectedFacets: function(facets) {
        _.each(facets, function(facet, key) {
            if (key === 'modules') {
                this.selectedFacets[key] = [];
            } else {
                this.selectedFacets[key] = false;
            }
        }, this);
    },

    /**
     * Updates {@link #selectedFacets} with the facet change.
     *
     * @param {String} facetId The facet type.
     * @param {String} facetCriteriaId The id of the facet criteria.
     * @param {boolean} isSingleItem `true` if it's a single item facet.
     * @private
     */
    _updateSelectedFacets: function(facetId, facetCriteriaId, isSingleItem) {
        if (isSingleItem) {
            this.selectedFacets[facetId] = !this.selectedFacets[facetId];
            return;
        }
        var index;
        if (this.selectedFacets[facetId]) {
            index = this.selectedFacets[facetId].indexOf(facetCriteriaId);
        } else {
            this.selectedFacets[facetId] = [];
        }
        if (_.isUndefined(index) || index === -1) {
            this.selectedFacets[facetId].splice(0, 0, facetCriteriaId);
        } else {
            this.selectedFacets[facetId].splice(index, 1);
            if (this.selectedFacets[facetId].length === 0) {
                delete this.selectedFacets[facetId];
            }
        }
    },

    /**
     * Searches on a term and a module list.
     *
     * @param {boolean} reset `true` if we reset the filters.
     */
    search: function(reset) {
        // Prevents to trigger a new fetch if the user clicks on
        if (reset && !this.filteredSearch) {
            return;
        }
        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = false;

        var tagFilters = _.pluck(this.context.get('tags'), 'id');

        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * Refines the search applying a facet change.
     *
     * @param facetId The facet id.
     * @param facetCriteriaId The facet criteria id.
     * @param isSingleItem `true` if it's a single criteria facet.
     */
    filter: function(facetId, facetCriteriaId, isSingleItem) {
        this._updateSelectedFacets(facetId, facetCriteriaId, isSingleItem);

        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = true;
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    agg_filters: this.selectedFacets,
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * We override `loadData` to not send the `fields` param in the
     * request, so it's consistent with the request sent by
     * {@link View.Views.Base.QuicksearchBarView#fireSearchRequest fireSearchRequest}
     * method in the quicksearch bar.
     * Note that the `fields` param is not used anymore by the globalsearch API.
     *
     * @inheritdoc
     */
    loadData: function(options, setFields) {
        setFields = false;
        options = options || {};

        options.module_list = this.context.get('module_list') || [];

        // pull tag ids out of context and pass them into our options to filter
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        if (tagFilters) {
            options.apiOptions = options.apiOptions || {};
            options.apiOptions.data = {tag_filters: tagFilters};
            options.apiOptions.fetchWithPost = true;
            options.apiOptions.useNewApi = true;
        }

        this._super('loadData', [options, setFields]);
    }
}) },
"fluid": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.FluidLayout
 * @alias SUGAR.App.view.layouts.BaseFluidLayout
 * @extends View.Layout
 */
({
	// Fluid Layout (base) 

    /**
     * Places a view's element on the page. This should be overriden by any custom layout types.
     * In layout defs, the child component should have a `span` definition corresponding to the bootstrap scaffold.
     * @param {View.View} comp
     * @protected
     */
    _placeComponent: function(comp, def) {
        var compdef = def.layout || def.view,
            size = compdef.span || 4;

        if (!this.$el.children()[0]) {
            this.$el.addClass("container-fluid").append('<div class="row-fluid"></div>');
        }

        //Create a new td and add the layout to it
        $().add("<div></div>").addClass("span" + size).append(comp.el).appendTo(this.$el.find("div.row-fluid")[0]);
    }
}) },
"dupecheck-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DupecheckFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckFilterLayout
 * @extends View.Layouts.Base.Filter
 */
({
	// Dupecheck-filter Layout (base) 

    extendsFrom: 'FilterLayout',
    initialFilter: 'all_records',

    initialize: function(options) {
        this._super('initialize', [options]);
        this.name = 'filter';

        //initialize the last filter to show all duplicates before allowing user to change the filter
        this.setLastFilter(this.module, this.layoutType, this.initialFilter);
    },

    /**
     * @inheritdoc
     *
     * Override getting relevant context logic in order to filter on current
     * context.
     */
    getRelevantContextList: function() {
        return [this.context];
    },

    /**
     * @inheritdoc
     *
     * Override getting last filter in order to retrieve found duplicates for
     * initial set.
     */
    getLastFilter: function() {
        var lastFilter = this._super('getLastFilter', arguments);
        return (_.isUndefined(lastFilter)) ? this.initialFilter : lastFilter;
    }
}) },
"modal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ModalLayout
 * @alias SUGAR.App.view.layouts.BaseModalLayout
 * @extends View.Layout
 */
/**
 *
 * Create a modal popup that renders popup layout container
 * array(
 *      'layout' => 'modal',
 *      'showEvent' => [event name] //corresponding trigger name (a single string or array of strings)
 *      ),
 * @fires [event name] Create popup modal window and draws specified type of layout
 *      @params Parameters - [Object] {
 *              span - [int] size of modal[1-12]
 *              options - (Optional) 3rd party options goes here
 *
 *              components - [Array] list of either views or layouts (optional for single layout)
 *                           i.e. [ {view: ... } , {layout: ..., context: ... }, ...]
 *
 *                  context should be within the each component metadata.
 *                  context - [Object] configured context attributes
 *                        i.e. { module:..., link:..., modelId:... }
 *                        {
 *                            module - [String] Module name (i.e. Accounts, Contacts, etc) (optional),
 *                            link - [String] related module name (optional),
 *                            modelId - [String] model ID (optional)
 *                        }
 *      }
 *
 *      @params callback - [function(model)] - called by trigger "modal:callback" with correponded model
 *
 * @fires "modal:callback" Executes binded callback function with the updated model as parameter
 *      @params model - object Backbone model that relates to the current job
 *
 * @fires "modal:close" Close popup modal and release layout for popup
 *
 * How to Use:
 * in the view dashlet
 *     this.layout.trigger([event name], ...)
 * in the field dashlet
 *     this.view.layout.trigger([event name], ...)
 */
({
	// Modal Layout (base) 

    baseComponents: [
        { 'view' : 'modal-header' }
    ],
    initialize: function(options, skipModalJsCheck) {
        var self = this,
            showEvent = options.meta.showEvent;

        if (!skipModalJsCheck) {
            if(!_.isFunction(this.$el.modal)) {
                app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            }
        }

        this.metaComponents = options.meta.components;
        options.meta.components = this.baseComponents;
        if (options.meta.before){
            _.each(options.meta.before, function(callback, event){
                self.before(event, callback);
            });
        }
        app.view.Layout.prototype.initialize.call(this, options);
        options.meta.components = this.metaComponents; //revert components metadata back to original
        if (showEvent) {
            if(_.isArray(showEvent)) {
                //Bind the multiple event handler names
                _.each(showEvent, function(evt, index) {
                    self._bindShowEvent(evt);
                });
            } else {
                self._bindShowEvent(showEvent);
            }
        }
    },
    _bindShowEvent : function(event, delegate){
        var self = this;
        if (_.isObject(event))
        {
            delegate = event.delegate;
            event = event.event;
        }
        if (delegate){
            self.layout.events = self.layout.events || {};
            self.layout.events[event] = function(params, callback){self.show(params, callback)};
            self.layout.delegateEvents();
        } else {
            self.layout.on(event, function(params, callback){self.show(params, callback);}, self);
        }
    },
    getBodyComponents: function() {
        return _.rest(this._components, this._initComponentSize);
    },
    _placeComponent: function(comp, def) {
        if(this.$('.modal:first').length == 0) {
            this.$el.append(
                $('<div>', {'class' : 'modal hide'}).append(
                    this.$body
                )
            );
        }

        if(def.bodyComponent) {
            if(_.isUndefined(this.$body)) {
                this.$body = $('<div>', {'class' : 'modal-body'});
                this.$('.modal:first').append(this.$body);
            }
            this.$body.append(comp.el);
        } else {
            this.$('.modal:first').append(comp.el);
        }
    },

    /**
     *
     * @param params
     * @param callback
     * @private
     */
    _buildComponentsBeforeShow : function(params, callback) {
        var self = this,
            params = params || {},
            buttons = params.buttons || [],
            message = params.message || '',
            components = (params.components || this.metaComponents || []),
            title = (params.title || this.meta.title) + '';
        if(message && components.length == 0) {
            this.confirmMessage = message;
            components.push({view: 'modal-confirm'});
        }
        //stops for empty component elements
        if(components.length == 0) {
            app.logger.error("Unable to display modal dialog: no components or message");
            return false;
        }

        //set title and buttons for modal-header
        var header_view = self.getComponent('modal-header');
        if(header_view) {
            header_view.setTitle(title);
            header_view.setButton(buttons);
        }

        //if previous modal-body exists, remove it.
        if(self._initComponentSize) {
            for(var i = 0; i < self._components.length; i++) {
                self._components[self._components.length - 1].$el.remove();
                self.removeComponent(self._components.length - 1);
            }
        } else {
            self._initComponentSize = self._components.length;
        }

        this.initComponents(components);

        self.context.off("modal:callback");
        self.context.on("modal:callback", function(model) {
            callback(model);
            self.hide();
        },self);
        self.context.off("modal:close");
        self.context.on("modal:close", self.hide, self);


    },

    show: function(params, callback) {
        if (!this.triggerBefore("show") || this.disposed) return false;
        var self = this;
        if (params.before){
            _.each(params.before, function(callback, event){
                self.offBefore(event);
                self.before(event, callback);
            });
        }

        if (this._buildComponentsBeforeShow(params, callback) === false)
            return false;
        this.loadData();
        this.render();
        var width = params ? params.width : null,
            options = params ? params.options || {} : {},
            modal_container = this.$(".modal:first");

        //Clean out previous span css class
        modal_container.attr("style", "");
        if(_.isNumber(width)) {
            modal_container.width(width);
            modal_container.css('marginLeft', -(width/2) + 'px');
        }
        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }

        modal_container.modal(_.extend({keyboard:false, backdrop:'static'}, options.modal));
        modal_container.modal('show');

        this.trigger("show");
        return true;
    },
    hide: function(event) {
        if (!this.triggerBefore("hide")) return false;
        //restore back to the scroll position at the top
        var modal_container = this.$(".modal:first");
        modal_container.scrollTop(0);

        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }
        modal_container.modal('hide');
        this.trigger("hide");
        return true;
    }
}) },
"dashablelist-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashablelistFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDashablelistFilterLayout
 * @extends View.Layout
 */
({
	// Dashablelist-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        // We need to initialize the filterpanel with the filter and module
        // saved on the dashlet.
        var filterPanelLayout = this.getComponent('filterpanel');
        if (filterPanelLayout) {
            filterPanelLayout.before('render', this._reinitializeFilterPanel, this);
            this.listenTo(this.layout, 'dashlet:filter:reinitialize', filterPanelLayout.render);
        }
    },

    /**
     * This function sets the `currentModule` on the filterpanel layout, and
     * the `currentFilterId` on its context. It is invoked before
     * `filter:reinitialize` is triggered from `_render` on the filterpanel
     * layout.
     *
     * @private
     */
    _reinitializeFilterPanel: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        var moduleName = this.model.get('module'),
            id = this.model.get('filter_id');

        filterPanelLayout.currentModule = moduleName;
        this.context.set('currentFilterId', id);
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Create-nodupecheck Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel'
    ]
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerContentLayout
 * @extends View.Layout
 *
 * Triggered Events:
 *  config:howtoData:change - When a different accordion panel is clicked, a howtoData:change event will be triggered
 *      with the current how-to data for View.Views.Base.ConfigHowToView to listen for and update
 */
({
	// Config-drawer-content Layout (base) 

    events: {
        'click .accordion-toggle': 'onAccordionToggleClicked'
    },

    /**
     * The HTML ID of the Accordion divs
     */
    collapseDivId: 'config-accordion',

    /**
     * The currently-selected config panel
     */
    selectedPanel: '',

    /**
     * The current HowTo data Object
     */
    currentHowToData: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.currentHowToData = {};
        this._initHowTo();
    },

    /**
     * @inheritdoc
     */
    _render: function () {
        this._super('_render');

        //This is because backbone injects a wrapper element.
        this.$el.addClass('accordion');
        this.$el.attr('id', this.collapseDivId);

        //apply the accordion to this layout
        this.$('.collapse').collapse({
            toggle:false,
            parent:'#' + this.collapseDivId
        });

        // select the first panel in metadata
        this.selectPanel(_.first(this.meta.components).view);
    },

    /**
     * Used to select a specific panel by name
     * Correct names can be found in the specific view's hbs
     * Specifically found in the id attribute of '.accordion-heading a'
     *
     * @param {String} panelName The ID name of the panel to select
     */
    selectPanel: function(panelName) {
        this.selectedPanel = panelName;
        this.$('#' + panelName + 'Collapse').collapse('show');
        // manually trigger the accordion to toggle
        // but don't pass event so it uses the selectedPanel name
        this.onAccordionToggleClicked();
    },

    /**
     * Event handler for 'click .accordion-toggle' event
     *
     * @param {jQuery.Event|undefined} evt
     */
    onAccordionToggleClicked: function(evt) {
        var helpId = (evt) ? $(evt.currentTarget).data('help-id') : this.selectedPanel;
        this._switchHowToData(helpId);

        this.context.trigger('config:howtoData:change', this.currentHowToData);
    },

    /**
     * Function for child modules to initialize their own HowTo data
     *
     * @private
     */
    _initHowTo: function() {
    },

    /**
     * Handles switching the HowTo text and info by a specific accordion view being toggled
     *
     * @param {String} helpId The
     * @private
     */
    _switchHowToData: function(helpId) {
    },

    /**
     * Allows child config views with specific needs to be able to 'manually' update the HowTo text
     *
     * @param title
     * @param text
     */
    changeHowToData: function(title, text) {
        this.currentHowToData.title = title;
        this.currentHowToData.text = text;
        this.context.trigger('config:howtoData:change', this.currentHowToData);
    }
}) },
"filterpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FilterpanelLayout
 * @alias SUGAR.App.view.layouts.BaseFilterpanelLayout
 * @extends View.Layouts.Base.TogglepanelLayout
 */
({
	// Filterpanel Layout (base) 

    extendsFrom: 'TogglepanelLayout',

    /**
     * @inheritdoc
     *
     * Certain options can be set in the filterpanel metadata:
     *     - `auto_apply`: this will determine whether or not to apply the
     *       filter while completing filter rows. This is used mainly because
     *       getRelevantContextList may return the global context and will
     *       filter its collection automatically, and sometimes this is not
     *       desired (e.g. a drawer layout with a filterpanel embedded).
     *
     *     - `stickiness`: this will determine whether or not to save
     *       properties pertaining to filters in localstorage. This is needed
     *       for certain views that have filterpanels, do not require
     *       stickiness and do not want to affect already-stored values in
     *       localstorage (e.g. the filterpanel layout in dashboardconfiguration
     *       shouldn't affect the stickiness of filters on record/list views,
     *       so it should be set to false).
     *
     *     - `show_actions`: this will determine whether or not the
     *       `delete`, `reset`, and `cancel` action buttons will be rendered on
     *       the `filter-actions` view.
     *
     *     @example
     *     <pre><code>
     *         'layout' => array(
     *              'type' =>'filterpanel',
     *              'meta' => array(
     *                  'filter_options' => array(
     *                      'auto_apply' => false,
     *                      'stickiness' => false,
     *                      'show_actions' => false,
     *                  ),
     *              ),
     *          ),
     *     </code></pre>
     */
    initialize: function(opts) {
        // The filter options default to true.
        var defaultOptions = {
            'auto_apply': true,
            'stickiness': true,
            'show_actions': true
        };

        var moduleMeta = app.metadata.getModule(opts.module) || {};
        this.disableActivityStreamToggle(opts.module, moduleMeta, opts.meta || {});

        this.on("filterpanel:change:module", function(module, link) {
            this.currentModule = module;
            this.currentLink = link;
        }, this);

        this.on('filter:create:open', _.debounce(function() {
            // This debounce method should be in accordance with filter-rows::openForm,
            // so components show up at the same time
            this.$('.filter-options').removeClass('hide');

            // "filter:create:open" is triggered even when the edit drawer is
            // being closed, so protect against saving the shortcuts when that
            // happens
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (_.isNull(activeShortcutSession)
                || (activeShortcutSession && activeShortcutSession.layout !== this)) {
                app.shortcuts.saveSession();
                app.shortcuts.createSession([
                    'Filter:Add',
                    'Filter:Remove',
                    'Filter:Close',
                    'Filter:Save',
                    'Filter:Delete',
                    'Filter:Reset'
                ], this);
            }
        }, 100, true), this);

        this.on('filter:create:close', function() {
            this.$('.filter-options').addClass('hide');

            // "filter:create:close" is triggered even when filter:create:open has not been called
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (activeShortcutSession && (activeShortcutSession.layout === this)) {
                app.shortcuts.restoreSession();
            }
        }, this);

        // This is required, for example, if we've disabled the subapanels panel so that app doesn't attempt to render later
        this.on('filterpanel:lastviewed:set', function(viewed) {
            this.toggleViewLastStateKey = this.toggleViewLastStateKey || app.user.lastState.key('toggle-view', this);
            var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);
            if (lastViewed !== viewed) {
                app.user.lastState.set(this.toggleViewLastStateKey, viewed);
            }
        }, this);

        this._super("initialize", [opts]);

        // Set the filter that's currently being edited.
        this.context.editingFilter = null;

        // Obtain any options set in the metadata and override the defaultOptions with them
        // to set on the context.
        var filterOptions = _.extend(defaultOptions, this.meta.filter_options, this.context.get('filterOptions'));
        this.context.set('filterOptions', filterOptions);

        // The `defaultModule` will either evaluate to the model's module (more
        // specific, and used on dashablelist filters), or the module on the
        // current context.
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey),
            defaultModule = this.module || this.model.get('module') || this.context.get('module');

        this.trigger('filterpanel:change:module', (moduleMeta.activityStreamEnabled && lastViewed === 'activitystream') ? 'Activities' : defaultModule);
    },

    /**
     * Applies last filter
     * @param {Collection} collection the collection to retrieve the filter definition
     * @param {String} condition(optional) You can specify a condition in order to prevent applying filtering
     */
    applyLastFilter: function(collection, condition) {
        var triggerFilter = true;
        if (_.size(collection.origFilterDef)) {
            if (condition === 'favorite') {
                //Here we are verifying the filter applied contains $favorite otherwise we don't really care about
                //refreshing the listview
                triggerFilter = !_.isUndefined(_.find(collection.origFilterDef, function(value, key) {
                    return key === '$favorite' || (value && !_.isUndefined(value.$favorite));
                }));
            }
            if (triggerFilter) {
                var query = this.$('.search input.search-name').val();
                this.trigger('filter:apply', query, collection.origFilterDef);
            }
        }
    },

    /**
     * Disables the activity stream toggle if activity stream is not enabled for a module
     * @param {String} moduleName The name of the module
     * @param {Object} moduleMeta The metadata for the module
     * @param {Object} viewMeta The metadata for the component
     */
    disableActivityStreamToggle: function(moduleName, moduleMeta, viewMeta) {
        if (moduleName !== 'Activities' && !moduleMeta.activityStreamEnabled) {
            _.each(viewMeta.availableToggles, function(toggle) {
                if (toggle.name === 'activitystream') {
                    toggle.disabled = true;
                    toggle.label = 'LBL_ACTIVITY_STREAM_DISABLED';
                }
            });
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');
        // `filter-rows` view is outside of `filter` layout and is rendered after `filter` layout is rendered.
        // Now that we are able to preserve last search, we need to initialize filter only once all the filter
        // components rendered.
        this.trigger('filter:reinitialize');
    }
}) },
"tabbed-layout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.TabbedLayoutLayout
 * @alias SUGAR.App.view.layouts.BaseTabbedLayoutLayout
 * @extends View.Layout
 */
({
	// Tabbed-layout Layout (base) 

    initialize: function(options) {
        this.firstIsActive = false;
        this.template = app.template.get("l.tabbed-layout");
        this.renderHtml();

        app.view.Layout.prototype.initialize.call(this, options);
    },

    renderHtml: function() {
        this.$el.html(this.template(this));
    },

    // Assign the tabs
    _placeComponent: function(comp, def) {
        var id = _.uniqueId('record-bottom'),
            nav = $('<li/>').html('<a href="#' + id + '" onclick="return false;" data-toggle="tab">' + app.lang.get(def.layout.name, this.module) + '</a>'),
            content = $('<div/>').addClass('tab-pane').attr('id', id).html(comp.el);

        if (!this.firstIsActive) {
            nav.addClass('active');
            content.addClass('active');
        }

        this.firstIsActive = true;
        this.$('.tab-content').append(content);
        this.$('.nav').append(nav);
    }
}) },
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivitystreamLayout
 * @alias SUGAR.App.view.layouts.BaseActivitystreamLayout
 * @extends View.Layout
 */
({
	// Activitystream Layout (base) 

    className: "block filtered activitystream-layout",

    initialize: function(opts) {
        this.opts = opts;
        this.renderedActivities = {};

        app.view.Layout.prototype.initialize.call(this, opts);

        this.setCollectionOptions();
        this.exposeDataTransfer();

        this.context.on("activitystream:post:prepend", this.prependPost, this);
        this.context.on('activitystream:paginate', this.paginate, this);

        // Remove active state from all preview buttons
        app.events.on('preview:close', function() {
            this.clearRowDecorations();
        }, this);
    },

    /**
     * Removes highlighted styling from stream activities.
     */
    clearRowDecorations: function() {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            var activities = this.$('.activitystream-posts-comments-container');
            activities.removeClass('highlighted');
            activities.find('.preview-btn').removeClass('active');
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;
        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId = self.context.parent.get('modelId'),
                action = model.module, // equal to 'Activities'
                url;
            switch (layoutType) {
                case "activities":
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case "records":
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case "record":
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }
            return app.api.call("read", url, null, callbacks);
        };

        this.context.get('collection').setOption({
            endpoint: endpoint,
            success: function(collection) {
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            error: function(error) {
                self.collection.dataFetched = true;
                self.collection.reset();
            }
        });
    },

    /**
     * Expose the dataTransfer object for drag and drop file uploads.
     */
    exposeDataTransfer: function() {
        jQuery.event.props.push('dataTransfer');
    },

    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get("model");
            this.listenTo(model, "sync", _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, "sync", function() {
                    var options = this.context.get("collectionOptions");
                    this.collection.fetch(options);
                });
            }));
        }
    },

    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        // We want to ensure the data related to this activity loads before the
        // stream for a better user experience.
        var parentCol = this.context.parent.get("collection");
        if (parentCol.isEmpty()) {
            parentCol.once("sync", function(){
                this._load(options);
            }, this);
        } else {
            this._load(options);
        }
    },

    _load: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }
        options = _.extend({}, options, this.context.get('collectionOptions'));
        this.collection.fetch(options);
    },

    renderPost: function(model, readonly) {
        var view;
        if(_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                name: "activitystream",
                module: this.module,
                layout: this,
                model: model,
                readonly: readonly
            });
            this.addComponent(view);
            this.renderedActivities[model.id] = view;
            view.render();
        }
        return view;
    },

    _placeComponent: function(component) {
        if (this.disposed)
            return;

        if(component.name === "activitystream") {
            this.$el.find(".activitystream-list").append(component.el);
        } else if (component.name === 'activitystream-bottom') {
            this.$el.append(component.el);
            component.render();
        } else {
            this.$el.prepend(component.el);
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get("model");
            collection = this.context.parent.get("collection");

            if (model) {
                model.off("change sync", null, this);
            }
            if (collection) {
                collection.off("sync", null, this);
            }
        }

        app.view.Layout.prototype.unbindData.call(this);
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        var nonActivities = [];
        _.each(this._components, function(component) {
            if (component.name !== 'activitystream') {
                nonActivities.push(component);
            } else {
                component.dispose();
            }
        });
        this._components = nonActivities;
        this.renderedActivities = {};
    },

    /**
     * Get the next set of activity stream posts.
     */
    paginate: function() {
        this.collection.paginate({
            add: true
        });
    }
}) },
"dupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout displays a list of duplicate records found along with a count
 *
 * Note: Next step will be to add ability to switch to a filter list (and back).
 *       This is why this is in a layout.
 *
 * @class View.Layouts.Base.DupecheckLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckLayout
 * @extends View.Layout
 */
({
	// Dupecheck Layout (base) 

    initialize: function(options) {
        if(options.context.has('dupelisttype')) {
            options.meta = this.switchListView(options.meta, options.context.get('dupelisttype'));
        }
        app.view.Layout.prototype.initialize.call(this, options);
    },

    switchListView: function(meta, dupelisttype) {
        var listView = _.find(meta.components, function(component) {
            return (component.name === 'dupecheck-list');
        });
        listView.view = dupelisttype;
        return meta;
    }
}) },
"quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchLayout
 * @alias SUGAR.App.view.views.BaseQuicksearchLayout
 * @extends View.Layout
 */
({
	// Quicksearch Layout (base) 

    className: 'search',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This is to be shared and used by components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of this.collection.
        this.collection = app.data.createMixedBeanCollection();

        this.selectedTags = [];

        /**
         * Key to indicate version 2 search (new global search). This is used by the component views to determine
         * what version of the API to use. Default is false.
         * @type {boolean}
         */
        // FIXME SC-4254 Remove this.v2
        this.v2 = this.meta.v2 || false;

        /**
         * Index of the focused component. Only the focused component should have keyboard listeners.
         * @type {number}
         */
        this.compOnFocusIndex = 0;

        /**
         * Maximum viewport width of responsive mode. Under this width we should
         * be in responsive mode, and above in desktop mode.
         * @type {number}
         */
        this.maxResponsiveWidth = 540;

        /**
         * Tells if we're in responsive mode or not.
         *
         * In responsive mode, the search bar is hidden when collapsed and only
         * the magnifying glass is shown. When it's expanded, it takes the full
         * width of the screen.
         *
         * @type {boolean}
         */
        this.isResponsiveMode = false;

        /**
         * Indicates if the search bar is expanded
         * @type {boolean}
         */
        this.expanded = false;

        // shortcut keys
        // Focus the search bar
        app.shortcuts.register(app.shortcuts.GLOBAL + 'Search', ['s', 'ctrl+alt+0'], function() {
            this.trigger('navigate:to:component', 'quicksearch-bar');
        }, this);

        // When a component is trying to navigate from its last element to the next component,
        // Check to make sure there is a next navigable component. If it exists, set it to the component to focus
        this.before('navigate:next:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[++i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // When a component is trying to navigate from its first element to the previous component,
        // Check to make sure there is a previous navigable component. If it exists, set it to the component to focus
        this.before('navigate:previous:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[--i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // Navigate to the next component. We have already set this.compOnFocusIndex in the before function.
        this.on('navigate:next:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', true);
        }, this);

        // Navigate to the previous component. We have already set this.compOnFocusIndex in the previous function.
        this.on('navigate:previous:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', false);
        }, this);

        // Navigate to a specific component. This bypasses the previous/next logic.
        this.on('navigate:to:component', function(componentName) {
            var newIndex = this.compOnFocusIndex;
            // Find the index of the component that is requesting focus.
            // We cannot use `layout.getComponent()` because that only returns the component, not the index.
            _.each(this._components, function(component, index) {
                if (componentName === component.name) {
                    newIndex = index;
                    return;
                }
            });
            // Unfocus the old component and focus on the new component.
            this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
            this.compOnFocusIndex = newIndex;
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive');
        }, this);

        // Reset navigation
        this.on('quicksearch:close', function(keepExpanded) {
            this.removeFocus();
            if (!this.expanded) {
                return;
            }
            this.collection.abortFetchRequest();
            if (keepExpanded) {
                return;
            }
            this.collapse();
        }, this);

        this.on('quicksearch:expand', this.expand);

        // Listener for app:view:change to expand or collapse the search bar
        app.events.on('app:view:change', function() {
            if (this.context.get('search')) {
                _.defer(_.bind(this.expand, this));
            } else {
                _.bind(this.collapse, this);
            }
        }, this);

        this.$el.focusin(_.bind(function() {
            this.$el.off('focusout');
            this.$el.focusout(_.bind(function() {
                this.$el.off('focusout');
                _.defer(_.bind(function() {
                    // We use `has(':focus')` instead of `is(':focus')` to check
                    // if the focused element is or is inside `this.$el`.
                    if (this.$el.has(':focus').length === 0) {
                        this.trigger('quicksearch:close', this.context.get('search'));
                    }
                }, this));
            }, this));
        }, this));

        // Listener for display of tags ribbon menu
        this.on('quicksearch:tag:open', function() {
            this.$el.addClass('quicksearch-tags-open');
        }, this);

        // Listener for hiding of tags ribbon menu
        this.on('quicksearch:tag:close', function() {
            this.$el.removeClass('quicksearch-tags-open');
        }, this);

        // On window resize, if expanded, recalculate expansion
        $(window)
            .off('resize.quicksearch')
            .on('resize.quicksearch', _.debounce(_.bind(this.resizeHandler, this), 10));
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (component.name === 'quicksearch-modulelist' ||
            component.name === 'quicksearch-taglist' ||
            component.name === 'quicksearch-bar'
        ) {
            this.$('[data-component=searchbar]').append(component.el);
        } else {
            this._super('_placeComponent', [component]);
        }
    },

    /**
     * Removes the current focus and resets the focused index
     */
    removeFocus: function() {
        this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
        this.compOnFocusIndex = 0;
    },


    /**
     * Expands the quicksearch.
     *
     * @param {boolean} update `true` means the expansion is to update the width.
     *                  `false` means the expansion is new and needs animation.
     */
    expand: function(update) {
        // if the search bar is already expanded and it is not an update,
        // do nothing.
        if (this.expanded && !update) {
            return;
        }

        this.expanded = true;
        this.$el.addClass('expanded');

        // On route, call the router handler.
        app.router
            .off('route', this.routerHandler)
            .on('route', this.routerHandler, this);

        this.trigger('quicksearch:expanded');
        this.trigger('quicksearch:button:toggle', false);

        if (this.isResponsiveMode) {
            this.trigger('navigate:to:component', 'quicksearch-bar');
            return;
        }

        // Calculate the target searchbox width
        var newWidth = this._calculateExpansion();

        // if the newWidth is not defined, then the menu hasn't completely
        // loaded, and we should do nothing.
        if (_.isUndefined(newWidth)) {
            return;
        }

        // For new expansions, we need to clear out the modules.
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }
        headerLayout.trigger('view:resize', headerLayout.getModuleListMinWidth());

        // Now that there is space for the search bar to expand, animate the
        // expansion.
        if (update) {
            this.$('[data-component=searchbar]').width(newWidth);
        } else {
            this.$('[data-component=searchbar]').animate({width: newWidth}, {duration: 100});
        }

        // Turn off the default header resize listener
        headerLayout.setModuleListResize(false);
    },

    /**
     * Resizes the expanded search bar when the window is resized.
     * @private
     */
    resizeHandler: function() {
        this._toggleResponsiveMode();
        if (this.expanded && !this.isResponsiveMode) {
            _.defer(_.bind(this.expand, this, true));
        }
    },

    /**
     * Renders the layout and toggles the responsive class.
     *
     * @private
     */
    _render: function() {
        this._super('_render');
        this._toggleResponsiveMode();
    },

    /**
     * Toggles the responsive mode according to the viewport width.
     *
     * @private
     */
    _toggleResponsiveMode: function() {
        this.isResponsiveMode = $(window).width() < this.maxResponsiveWidth;
    },

    /**
     * Handles the route event on the router.
     *
     * This simple function allows us to reuse a function pointer to the router
     * handler. The router does not allow namespaced events such as
     * `route.quicksearch`. So, this function pointer is necessary to
     * properly dispose the event handler.
     */
    routerHandler: function() {
        this.trigger('quicksearch:close', this.context.get('search'));
    },

    /**
     * Calculates the target width for the search bar expansion based off the current state of the megamenu.
     *
     * @return {number} The target width for expansion.
     * @private
     */
    _calculateExpansion: function() {
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // The starting width of the input box
        var searchbarStartingWidth = this.$('[data-component=searchbar]').outerWidth();

        // The total width of the module list header
        var totalModuleWidth = headerLayout.getModuleListWidth();

        // The minimum width necessary for module list header
        var minimumModuleWidth = headerLayout.getModuleListMinWidth();

        // The target width is most of the module list, saving room for the
        // minimum module list width.
        return searchbarStartingWidth +
            totalModuleWidth -
            minimumModuleWidth;
    },

    /**
     * Collapses the quicksearch.
     */
    collapse: function() {
        this.expanded = false;
        this.$el.removeClass('expanded');

        this.trigger('quicksearch:collapse');
        app.router.off('route', this.routerHandler);
        this.trigger('quicksearch:button:toggle', true);

        if (this.isResponsiveMode) {
            return;
        }
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // Turn on the default header resize listener
        headerLayout.setModuleListResize(true);

        // jQuery `width` function with no arguments (or null arguments) only
        // returns the current width. Calling `width('')` with the empty string
        // sets the width to an empty value, which the browser ignores and
        // uses the css width.
        this.$('[data-component=searchbar]').width('');
        headerLayout.resize();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        app.router.off('route', null, this);
        this.$el.off();
        $(window).off('resize.quicksearch');
        this._super('unbind');
    }
}) },
"sweetspot-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/06_Customer_Center/10_Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('.main-pane').append(component.el);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:cancel:config', this.cancelConfig, this);

        // Button events
        this.context.on('button:save_button:click', this.saveConfig, this);
        this.context.on('button:cancel_button:click', this.cancelConfig, this);
    },


    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Object} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {sweetspot: data};
    },

    /**
     * Receives all the configuration models from the subcomponents, to be
     * saved in user preferences.
     *
     * @protected
     */
    _getAllConfigs: function() {
        var config = {};
        this.context.off('sweetspot:receive:configs');
        this.context.on('sweetspot:receive:configs', function(data) {
            _.extend(config, data);
        });
        this.context.trigger('sweetspot:ask:configs');
        return config;
    },

    /**
     * Saves the sanitized Sweet Spot settings in user preferences and closes
     * the drawer.
     */
    saveConfig: function() {
        var data = this._getAllConfigs();
        data = this._formatForUserPrefs(data);

        this.context.trigger('sweetspot:config:enableButtons', false);
        app.alert.show('sweetspot', {
            level: 'process',
            title: app.lang.get('LBL_SAVING'),
            autoClose: false
        });

        app.user.updatePreferences(data, _.bind(this._saveConfigCallback, this));
    },

    /**
     * Callback for the call to {@link Core.User#updatePreferences}.
     *
     * @param {string} err Error message returned by the server.
     */
    _saveConfigCallback: function(err) {
        app.alert.dismiss('sweetspot');
        if (err) {
            var errorMsg = app.lang.get('LBL_SWEETSPOT_CONFIG_ERR', this.module, {errorMsg: err});
            this.context.trigger('sweetspot:config:enableButtons', true);
            app.alert.show('config-failed', {
                level: 'error',
                title: 'LBL_SWEETSPOT',
                messages: errorMsg
            });
            return;
        }
        app.drawer.close(this.collection);
        app.events.trigger('sweetspot:reset');
    },

    /**
     * Closes the config drawer without saving changes.
     */
    cancelConfig: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.context.off('sweetspot:receive:configs');
        this._super('_dispose');
    }
}) }
}}

,
	"modules":{
		"Login":{
}
	}}})(SUGAR.App);